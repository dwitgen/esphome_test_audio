diff --git a/esphome/components/adc/adc_sensor.h b/esphome/components/adc/adc_sensor.h
index 7a3e1c8da..3d016eec4 100644
--- a/esphome/components/adc/adc_sensor.h
+++ b/esphome/components/adc/adc_sensor.h
@@ -6,32 +6,30 @@
 #include "esphome/core/hal.h"
 
 #ifdef USE_ESP32
-#include <esp_adc_cal.h>
-#include "driver/adc.h"
+  #if ESP_IDF_VERSION_MAJOR >= 5
+    #include "esp_adc/adc_cali.h"
+    #include "esp_adc/adc_cali_scheme.h"
+    #include "esp_adc/adc_oneshot.h"
+  #else
+    #include <esp_adc_cal.h>
+    #include "driver/adc.h"
+  #endif
 #endif  // USE_ESP32
 
 namespace esphome {
 namespace adc {
 
 #ifdef USE_ESP32
-// clang-format off
-#if (ESP_IDF_VERSION_MAJOR == 4 && ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 7)) || \
-    (ESP_IDF_VERSION_MAJOR == 5 && \
-     ((ESP_IDF_VERSION_MINOR == 0 && ESP_IDF_VERSION_PATCH >= 5) || \
-      (ESP_IDF_VERSION_MINOR == 1 && ESP_IDF_VERSION_PATCH >= 3) || \
-      (ESP_IDF_VERSION_MINOR >= 2)) \
-    )
-// clang-format on
-static const adc_atten_t ADC_ATTEN_DB_12_COMPAT = ADC_ATTEN_DB_12;
+#if (ESP_IDF_VERSION_MAJOR >= 5)
+  static const adc_atten_t ADC_ATTEN_DB_12_COMPAT = ADC_ATTEN_DB_12;  
 #else
-static const adc_atten_t ADC_ATTEN_DB_12_COMPAT = ADC_ATTEN_DB_11;
+  static const adc_atten_t ADC_ATTEN_DB_12_COMPAT = ADC_ATTEN_DB_11;  
 #endif
 #endif  // USE_ESP32
 
 class ADCSensor : public sensor::Sensor, public PollingComponent, public voltage_sampler::VoltageSampler {
  public:
 #ifdef USE_ESP32
-  /// Set the attenuation for this pin. Only available on the ESP32.
   void set_attenuation(adc_atten_t attenuation) { this->attenuation_ = attenuation; }
   void set_channel1(adc1_channel_t channel) {
     this->channel1_ = channel;
@@ -42,49 +40,104 @@ class ADCSensor : public sensor::Sensor, public PollingComponent, public voltage
     this->channel1_ = ADC1_CHANNEL_MAX;
   }
   void set_autorange(bool autorange) { this->autorange_ = autorange; }
-#endif  // USE_ESP32
+#endif
 
-  /// Update ADC values
   void update() override;
-  /// Setup ADC
   void setup() override;
   void dump_config() override;
-  /// `HARDWARE_LATE` setup priority
   float get_setup_priority() const override;
   void set_pin(InternalGPIOPin *pin) { this->pin_ = pin; }
   void set_output_raw(bool output_raw) { this->output_raw_ = output_raw; }
   void set_sample_count(uint8_t sample_count);
   float sample() override;
 
-#ifdef USE_ESP8266
-  std::string unique_id() override;
-#endif  // USE_ESP8266
-
-#ifdef USE_RP2040
-  void set_is_temperature() { this->is_temperature_ = true; }
-#endif  // USE_RP2040
-
  protected:
   InternalGPIOPin *pin_;
   bool output_raw_{false};
   uint8_t sample_count_{1};
 
-#ifdef USE_RP2040
-  bool is_temperature_{false};
-#endif  // USE_RP2040
-
 #ifdef USE_ESP32
   adc_atten_t attenuation_{ADC_ATTEN_DB_0};
   adc1_channel_t channel1_{ADC1_CHANNEL_MAX};
   adc2_channel_t channel2_{ADC2_CHANNEL_MAX};
   bool autorange_{false};
-#if ESP_IDF_VERSION_MAJOR >= 5
-  esp_adc_cal_characteristics_t cal_characteristics_[SOC_ADC_ATTEN_NUM] = {};
-#else
-  esp_adc_cal_characteristics_t cal_characteristics_[ADC_ATTEN_MAX] = {};
-#endif  // ESP_IDF_VERSION_MAJOR
-#endif  // USE_ESP32
+
+  #if ESP_IDF_VERSION_MAJOR >= 5
+    adc_oneshot_unit_handle_t adc_handle_;
+    adc_cali_handle_t cal_handle_;
+  #else
+    esp_adc_cal_characteristics_t cal_characteristics_[ADC_ATTEN_MAX] = {};
+  #endif
+#endif
 };
 
+// ========================== SETUP ==========================
+
+void ADCSensor::setup() {
+#ifdef USE_ESP32
+  #if ESP_IDF_VERSION_MAJOR >= 5
+    adc_oneshot_unit_init_cfg_t adc_init_cfg = {
+      .unit_id = ADC_UNIT_1
+    };
+    ESP_ERROR_CHECK(adc_oneshot_new_unit(&adc_init_cfg, &adc_handle_));
+
+    adc_oneshot_chan_cfg_t channel_config = {
+      .atten = attenuation_,
+      .bitwidth = ADC_BITWIDTH_DEFAULT
+    };
+    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc_handle_, channel1_, &channel_config));
+
+    // Calibration
+    adc_cali_line_fitting_config_t cal_cfg = {
+      .unit_id = ADC_UNIT_1,
+      .atten = attenuation_,
+      .bitwidth = ADC_BITWIDTH_DEFAULT,
+    };
+    ESP_ERROR_CHECK(adc_cali_create_scheme_line_fitting(&cal_cfg, &cal_handle_));
+
+  #else
+    esp_adc_cal_characteristics_t *chars = &cal_characteristics_[attenuation_];
+    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(
+        ADC_UNIT_1, attenuation_, ADC_WIDTH_BIT_12, 1100, chars);
+  #endif
+#endif
+}
+
+// ========================== SAMPLE ==========================
+
+float ADCSensor::sample() {
+#ifdef USE_ESP32
+  int raw = 0;
+  #if ESP_IDF_VERSION_MAJOR >= 5
+    ESP_ERROR_CHECK(adc_oneshot_read(adc_handle_, channel1_, &raw));
+    int voltage = 0;
+    ESP_ERROR_CHECK(adc_cali_raw_to_voltage(cal_handle_, raw, &voltage));
+    return output_raw_ ? raw : voltage / 1000.0f;  // Convert to volts
+  #else
+    raw = adc1_get_raw(channel1_);
+    uint32_t voltage = esp_adc_cal_raw_to_voltage(raw, &cal_characteristics_[attenuation_]);
+    return output_raw_ ? raw : voltage / 1000.0f;
+  #endif
+#endif
+  return 0.0f;
+}
+
+// ========================== UPDATE ==========================
+
+void ADCSensor::update() {
+  float value = this->sample();
+  this->publish_state(value);
+}
+
+// ========================== CONFIG ==========================
+
+void ADCSensor::dump_config() {
+  ESP_LOGCONFIG("ADC Sensor", "Configured on Channel %d", channel1_);
+}
+
+float ADCSensor::get_setup_priority() const {
+  return setup_priority::HARDWARE_LATE;
+}
+
 }  // namespace adc
 }  // namespace esphome
