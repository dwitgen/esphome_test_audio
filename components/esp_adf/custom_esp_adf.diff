diff --git a/.gitmodules b/.gitmodules
index 2093ecbb..826c9916 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -4,6 +4,7 @@
 [submodule "components/esp-adf-libs"]
 	path = components/esp-adf-libs
 	url = https://github.com/espressif/esp-adf-libs
+	branch = master
 [submodule "components/esp-sr"]
 	path = components/esp-sr
 	url = https://github.com/espressif/esp-sr.git
diff --git a/components/audio_board/include/board_pins_config.h b/components/audio_board/include/board_pins_config.h
index 62893921..c9a3064b 100644
--- a/components/audio_board/include/board_pins_config.h
+++ b/components/audio_board/include/board_pins_config.h
@@ -29,6 +29,7 @@
 #include "driver/spi_common.h"
 #include "driver/spi_master.h"
 #include "driver/spi_slave.h"
+#include "driver/i2s_std.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -61,13 +62,13 @@ esp_err_t get_i2c_pins(i2c_port_t port, i2c_config_t *i2c_config);
  * @brief                  Get i2s pins configuration
  *
  * @param      port        i2s port number to get configuration
- * @param      i2s_config  i2s configuration parameters
+ * @param      gpio_cfg  i2s configuration parameters
  *
  * @return
  *     - ESP_OK
  *     - ESP_FAIL
  */
-esp_err_t get_i2s_pins(int port, board_i2s_pin_t *i2s_config);
+esp_err_t get_i2s_pins(int port, i2s_std_gpio_config_t *gpio_cfg);
 
 /**
  * @brief                  Get spi pins configuration
diff --git a/components/audio_hal/CMakeLists.txt b/components/audio_hal/CMakeLists.txt
index cb9d365d..6b4d42ca 100644
--- a/components/audio_hal/CMakeLists.txt
+++ b/components/audio_hal/CMakeLists.txt
@@ -1,55 +1,57 @@
-set(COMPONENT_ADD_INCLUDEDIRS ./include
-                            ./driver/es8388
-                            ./driver/es8374
-                            ./driver/es8311
-                            ./driver/es8156
-                            ./driver/es7243
-                            ./driver/es7148
-                            ./driver/es7210
-                            ./driver/es7243e
-                            ./driver/tas5805m
-                            ./driver/include)
-IF (NOT ((CONFIG_IDF_TARGET STREQUAL "esp32c3") OR (CONFIG_IDF_TARGET STREQUAL "esp32c6")))
-    list(APPEND COMPONENT_ADD_INCLUDEDIRS 
-    ./driver/zl38063
-    ./driver/zl38063/api_lib
-    ./driver/zl38063/example_apps
-    ./driver/zl38063/firmware)
-endif()
-
-# Edit following two lines to set component requirements (see docs)
-set(COMPONENT_REQUIRES )
-set(COMPONENT_PRIV_REQUIRES audio_sal audio_board mbedtls esp_peripherals display_service esp_dispatcher)
-
-set(COMPONENT_SRCS ./audio_hal.c
-                    ./audio_volume.c
-                    ./driver/es8388/es8388.c
-                    ./driver/es8388/headphone_detect.c
-                    ./driver/es8374/es8374.c
-                    ./driver/es8311/es8311.c
-                    ./driver/es8156/es8156.c
-                    ./driver/es7243/es7243.c
-                    ./driver/es7148/es7148.c
-                    ./driver/es7210/es7210.c
-                    ./driver/es7243e/es7243e.c
-                    ./driver/tas5805m/tas5805m.c
-                    )
-
-IF (NOT ((CONFIG_IDF_TARGET STREQUAL "esp32c3") OR (CONFIG_IDF_TARGET STREQUAL "esp32c6") OR (CONFIG_IDF_TARGET STREQUAL "esp32p4")))
-    list(APPEND COMPONENT_SRCS 
-    ./driver/zl38063/zl38063.c
-    ./driver/zl38063/api_lib/vprocTwolf_access.c
-    ./driver/zl38063/api_lib/vproc_common.c
-    ./driver/zl38063/example_apps/tw_hal_verify.c
-    ./driver/zl38063/example_apps/tw_ldcfg.c
-    ./driver/zl38063/example_apps/tw_ldfw.c
-    ./driver/zl38063/example_apps/tw_ldfwcfg.c
-    ./driver/zl38063/example_apps/tw_spi_access.c)
-endif()
-
-register_component()
-
-IF (NOT ((CONFIG_IDF_TARGET STREQUAL "esp32c3") OR (CONFIG_IDF_TARGET STREQUAL "esp32c6") OR (CONFIG_IDF_TARGET STREQUAL "esp32p4")))
-    target_link_libraries(${COMPONENT_TARGET} INTERFACE "-L${CMAKE_CURRENT_LIST_DIR}/driver/zl38063/firmware")
-    target_link_libraries(${COMPONENT_TARGET} INTERFACE firmware)
-ENDIF()
+set(COMPONENT_ADD_INCLUDEDIRS ./include
+                            ./driver/es8388
+                            ./driver/es8374
+                            ./driver/es8311
+                            ./driver/es8156
+                            ./driver/es7243
+                            ./driver/es7148
+                            ./driver/es7210
+                            ./driver/es7243e
+                            ./driver/tas5805m
+                            ./driver/include)
+IF (NOT ((CONFIG_IDF_TARGET STREQUAL "esp32c3") OR (CONFIG_IDF_TARGET STREQUAL "esp32c6")))
+    list(APPEND COMPONENT_ADD_INCLUDEDIRS 
+    ./driver/zl38063
+    ./driver/zl38063/api_lib
+    ./driver/zl38063/example_apps
+    ./driver/zl38063/firmware)
+endif()
+
+
+# Edit following two lines to set component requirements (see docs)
+set(COMPONENT_REQUIRES esp_peripherals)
+set(COMPONENT_PRIV_REQUIRES audio_sal audio_board mbedtls display_service esp_dispatcher)
+
+set(COMPONENT_SRCS ./audio_hal.c
+                    ./audio_volume.c
+                    ./driver/es8388/es8388.c
+                    ./driver/es8388/headphone_detect.c
+                    ./driver/es8374/es8374.c
+                    ./driver/es8311/es8311.c
+                    ./driver/es8156/es8156.c
+                    ./driver/es7243/es7243.c
+                    ./driver/es7148/es7148.c
+                    ./driver/es7210/es7210.c
+                    ./driver/es7243e/es7243e.c
+                    ./driver/tas5805m/tas5805m.c
+                    )
+
+IF (NOT ((CONFIG_IDF_TARGET STREQUAL "esp32c3") OR (CONFIG_IDF_TARGET STREQUAL "esp32c6")))
+    list(APPEND COMPONENT_SRCS 
+    ./driver/zl38063/zl38063.c
+    ./driver/zl38063/api_lib/vprocTwolf_access.c
+    ./driver/zl38063/api_lib/vproc_common.c
+    ./driver/zl38063/example_apps/tw_hal_verify.c
+    ./driver/zl38063/example_apps/tw_ldcfg.c
+    ./driver/zl38063/example_apps/tw_ldfw.c
+    ./driver/zl38063/example_apps/tw_ldfwcfg.c
+    ./driver/zl38063/example_apps/tw_spi_access.c)
+endif()
+
+register_component()
+
+IF (NOT ((CONFIG_IDF_TARGET STREQUAL "esp32c3") OR (CONFIG_IDF_TARGET STREQUAL "esp32c6")))
+    target_link_libraries(${COMPONENT_TARGET} INTERFACE "-L${CMAKE_CURRENT_LIST_DIR}/driver/zl38063/firmware")
+    target_link_libraries(${COMPONENT_TARGET} INTERFACE firmware)
+ENDIF()
+
diff --git a/components/audio_hal/audio_hal.c b/components/audio_hal/audio_hal.c
old mode 100755
new mode 100644
index ab9337d0..398a81a8
--- a/components/audio_hal/audio_hal.c
+++ b/components/audio_hal/audio_hal.c
@@ -1,149 +1,149 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "driver/gpio.h"
-#include "esp_log.h"
-#include "audio_hal.h"
-
-#include "audio_mem.h"
-#include "audio_mutex.h"
-
-static const char *TAG = "AUDIO_HAL";
-
-#define AUDIO_HAL_CHECK_NULL(a, format, b, ...) \
-    if ((a) == 0) { \
-        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
-        return b;\
-    }
-
-audio_hal_handle_t audio_hal_init(audio_hal_codec_config_t *audio_hal_conf, audio_hal_func_t *audio_hal_func)
-{
-    esp_err_t ret = 0;
-    audio_hal_handle_t audio_hal = (audio_hal_handle_t)audio_calloc(1, sizeof(audio_hal_func_t));
-    AUDIO_MEM_CHECK(TAG, audio_hal, return NULL);
-    memcpy(audio_hal, audio_hal_func, sizeof(audio_hal_func_t));
-    audio_hal->audio_hal_lock = mutex_create();
-
-    AUDIO_MEM_CHECK(TAG, audio_hal->audio_hal_lock, {
-        audio_free(audio_hal);
-        return NULL;
-    });
-    mutex_lock(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_initialize(audio_hal_conf);
-    if (ret == ESP_FAIL) {
-        audio_free(audio_hal);
-        if (audio_hal_func->handle) {
-            return audio_hal_func->handle;
-        } else {
-            ESP_LOGE(TAG, "codec init failed!");
-            return NULL;
-        }
-    }
-    ret |= audio_hal->audio_codec_config_iface(audio_hal_conf->codec_mode, &audio_hal_conf->i2s_iface);
-    if ((audio_hal_conf->codec_mode == AUDIO_HAL_CODEC_MODE_DECODE) || (audio_hal_conf->codec_mode == AUDIO_HAL_CODEC_MODE_BOTH)) {
-        ret |= audio_hal->audio_codec_set_volume(AUDIO_HAL_VOL_DEFAULT);
-    }
-    AUDIO_RET_ON_FALSE(TAG, ret, return NULL, "audio_hal_init failed");
-    audio_hal->handle = audio_hal;
-    audio_hal_func->handle = audio_hal;
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return audio_hal;
-}
-
-esp_err_t audio_hal_deinit(audio_hal_handle_t audio_hal)
-{
-    esp_err_t ret;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    mutex_destroy(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_deinitialize();
-    audio_hal->audio_hal_lock = NULL;
-    audio_hal->handle = NULL;
-    audio_free(audio_hal);
-    audio_hal = NULL;
-    return ret;
-}
-
-esp_err_t audio_hal_ctrl_codec(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_ctrl_t audio_hal_state)
-{
-    esp_err_t ret;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    mutex_lock(audio_hal->audio_hal_lock);
-    ESP_LOGI(TAG, "Codec mode is %d, Ctrl:%d", mode, audio_hal_state);
-    ret = audio_hal->audio_codec_ctrl(mode, audio_hal_state);
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return ret;
-}
-
-esp_err_t audio_hal_codec_iface_config(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    esp_err_t ret = 0;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    AUDIO_HAL_CHECK_NULL(iface, "Get volume para is null", -1);
-    mutex_lock(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_config_iface(mode, iface);
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return ret;
-}
-
-esp_err_t audio_hal_set_mute(audio_hal_handle_t audio_hal, bool mute)
-{
-    esp_err_t ret;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    mutex_lock(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_set_mute(mute);
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return ret;
-}
-
-esp_err_t audio_hal_enable_pa(audio_hal_handle_t audio_hal, bool enable)
-{
-    esp_err_t ret;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    mutex_lock(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_enable_pa(enable);
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return ret;
-}
-
-esp_err_t audio_hal_set_volume(audio_hal_handle_t audio_hal, int volume)
-{
-    esp_err_t ret;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    mutex_lock(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_set_volume(volume);
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return ret;
-}
-
-esp_err_t audio_hal_get_volume(audio_hal_handle_t audio_hal, int *volume)
-{
-    esp_err_t ret;
-    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
-    AUDIO_HAL_CHECK_NULL(volume, "Get volume para is null", -1);
-    mutex_lock(audio_hal->audio_hal_lock);
-    ret = audio_hal->audio_codec_get_volume(volume);
-    mutex_unlock(audio_hal->audio_hal_lock);
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "driver/gpio.h"
+#include "esp_log.h"
+#include "audio_hal.h"
+
+#include "audio_mem.h"
+#include "audio_mutex.h"
+
+static const char *TAG = "AUDIO_HAL";
+
+#define AUDIO_HAL_CHECK_NULL(a, format, b, ...) \
+    if ((a) == 0) { \
+        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
+        return b;\
+    }
+
+audio_hal_handle_t audio_hal_init(audio_hal_codec_config_t *audio_hal_conf, audio_hal_func_t *audio_hal_func)
+{
+    esp_err_t ret = 0;
+    audio_hal_handle_t audio_hal = (audio_hal_handle_t)audio_calloc(1, sizeof(audio_hal_func_t));
+    AUDIO_MEM_CHECK(TAG, audio_hal, return NULL);
+    memcpy(audio_hal, audio_hal_func, sizeof(audio_hal_func_t));
+    audio_hal->audio_hal_lock = mutex_create();
+
+    AUDIO_MEM_CHECK(TAG, audio_hal->audio_hal_lock, {
+        audio_free(audio_hal);
+        return NULL;
+    });
+    mutex_lock(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_initialize(audio_hal_conf);
+    if (ret == ESP_FAIL) {
+        audio_free(audio_hal);
+        if (audio_hal_func->handle) {
+            return audio_hal_func->handle;
+        } else {
+            ESP_LOGE(TAG, "codec init failed!");
+            return NULL;
+        }
+    }
+    ret |= audio_hal->audio_codec_config_iface(audio_hal_conf->codec_mode, &audio_hal_conf->i2s_iface);
+    if ((audio_hal_conf->codec_mode == AUDIO_HAL_CODEC_MODE_DECODE) || (audio_hal_conf->codec_mode == AUDIO_HAL_CODEC_MODE_BOTH)) {
+        ret |= audio_hal->audio_codec_set_volume(AUDIO_HAL_VOL_DEFAULT);
+    }
+    AUDIO_RET_ON_FALSE(TAG, ret, return NULL, "audio_hal_init failed");
+    audio_hal->handle = audio_hal;
+    audio_hal_func->handle = audio_hal;
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return audio_hal;
+}
+
+esp_err_t audio_hal_deinit(audio_hal_handle_t audio_hal)
+{
+    esp_err_t ret;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    mutex_destroy(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_deinitialize();
+    audio_hal->audio_hal_lock = NULL;
+    audio_hal->handle = NULL;
+    audio_free(audio_hal);
+    audio_hal = NULL;
+    return ret;
+}
+
+esp_err_t audio_hal_ctrl_codec(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_ctrl_t audio_hal_state)
+{
+    esp_err_t ret;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    mutex_lock(audio_hal->audio_hal_lock);
+    ESP_LOGI(TAG, "Codec mode is %d, Ctrl:%d", mode, audio_hal_state);
+    ret = audio_hal->audio_codec_ctrl(mode, audio_hal_state);
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return ret;
+}
+
+esp_err_t audio_hal_codec_iface_config(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    esp_err_t ret = 0;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    AUDIO_HAL_CHECK_NULL(iface, "Get volume para is null", -1);
+    mutex_lock(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_config_iface(mode, iface);
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return ret;
+}
+
+esp_err_t audio_hal_set_mute(audio_hal_handle_t audio_hal, bool mute)
+{
+    esp_err_t ret;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    mutex_lock(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_set_mute(mute);
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return ret;
+}
+
+esp_err_t audio_hal_enable_pa(audio_hal_handle_t audio_hal, bool enable)
+{
+    esp_err_t ret;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    mutex_lock(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_enable_pa(enable);
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return ret;
+}
+
+esp_err_t audio_hal_set_volume(audio_hal_handle_t audio_hal, int volume)
+{
+    esp_err_t ret;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    mutex_lock(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_set_volume(volume);
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return ret;
+}
+
+esp_err_t audio_hal_get_volume(audio_hal_handle_t audio_hal, int *volume)
+{
+    esp_err_t ret;
+    AUDIO_HAL_CHECK_NULL(audio_hal, "audio_hal handle is null", -1);
+    AUDIO_HAL_CHECK_NULL(volume, "Get volume para is null", -1);
+    mutex_lock(audio_hal->audio_hal_lock);
+    ret = audio_hal->audio_codec_get_volume(volume);
+    mutex_unlock(audio_hal->audio_hal_lock);
+    return ret;
+}
diff --git a/components/audio_hal/audio_volume.c b/components/audio_hal/audio_volume.c
index cee41fb7..ac0b8cc5 100644
--- a/components/audio_hal/audio_volume.c
+++ b/components/audio_hal/audio_volume.c
@@ -1,173 +1,173 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/*
- *                   |----------------Digital Gain---------------------|--Analog Gain-|
- *
- *  |--------------|    |--------------------|    |------------------|    |---------|    |----------------|
- *  | Audio Stream |--->| Audio Process Gain |--->| Codec DAC Volume |--->| PA Gain |--->| Speaker Output |
- *  |--------------|    |--------------------|    |------------------|    |---------|    |----------------|
- *
- * The speaker playback route is shown as the block diagram above. The speaker loudness is affected by both
- * audio Digital Gain and Analog Gain.
- *
- * Digital Gain:
- * Audio Process Gain: Audio Process, such as ALC, AGC, DRC target MAX Gain.
- * Codec DAC Volume: The audio codec DAC volume control, such as ES8311 DAC_Volume control register.
- *
- * Analog Gain:
- * PA Gain: The speaker power amplifier Gain, which is determined by the hardware circuit board.
- *
- * User can control the speaker playback volume by adjusting Codec DAC Volume.
- *
- * We use volume level (1-100) to represent the volume levels, level 100 is the MAX volume. We create a volume
- * mapping index table for the user to set the volume level through Codec DAC volume. The default mapping table
- * maps volume level(1-100) to Codec DAC Volume (-49.5dB, 0dB). The volume setting has 25 volume levels.
- * Level step is 4, and the corresponding to Codec DAC Volume Gain is 2 dB step. Normally, Codec DAC volume -50 dB
- * reproduces a minimal speaker loudness, and the 2 dB step allows the user to detect the volume change.
- *
- * Gain and Decibel Reference: https://www.espressif.com/zh-hans/media_overview/blog
- *
- */
-
-#include <string.h>
-#include <math.h>
-#include "audio_volume.h"
-#include "audio_mem.h"
-
-/**
- * The speaker playback route gain (Audio Process Gain + Codec DAC Volume + PA Gain) needs to ensure that the
- * speaker PA output is not saturated and exceeds the speaker rated power. We define the maximum route gain
- * as MAX_GAIN. To ensure the speaker PA output is not saturated, MAX_GAIN can be calculated simply by the formula.
- *    MAX_GAIN = 20 * log(Vpa/Vdac)
- *    Vpa: PA power supply
- *    Vdac: Codec DAC power supply
- * e.g., Vpa = 5V, Vdac = 3.3V, then MAX_GAIN = 20 * log(5/3.3) = 3.6 dB.
- * If the speaker rated power is lower than the speaker PA MAX power, MAX_GAIN should be defined according to
- * the speaker rated power.
- *
- */
-#define VPA        (5.0)
-#define VDAC       (3.3)
-#define MAX_GAIN   (20.0 * log10(VPA / VDAC))
-
-/*
- * User can customize the volume setting by modifying the mapping table and adjust the volume step according to
- * the speaker playback system, and the other volume levels shift the value accordingly.
- * Integers are used instead of floating-point variables to reduce storage space. -80 means -40 dB, 0 means 0 dB.
- */
-static const int8_t dac_volume_offset[] = {
-    -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80,
-    -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60,
-    -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40,
-    -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20,
-    -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9,  -8,  -7,  -6,  -5,  -4,  -3,  -2,  -1,   0
-};
-
-/**
- * @brief Get DAC volume offset from user set volume, you can use an array or function to finish this map
- *
- * @note The max DAC volume is 0 dB when the user volume is 100. 0 dB means there is no attenuation of the sound source,
- *       and it is the original sound source. It can not exceed 0 dB. Otherwise, there is a risk of clipping noise.
- * @note For better audio dynamic range, we'd better use 0dB full scale digital gain and lower analog gain.
- * @note DAC volume offset is positively correlated with the user volume.
- *
- * @param volume User set volume (1-100)
- *
- * @return
- *     - Codec DAC volume offset. The max value must be 0 dB.
- */
-static inline float codec_get_dac_volume_offset(int volume)
-{
-    float offset = dac_volume_offset[volume - 1] / 2.0;
-    return offset;
-}
-
-/**
- * @brief The register value is linear to the dac_volume
- */
-static inline uint8_t audio_codec_calculate_reg(volume_handle_t vol_handle, float dac_volume)
-{
-    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) vol_handle;
-    uint8_t reg = (uint8_t) (dac_volume / (handle->dac_vol_symbol * handle->volume_accuracy) + handle->zero_volume_reg);
-    return reg;
-}
-
-volume_handle_t audio_codec_volume_init(codec_dac_volume_config_t *config)
-{
-    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) audio_calloc(1, sizeof(codec_dac_volume_config_t));
-    memcpy(handle, config, sizeof(codec_dac_volume_config_t));
-    if (!handle->offset_conv_volume) {
-        handle->offset_conv_volume = codec_get_dac_volume_offset;
-    }
-    return (volume_handle_t) handle;
-}
-
-/**
- * @brief Take zero dac_volume as the origin and calculate the volume offset according to the register value
- */
-float audio_codec_cal_dac_volume(volume_handle_t vol_handle)
-{
-    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) vol_handle;
-    float dac_volume = handle->dac_vol_symbol * handle->volume_accuracy * (handle->reg_value - handle->zero_volume_reg);
-    return dac_volume;
-}
-
-uint8_t audio_codec_get_dac_reg_value(volume_handle_t vol_handle, int volume)
-{
-    float dac_volume = 0;
-    int user_volume = volume;
-    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) vol_handle;
-
-    if (user_volume < 0) {
-        user_volume = 0;
-    } else if (user_volume > 100) {
-        user_volume = 100;
-    }
-
-    if (user_volume == 0) {
-        dac_volume = handle->min_dac_volume; // Make sure the speaker voice is near silent
-    } else {
-        /*
-         * For better audio performance, at the max volume, we need to ensure:
-         * Audio Process Gain + Codec DAC Volume + PA Gain <= MAX_GAIN.
-         * The PA Gain and Audio Process Gain are known when the board design is fixed, so
-         * max Codec DAC Volume = MAX_GAIN - PA Gain - Audio Process Gain∩╝îthen
-         * the volume mapping table shift accordingly.
-         */
-        dac_volume = handle->offset_conv_volume(user_volume) + MAX_GAIN - handle->board_pa_gain;
-        dac_volume = dac_volume < handle->max_dac_volume ? dac_volume : handle->max_dac_volume;
-    }
-    handle->reg_value = audio_codec_calculate_reg(handle, dac_volume);
-    handle->user_volume = user_volume;
-    return handle->reg_value;
-}
-
-void audio_codec_volume_deinit(volume_handle_t vol_handle)
-{
-    if (vol_handle) {
-        audio_free(vol_handle);
-        vol_handle = NULL;
-    }
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/*
+ *                   |----------------Digital Gain---------------------|--Analog Gain-|
+ *
+ *  |--------------|    |--------------------|    |------------------|    |---------|    |----------------|
+ *  | Audio Stream |--->| Audio Process Gain |--->| Codec DAC Volume |--->| PA Gain |--->| Speaker Output |
+ *  |--------------|    |--------------------|    |------------------|    |---------|    |----------------|
+ *
+ * The speaker playback route is shown as the block diagram above. The speaker loudness is affected by both
+ * audio Digital Gain and Analog Gain.
+ *
+ * Digital Gain:
+ * Audio Process Gain: Audio Process, such as ALC, AGC, DRC target MAX Gain.
+ * Codec DAC Volume: The audio codec DAC volume control, such as ES8311 DAC_Volume control register.
+ *
+ * Analog Gain:
+ * PA Gain: The speaker power amplifier Gain, which is determined by the hardware circuit board.
+ *
+ * User can control the speaker playback volume by adjusting Codec DAC Volume.
+ *
+ * We use volume level (1-100) to represent the volume levels, level 100 is the MAX volume. We create a volume
+ * mapping index table for the user to set the volume level through Codec DAC volume. The default mapping table
+ * maps volume level(1-100) to Codec DAC Volume (-49.5dB, 0dB). The volume setting has 25 volume levels.
+ * Level step is 4, and the corresponding to Codec DAC Volume Gain is 2 dB step. Normally, Codec DAC volume -50 dB
+ * reproduces a minimal speaker loudness, and the 2 dB step allows the user to detect the volume change.
+ *
+ * Gain and Decibel Reference: https://www.espressif.com/zh-hans/media_overview/blog
+ *
+ */
+
+#include <string.h>
+#include <math.h>
+#include "audio_volume.h"
+#include "audio_mem.h"
+
+/**
+ * The speaker playback route gain (Audio Process Gain + Codec DAC Volume + PA Gain) needs to ensure that the
+ * speaker PA output is not saturated and exceeds the speaker rated power. We define the maximum route gain
+ * as MAX_GAIN. To ensure the speaker PA output is not saturated, MAX_GAIN can be calculated simply by the formula.
+ *    MAX_GAIN = 20 * log(Vpa/Vdac)
+ *    Vpa: PA power supply
+ *    Vdac: Codec DAC power supply
+ * e.g., Vpa = 5V, Vdac = 3.3V, then MAX_GAIN = 20 * log(5/3.3) = 3.6 dB.
+ * If the speaker rated power is lower than the speaker PA MAX power, MAX_GAIN should be defined according to
+ * the speaker rated power.
+ *
+ */
+#define VPA        (5.0)
+#define VDAC       (3.3)
+#define MAX_GAIN   (20.0 * log10(VPA / VDAC))
+
+/*
+ * User can customize the volume setting by modifying the mapping table and adjust the volume step according to
+ * the speaker playback system, and the other volume levels shift the value accordingly.
+ * Integers are used instead of floating-point variables to reduce storage space. -80 means -40 dB, 0 means 0 dB.
+ */
+static const int8_t dac_volume_offset[] = {
+    -99, -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86, -85, -84, -83, -82, -81, -80,
+    -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60,
+    -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40,
+    -39, -38, -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20,
+    -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9,  -8,  -7,  -6,  -5,  -4,  -3,  -2,  -1,   0
+};
+
+/**
+ * @brief Get DAC volume offset from user set volume, you can use an array or function to finish this map
+ *
+ * @note The max DAC volume is 0 dB when the user volume is 100. 0 dB means there is no attenuation of the sound source,
+ *       and it is the original sound source. It can not exceed 0 dB. Otherwise, there is a risk of clipping noise.
+ * @note For better audio dynamic range, we'd better use 0dB full scale digital gain and lower analog gain.
+ * @note DAC volume offset is positively correlated with the user volume.
+ *
+ * @param volume User set volume (1-100)
+ *
+ * @return
+ *     - Codec DAC volume offset. The max value must be 0 dB.
+ */
+static inline float codec_get_dac_volume_offset(int volume)
+{
+    float offset = dac_volume_offset[volume - 1] / 2.0;
+    return offset;
+}
+
+/**
+ * @brief The register value is linear to the dac_volume
+ */
+static inline uint8_t audio_codec_calculate_reg(volume_handle_t vol_handle, float dac_volume)
+{
+    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) vol_handle;
+    uint8_t reg = (uint8_t) (dac_volume / (handle->dac_vol_symbol * handle->volume_accuracy) + handle->zero_volume_reg);
+    return reg;
+}
+
+volume_handle_t audio_codec_volume_init(codec_dac_volume_config_t *config)
+{
+    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) audio_calloc(1, sizeof(codec_dac_volume_config_t));
+    memcpy(handle, config, sizeof(codec_dac_volume_config_t));
+    if (!handle->offset_conv_volume) {
+        handle->offset_conv_volume = codec_get_dac_volume_offset;
+    }
+    return (volume_handle_t) handle;
+}
+
+/**
+ * @brief Take zero dac_volume as the origin and calculate the volume offset according to the register value
+ */
+float audio_codec_cal_dac_volume(volume_handle_t vol_handle)
+{
+    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) vol_handle;
+    float dac_volume = handle->dac_vol_symbol * handle->volume_accuracy * (handle->reg_value - handle->zero_volume_reg);
+    return dac_volume;
+}
+
+uint8_t audio_codec_get_dac_reg_value(volume_handle_t vol_handle, int volume)
+{
+    float dac_volume = 0;
+    int user_volume = volume;
+    codec_dac_volume_config_t *handle = (codec_dac_volume_config_t *) vol_handle;
+
+    if (user_volume < 0) {
+        user_volume = 0;
+    } else if (user_volume > 100) {
+        user_volume = 100;
+    }
+
+    if (user_volume == 0) {
+        dac_volume = handle->min_dac_volume; // Make sure the speaker voice is near silent
+    } else {
+        /*
+         * For better audio performance, at the max volume, we need to ensure:
+         * Audio Process Gain + Codec DAC Volume + PA Gain <= MAX_GAIN.
+         * The PA Gain and Audio Process Gain are known when the board design is fixed, so
+         * max Codec DAC Volume = MAX_GAIN - PA Gain - Audio Process Gain∩╝îthen
+         * the volume mapping table shift accordingly.
+         */
+        dac_volume = handle->offset_conv_volume(user_volume) + MAX_GAIN - handle->board_pa_gain;
+        dac_volume = dac_volume < handle->max_dac_volume ? dac_volume : handle->max_dac_volume;
+    }
+    handle->reg_value = audio_codec_calculate_reg(handle, dac_volume);
+    handle->user_volume = user_volume;
+    return handle->reg_value;
+}
+
+void audio_codec_volume_deinit(volume_handle_t vol_handle)
+{
+    if (vol_handle) {
+        audio_free(vol_handle);
+        vol_handle = NULL;
+    }
+}
diff --git a/components/audio_hal/component.mk b/components/audio_hal/component.mk
index d794d0e7..99ecccd3 100644
--- a/components/audio_hal/component.mk
+++ b/components/audio_hal/component.mk
@@ -1,24 +1,24 @@
-#
-# "main" pseudo-component makefile.
-#
-# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
-
-COMPONENT_ADD_INCLUDEDIRS := ./include ./driver/include
-COMPONENT_SRCDIRS := .
-COMPONENT_PRIV_INCLUDEDIRS := ./driver/include
-
-COMPONENT_ADD_INCLUDEDIRS += ./driver/es8388 ./driver/es8374
-COMPONENT_SRCDIRS += ./driver/es8388 ./driver/es8374
-
-COMPONENT_ADD_INCLUDEDIRS += ./driver/es8311 ./driver/es7243
-COMPONENT_SRCDIRS += ./driver/es8311 ./driver/es7243
-
-COMPONENT_ADD_INCLUDEDIRS += ./driver/zl38063 ./driver/zl38063/api_lib ./driver/zl38063/example_apps ./driver/zl38063/firmware
-COMPONENT_SRCDIRS += ./driver/zl38063 ./driver/zl38063/api_lib ./driver/zl38063/example_apps ./driver/zl38063/firmware
-COMPONENT_ADD_LDFLAGS += -L$(COMPONENT_PATH)/driver/zl38063/firmware -lfirmware
-
-COMPONENT_ADD_INCLUDEDIRS += ./driver/tas5805m ./driver/es7148
-COMPONENT_SRCDIRS += ./driver/tas5805m ./driver/es7148
-
-COMPONENT_ADD_INCLUDEDIRS += ./driver/es7210 ./driver/es8156 ./driver/es7243e
-COMPONENT_SRCDIRS += ./driver/es7210 ./driver/es8156 ./driver/es7243e
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
+
+COMPONENT_ADD_INCLUDEDIRS := ./include ./driver/include
+COMPONENT_SRCDIRS := .
+COMPONENT_PRIV_INCLUDEDIRS := ./driver/include
+
+COMPONENT_ADD_INCLUDEDIRS += ./driver/es8388 ./driver/es8374
+COMPONENT_SRCDIRS += ./driver/es8388 ./driver/es8374
+
+COMPONENT_ADD_INCLUDEDIRS += ./driver/es8311 ./driver/es7243
+COMPONENT_SRCDIRS += ./driver/es8311 ./driver/es7243
+
+COMPONENT_ADD_INCLUDEDIRS += ./driver/zl38063 ./driver/zl38063/api_lib ./driver/zl38063/example_apps ./driver/zl38063/firmware
+COMPONENT_SRCDIRS += ./driver/zl38063 ./driver/zl38063/api_lib ./driver/zl38063/example_apps ./driver/zl38063/firmware
+COMPONENT_ADD_LDFLAGS += -L$(COMPONENT_PATH)/driver/zl38063/firmware -lfirmware
+
+COMPONENT_ADD_INCLUDEDIRS += ./driver/tas5805m ./driver/es7148
+COMPONENT_SRCDIRS += ./driver/tas5805m ./driver/es7148
+
+COMPONENT_ADD_INCLUDEDIRS += ./driver/es7210 ./driver/es8156 ./driver/es7243e
+COMPONENT_SRCDIRS += ./driver/es7210 ./driver/es8156 ./driver/es7243e
diff --git a/components/audio_hal/driver/es7148/es7148.c b/components/audio_hal/driver/es7148/es7148.c
index e50ade64..d3af5cc5 100644
--- a/components/audio_hal/driver/es7148/es7148.c
+++ b/components/audio_hal/driver/es7148/es7148.c
@@ -1,95 +1,95 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "es7148.h"
-#include "driver/gpio.h"
-#include "board.h"
-
-
-static const char *TAG = "es7148";
-
-
-static bool codec_init_flag = 0;
-
-audio_hal_func_t AUDIO_CODEC_ES7148_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es7148_codec_init,
-    .audio_codec_deinitialize = es7148_codec_deinit,
-    .audio_codec_ctrl = es7148_codec_ctrl_state,
-    .audio_codec_config_iface = es7148_codec_config_i2s,
-    .audio_codec_set_mute = es7148_codec_set_voice_mute,
-    .audio_codec_set_volume = es7148_codec_set_voice_volume,
-    .audio_codec_get_volume = es7148_codec_get_voice_volume,
-    .audio_codec_enable_pa = NULL,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static bool es7148_codec_initialized()
-{
-    return codec_init_flag;
-}
-
-esp_err_t es7148_codec_init(audio_hal_codec_config_t *cfg)
-{
-    if (es7148_codec_initialized()) {
-        ESP_LOGW(TAG, "The es7148 codec has been already initialized");
-        return ESP_OK;
-    }
-    codec_init_flag = true;
-    return ESP_OK;
-}
-
-esp_err_t es7148_codec_deinit(void)
-{
-    codec_init_flag = false;
-    return ESP_OK;
-}
-
-esp_err_t es7148_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7148_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7148_codec_set_voice_mute(bool mute)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7148_codec_set_voice_volume(int volume)
-{
-    int ret = 0;
-    return ret;
-}
-
-esp_err_t es7148_codec_get_voice_volume(int *volume)
-{
-    int ret = 0;
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "es7148.h"
+#include "driver/gpio.h"
+#include "board.h"
+
+
+static const char *TAG = "es7148";
+
+
+static bool codec_init_flag = 0;
+
+audio_hal_func_t AUDIO_CODEC_ES7148_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es7148_codec_init,
+    .audio_codec_deinitialize = es7148_codec_deinit,
+    .audio_codec_ctrl = es7148_codec_ctrl_state,
+    .audio_codec_config_iface = es7148_codec_config_i2s,
+    .audio_codec_set_mute = es7148_codec_set_voice_mute,
+    .audio_codec_set_volume = es7148_codec_set_voice_volume,
+    .audio_codec_get_volume = es7148_codec_get_voice_volume,
+    .audio_codec_enable_pa = NULL,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static bool es7148_codec_initialized()
+{
+    return codec_init_flag;
+}
+
+esp_err_t es7148_codec_init(audio_hal_codec_config_t *cfg)
+{
+    if (es7148_codec_initialized()) {
+        ESP_LOGW(TAG, "The es7148 codec has been already initialized");
+        return ESP_OK;
+    }
+    codec_init_flag = true;
+    return ESP_OK;
+}
+
+esp_err_t es7148_codec_deinit(void)
+{
+    codec_init_flag = false;
+    return ESP_OK;
+}
+
+esp_err_t es7148_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7148_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7148_codec_set_voice_mute(bool mute)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7148_codec_set_voice_volume(int volume)
+{
+    int ret = 0;
+    return ret;
+}
+
+esp_err_t es7148_codec_get_voice_volume(int *volume)
+{
+    int ret = 0;
+    return ret;
+}
diff --git a/components/audio_hal/driver/es7148/es7148.h b/components/audio_hal/driver/es7148/es7148.h
index 6f677f7e..ea02eb18 100644
--- a/components/audio_hal/driver/es7148/es7148.h
+++ b/components/audio_hal/driver/es7148/es7148.h
@@ -1,119 +1,119 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __ES7148_H__
-#define __ES7148_H__
-
-#include "audio_hal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Initialize es7148 chip
- *
- * @param cfg configuration of es7148
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7148_codec_init(audio_hal_codec_config_t *cfg);
-/**
- * @brief Deinitialize es7148 chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7148_codec_deinit(void);
-/**
- * The functions es7148_ctrl_state and es7148_config_i2s are not used by this driver.
- * They are kept here to maintain the uniformity and convenience of the interface
- * of the ADF project.
- * These settings for es7148 are burned in firmware and configuration files.
- * Default i2s configuration: 48000Hz, 16bit, Left-Right channels.
- * Use resampling to be compatible with different file types.
- *
- * @brief Control es7148 chip
- *
- * @param mode codec mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es7148_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-/**
- * @brief Configure es7148 codec mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es7148_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief mute or unmute the codec
- *
- * @param mute:  true, false
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7148_codec_set_voice_mute(bool mute);
-
-/**
- * @brief  Set voice volume
- *
- * @param volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7148_codec_set_voice_volume(int volume);
-
-/**
- * @brief Get voice volume
- *
- * @param[out] *volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7148_codec_get_voice_volume(int *volume);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __ES7148_H__
+#define __ES7148_H__
+
+#include "audio_hal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initialize es7148 chip
+ *
+ * @param cfg configuration of es7148
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7148_codec_init(audio_hal_codec_config_t *cfg);
+/**
+ * @brief Deinitialize es7148 chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7148_codec_deinit(void);
+/**
+ * The functions es7148_ctrl_state and es7148_config_i2s are not used by this driver.
+ * They are kept here to maintain the uniformity and convenience of the interface
+ * of the ADF project.
+ * These settings for es7148 are burned in firmware and configuration files.
+ * Default i2s configuration: 48000Hz, 16bit, Left-Right channels.
+ * Use resampling to be compatible with different file types.
+ *
+ * @brief Control es7148 chip
+ *
+ * @param mode codec mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es7148_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+/**
+ * @brief Configure es7148 codec mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es7148_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief mute or unmute the codec
+ *
+ * @param mute:  true, false
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7148_codec_set_voice_mute(bool mute);
+
+/**
+ * @brief  Set voice volume
+ *
+ * @param volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7148_codec_set_voice_volume(int volume);
+
+/**
+ * @brief Get voice volume
+ *
+ * @param[out] *volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7148_codec_get_voice_volume(int *volume);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/es7210/es7210.c b/components/audio_hal/driver/es7210/es7210.c
index 73bd08f4..9db6de80 100644
--- a/components/audio_hal/driver/es7210/es7210.c
+++ b/components/audio_hal/driver/es7210/es7210.c
@@ -1,605 +1,605 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "board.h"
-#include "i2c_bus.h"
-#include "es7210.h"
-
-/* ES7210 address */
-#define ES7210_ADDR (ES7210_AD1_AD0_00)
-
-#define I2S_DSP_MODE          (0)
-#define MCLK_DIV_FRE          (256)
-#define FROM_PAD_PIN          (0)
-#define FROM_CLOCK_DOUBLE_PIN (1)
-#define ENABLE_TDM_MAX_NUM    (3)
-#define ES7210_MCLK_SOURCE    (FROM_CLOCK_DOUBLE_PIN)  /* In master mode. 0 : MCLK from pad; 1 : MCLK from clock doubler */
-
-#ifndef ES7210_MIC_SELECT
-#define ES7210_MIC_SELECT (ES7210_INPUT_MIC1 | ES7210_INPUT_MIC2)
-#endif  /* ES7210_MIC_SELECT */
-
-static char *TAG = "ES7210";
-
-static struct {
-    i2c_bus_handle_t i2c_handle;
-    es7210_input_mics_t mic_select;
-    es7210_gain_value_t gain;
-} es7210_handle;
-
-/**
- * Operate function of ADC
- */
-audio_hal_func_t AUDIO_CODEC_ES7210_DEFAULT_HANDLE = {
-    .audio_codec_initialize   = es7210_adc_init,
-    .audio_codec_deinitialize = es7210_adc_deinit,
-    .audio_codec_ctrl         = es7210_adc_ctrl_state,
-    .audio_codec_config_iface = es7210_adc_config_i2s,
-    .audio_codec_set_mute     = es7210_set_mute,
-    .audio_codec_set_volume   = es7210_adc_set_volume,
-    .audio_codec_get_volume   = NULL,
-    .audio_codec_enable_pa    = NULL,
-    .audio_hal_lock           = NULL,
-    .handle                   = NULL,
-};
-
-/*
- * Clock coefficient structer
- */
-struct _coeff_div {
-    uint32_t mclk;            /* mclk frequency */
-    uint32_t lrck;            /* lrck */
-    uint8_t  ss_ds;
-    uint8_t  adc_div;         /* adcclk divider */
-    uint8_t  dll;             /* dll_bypass */
-    uint8_t  doubler;         /* doubler enable */
-    uint8_t  osr;             /* adc osr */
-    uint8_t  mclk_src;        /* select mclk  source */
-    uint32_t lrck_h;          /* The high 4 bits of lrck */
-    uint32_t lrck_l;          /* The low 8 bits of lrck */
-};
-
-/* Codec hifi mclk clock divider coefficients
- *           MEMBER      REG
- *           mclk:       0x03
- *           lrck:       standard
- *           ss_ds:      --
- *           adc_div:    0x02
- *           dll:        0x06
- *           doubler:    0x02
- *           osr:        0x07
- *           mclk_src:   0x03
- *           lrckh:      0x04
- *           lrckl:      0x05
-*/
-static const struct _coeff_div coeff_div[] = {
-    //mclk      lrck    ss_ds adc_div  dll  doubler osr  mclk_src  lrckh   lrckl
-    /* 8k */
-    {12288000,  8000 ,  0x00,  0x03,  0x01,  0x00,  0x20,  0x00,    0x06,  0x00},
-    {16384000,  8000 ,  0x00,  0x04,  0x01,  0x00,  0x20,  0x00,    0x08,  0x00},
-    {19200000,  8000 ,  0x00,  0x1e,  0x00,  0x01,  0x28,  0x00,    0x09,  0x60},
-    {4096000,   8000 ,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
-
-    /* 11.025k */
-    {11289600,  11025,  0x00,  0x02,  0x01,  0x00,  0x20,  0x00,    0x01,  0x00},
-
-    /* 12k */
-    {12288000,  12000,  0x00,  0x02,  0x01,  0x00,  0x20,  0x00,    0x04,  0x00},
-    {19200000,  12000,  0x00,  0x14,  0x00,  0x01,  0x28,  0x00,    0x06,  0x40},
-
-    /* 16k */
-    {4096000,   16000,  0x00,  0x01,  0x01,  0x01,  0x20,  0x00,    0x01,  0x00},
-    {19200000,  16000,  0x00,  0x0a,  0x00,  0x00,  0x1e,  0x00,    0x04,  0x80},
-    {16384000,  16000,  0x00,  0x02,  0x01,  0x00,  0x20,  0x00,    0x04,  0x00},
-    {12288000,  16000,  0x00,  0x03,  0x01,  0x01,  0x20,  0x00,    0x03,  0x00},
-
-    /* 22.05k */
-    {11289600,  22050,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
-
-    /* 24k */
-    {12288000,  24000,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
-    {19200000,  24000,  0x00,  0x0a,  0x00,  0x01,  0x28,  0x00,    0x03,  0x20},
-
-    /* 32k */
-    {12288000,  32000,  0x00,  0x03,  0x00,  0x00,  0x20,  0x00,    0x01,  0x80},
-    {16384000,  32000,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
-    {19200000,  32000,  0x00,  0x05,  0x00,  0x00,  0x1e,  0x00,    0x02,  0x58},
-
-    /* 44.1k */
-    {11289600,  44100,  0x00,  0x01,  0x01,  0x01,  0x20,  0x00,    0x01,  0x00},
-
-    /* 48k */
-    {12288000,  48000,  0x00,  0x01,  0x01,  0x01,  0x20,  0x00,    0x01,  0x00},
-    {19200000,  48000,  0x00,  0x05,  0x00,  0x01,  0x28,  0x00,    0x01,  0x90},
-
-    /* 64k */
-    {16384000,  64000,  0x01,  0x01,  0x01,  0x00,  0x20,  0x00,    0x01,  0x00},
-    {19200000,  64000,  0x00,  0x05,  0x00,  0x01,  0x1e,  0x00,    0x01,  0x2c},
-
-    /* 88.2k */
-    {11289600,  88200,  0x01,  0x01,  0x01,  0x01,  0x20,  0x00,    0x00,  0x80},
-
-    /* 96k */
-    {12288000,  96000,  0x01,  0x01,  0x01,  0x01,  0x20,  0x00,    0x00,  0x80},
-    {19200000,  96000,  0x01,  0x05,  0x00,  0x01,  0x28,  0x00,    0x00,  0xc8},
-};
-
-static int es7210_read_reg(uint8_t reg_addr)
-{
-    uint8_t data;
-    esp_err_t ret = i2c_bus_read_bytes(es7210_handle.i2c_handle, ES7210_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-    if (ret != ESP_OK) {
-        ESP_LOGE(TAG, "Failed to es7210 read 0x%x reg", reg_addr);
-    }
-    return (int)data;
-}
-
-static esp_err_t es7210_write_reg(uint8_t reg_addr, uint8_t data)
-{
-    return i2c_bus_write_bytes(es7210_handle.i2c_handle, ES7210_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-}
-
-static esp_err_t es7210_update_reg_bit(uint8_t reg_addr, uint8_t update_bits, uint8_t data)
-{
-    uint8_t regv;
-    regv = es7210_read_reg(reg_addr);
-    regv = (regv & (~update_bits)) | (update_bits & data);
-    return es7210_write_reg(reg_addr, regv);
-}
-
-static int i2c_init()
-{
-    int ret = 0;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000,
-    };
-    ret = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    AUDIO_RET_ON_FALSE(TAG, ret, return ESP_FAIL, "getting i2c pins error");
-    es7210_handle.i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return ret;
-}
-
-static int get_coeff(uint32_t mclk, uint32_t lrck)
-{
-    for (int i = 0; i < (sizeof(coeff_div) / sizeof(coeff_div[0])); i++) {
-        if (coeff_div[i].lrck == lrck && coeff_div[i].mclk == mclk)
-            return i;
-    }
-    return -1;
-}
-
-int8_t get_es7210_mclk_src(void)
-{
-    return ES7210_MCLK_SOURCE;
-}
-
-esp_err_t es7210_config_sample(audio_hal_iface_samples_t sample)
-{
-    int coeff;
-    int sample_fre = 0;
-    int mclk_fre = 0;
-    esp_err_t ret = ESP_OK;
-    switch (sample) {
-        case AUDIO_HAL_08K_SAMPLES:
-            sample_fre = 8000;
-            break;
-        case AUDIO_HAL_11K_SAMPLES:
-            sample_fre = 11025;
-            break;
-        case AUDIO_HAL_16K_SAMPLES:
-            sample_fre = 16000;
-            break;
-        case AUDIO_HAL_22K_SAMPLES:
-            sample_fre = 22050;
-            break;
-        case AUDIO_HAL_24K_SAMPLES:
-            sample_fre = 24000;
-            break;
-        case AUDIO_HAL_32K_SAMPLES:
-            sample_fre = 32000;
-            break;
-        case AUDIO_HAL_44K_SAMPLES:
-            sample_fre = 44100;
-            break;
-        case AUDIO_HAL_48K_SAMPLES:
-            sample_fre = 48000;
-            break;
-        default:
-            ESP_LOGE(TAG, "Unable to configure sample rate %dHz", sample_fre);
-            break;
-    }
-    mclk_fre = sample_fre * MCLK_DIV_FRE;
-    coeff = get_coeff(mclk_fre, sample_fre);
-    if (coeff < 0) {
-        ESP_LOGE(TAG, "Unable to configure sample rate %dHz with %dHz MCLK", sample_fre, mclk_fre);
-        return ESP_FAIL;
-    }
-    /* Set clock parammeters */
-    if (coeff >= 0) {
-        /* Set adc_div & doubler & dll */
-        uint8_t regv;
-        regv = es7210_read_reg(ES7210_MAINCLK_REG02) & 0x00;
-        regv |= coeff_div[coeff].adc_div;
-        regv |= coeff_div[coeff].doubler << 6;
-        regv |= coeff_div[coeff].dll << 7;
-        ret |= es7210_write_reg(ES7210_MAINCLK_REG02, regv);
-        /* Set osr */
-        regv = coeff_div[coeff].osr;
-        ret |= es7210_write_reg(ES7210_OSR_REG07, regv);
-        /* Set lrck */
-        regv = coeff_div[coeff].lrck_h;
-        ret |= es7210_write_reg(ES7210_LRCK_DIVH_REG04, regv);
-        regv = coeff_div[coeff].lrck_l;
-        ret |= es7210_write_reg(ES7210_LRCK_DIVL_REG05, regv);
-    }
-    return ret;
-}
-
-esp_err_t es7210_mic_select(es7210_input_mics_t mic_select)
-{
-    esp_err_t ret = ESP_OK;
-    uint16_t mic_num = 0;
-    es7210_handle.mic_select = mic_select;
-    if (es7210_handle.mic_select & (ES7210_INPUT_MIC1 | ES7210_INPUT_MIC2 | ES7210_INPUT_MIC3 | ES7210_INPUT_MIC4)) {
-        for (int i = 0; i < 4; i++) {
-            ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43 + i, 0x10, 0x00);
-        }
-        ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B, 0xff);
-        ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0xff);
-        if (es7210_handle.mic_select & ES7210_INPUT_MIC1) {
-            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC1");
-            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x0b, 0x00);
-            ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B, 0x00);
-            ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43, 0x10, 0x10);
-            ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43, 0x0f, es7210_handle.gain);
-        }
-        if (es7210_handle.mic_select & ES7210_INPUT_MIC2) {
-            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC2");
-            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x0b, 0x00);
-            ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B, 0x00);
-            ret |= es7210_update_reg_bit(ES7210_MIC2_GAIN_REG44, 0x10, 0x10);
-            ret |= es7210_update_reg_bit(ES7210_MIC2_GAIN_REG44, 0x0f, es7210_handle.gain);
-        }
-        if (es7210_handle.mic_select & ES7210_INPUT_MIC3) {
-            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC3");
-            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x15, 0x00);
-            ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0x00);
-            ret |= es7210_update_reg_bit(ES7210_MIC3_GAIN_REG45, 0x10, 0x10);
-            ret |= es7210_update_reg_bit(ES7210_MIC3_GAIN_REG45, 0x0f, es7210_handle.gain);
-        }
-        if (es7210_handle.mic_select & ES7210_INPUT_MIC4) {
-            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC4");
-            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x15, 0x00);
-            ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0x00);
-            ret |= es7210_update_reg_bit(ES7210_MIC4_GAIN_REG46, 0x10, 0x10);
-            ret |= es7210_update_reg_bit(ES7210_MIC4_GAIN_REG46, 0x0f, es7210_handle.gain);
-        }
-    } else {
-        ESP_LOGE(TAG, "Microphone selection error");
-        return ESP_FAIL;
-    }
-
-    for (int i = ES7210_INPUT_MIC1; i <= ES7210_INPUT_MIC4; i = i << 1) {
-        if (es7210_handle.mic_select & i) {
-            mic_num++;
-        }
-    }
-    if (mic_num >= ENABLE_TDM_MAX_NUM) {
-        ret |= es7210_write_reg(ES7210_SDP_INTERFACE2_REG12, 0x02);
-        ESP_LOGW(TAG, "Enable TDM mode. ES7210_SDP_INTERFACE2_REG12: %X", es7210_read_reg(ES7210_SDP_INTERFACE2_REG12));
-    } else {
-        ret |= es7210_write_reg(ES7210_SDP_INTERFACE2_REG12, 0x00);
-        ESP_LOGW(TAG, "Disable TDM mode. ES7210_SDP_INTERFACE2_REG12: %X", es7210_read_reg(ES7210_SDP_INTERFACE2_REG12));
-    }
-    return ret;
-}
-
-esp_err_t es7210_adc_init(audio_hal_codec_config_t *codec_cfg)
-{
-    esp_err_t ret = ESP_OK;
-    i2c_init();
-    ret |= es7210_write_reg(ES7210_RESET_REG00, 0xff);
-    ret |= es7210_write_reg(ES7210_RESET_REG00, 0x41);
-    ret |= es7210_write_reg(ES7210_CLOCK_OFF_REG01, 0x3f);
-    ret |= es7210_write_reg(ES7210_TIME_CONTROL0_REG09, 0x30);  /* Set chip state cycle */
-    ret |= es7210_write_reg(ES7210_TIME_CONTROL1_REG0A, 0x30);  /* Set power on state cycle */
-    ret |= es7210_write_reg(ES7210_ADC12_HPF2_REG23, 0x2a);     /* Quick setup */
-    ret |= es7210_write_reg(ES7210_ADC12_HPF1_REG22, 0x0a);
-    ret |= es7210_write_reg(ES7210_ADC34_HPF2_REG20, 0x0a);
-    ret |= es7210_write_reg(ES7210_ADC34_HPF1_REG21, 0x2a);
-    /* Set master/slave audio interface */
-    audio_hal_codec_i2s_iface_t *i2s_cfg = &(codec_cfg->i2s_iface);
-    switch (i2s_cfg->mode) {
-        case AUDIO_HAL_MODE_MASTER:  /* MASTER MODE */
-            ESP_LOGI(TAG, "ES7210 in Master mode");
-            ret |= es7210_update_reg_bit(ES7210_MODE_CONFIG_REG08, 0x01, 0x01);
-            /* Select clock source for internal mclk */
-            switch (get_es7210_mclk_src()) {
-                case FROM_PAD_PIN:
-                    ret |= es7210_update_reg_bit(ES7210_MASTER_CLK_REG03, 0x80, 0x00);
-                    break;
-                case FROM_CLOCK_DOUBLE_PIN:
-                    ret |= es7210_update_reg_bit(ES7210_MASTER_CLK_REG03, 0x80, 0x80);
-                    break;
-                default:
-                    ret |= es7210_update_reg_bit(ES7210_MASTER_CLK_REG03, 0x80, 0x00);
-                    break;
-            }
-            break;
-        case AUDIO_HAL_MODE_SLAVE:  /* SLAVE MODE */
-            ESP_LOGI(TAG, "ES7210 in Slave mode");
-            ret |= es7210_update_reg_bit(ES7210_MODE_CONFIG_REG08, 0x01, 0x00);
-            break;
-        default:
-            ret |= es7210_update_reg_bit(ES7210_MODE_CONFIG_REG08, 0x01, 0x00);
-    }
-    ret |= es7210_write_reg(ES7210_ANALOG_REG40, 0x43);      /* Select power off analog, vdda = 3.3V, close vx20ff, VMID select 5K╬⌐ start */
-    ret |= es7210_write_reg(ES7210_MIC12_BIAS_REG41, 0x70);  /* Select 2.87v */
-    ret |= es7210_write_reg(ES7210_MIC34_BIAS_REG42, 0x70);  /* Select 2.87v */
-    ret |= es7210_write_reg(ES7210_OSR_REG07, 0x20);
-    ret |= es7210_write_reg(ES7210_MAINCLK_REG02, 0xc1);  /* Set the frequency division coefficient and use dll except clock doubler, and need to set 0xc1 to clear the state */
-    ret |= es7210_config_sample(i2s_cfg->samples);
-    ret |= es7210_mic_select(ES7210_MIC_SELECT);
-    ret |= es7210_adc_set_gain(ES7210_MIC_SELECT, GAIN_24DB);
-    return ESP_OK;
-}
-
-esp_err_t es7210_adc_deinit()
-{
-    i2c_bus_delete(es7210_handle.i2c_handle);
-    return ESP_OK;
-}
-
-esp_err_t es7210_config_fmt(audio_hal_iface_format_t fmt)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t adc_iface = 0;
-    adc_iface = es7210_read_reg(ES7210_SDP_INTERFACE1_REG11);
-    adc_iface &= 0xfc;
-    switch (fmt) {
-        case AUDIO_HAL_I2S_NORMAL:
-            ESP_LOGD(TAG, "ES7210 in I2S Format");
-            adc_iface |= 0x00;
-            break;
-        case AUDIO_HAL_I2S_LEFT:
-        case AUDIO_HAL_I2S_RIGHT:
-            ESP_LOGD(TAG, "ES7210 in LJ Format");
-            adc_iface |= 0x01;
-            break;
-        case AUDIO_HAL_I2S_DSP:
-            if (I2S_DSP_MODE) {
-                ESP_LOGD(TAG, "ES7210 in DSP-A Format");
-                adc_iface |= 0x13;
-            } else {
-                ESP_LOGD(TAG, "ES7210 in DSP-B Format");
-                adc_iface |= 0x03;
-            }
-            break;
-        default:
-            adc_iface &= 0xfc;
-            break;
-    }
-    ret |= es7210_write_reg(ES7210_SDP_INTERFACE1_REG11, adc_iface);
-    ESP_LOGI(TAG, "config fmt %X", adc_iface);
-    return ret;
-}
-
-esp_err_t es7210_set_bits(audio_hal_iface_bits_t bits)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t adc_iface = 0;
-    adc_iface = es7210_read_reg(ES7210_SDP_INTERFACE1_REG11);
-    adc_iface &= 0x1f;
-    switch (bits) {
-        case AUDIO_HAL_BIT_LENGTH_16BITS:
-            adc_iface |= 0x60;
-            break;
-        case AUDIO_HAL_BIT_LENGTH_24BITS:
-            adc_iface |= 0x00;
-            break;
-        case AUDIO_HAL_BIT_LENGTH_32BITS:
-            adc_iface |= 0x80;
-            break;
-        default:
-            adc_iface |= 0x60;
-            break;
-    }
-    ret |= es7210_write_reg(ES7210_SDP_INTERFACE1_REG11, adc_iface);
-    return ret;
-}
-
-esp_err_t es7210_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    esp_err_t ret = ESP_OK;
-    ret |= es7210_set_bits(iface->bits);
-    ret |= es7210_config_fmt(iface->fmt);
-    ret |= es7210_config_sample(iface->samples);
-    return ret;
-}
-
-esp_err_t es7210_start(uint8_t clock_reg_value)
-{
-    esp_err_t ret = ESP_OK;
-    ret |= es7210_write_reg(ES7210_CLOCK_OFF_REG01, clock_reg_value);
-    ret |= es7210_write_reg(ES7210_POWER_DOWN_REG06, 0x00);
-    ret |= es7210_write_reg(ES7210_ANALOG_REG40, 0x43);
-    ret |= es7210_write_reg(ES7210_MIC1_POWER_REG47, 0x08);
-    ret |= es7210_write_reg(ES7210_MIC2_POWER_REG48, 0x08);
-    ret |= es7210_write_reg(ES7210_MIC3_POWER_REG49, 0x08);
-    ret |= es7210_write_reg(ES7210_MIC4_POWER_REG4A, 0x08);
-    ret |= es7210_mic_select(es7210_handle.mic_select);
-    return ret;
-}
-
-esp_err_t es7210_stop(void)
-{
-    esp_err_t ret = ESP_OK;
-    ret |= es7210_write_reg(ES7210_MIC1_POWER_REG47, 0xff);
-    ret |= es7210_write_reg(ES7210_MIC2_POWER_REG48, 0xff);
-    ret |= es7210_write_reg(ES7210_MIC3_POWER_REG49, 0xff);
-    ret |= es7210_write_reg(ES7210_MIC4_POWER_REG4A, 0xff);
-    ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B,0xff);
-    ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0xff);
-    ret |= es7210_write_reg(ES7210_ANALOG_REG40, 0xc0);
-    ret |= es7210_write_reg(ES7210_CLOCK_OFF_REG01, 0x7f);
-    ret |= es7210_write_reg(ES7210_POWER_DOWN_REG06, 0x07);
-    return ret;
-}
-
-esp_err_t es7210_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    static uint8_t regv;
-    esp_err_t ret = ESP_OK;
-    ESP_LOGW(TAG, "ES7210 only supports ADC mode");
-    ret = es7210_read_reg(ES7210_CLOCK_OFF_REG01);
-    if ((ret != 0x7f) && (ret != 0xff)) {
-        regv = es7210_read_reg(ES7210_CLOCK_OFF_REG01);
-    }
-    if (ctrl_state == AUDIO_HAL_CTRL_START) {
-        ESP_LOGI(TAG, "The ES7210_CLOCK_OFF_REG01 value before stop is %x",regv);
-        ret |= es7210_start(regv);
-    } else {
-        ESP_LOGW(TAG, "The codec is about to stop");
-        regv = es7210_read_reg(ES7210_CLOCK_OFF_REG01);
-        ret |= es7210_stop();
-    }
-    return ret;
-}
-
-esp_err_t es7210_adc_set_gain(es7210_input_mics_t mic_select, es7210_gain_value_t gain)
-{
-    esp_err_t ret = ESP_OK;
-    uint32_t max_gain_vaule = 14;
-    if (gain < 0) {
-        gain = 0;
-    } else if (gain > max_gain_vaule) {
-        gain = max_gain_vaule;
-    }
-    ESP_LOGD(TAG, "Set gain %d", gain);
-    if (mic_select & ES7210_INPUT_MIC1) {
-        ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43, 0x0f, gain);
-    }
-    if (mic_select & ES7210_INPUT_MIC2) {
-        ret |= es7210_update_reg_bit(ES7210_MIC2_GAIN_REG44, 0x0f, gain);
-    }
-    if (mic_select & ES7210_INPUT_MIC3) {
-        ret |= es7210_update_reg_bit(ES7210_MIC3_GAIN_REG45, 0x0f, gain);
-    }
-    if (mic_select & ES7210_INPUT_MIC4) {
-        ret |= es7210_update_reg_bit(ES7210_MIC4_GAIN_REG46, 0x0f, gain);
-    }
-    es7210_handle.gain = gain;
-    return ret;
-}
-
-esp_err_t es7210_adc_get_gain(es7210_input_mics_t mic_select, int *gain)
-{
-    AUDIO_NULL_CHECK(TAG, gain, return ESP_FAIL);
-    switch (mic_select) {
-        case ES7210_INPUT_MIC1:
-            *gain = es7210_read_reg(ES7210_MIC1_GAIN_REG43);
-            break;
-        case ES7210_INPUT_MIC2:
-            *gain = es7210_read_reg(ES7210_MIC2_GAIN_REG44);
-            break;
-        case ES7210_INPUT_MIC3:
-            *gain = es7210_read_reg(ES7210_MIC3_GAIN_REG45);
-            break;
-        case ES7210_INPUT_MIC4:
-            *gain = es7210_read_reg(ES7210_MIC4_GAIN_REG46);
-            break;
-        default:
-            ESP_LOGE(TAG, "Unable to obtain multiple or zero microphone gains at the same time");
-            return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-esp_err_t es7210_adc_print_gains(void)
-{
-    int regv = 0;
-    if (es7210_handle.mic_select & ES7210_INPUT_MIC1) {
-        es7210_adc_get_gain(ES7210_INPUT_MIC1, &regv);
-        /* Print the last four bits for gain */
-        if (regv != ESP_FAIL) {
-            ESP_LOGI(TAG, "Get ES7210_MIC1_GAIN_REG43 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
-        }
-    }
-    if (es7210_handle.mic_select & ES7210_INPUT_MIC2) {
-        es7210_adc_get_gain(ES7210_INPUT_MIC2, &regv);
-        if (regv != ESP_FAIL) {
-            ESP_LOGI(TAG, "Get ES7210_MIC2_GAIN_REG44 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
-        }
-    }
-    if (es7210_handle.mic_select & ES7210_INPUT_MIC3) {
-        es7210_adc_get_gain(ES7210_INPUT_MIC3, &regv);
-        if (regv != ESP_FAIL) {
-            ESP_LOGI(TAG, "Get ES7210_MIC3_GAIN_REG45 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
-        }
-    }
-    if (es7210_handle.mic_select & ES7210_INPUT_MIC4) {
-        es7210_adc_get_gain(ES7210_INPUT_MIC4, &regv);
-        if (regv != ESP_FAIL) {
-            ESP_LOGI(TAG, "Get ES7210_MIC4_GAIN_REG46 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t es7210_adc_set_volume(int volume)
-{
-    ESP_LOGD(TAG, "ADC can adjust gain");
-    if (volume > GAIN_37_5DB) {
-        volume = GAIN_37_5DB;
-    }
-    esp_err_t ret = es7210_adc_set_gain(es7210_handle.mic_select, volume);
-    return ret;
-}
-
-esp_err_t es7210_set_mute(bool enable)
-{
-    esp_err_t ret = 0;
-    if (enable) {
-        ret |= es7210_update_reg_bit(ES7210_ADC34_MUTERANGE_REG14, 0x03, 0x03);
-        ret |= es7210_update_reg_bit(ES7210_ADC12_MUTERANGE_REG15, 0x03, 0x03);
-    } else {
-        ret |= es7210_update_reg_bit(ES7210_ADC34_MUTERANGE_REG14, 0x03, 0x00);
-        ret |= es7210_update_reg_bit(ES7210_ADC12_MUTERANGE_REG15, 0x03, 0x00);
-    }
-    ESP_LOGI(TAG, "%s", enable ? "Muted" : "Unmuted");
-    return ret == 0 ? ESP_OK : ESP_FAIL;
-}
-
-void es7210_read_all(void)
-{
-    for (int i = 0; i <= 0x4E; i++) {
-        uint8_t reg = es7210_read_reg(i);
-        ESP_LOGI(TAG, "REG:%02x, %02x", reg, i);
-    }
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "board.h"
+#include "i2c_bus.h"
+#include "es7210.h"
+
+/* ES7210 address */
+#define ES7210_ADDR (ES7210_AD1_AD0_00)
+
+#define I2S_DSP_MODE          (0)
+#define MCLK_DIV_FRE          (256)
+#define FROM_PAD_PIN          (0)
+#define FROM_CLOCK_DOUBLE_PIN (1)
+#define ENABLE_TDM_MAX_NUM    (3)
+#define ES7210_MCLK_SOURCE    (FROM_CLOCK_DOUBLE_PIN)  /* In master mode. 0 : MCLK from pad; 1 : MCLK from clock doubler */
+
+#ifndef ES7210_MIC_SELECT
+#define ES7210_MIC_SELECT (ES7210_INPUT_MIC1 | ES7210_INPUT_MIC2)
+#endif  /* ES7210_MIC_SELECT */
+
+static char *TAG = "ES7210";
+
+static struct {
+    i2c_bus_handle_t i2c_handle;
+    es7210_input_mics_t mic_select;
+    es7210_gain_value_t gain;
+} es7210_handle;
+
+/**
+ * Operate function of ADC
+ */
+audio_hal_func_t AUDIO_CODEC_ES7210_DEFAULT_HANDLE = {
+    .audio_codec_initialize   = es7210_adc_init,
+    .audio_codec_deinitialize = es7210_adc_deinit,
+    .audio_codec_ctrl         = es7210_adc_ctrl_state,
+    .audio_codec_config_iface = es7210_adc_config_i2s,
+    .audio_codec_set_mute     = es7210_set_mute,
+    .audio_codec_set_volume   = es7210_adc_set_volume,
+    .audio_codec_get_volume   = NULL,
+    .audio_codec_enable_pa    = NULL,
+    .audio_hal_lock           = NULL,
+    .handle                   = NULL,
+};
+
+/*
+ * Clock coefficient structer
+ */
+struct _coeff_div {
+    uint32_t mclk;            /* mclk frequency */
+    uint32_t lrck;            /* lrck */
+    uint8_t  ss_ds;
+    uint8_t  adc_div;         /* adcclk divider */
+    uint8_t  dll;             /* dll_bypass */
+    uint8_t  doubler;         /* doubler enable */
+    uint8_t  osr;             /* adc osr */
+    uint8_t  mclk_src;        /* select mclk  source */
+    uint32_t lrck_h;          /* The high 4 bits of lrck */
+    uint32_t lrck_l;          /* The low 8 bits of lrck */
+};
+
+/* Codec hifi mclk clock divider coefficients
+ *           MEMBER      REG
+ *           mclk:       0x03
+ *           lrck:       standard
+ *           ss_ds:      --
+ *           adc_div:    0x02
+ *           dll:        0x06
+ *           doubler:    0x02
+ *           osr:        0x07
+ *           mclk_src:   0x03
+ *           lrckh:      0x04
+ *           lrckl:      0x05
+*/
+static const struct _coeff_div coeff_div[] = {
+    //mclk      lrck    ss_ds adc_div  dll  doubler osr  mclk_src  lrckh   lrckl
+    /* 8k */
+    {12288000,  8000 ,  0x00,  0x03,  0x01,  0x00,  0x20,  0x00,    0x06,  0x00},
+    {16384000,  8000 ,  0x00,  0x04,  0x01,  0x00,  0x20,  0x00,    0x08,  0x00},
+    {19200000,  8000 ,  0x00,  0x1e,  0x00,  0x01,  0x28,  0x00,    0x09,  0x60},
+    {4096000,   8000 ,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
+
+    /* 11.025k */
+    {11289600,  11025,  0x00,  0x02,  0x01,  0x00,  0x20,  0x00,    0x01,  0x00},
+
+    /* 12k */
+    {12288000,  12000,  0x00,  0x02,  0x01,  0x00,  0x20,  0x00,    0x04,  0x00},
+    {19200000,  12000,  0x00,  0x14,  0x00,  0x01,  0x28,  0x00,    0x06,  0x40},
+
+    /* 16k */
+    {4096000,   16000,  0x00,  0x01,  0x01,  0x01,  0x20,  0x00,    0x01,  0x00},
+    {19200000,  16000,  0x00,  0x0a,  0x00,  0x00,  0x1e,  0x00,    0x04,  0x80},
+    {16384000,  16000,  0x00,  0x02,  0x01,  0x00,  0x20,  0x00,    0x04,  0x00},
+    {12288000,  16000,  0x00,  0x03,  0x01,  0x01,  0x20,  0x00,    0x03,  0x00},
+
+    /* 22.05k */
+    {11289600,  22050,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
+
+    /* 24k */
+    {12288000,  24000,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
+    {19200000,  24000,  0x00,  0x0a,  0x00,  0x01,  0x28,  0x00,    0x03,  0x20},
+
+    /* 32k */
+    {12288000,  32000,  0x00,  0x03,  0x00,  0x00,  0x20,  0x00,    0x01,  0x80},
+    {16384000,  32000,  0x00,  0x01,  0x01,  0x00,  0x20,  0x00,    0x02,  0x00},
+    {19200000,  32000,  0x00,  0x05,  0x00,  0x00,  0x1e,  0x00,    0x02,  0x58},
+
+    /* 44.1k */
+    {11289600,  44100,  0x00,  0x01,  0x01,  0x01,  0x20,  0x00,    0x01,  0x00},
+
+    /* 48k */
+    {12288000,  48000,  0x00,  0x01,  0x01,  0x01,  0x20,  0x00,    0x01,  0x00},
+    {19200000,  48000,  0x00,  0x05,  0x00,  0x01,  0x28,  0x00,    0x01,  0x90},
+
+    /* 64k */
+    {16384000,  64000,  0x01,  0x01,  0x01,  0x00,  0x20,  0x00,    0x01,  0x00},
+    {19200000,  64000,  0x00,  0x05,  0x00,  0x01,  0x1e,  0x00,    0x01,  0x2c},
+
+    /* 88.2k */
+    {11289600,  88200,  0x01,  0x01,  0x01,  0x01,  0x20,  0x00,    0x00,  0x80},
+
+    /* 96k */
+    {12288000,  96000,  0x01,  0x01,  0x01,  0x01,  0x20,  0x00,    0x00,  0x80},
+    {19200000,  96000,  0x01,  0x05,  0x00,  0x01,  0x28,  0x00,    0x00,  0xc8},
+};
+
+static int es7210_read_reg(uint8_t reg_addr)
+{
+    uint8_t data;
+    esp_err_t ret = i2c_bus_read_bytes(es7210_handle.i2c_handle, ES7210_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to es7210 read 0x%x reg", reg_addr);
+    }
+    return (int)data;
+}
+
+static esp_err_t es7210_write_reg(uint8_t reg_addr, uint8_t data)
+{
+    return i2c_bus_write_bytes(es7210_handle.i2c_handle, ES7210_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+}
+
+static esp_err_t es7210_update_reg_bit(uint8_t reg_addr, uint8_t update_bits, uint8_t data)
+{
+    uint8_t regv;
+    regv = es7210_read_reg(reg_addr);
+    regv = (regv & (~update_bits)) | (update_bits & data);
+    return es7210_write_reg(reg_addr, regv);
+}
+
+static int i2c_init()
+{
+    int ret = 0;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000,
+    };
+    ret = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    AUDIO_RET_ON_FALSE(TAG, ret, return ESP_FAIL, "getting i2c pins error");
+    es7210_handle.i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return ret;
+}
+
+static int get_coeff(uint32_t mclk, uint32_t lrck)
+{
+    for (int i = 0; i < (sizeof(coeff_div) / sizeof(coeff_div[0])); i++) {
+        if (coeff_div[i].lrck == lrck && coeff_div[i].mclk == mclk)
+            return i;
+    }
+    return -1;
+}
+
+int8_t get_es7210_mclk_src(void)
+{
+    return ES7210_MCLK_SOURCE;
+}
+
+esp_err_t es7210_config_sample(audio_hal_iface_samples_t sample)
+{
+    int coeff;
+    int sample_fre = 0;
+    int mclk_fre = 0;
+    esp_err_t ret = ESP_OK;
+    switch (sample) {
+        case AUDIO_HAL_08K_SAMPLES:
+            sample_fre = 8000;
+            break;
+        case AUDIO_HAL_11K_SAMPLES:
+            sample_fre = 11025;
+            break;
+        case AUDIO_HAL_16K_SAMPLES:
+            sample_fre = 16000;
+            break;
+        case AUDIO_HAL_22K_SAMPLES:
+            sample_fre = 22050;
+            break;
+        case AUDIO_HAL_24K_SAMPLES:
+            sample_fre = 24000;
+            break;
+        case AUDIO_HAL_32K_SAMPLES:
+            sample_fre = 32000;
+            break;
+        case AUDIO_HAL_44K_SAMPLES:
+            sample_fre = 44100;
+            break;
+        case AUDIO_HAL_48K_SAMPLES:
+            sample_fre = 48000;
+            break;
+        default:
+            ESP_LOGE(TAG, "Unable to configure sample rate %dHz", sample_fre);
+            break;
+    }
+    mclk_fre = sample_fre * MCLK_DIV_FRE;
+    coeff = get_coeff(mclk_fre, sample_fre);
+    if (coeff < 0) {
+        ESP_LOGE(TAG, "Unable to configure sample rate %dHz with %dHz MCLK", sample_fre, mclk_fre);
+        return ESP_FAIL;
+    }
+    /* Set clock parammeters */
+    if (coeff >= 0) {
+        /* Set adc_div & doubler & dll */
+        uint8_t regv;
+        regv = es7210_read_reg(ES7210_MAINCLK_REG02) & 0x00;
+        regv |= coeff_div[coeff].adc_div;
+        regv |= coeff_div[coeff].doubler << 6;
+        regv |= coeff_div[coeff].dll << 7;
+        ret |= es7210_write_reg(ES7210_MAINCLK_REG02, regv);
+        /* Set osr */
+        regv = coeff_div[coeff].osr;
+        ret |= es7210_write_reg(ES7210_OSR_REG07, regv);
+        /* Set lrck */
+        regv = coeff_div[coeff].lrck_h;
+        ret |= es7210_write_reg(ES7210_LRCK_DIVH_REG04, regv);
+        regv = coeff_div[coeff].lrck_l;
+        ret |= es7210_write_reg(ES7210_LRCK_DIVL_REG05, regv);
+    }
+    return ret;
+}
+
+esp_err_t es7210_mic_select(es7210_input_mics_t mic_select)
+{
+    esp_err_t ret = ESP_OK;
+    uint16_t mic_num = 0;
+    es7210_handle.mic_select = mic_select;
+    if (es7210_handle.mic_select & (ES7210_INPUT_MIC1 | ES7210_INPUT_MIC2 | ES7210_INPUT_MIC3 | ES7210_INPUT_MIC4)) {
+        for (int i = 0; i < 4; i++) {
+            ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43 + i, 0x10, 0x00);
+        }
+        ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B, 0xff);
+        ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0xff);
+        if (es7210_handle.mic_select & ES7210_INPUT_MIC1) {
+            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC1");
+            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x0b, 0x00);
+            ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B, 0x00);
+            ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43, 0x10, 0x10);
+            ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43, 0x0f, es7210_handle.gain);
+        }
+        if (es7210_handle.mic_select & ES7210_INPUT_MIC2) {
+            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC2");
+            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x0b, 0x00);
+            ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B, 0x00);
+            ret |= es7210_update_reg_bit(ES7210_MIC2_GAIN_REG44, 0x10, 0x10);
+            ret |= es7210_update_reg_bit(ES7210_MIC2_GAIN_REG44, 0x0f, es7210_handle.gain);
+        }
+        if (es7210_handle.mic_select & ES7210_INPUT_MIC3) {
+            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC3");
+            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x15, 0x00);
+            ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0x00);
+            ret |= es7210_update_reg_bit(ES7210_MIC3_GAIN_REG45, 0x10, 0x10);
+            ret |= es7210_update_reg_bit(ES7210_MIC3_GAIN_REG45, 0x0f, es7210_handle.gain);
+        }
+        if (es7210_handle.mic_select & ES7210_INPUT_MIC4) {
+            ESP_LOGI(TAG, "Enable ES7210_INPUT_MIC4");
+            ret |= es7210_update_reg_bit(ES7210_CLOCK_OFF_REG01, 0x15, 0x00);
+            ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0x00);
+            ret |= es7210_update_reg_bit(ES7210_MIC4_GAIN_REG46, 0x10, 0x10);
+            ret |= es7210_update_reg_bit(ES7210_MIC4_GAIN_REG46, 0x0f, es7210_handle.gain);
+        }
+    } else {
+        ESP_LOGE(TAG, "Microphone selection error");
+        return ESP_FAIL;
+    }
+
+    for (int i = ES7210_INPUT_MIC1; i <= ES7210_INPUT_MIC4; i = i << 1) {
+        if (es7210_handle.mic_select & i) {
+            mic_num++;
+        }
+    }
+    if (mic_num >= ENABLE_TDM_MAX_NUM) {
+        ret |= es7210_write_reg(ES7210_SDP_INTERFACE2_REG12, 0x02);
+        ESP_LOGW(TAG, "Enable TDM mode. ES7210_SDP_INTERFACE2_REG12: %X", es7210_read_reg(ES7210_SDP_INTERFACE2_REG12));
+    } else {
+        ret |= es7210_write_reg(ES7210_SDP_INTERFACE2_REG12, 0x00);
+        ESP_LOGW(TAG, "Disable TDM mode. ES7210_SDP_INTERFACE2_REG12: %X", es7210_read_reg(ES7210_SDP_INTERFACE2_REG12));
+    }
+    return ret;
+}
+
+esp_err_t es7210_adc_init(audio_hal_codec_config_t *codec_cfg)
+{
+    esp_err_t ret = ESP_OK;
+    i2c_init();
+    ret |= es7210_write_reg(ES7210_RESET_REG00, 0xff);
+    ret |= es7210_write_reg(ES7210_RESET_REG00, 0x41);
+    ret |= es7210_write_reg(ES7210_CLOCK_OFF_REG01, 0x3f);
+    ret |= es7210_write_reg(ES7210_TIME_CONTROL0_REG09, 0x30);  /* Set chip state cycle */
+    ret |= es7210_write_reg(ES7210_TIME_CONTROL1_REG0A, 0x30);  /* Set power on state cycle */
+    ret |= es7210_write_reg(ES7210_ADC12_HPF2_REG23, 0x2a);     /* Quick setup */
+    ret |= es7210_write_reg(ES7210_ADC12_HPF1_REG22, 0x0a);
+    ret |= es7210_write_reg(ES7210_ADC34_HPF2_REG20, 0x0a);
+    ret |= es7210_write_reg(ES7210_ADC34_HPF1_REG21, 0x2a);
+    /* Set master/slave audio interface */
+    audio_hal_codec_i2s_iface_t *i2s_cfg = &(codec_cfg->i2s_iface);
+    switch (i2s_cfg->mode) {
+        case AUDIO_HAL_MODE_MASTER:  /* MASTER MODE */
+            ESP_LOGI(TAG, "ES7210 in Master mode");
+            ret |= es7210_update_reg_bit(ES7210_MODE_CONFIG_REG08, 0x01, 0x01);
+            /* Select clock source for internal mclk */
+            switch (get_es7210_mclk_src()) {
+                case FROM_PAD_PIN:
+                    ret |= es7210_update_reg_bit(ES7210_MASTER_CLK_REG03, 0x80, 0x00);
+                    break;
+                case FROM_CLOCK_DOUBLE_PIN:
+                    ret |= es7210_update_reg_bit(ES7210_MASTER_CLK_REG03, 0x80, 0x80);
+                    break;
+                default:
+                    ret |= es7210_update_reg_bit(ES7210_MASTER_CLK_REG03, 0x80, 0x00);
+                    break;
+            }
+            break;
+        case AUDIO_HAL_MODE_SLAVE:  /* SLAVE MODE */
+            ESP_LOGI(TAG, "ES7210 in Slave mode");
+            ret |= es7210_update_reg_bit(ES7210_MODE_CONFIG_REG08, 0x01, 0x00);
+            break;
+        default:
+            ret |= es7210_update_reg_bit(ES7210_MODE_CONFIG_REG08, 0x01, 0x00);
+    }
+    ret |= es7210_write_reg(ES7210_ANALOG_REG40, 0x43);      /* Select power off analog, vdda = 3.3V, close vx20ff, VMID select 5K╬⌐ start */
+    ret |= es7210_write_reg(ES7210_MIC12_BIAS_REG41, 0x70);  /* Select 2.87v */
+    ret |= es7210_write_reg(ES7210_MIC34_BIAS_REG42, 0x70);  /* Select 2.87v */
+    ret |= es7210_write_reg(ES7210_OSR_REG07, 0x20);
+    ret |= es7210_write_reg(ES7210_MAINCLK_REG02, 0xc1);  /* Set the frequency division coefficient and use dll except clock doubler, and need to set 0xc1 to clear the state */
+    ret |= es7210_config_sample(i2s_cfg->samples);
+    ret |= es7210_mic_select(ES7210_MIC_SELECT);
+    ret |= es7210_adc_set_gain(ES7210_MIC_SELECT, GAIN_24DB);
+    return ESP_OK;
+}
+
+esp_err_t es7210_adc_deinit()
+{
+    i2c_bus_delete(es7210_handle.i2c_handle);
+    return ESP_OK;
+}
+
+esp_err_t es7210_config_fmt(audio_hal_iface_format_t fmt)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t adc_iface = 0;
+    adc_iface = es7210_read_reg(ES7210_SDP_INTERFACE1_REG11);
+    adc_iface &= 0xfc;
+    switch (fmt) {
+        case AUDIO_HAL_I2S_NORMAL:
+            ESP_LOGD(TAG, "ES7210 in I2S Format");
+            adc_iface |= 0x00;
+            break;
+        case AUDIO_HAL_I2S_LEFT:
+        case AUDIO_HAL_I2S_RIGHT:
+            ESP_LOGD(TAG, "ES7210 in LJ Format");
+            adc_iface |= 0x01;
+            break;
+        case AUDIO_HAL_I2S_DSP:
+            if (I2S_DSP_MODE) {
+                ESP_LOGD(TAG, "ES7210 in DSP-A Format");
+                adc_iface |= 0x13;
+            } else {
+                ESP_LOGD(TAG, "ES7210 in DSP-B Format");
+                adc_iface |= 0x03;
+            }
+            break;
+        default:
+            adc_iface &= 0xfc;
+            break;
+    }
+    ret |= es7210_write_reg(ES7210_SDP_INTERFACE1_REG11, adc_iface);
+    ESP_LOGI(TAG, "config fmt %X", adc_iface);
+    return ret;
+}
+
+esp_err_t es7210_set_bits(audio_hal_iface_bits_t bits)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t adc_iface = 0;
+    adc_iface = es7210_read_reg(ES7210_SDP_INTERFACE1_REG11);
+    adc_iface &= 0x1f;
+    switch (bits) {
+        case AUDIO_HAL_BIT_LENGTH_16BITS:
+            adc_iface |= 0x60;
+            break;
+        case AUDIO_HAL_BIT_LENGTH_24BITS:
+            adc_iface |= 0x00;
+            break;
+        case AUDIO_HAL_BIT_LENGTH_32BITS:
+            adc_iface |= 0x80;
+            break;
+        default:
+            adc_iface |= 0x60;
+            break;
+    }
+    ret |= es7210_write_reg(ES7210_SDP_INTERFACE1_REG11, adc_iface);
+    return ret;
+}
+
+esp_err_t es7210_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    esp_err_t ret = ESP_OK;
+    ret |= es7210_set_bits(iface->bits);
+    ret |= es7210_config_fmt(iface->fmt);
+    ret |= es7210_config_sample(iface->samples);
+    return ret;
+}
+
+esp_err_t es7210_start(uint8_t clock_reg_value)
+{
+    esp_err_t ret = ESP_OK;
+    ret |= es7210_write_reg(ES7210_CLOCK_OFF_REG01, clock_reg_value);
+    ret |= es7210_write_reg(ES7210_POWER_DOWN_REG06, 0x00);
+    ret |= es7210_write_reg(ES7210_ANALOG_REG40, 0x43);
+    ret |= es7210_write_reg(ES7210_MIC1_POWER_REG47, 0x08);
+    ret |= es7210_write_reg(ES7210_MIC2_POWER_REG48, 0x08);
+    ret |= es7210_write_reg(ES7210_MIC3_POWER_REG49, 0x08);
+    ret |= es7210_write_reg(ES7210_MIC4_POWER_REG4A, 0x08);
+    ret |= es7210_mic_select(es7210_handle.mic_select);
+    return ret;
+}
+
+esp_err_t es7210_stop(void)
+{
+    esp_err_t ret = ESP_OK;
+    ret |= es7210_write_reg(ES7210_MIC1_POWER_REG47, 0xff);
+    ret |= es7210_write_reg(ES7210_MIC2_POWER_REG48, 0xff);
+    ret |= es7210_write_reg(ES7210_MIC3_POWER_REG49, 0xff);
+    ret |= es7210_write_reg(ES7210_MIC4_POWER_REG4A, 0xff);
+    ret |= es7210_write_reg(ES7210_MIC12_POWER_REG4B,0xff);
+    ret |= es7210_write_reg(ES7210_MIC34_POWER_REG4C, 0xff);
+    ret |= es7210_write_reg(ES7210_ANALOG_REG40, 0xc0);
+    ret |= es7210_write_reg(ES7210_CLOCK_OFF_REG01, 0x7f);
+    ret |= es7210_write_reg(ES7210_POWER_DOWN_REG06, 0x07);
+    return ret;
+}
+
+esp_err_t es7210_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    static uint8_t regv;
+    esp_err_t ret = ESP_OK;
+    ESP_LOGW(TAG, "ES7210 only supports ADC mode");
+    ret = es7210_read_reg(ES7210_CLOCK_OFF_REG01);
+    if ((ret != 0x7f) && (ret != 0xff)) {
+        regv = es7210_read_reg(ES7210_CLOCK_OFF_REG01);
+    }
+    if (ctrl_state == AUDIO_HAL_CTRL_START) {
+        ESP_LOGI(TAG, "The ES7210_CLOCK_OFF_REG01 value before stop is %x",regv);
+        ret |= es7210_start(regv);
+    } else {
+        ESP_LOGW(TAG, "The codec is about to stop");
+        regv = es7210_read_reg(ES7210_CLOCK_OFF_REG01);
+        ret |= es7210_stop();
+    }
+    return ret;
+}
+
+esp_err_t es7210_adc_set_gain(es7210_input_mics_t mic_select, es7210_gain_value_t gain)
+{
+    esp_err_t ret = ESP_OK;
+    uint32_t max_gain_vaule = 14;
+    if (gain < 0) {
+        gain = 0;
+    } else if (gain > max_gain_vaule) {
+        gain = max_gain_vaule;
+    }
+    ESP_LOGD(TAG, "Set gain %d", gain);
+    if (mic_select & ES7210_INPUT_MIC1) {
+        ret |= es7210_update_reg_bit(ES7210_MIC1_GAIN_REG43, 0x0f, gain);
+    }
+    if (mic_select & ES7210_INPUT_MIC2) {
+        ret |= es7210_update_reg_bit(ES7210_MIC2_GAIN_REG44, 0x0f, gain);
+    }
+    if (mic_select & ES7210_INPUT_MIC3) {
+        ret |= es7210_update_reg_bit(ES7210_MIC3_GAIN_REG45, 0x0f, gain);
+    }
+    if (mic_select & ES7210_INPUT_MIC4) {
+        ret |= es7210_update_reg_bit(ES7210_MIC4_GAIN_REG46, 0x0f, gain);
+    }
+    es7210_handle.gain = gain;
+    return ret;
+}
+
+esp_err_t es7210_adc_get_gain(es7210_input_mics_t mic_select, int *gain)
+{
+    AUDIO_NULL_CHECK(TAG, gain, return ESP_FAIL);
+    switch (mic_select) {
+        case ES7210_INPUT_MIC1:
+            *gain = es7210_read_reg(ES7210_MIC1_GAIN_REG43);
+            break;
+        case ES7210_INPUT_MIC2:
+            *gain = es7210_read_reg(ES7210_MIC2_GAIN_REG44);
+            break;
+        case ES7210_INPUT_MIC3:
+            *gain = es7210_read_reg(ES7210_MIC3_GAIN_REG45);
+            break;
+        case ES7210_INPUT_MIC4:
+            *gain = es7210_read_reg(ES7210_MIC4_GAIN_REG46);
+            break;
+        default:
+            ESP_LOGE(TAG, "Unable to obtain multiple or zero microphone gains at the same time");
+            return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+esp_err_t es7210_adc_print_gains(void)
+{
+    int regv = 0;
+    if (es7210_handle.mic_select & ES7210_INPUT_MIC1) {
+        es7210_adc_get_gain(ES7210_INPUT_MIC1, &regv);
+        /* Print the last four bits for gain */
+        if (regv != ESP_FAIL) {
+            ESP_LOGI(TAG, "Get ES7210_MIC1_GAIN_REG43 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
+        }
+    }
+    if (es7210_handle.mic_select & ES7210_INPUT_MIC2) {
+        es7210_adc_get_gain(ES7210_INPUT_MIC2, &regv);
+        if (regv != ESP_FAIL) {
+            ESP_LOGI(TAG, "Get ES7210_MIC2_GAIN_REG44 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
+        }
+    }
+    if (es7210_handle.mic_select & ES7210_INPUT_MIC3) {
+        es7210_adc_get_gain(ES7210_INPUT_MIC3, &regv);
+        if (regv != ESP_FAIL) {
+            ESP_LOGI(TAG, "Get ES7210_MIC3_GAIN_REG45 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
+        }
+    }
+    if (es7210_handle.mic_select & ES7210_INPUT_MIC4) {
+        es7210_adc_get_gain(ES7210_INPUT_MIC4, &regv);
+        if (regv != ESP_FAIL) {
+            ESP_LOGI(TAG, "Get ES7210_MIC4_GAIN_REG46 (gain_value & 0xF) 0x0%x", (regv & 0x0f));
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t es7210_adc_set_volume(int volume)
+{
+    ESP_LOGD(TAG, "ADC can adjust gain");
+    if (volume > GAIN_37_5DB) {
+        volume = GAIN_37_5DB;
+    }
+    esp_err_t ret = es7210_adc_set_gain(es7210_handle.mic_select, volume);
+    return ret;
+}
+
+esp_err_t es7210_set_mute(bool enable)
+{
+    esp_err_t ret = 0;
+    if (enable) {
+        ret |= es7210_update_reg_bit(ES7210_ADC34_MUTERANGE_REG14, 0x03, 0x03);
+        ret |= es7210_update_reg_bit(ES7210_ADC12_MUTERANGE_REG15, 0x03, 0x03);
+    } else {
+        ret |= es7210_update_reg_bit(ES7210_ADC34_MUTERANGE_REG14, 0x03, 0x00);
+        ret |= es7210_update_reg_bit(ES7210_ADC12_MUTERANGE_REG15, 0x03, 0x00);
+    }
+    ESP_LOGI(TAG, "%s", enable ? "Muted" : "Unmuted");
+    return ret == 0 ? ESP_OK : ESP_FAIL;
+}
+
+void es7210_read_all(void)
+{
+    for (int i = 0; i <= 0x4E; i++) {
+        uint8_t reg = es7210_read_reg(i);
+        ESP_LOGI(TAG, "REG:%02x, %02x", reg, i);
+    }
+}
diff --git a/components/audio_hal/driver/es7210/es7210.h b/components/audio_hal/driver/es7210/es7210.h
index 52899c9e..7cc2341a 100644
--- a/components/audio_hal/driver/es7210/es7210.h
+++ b/components/audio_hal/driver/es7210/es7210.h
@@ -1,227 +1,227 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ES7210_H
-#define _ES7210_H
-
-#include "audio_hal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif  /* __cplusplus */
-
-#define ES7210_RESET_REG00           0x00  /* Reset control */
-#define ES7210_CLOCK_OFF_REG01       0x01  /* Used to turn off the ADC clock */
-#define ES7210_MAINCLK_REG02         0x02  /* Set ADC clock frequency division */
-#define ES7210_MASTER_CLK_REG03      0x03  /* MCLK source $ SCLK division */
-#define ES7210_LRCK_DIVH_REG04       0x04  /* lrck_divh */
-#define ES7210_LRCK_DIVL_REG05       0x05  /* lrck_divl */
-#define ES7210_POWER_DOWN_REG06      0x06  /* power down */
-#define ES7210_OSR_REG07             0x07
-#define ES7210_MODE_CONFIG_REG08     0x08  /* Set master/slave & channels */
-#define ES7210_TIME_CONTROL0_REG09   0x09  /* Set Chip intial state period*/
-#define ES7210_TIME_CONTROL1_REG0A   0x0A  /* Set Power up state period */
-#define ES7210_SDP_INTERFACE1_REG11  0x11  /* Set sample & fmt */
-#define ES7210_SDP_INTERFACE2_REG12  0x12  /* Pins state */
-#define ES7210_ADC_AUTOMUTE_REG13    0x13  /* Set mute */
-#define ES7210_ADC34_MUTERANGE_REG14 0x14  /* Set mute range */
-#define ES7210_ADC12_MUTERANGE_REG15 0x15  /* Set mute range */
-#define ES7210_ADC34_HPF2_REG20      0x20  /* HPF */
-#define ES7210_ADC34_HPF1_REG21      0x21
-#define ES7210_ADC12_HPF1_REG22      0x22
-#define ES7210_ADC12_HPF2_REG23      0x23
-#define ES7210_ANALOG_REG40          0x40  /* ANALOG Power */
-#define ES7210_MIC12_BIAS_REG41      0x41
-#define ES7210_MIC34_BIAS_REG42      0x42
-#define ES7210_MIC1_GAIN_REG43       0x43
-#define ES7210_MIC2_GAIN_REG44       0x44
-#define ES7210_MIC3_GAIN_REG45       0x45
-#define ES7210_MIC4_GAIN_REG46       0x46
-#define ES7210_MIC1_POWER_REG47      0x47
-#define ES7210_MIC2_POWER_REG48      0x48
-#define ES7210_MIC3_POWER_REG49      0x49
-#define ES7210_MIC4_POWER_REG4A      0x4A
-#define ES7210_MIC12_POWER_REG4B     0x4B  /* MICBias & ADC & PGA Power */
-#define ES7210_MIC34_POWER_REG4C     0x4C
-
-typedef enum {
-    ES7210_AD1_AD0_00 = 0x80,
-    ES7210_AD1_AD0_01 = 0x82,
-    ES7210_AD1_AD0_10 = 0x84,
-    ES7210_AD1_AD0_11 = 0x86
-} es7210_address_t;
-
-typedef enum {
-    ES7210_INPUT_MIC1 = 0x01,
-    ES7210_INPUT_MIC2 = 0x02,
-    ES7210_INPUT_MIC3 = 0x04,
-    ES7210_INPUT_MIC4 = 0x08
-} es7210_input_mics_t;
-
-typedef enum gain_value {
-    GAIN_0DB = 0,
-    GAIN_3DB,
-    GAIN_6DB,
-    GAIN_9DB,
-    GAIN_12DB,
-    GAIN_15DB,
-    GAIN_18DB,
-    GAIN_21DB,
-    GAIN_24DB,
-    GAIN_27DB,
-    GAIN_30DB,
-    GAIN_33DB,
-    GAIN_34_5DB,
-    GAIN_36DB,
-    GAIN_37_5DB,
-} es7210_gain_value_t;
-
-/**
- * @brief  Initialize ES7210 ADC chip
- *
- * @param[in]  codec_cfg  configuration of ES7210
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es7210_adc_init(audio_hal_codec_config_t *codec_cfg);
-
-/**
- * @brief  Deinitialize ES7210 ADC chip
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es7210_adc_deinit();
-
-/**
- * @brief  Configure ES7210 ADC mode and I2S interface
- *
- * @param[in]  mode   codec mode
- * @param[in]  iface  I2S config
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es7210_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief  Control ES7210 ADC chip
- *
- * @param[in]  mode        codec mode
- * @param[in]  ctrl_state  start or stop progress
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es7210_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief  Set gain (Note: the enabled microphone sets the same gain)
- *
- * @param[in]  mic_select  mic select. eg: ES7210_INPUT_MIC1 | ES7210_INPUT_MIC2
- * @param[in]  gain        gain
- *
- *                         gain        :   value
- *                         GAIN_0DB    :   1
- *                         GAIN_3DB    :   2
- *                         GAIN_6DB    :   3
- *                         ┬╖
- *                         ┬╖
- *                         ┬╖
- *                         GAIN_30DB   :   10
- *                         GAIN_33DB   :   11
- *                         GAIN_34_5DB :   12
- *                         GAIN_36DB   :   13
- *                         GAIN_37_5DB :   14
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es7210_adc_set_gain(es7210_input_mics_t mic_select, es7210_gain_value_t gain);
-
-/**
- * @brief  Get adcn gain
- *
- * @param[in]  mic_select  Selected mic
- * @param[in]  gain        gain value
- *
- * @return
- *       - ESP_OK
- */
-esp_err_t es7210_adc_get_gain(es7210_input_mics_t mic_select, int *gain);
-
-/**
- * @brief  Print all adc gain
- *
- * @return
- *       - ESP_OK
- */
-esp_err_t es7210_adc_print_gains(void);
-
-/**
- * @brief  Set volume
- *
- * @param[in]  volume  volume
- *
- * @return
- *       - ESP_OK
- */
-esp_err_t es7210_adc_set_volume(int volume);
-
-/**
- * @brief  Set ES7210 ADC mute status
- *
- * @return
- *       - ESP_FAIL
- *       - ESP_OK
- */
-esp_err_t es7210_set_mute(bool enable);
-
-/**
- * @brief  Select ES7210 mic
- *
- * @param[in]  mic_select  mics
- *
- * @return
- *       - ESP_FAIL
- *       - ESP_OK
- */
-esp_err_t es7210_mic_select(es7210_input_mics_t mic_select);
-
-/**
- * @brief  Read all regs of ES7210
- */
-void es7210_read_all(void);
-
-#ifdef __cplusplus
-}
-#endif  /* __cplusplus */
-
-#endif  /* _ES7210_H_ */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ES7210_H
+#define _ES7210_H
+
+#include "audio_hal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+#define ES7210_RESET_REG00           0x00  /* Reset control */
+#define ES7210_CLOCK_OFF_REG01       0x01  /* Used to turn off the ADC clock */
+#define ES7210_MAINCLK_REG02         0x02  /* Set ADC clock frequency division */
+#define ES7210_MASTER_CLK_REG03      0x03  /* MCLK source $ SCLK division */
+#define ES7210_LRCK_DIVH_REG04       0x04  /* lrck_divh */
+#define ES7210_LRCK_DIVL_REG05       0x05  /* lrck_divl */
+#define ES7210_POWER_DOWN_REG06      0x06  /* power down */
+#define ES7210_OSR_REG07             0x07
+#define ES7210_MODE_CONFIG_REG08     0x08  /* Set master/slave & channels */
+#define ES7210_TIME_CONTROL0_REG09   0x09  /* Set Chip intial state period*/
+#define ES7210_TIME_CONTROL1_REG0A   0x0A  /* Set Power up state period */
+#define ES7210_SDP_INTERFACE1_REG11  0x11  /* Set sample & fmt */
+#define ES7210_SDP_INTERFACE2_REG12  0x12  /* Pins state */
+#define ES7210_ADC_AUTOMUTE_REG13    0x13  /* Set mute */
+#define ES7210_ADC34_MUTERANGE_REG14 0x14  /* Set mute range */
+#define ES7210_ADC12_MUTERANGE_REG15 0x15  /* Set mute range */
+#define ES7210_ADC34_HPF2_REG20      0x20  /* HPF */
+#define ES7210_ADC34_HPF1_REG21      0x21
+#define ES7210_ADC12_HPF1_REG22      0x22
+#define ES7210_ADC12_HPF2_REG23      0x23
+#define ES7210_ANALOG_REG40          0x40  /* ANALOG Power */
+#define ES7210_MIC12_BIAS_REG41      0x41
+#define ES7210_MIC34_BIAS_REG42      0x42
+#define ES7210_MIC1_GAIN_REG43       0x43
+#define ES7210_MIC2_GAIN_REG44       0x44
+#define ES7210_MIC3_GAIN_REG45       0x45
+#define ES7210_MIC4_GAIN_REG46       0x46
+#define ES7210_MIC1_POWER_REG47      0x47
+#define ES7210_MIC2_POWER_REG48      0x48
+#define ES7210_MIC3_POWER_REG49      0x49
+#define ES7210_MIC4_POWER_REG4A      0x4A
+#define ES7210_MIC12_POWER_REG4B     0x4B  /* MICBias & ADC & PGA Power */
+#define ES7210_MIC34_POWER_REG4C     0x4C
+
+typedef enum {
+    ES7210_AD1_AD0_00 = 0x80,
+    ES7210_AD1_AD0_01 = 0x82,
+    ES7210_AD1_AD0_10 = 0x84,
+    ES7210_AD1_AD0_11 = 0x86
+} es7210_address_t;
+
+typedef enum {
+    ES7210_INPUT_MIC1 = 0x01,
+    ES7210_INPUT_MIC2 = 0x02,
+    ES7210_INPUT_MIC3 = 0x04,
+    ES7210_INPUT_MIC4 = 0x08
+} es7210_input_mics_t;
+
+typedef enum gain_value {
+    GAIN_0DB = 0,
+    GAIN_3DB,
+    GAIN_6DB,
+    GAIN_9DB,
+    GAIN_12DB,
+    GAIN_15DB,
+    GAIN_18DB,
+    GAIN_21DB,
+    GAIN_24DB,
+    GAIN_27DB,
+    GAIN_30DB,
+    GAIN_33DB,
+    GAIN_34_5DB,
+    GAIN_36DB,
+    GAIN_37_5DB,
+} es7210_gain_value_t;
+
+/**
+ * @brief  Initialize ES7210 ADC chip
+ *
+ * @param[in]  codec_cfg  configuration of ES7210
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es7210_adc_init(audio_hal_codec_config_t *codec_cfg);
+
+/**
+ * @brief  Deinitialize ES7210 ADC chip
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es7210_adc_deinit();
+
+/**
+ * @brief  Configure ES7210 ADC mode and I2S interface
+ *
+ * @param[in]  mode   codec mode
+ * @param[in]  iface  I2S config
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es7210_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief  Control ES7210 ADC chip
+ *
+ * @param[in]  mode        codec mode
+ * @param[in]  ctrl_state  start or stop progress
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es7210_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief  Set gain (Note: the enabled microphone sets the same gain)
+ *
+ * @param[in]  mic_select  mic select. eg: ES7210_INPUT_MIC1 | ES7210_INPUT_MIC2
+ * @param[in]  gain        gain
+ *
+ *                         gain        :   value
+ *                         GAIN_0DB    :   1
+ *                         GAIN_3DB    :   2
+ *                         GAIN_6DB    :   3
+ *                         ┬╖
+ *                         ┬╖
+ *                         ┬╖
+ *                         GAIN_30DB   :   10
+ *                         GAIN_33DB   :   11
+ *                         GAIN_34_5DB :   12
+ *                         GAIN_36DB   :   13
+ *                         GAIN_37_5DB :   14
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es7210_adc_set_gain(es7210_input_mics_t mic_select, es7210_gain_value_t gain);
+
+/**
+ * @brief  Get adcn gain
+ *
+ * @param[in]  mic_select  Selected mic
+ * @param[in]  gain        gain value
+ *
+ * @return
+ *       - ESP_OK
+ */
+esp_err_t es7210_adc_get_gain(es7210_input_mics_t mic_select, int *gain);
+
+/**
+ * @brief  Print all adc gain
+ *
+ * @return
+ *       - ESP_OK
+ */
+esp_err_t es7210_adc_print_gains(void);
+
+/**
+ * @brief  Set volume
+ *
+ * @param[in]  volume  volume
+ *
+ * @return
+ *       - ESP_OK
+ */
+esp_err_t es7210_adc_set_volume(int volume);
+
+/**
+ * @brief  Set ES7210 ADC mute status
+ *
+ * @return
+ *       - ESP_FAIL
+ *       - ESP_OK
+ */
+esp_err_t es7210_set_mute(bool enable);
+
+/**
+ * @brief  Select ES7210 mic
+ *
+ * @param[in]  mic_select  mics
+ *
+ * @return
+ *       - ESP_FAIL
+ *       - ESP_OK
+ */
+esp_err_t es7210_mic_select(es7210_input_mics_t mic_select);
+
+/**
+ * @brief  Read all regs of ES7210
+ */
+void es7210_read_all(void);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* _ES7210_H_ */
diff --git a/components/audio_hal/driver/es7243/es7243.c b/components/audio_hal/driver/es7243/es7243.c
index c6d29514..ec118e1c 100644
--- a/components/audio_hal/driver/es7243/es7243.c
+++ b/components/audio_hal/driver/es7243/es7243.c
@@ -1,190 +1,190 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "es7243.h"
-#include "i2c_bus.h"
-#include "board.h"
-#include "esp_log.h"
-
-#define MCLK_PULSES_NUMBER    (20)
-#define ES_ASSERT(a, format, b, ...) \
-    if ((a) != 0) { \
-        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
-        return b;\
-    }
-
-static char *TAG = "DRV7243";
-static i2c_bus_handle_t i2c_handle;
-static int es7243_addr = 0x26;
-
-audio_hal_func_t AUDIO_CODEC_ES7243_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es7243_adc_init,
-    .audio_codec_deinitialize = es7243_adc_deinit,
-    .audio_codec_ctrl = es7243_adc_ctrl_state,
-    .audio_codec_config_iface = es7243_adc_config_i2s,
-    .audio_codec_set_mute = es7243_adc_set_voice_mute,
-    .audio_codec_set_volume = es7243_adc_set_voice_volume,
-    .audio_codec_get_volume = es7243_adc_get_voice_volume,
-    .audio_codec_enable_pa = NULL,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static esp_err_t es7243_write_reg(uint8_t reg_add, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, es7243_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
-}
-
-static int i2c_init()
-{
-    int res = 0;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000,
-    };
-    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    ES_ASSERT(res, "getting i2c pins error", -1);
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-esp_err_t es7243_adc_set_addr(int addr)
-{
-    es7243_addr = addr;
-    return ESP_OK;
-}
-
-static esp_err_t es7243_mclk_active(uint8_t mclk_gpio)
-{
-    #if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-    esp_rom_gpio_pad_select_gpio(mclk_gpio);
-    #else
-    gpio_pad_select_gpio(mclk_gpio);
-    #endif
-    gpio_set_direction(mclk_gpio, GPIO_MODE_OUTPUT);
-    /*
-        Before initializing es7243, it is necessary to output
-        mclk to es7243 to activate the I2C configuration.
-        So give some clocks to active es7243.
-    */
-    for (int i = 0; i < MCLK_PULSES_NUMBER; ++i) {
-        gpio_set_level(mclk_gpio, 0);
-        vTaskDelay(1 / portTICK_PERIOD_MS);
-        gpio_set_level(mclk_gpio, 1);
-        vTaskDelay(1 / portTICK_PERIOD_MS);
-    }
-    return ESP_OK;
-}
-
-esp_err_t es7243_adc_init(audio_hal_codec_config_t *codec_cfg)
-{
-    esp_err_t ret = ESP_OK;
-    es7243_mclk_active(get_es7243_mclk_gpio());
-    i2c_init();
-    ret |= es7243_write_reg(0x00, 0x01);
-    ret |= es7243_write_reg(0x06, 0x00);
-    ret |= es7243_write_reg(0x05, 0x1B);
-    ret |= es7243_write_reg(0x01, 0x0C);
-    ret |= es7243_write_reg(0x08, 0x43);
-    ret |= es7243_write_reg(0x05, 0x13);
-    if (ret) {
-        ESP_LOGE(TAG, "Es7243 initialize failed!");
-        return ESP_FAIL;
-    }
-    return ret;
-}
-
-esp_err_t es7243_adc_deinit(void)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7243_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7243_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7243_adc_set_voice_mute(bool mute)
-{
-    ESP_LOGI(TAG, "Enter into es7243_mute(), mute = %d\n", mute);
-    if (mute) {
-        es7243_write_reg(0x05, 0x1B);
-    } else {
-        es7243_write_reg(0x05, 0x13);
-    }
-    return ESP_OK;
-}
-
-esp_err_t es7243_adc_set_voice_volume(int volume)
-{
-    esp_err_t ret = ESP_OK;
-    if (volume > 100) {
-        volume = 100;
-    }
-    if (volume < 0) {
-        volume = 0;
-    }
-    switch (volume) {
-        case 0 ... 12:
-            ret |= es7243_write_reg(0x08, 0x11); // 1db
-            break;
-        case 13 ... 25:
-            ret |= es7243_write_reg(0x08, 0x13); //3.5db
-            break;
-        case 26 ... 38:
-            ret |= es7243_write_reg(0x08, 0x21); //18db
-            break;
-        case 39 ... 51:
-            ret |= es7243_write_reg(0x08, 0x23); //20.5db
-            break;
-        case 52 ... 65:
-            ret |= es7243_write_reg(0x08, 0x06); //22.5db
-            break;
-        case 66 ... 80:
-            ret |= es7243_write_reg(0x08, 0x41); //24.5db
-            break;
-        case 81 ... 90:
-            ret |= es7243_write_reg(0x08, 0x07); //25db
-            break;
-        case 91 ... 100:
-            ret |= es7243_write_reg(0x08, 0x43); //27db
-            break;
-        default:
-            break;
-    }
-    return ESP_OK;
-}
-
-esp_err_t es7243_adc_get_voice_volume(int *volume)
-{
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "es7243.h"
+#include "i2c_bus.h"
+#include "board.h"
+#include "esp_log.h"
+
+#define MCLK_PULSES_NUMBER    (20)
+#define ES_ASSERT(a, format, b, ...) \
+    if ((a) != 0) { \
+        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
+        return b;\
+    }
+
+static char *TAG = "DRV7243";
+static i2c_bus_handle_t i2c_handle;
+static int es7243_addr = 0x26;
+
+audio_hal_func_t AUDIO_CODEC_ES7243_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es7243_adc_init,
+    .audio_codec_deinitialize = es7243_adc_deinit,
+    .audio_codec_ctrl = es7243_adc_ctrl_state,
+    .audio_codec_config_iface = es7243_adc_config_i2s,
+    .audio_codec_set_mute = es7243_adc_set_voice_mute,
+    .audio_codec_set_volume = es7243_adc_set_voice_volume,
+    .audio_codec_get_volume = es7243_adc_get_voice_volume,
+    .audio_codec_enable_pa = NULL,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static esp_err_t es7243_write_reg(uint8_t reg_add, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, es7243_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
+}
+
+static int i2c_init()
+{
+    int res = 0;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000,
+    };
+    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    ES_ASSERT(res, "getting i2c pins error", -1);
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+esp_err_t es7243_adc_set_addr(int addr)
+{
+    es7243_addr = addr;
+    return ESP_OK;
+}
+
+static esp_err_t es7243_mclk_active(uint8_t mclk_gpio)
+{
+    #if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+    esp_rom_gpio_pad_select_gpio(mclk_gpio);
+    #else
+    gpio_pad_select_gpio(mclk_gpio);
+    #endif
+    gpio_set_direction(mclk_gpio, GPIO_MODE_OUTPUT);
+    /*
+        Before initializing es7243, it is necessary to output
+        mclk to es7243 to activate the I2C configuration.
+        So give some clocks to active es7243.
+    */
+    for (int i = 0; i < MCLK_PULSES_NUMBER; ++i) {
+        gpio_set_level(mclk_gpio, 0);
+        vTaskDelay(1 / portTICK_PERIOD_MS);
+        gpio_set_level(mclk_gpio, 1);
+        vTaskDelay(1 / portTICK_PERIOD_MS);
+    }
+    return ESP_OK;
+}
+
+esp_err_t es7243_adc_init(audio_hal_codec_config_t *codec_cfg)
+{
+    esp_err_t ret = ESP_OK;
+    es7243_mclk_active(get_es7243_mclk_gpio());
+    i2c_init();
+    ret |= es7243_write_reg(0x00, 0x01);
+    ret |= es7243_write_reg(0x06, 0x00);
+    ret |= es7243_write_reg(0x05, 0x1B);
+    ret |= es7243_write_reg(0x01, 0x0C);
+    ret |= es7243_write_reg(0x08, 0x43);
+    ret |= es7243_write_reg(0x05, 0x13);
+    if (ret) {
+        ESP_LOGE(TAG, "Es7243 initialize failed!");
+        return ESP_FAIL;
+    }
+    return ret;
+}
+
+esp_err_t es7243_adc_deinit(void)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7243_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7243_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7243_adc_set_voice_mute(bool mute)
+{
+    ESP_LOGI(TAG, "Enter into es7243_mute(), mute = %d\n", mute);
+    if (mute) {
+        es7243_write_reg(0x05, 0x1B);
+    } else {
+        es7243_write_reg(0x05, 0x13);
+    }
+    return ESP_OK;
+}
+
+esp_err_t es7243_adc_set_voice_volume(int volume)
+{
+    esp_err_t ret = ESP_OK;
+    if (volume > 100) {
+        volume = 100;
+    }
+    if (volume < 0) {
+        volume = 0;
+    }
+    switch (volume) {
+        case 0 ... 12:
+            ret |= es7243_write_reg(0x08, 0x11); // 1db
+            break;
+        case 13 ... 25:
+            ret |= es7243_write_reg(0x08, 0x13); //3.5db
+            break;
+        case 26 ... 38:
+            ret |= es7243_write_reg(0x08, 0x21); //18db
+            break;
+        case 39 ... 51:
+            ret |= es7243_write_reg(0x08, 0x23); //20.5db
+            break;
+        case 52 ... 65:
+            ret |= es7243_write_reg(0x08, 0x06); //22.5db
+            break;
+        case 66 ... 80:
+            ret |= es7243_write_reg(0x08, 0x41); //24.5db
+            break;
+        case 81 ... 90:
+            ret |= es7243_write_reg(0x08, 0x07); //25db
+            break;
+        case 91 ... 100:
+            ret |= es7243_write_reg(0x08, 0x43); //27db
+            break;
+        default:
+            break;
+    }
+    return ESP_OK;
+}
+
+esp_err_t es7243_adc_get_voice_volume(int *volume)
+{
+    return ESP_OK;
+}
diff --git a/components/audio_hal/driver/es7243/es7243.h b/components/audio_hal/driver/es7243/es7243.h
index 2508430d..c9e39647 100644
--- a/components/audio_hal/driver/es7243/es7243.h
+++ b/components/audio_hal/driver/es7243/es7243.h
@@ -1,127 +1,127 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ES7243_H_
-#define _ES7243_H_
-
-#include "esp_err.h"
-#include "audio_hal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Initialize ES7243 adc chip
- *
- * @param codec_cfg configuration of ES7243
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243_adc_init(audio_hal_codec_config_t *codec_cfg);
-
-/**
- * @brief Deinitialize ES7243 adc chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243_adc_deinit(void);
-
-/**
- * @brief Control ES7243 adc chip
- *
- * @param mode adc mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es7243_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief Configure ES7243 adc mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es7243_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief  Set mute
- *
- * @param mute  true, false
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243_adc_set_voice_mute(bool mute);
-
-/**
- * @brief  Set adc gain
- *
- * @param volume  value of gain (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243_adc_set_voice_volume(int volume);
-
-/**
- * @brief Get adc gain
- *
- * @param[out] *volume:  value of gain (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243_adc_get_voice_volume(int *volume);
-
-/**
- * @brief Set adc I2C address
- *
- * @param[in] addr:  value of I2C address
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243_adc_set_addr(int addr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ES7243_H_
+#define _ES7243_H_
+
+#include "esp_err.h"
+#include "audio_hal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initialize ES7243 adc chip
+ *
+ * @param codec_cfg configuration of ES7243
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243_adc_init(audio_hal_codec_config_t *codec_cfg);
+
+/**
+ * @brief Deinitialize ES7243 adc chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243_adc_deinit(void);
+
+/**
+ * @brief Control ES7243 adc chip
+ *
+ * @param mode adc mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es7243_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief Configure ES7243 adc mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es7243_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief  Set mute
+ *
+ * @param mute  true, false
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243_adc_set_voice_mute(bool mute);
+
+/**
+ * @brief  Set adc gain
+ *
+ * @param volume  value of gain (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243_adc_set_voice_volume(int volume);
+
+/**
+ * @brief Get adc gain
+ *
+ * @param[out] *volume:  value of gain (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243_adc_get_voice_volume(int *volume);
+
+/**
+ * @brief Set adc I2C address
+ *
+ * @param[in] addr:  value of I2C address
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243_adc_set_addr(int addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/es7243e/es7243e.c b/components/audio_hal/driver/es7243e/es7243e.c
index 8657cd6d..98cd98cb 100644
--- a/components/audio_hal/driver/es7243e/es7243e.c
+++ b/components/audio_hal/driver/es7243e/es7243e.c
@@ -1,176 +1,176 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "es7243e.h"
-#include "i2c_bus.h"
-#include "board.h"
-#include "esp_log.h"
-
-static char *TAG = "DRV7243E";
-static i2c_bus_handle_t i2c_handle;
-static int es7243e_addr = 0x20;
-
-audio_hal_func_t AUDIO_CODEC_ES7243E_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es7243e_adc_init,
-    .audio_codec_deinitialize = es7243e_adc_deinit,
-    .audio_codec_ctrl = es7243e_adc_ctrl_state,
-    .audio_codec_config_iface = es7243e_adc_config_i2s,
-    .audio_codec_set_mute = NULL,
-    .audio_codec_set_volume = es7243e_adc_set_voice_volume,
-    .audio_codec_get_volume = es7243e_adc_get_voice_volume,
-    .audio_codec_enable_pa = NULL,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static esp_err_t es7243e_write_reg(uint8_t reg_add, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, es7243e_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
-}
-
-static int i2c_init()
-{
-    int res = 0;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000,
-    };
-    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    if (res != ESP_OK) {
-        ESP_LOGE(TAG, "getting i2c pins error");
-    }
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-esp_err_t es7243e_adc_set_addr(int addr)
-{
-    es7243e_addr = addr;
-    return ESP_OK;
-}
-
-esp_err_t es7243e_adc_init(audio_hal_codec_config_t *codec_cfg)
-{
-    esp_err_t ret = ESP_OK;
-    i2c_init();
-    ret |= es7243e_write_reg(0x01, 0x3A);
-    ret |= es7243e_write_reg(0x00, 0x80);
-    ret |= es7243e_write_reg(0xF9, 0x00);
-    ret |= es7243e_write_reg(0x04, 0x02);
-    ret |= es7243e_write_reg(0x04, 0x01);
-    ret |= es7243e_write_reg(0xF9, 0x01);
-    ret |= es7243e_write_reg(0x00, 0x1E);
-    ret |= es7243e_write_reg(0x01, 0x00);
-
-    ret |= es7243e_write_reg(0x02, 0x00);
-    ret |= es7243e_write_reg(0x03, 0x20);
-    ret |= es7243e_write_reg(0x04, 0x01);
-    ret |= es7243e_write_reg(0x0D, 0x00);
-    ret |= es7243e_write_reg(0x05, 0x00);
-    ret |= es7243e_write_reg(0x06, 0x03); // SCLK=MCLK/4
-    ret |= es7243e_write_reg(0x07, 0x00); // LRCK=MCLK/256
-    ret |= es7243e_write_reg(0x08, 0xFF); // LRCK=MCLK/256
-
-    ret |= es7243e_write_reg(0x09, 0xCA);
-    ret |= es7243e_write_reg(0x0A, 0x85);
-    ret |= es7243e_write_reg(0x0B, 0x00);
-    ret |= es7243e_write_reg(0x0E, 0xBF);
-    ret |= es7243e_write_reg(0x0F, 0x80);
-    ret |= es7243e_write_reg(0x14, 0x0C);
-    ret |= es7243e_write_reg(0x15, 0x0C);
-    ret |= es7243e_write_reg(0x17, 0x02);
-    ret |= es7243e_write_reg(0x18, 0x26);
-    ret |= es7243e_write_reg(0x19, 0x77);
-    ret |= es7243e_write_reg(0x1A, 0xF4);
-    ret |= es7243e_write_reg(0x1B, 0x66);
-    ret |= es7243e_write_reg(0x1C, 0x44);
-    ret |= es7243e_write_reg(0x1E, 0x00);
-    ret |= es7243e_write_reg(0x1F, 0x0C);
-    ret |= es7243e_write_reg(0x20, 0x1A); //PGA gain +30dB
-    ret |= es7243e_write_reg(0x21, 0x1A); //PGA gain +30dB
-
-    ret |= es7243e_write_reg(0x00, 0x80); //Slave  Mode
-    ret |= es7243e_write_reg(0x01, 0x3A);
-    ret |= es7243e_write_reg(0x16, 0x3F);
-    ret |= es7243e_write_reg(0x16, 0x00);
-    if (ret) {
-        ESP_LOGE(TAG, "Es7243e initialize failed!");
-        return ESP_FAIL;
-    }
-    return ret;
-}
-
-esp_err_t es7243e_adc_deinit(void)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7243e_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    esp_err_t ret = ESP_OK;
-    if (ctrl_state == AUDIO_HAL_CTRL_START) {
-        ret |= es7243e_write_reg(0xF9, 0x00);
-        ret |= es7243e_write_reg(0x04, 0x01);
-        ret |= es7243e_write_reg(0x17, 0x01);
-        ret |= es7243e_write_reg(0x20, 0x10);
-        ret |= es7243e_write_reg(0x21, 0x10);
-        ret |= es7243e_write_reg(0x00, 0x80);
-        ret |= es7243e_write_reg(0x01, 0x3A);
-        ret |= es7243e_write_reg(0x16, 0x3F);
-        ret |= es7243e_write_reg(0x16, 0x00);
-    } else {
-        ESP_LOGW(TAG, "The codec going to stop");
-        ret |= es7243e_write_reg(0x04, 0x02);
-        ret |= es7243e_write_reg(0x04, 0x01);
-        ret |= es7243e_write_reg(0xF7, 0x30);
-        ret |= es7243e_write_reg(0xF9, 0x01);
-        ret |= es7243e_write_reg(0x16, 0xFF);
-        ret |= es7243e_write_reg(0x17, 0x00);
-        ret |= es7243e_write_reg(0x01, 0x38);
-        ret |= es7243e_write_reg(0x20, 0x00);
-        ret |= es7243e_write_reg(0x21, 0x00);
-        ret |= es7243e_write_reg(0x00, 0x00);
-        ret |= es7243e_write_reg(0x00, 0x1E);
-        ret |= es7243e_write_reg(0x01, 0x30);
-        ret |= es7243e_write_reg(0x01, 0x00);
-    }
-    return ret;
-}
-
-esp_err_t es7243e_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7243e_adc_set_voice_volume(int volume)
-{
-    return ESP_OK;
-}
-
-esp_err_t es7243e_adc_get_voice_volume(int *volume)
-{
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "es7243e.h"
+#include "i2c_bus.h"
+#include "board.h"
+#include "esp_log.h"
+
+static char *TAG = "DRV7243E";
+static i2c_bus_handle_t i2c_handle;
+static int es7243e_addr = 0x20;
+
+audio_hal_func_t AUDIO_CODEC_ES7243E_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es7243e_adc_init,
+    .audio_codec_deinitialize = es7243e_adc_deinit,
+    .audio_codec_ctrl = es7243e_adc_ctrl_state,
+    .audio_codec_config_iface = es7243e_adc_config_i2s,
+    .audio_codec_set_mute = NULL,
+    .audio_codec_set_volume = es7243e_adc_set_voice_volume,
+    .audio_codec_get_volume = es7243e_adc_get_voice_volume,
+    .audio_codec_enable_pa = NULL,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static esp_err_t es7243e_write_reg(uint8_t reg_add, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, es7243e_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
+}
+
+static int i2c_init()
+{
+    int res = 0;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000,
+    };
+    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    if (res != ESP_OK) {
+        ESP_LOGE(TAG, "getting i2c pins error");
+    }
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+esp_err_t es7243e_adc_set_addr(int addr)
+{
+    es7243e_addr = addr;
+    return ESP_OK;
+}
+
+esp_err_t es7243e_adc_init(audio_hal_codec_config_t *codec_cfg)
+{
+    esp_err_t ret = ESP_OK;
+    i2c_init();
+    ret |= es7243e_write_reg(0x01, 0x3A);
+    ret |= es7243e_write_reg(0x00, 0x80);
+    ret |= es7243e_write_reg(0xF9, 0x00);
+    ret |= es7243e_write_reg(0x04, 0x02);
+    ret |= es7243e_write_reg(0x04, 0x01);
+    ret |= es7243e_write_reg(0xF9, 0x01);
+    ret |= es7243e_write_reg(0x00, 0x1E);
+    ret |= es7243e_write_reg(0x01, 0x00);
+
+    ret |= es7243e_write_reg(0x02, 0x00);
+    ret |= es7243e_write_reg(0x03, 0x20);
+    ret |= es7243e_write_reg(0x04, 0x01);
+    ret |= es7243e_write_reg(0x0D, 0x00);
+    ret |= es7243e_write_reg(0x05, 0x00);
+    ret |= es7243e_write_reg(0x06, 0x03); // SCLK=MCLK/4
+    ret |= es7243e_write_reg(0x07, 0x00); // LRCK=MCLK/256
+    ret |= es7243e_write_reg(0x08, 0xFF); // LRCK=MCLK/256
+
+    ret |= es7243e_write_reg(0x09, 0xCA);
+    ret |= es7243e_write_reg(0x0A, 0x85);
+    ret |= es7243e_write_reg(0x0B, 0x00);
+    ret |= es7243e_write_reg(0x0E, 0xBF);
+    ret |= es7243e_write_reg(0x0F, 0x80);
+    ret |= es7243e_write_reg(0x14, 0x0C);
+    ret |= es7243e_write_reg(0x15, 0x0C);
+    ret |= es7243e_write_reg(0x17, 0x02);
+    ret |= es7243e_write_reg(0x18, 0x26);
+    ret |= es7243e_write_reg(0x19, 0x77);
+    ret |= es7243e_write_reg(0x1A, 0xF4);
+    ret |= es7243e_write_reg(0x1B, 0x66);
+    ret |= es7243e_write_reg(0x1C, 0x44);
+    ret |= es7243e_write_reg(0x1E, 0x00);
+    ret |= es7243e_write_reg(0x1F, 0x0C);
+    ret |= es7243e_write_reg(0x20, 0x1A); //PGA gain +30dB
+    ret |= es7243e_write_reg(0x21, 0x1A); //PGA gain +30dB
+
+    ret |= es7243e_write_reg(0x00, 0x80); //Slave  Mode
+    ret |= es7243e_write_reg(0x01, 0x3A);
+    ret |= es7243e_write_reg(0x16, 0x3F);
+    ret |= es7243e_write_reg(0x16, 0x00);
+    if (ret) {
+        ESP_LOGE(TAG, "Es7243e initialize failed!");
+        return ESP_FAIL;
+    }
+    return ret;
+}
+
+esp_err_t es7243e_adc_deinit(void)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7243e_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    esp_err_t ret = ESP_OK;
+    if (ctrl_state == AUDIO_HAL_CTRL_START) {
+        ret |= es7243e_write_reg(0xF9, 0x00);
+        ret |= es7243e_write_reg(0x04, 0x01);
+        ret |= es7243e_write_reg(0x17, 0x01);
+        ret |= es7243e_write_reg(0x20, 0x10);
+        ret |= es7243e_write_reg(0x21, 0x10);
+        ret |= es7243e_write_reg(0x00, 0x80);
+        ret |= es7243e_write_reg(0x01, 0x3A);
+        ret |= es7243e_write_reg(0x16, 0x3F);
+        ret |= es7243e_write_reg(0x16, 0x00);
+    } else {
+        ESP_LOGW(TAG, "The codec going to stop");
+        ret |= es7243e_write_reg(0x04, 0x02);
+        ret |= es7243e_write_reg(0x04, 0x01);
+        ret |= es7243e_write_reg(0xF7, 0x30);
+        ret |= es7243e_write_reg(0xF9, 0x01);
+        ret |= es7243e_write_reg(0x16, 0xFF);
+        ret |= es7243e_write_reg(0x17, 0x00);
+        ret |= es7243e_write_reg(0x01, 0x38);
+        ret |= es7243e_write_reg(0x20, 0x00);
+        ret |= es7243e_write_reg(0x21, 0x00);
+        ret |= es7243e_write_reg(0x00, 0x00);
+        ret |= es7243e_write_reg(0x00, 0x1E);
+        ret |= es7243e_write_reg(0x01, 0x30);
+        ret |= es7243e_write_reg(0x01, 0x00);
+    }
+    return ret;
+}
+
+esp_err_t es7243e_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7243e_adc_set_voice_volume(int volume)
+{
+    return ESP_OK;
+}
+
+esp_err_t es7243e_adc_get_voice_volume(int *volume)
+{
+    return ESP_OK;
+}
diff --git a/components/audio_hal/driver/es7243e/es7243e.h b/components/audio_hal/driver/es7243e/es7243e.h
index d32d63ee..81803c23 100644
--- a/components/audio_hal/driver/es7243e/es7243e.h
+++ b/components/audio_hal/driver/es7243e/es7243e.h
@@ -1,116 +1,116 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ES7243E_H_
-#define _ES7243E_H_
-
-#include "esp_err.h"
-#include "audio_hal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Initialize ES7243E adc chip
- *
- * @param codec_cfg configuration of ES7243E
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243e_adc_init(audio_hal_codec_config_t *codec_cfg);
-
-/**
- * @brief Deinitialize ES7243E adc chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243e_adc_deinit(void);
-
-/**
- * @brief Control ES7243E adc chip
- *
- * @param mode adc mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es7243e_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief Configure ES7243E adc mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es7243e_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief  Set adc gain
- *
- * @param volume  value of gain (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243e_adc_set_voice_volume(int volume);
-
-/**
- * @brief Get adc gain
- *
- * @param[out] *volume:  value of gain (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243e_adc_get_voice_volume(int *volume);
-
-/**
- * @brief Set adc I2C address
- *
- * @param[in] addr:  value of I2C address
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es7243e_adc_set_addr(int addr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ES7243E_H_
+#define _ES7243E_H_
+
+#include "esp_err.h"
+#include "audio_hal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initialize ES7243E adc chip
+ *
+ * @param codec_cfg configuration of ES7243E
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243e_adc_init(audio_hal_codec_config_t *codec_cfg);
+
+/**
+ * @brief Deinitialize ES7243E adc chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243e_adc_deinit(void);
+
+/**
+ * @brief Control ES7243E adc chip
+ *
+ * @param mode adc mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es7243e_adc_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief Configure ES7243E adc mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es7243e_adc_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief  Set adc gain
+ *
+ * @param volume  value of gain (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243e_adc_set_voice_volume(int volume);
+
+/**
+ * @brief Get adc gain
+ *
+ * @param[out] *volume:  value of gain (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243e_adc_get_voice_volume(int *volume);
+
+/**
+ * @brief Set adc I2C address
+ *
+ * @param[in] addr:  value of I2C address
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es7243e_adc_set_addr(int addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/es8156/es8156.c b/components/audio_hal/driver/es8156/es8156.c
index e1de9923..ce9e9028 100644
--- a/components/audio_hal/driver/es8156/es8156.c
+++ b/components/audio_hal/driver/es8156/es8156.c
@@ -1,260 +1,260 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "string.h"
-#include "esp_log.h"
-#include "i2c_bus.h"
-#include "es8156.h"
-#include "driver/gpio.h"
-#include "board.h"
-#include "audio_volume.h"
-
-#define ES8156_ADDR         0x10
-
-static const char *TAG = "DRV8156";
-static bool codec_init_flag = 0;
-static i2c_bus_handle_t i2c_handle;
-static codec_dac_volume_config_t *dac_vol_handle;
-
-#define ES8156_DAC_VOL_CFG_DEFAULT() {                      \
-    .max_dac_volume = 32,                                   \
-    .min_dac_volume = -95.5,                                \
-    .board_pa_gain = BOARD_PA_GAIN,                         \
-    .volume_accuracy = 0.5,                                 \
-    .dac_vol_symbol = 1,                                    \
-    .zero_volume_reg = 0xBF,                                \
-    .reg_value = 0,                                         \
-    .user_volume = 0,                                       \
-    .offset_conv_volume = NULL,                             \
-}
-
-audio_hal_func_t AUDIO_CODEC_ES8156_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es8156_codec_init,
-    .audio_codec_deinitialize = es8156_codec_deinit,
-    .audio_codec_ctrl = es8156_codec_ctrl_state,
-    .audio_codec_config_iface = es8156_codec_config_i2s,
-    .audio_codec_set_mute = es8156_codec_set_voice_mute,
-    .audio_codec_set_volume = es8156_codec_set_voice_volume,
-    .audio_codec_get_volume = es8156_codec_get_voice_volume,
-    .audio_codec_enable_pa = es8156_pa_power,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static bool es8156_codec_initialized()
-{
-    return codec_init_flag;
-}
-
-static esp_err_t es8156_write_reg(uint8_t reg_addr, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, ES8156_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-}
-
-static int es8156_read_reg(uint8_t reg_addr)
-{
-    uint8_t data;
-    i2c_bus_read_bytes(i2c_handle, ES8156_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-    return (int)data;
-}
-
-static int i2c_init()
-{
-    int res = 0;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000,
-    };
-    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    if (res != ESP_OK) {
-        ESP_LOGE(TAG, "getting i2c pins error");
-    }
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-static esp_err_t es8156_standby(void)
-{
-    esp_err_t ret = 0;
-    ret = es8156_write_reg(0x14, 0x00);
-    ret |= es8156_write_reg(0x19, 0x02);
-    ret |= es8156_write_reg(0x21, 0x1F);
-    ret |= es8156_write_reg(0x22, 0x02);
-    ret |= es8156_write_reg(0x25, 0x21);
-    ret |= es8156_write_reg(0x25, 0xA1);
-    ret |= es8156_write_reg(0x18, 0x01);
-    ret |= es8156_write_reg(0x09, 0x02);
-    ret |= es8156_write_reg(0x09, 0x01);
-    ret |= es8156_write_reg(0x08, 0x00);
-    return ret;
-}
-
-static esp_err_t es8156_resume(void)
-{
-    esp_err_t ret = 0;
-    ret |= es8156_write_reg(0x08, 0x3F);
-    ret |= es8156_write_reg(0x09, 0x00);
-    ret |= es8156_write_reg(0x18, 0x00);
-
-    ret |= es8156_write_reg(0x25, 0x20);
-    ret |= es8156_write_reg(0x22, 0x00);
-    ret |= es8156_write_reg(0x21, 0x3C);
-    ret |= es8156_write_reg(0x19, 0x20);
-    ret |= es8156_write_reg(0x14, 179);
-    return ret;
-}
-
-esp_err_t es8156_pa_power(bool enable)
-{
-    esp_err_t ret = ESP_OK;
-    if (enable) {
-        ret = gpio_set_level(get_pa_enable_gpio(), 1);
-    } else {
-        ret = gpio_set_level(get_pa_enable_gpio(), 0);
-    }
-    return ret;
-}
-
-esp_err_t es8156_codec_init(audio_hal_codec_config_t *cfg)
-{
-    if (es8156_codec_initialized()) {
-        ESP_LOGW(TAG, "The es8156 DAC has been already initialized");
-        return ESP_OK;
-    }
-    codec_init_flag = true;
-
-    i2c_init();
-    es8156_write_reg(0x02, 0x04);
-    es8156_write_reg(0x20, 0x2A);
-    es8156_write_reg(0x21, 0x3C);
-    es8156_write_reg(0x22, 0x00);
-    es8156_write_reg(0x24, 0x07);
-    es8156_write_reg(0x23, 0x00);
-
-    es8156_write_reg(0x0A, 0x01);
-    es8156_write_reg(0x0B, 0x01);
-    es8156_write_reg(0x11, 0x00);
-    es8156_write_reg(0x14, 179);  // volume 70%
-
-    es8156_write_reg(0x0D, 0x14);
-    es8156_write_reg(0x18, 0x00);
-    es8156_write_reg(0x08, 0x3F);
-    es8156_write_reg(0x00, 0x02);
-    es8156_write_reg(0x00, 0x03);
-    es8156_write_reg(0x25, 0x20);
-
-    gpio_config_t io_conf;
-    memset(&io_conf, 0, sizeof(io_conf));
-    io_conf.mode = GPIO_MODE_OUTPUT;
-    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
-    io_conf.pull_down_en = 0;
-    io_conf.pull_up_en = 0;
-    gpio_config(&io_conf);
-    es8156_pa_power(true);
-
-    codec_dac_volume_config_t vol_cfg = ES8156_DAC_VOL_CFG_DEFAULT();
-    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
-    return ESP_OK;
-}
-
-esp_err_t es8156_codec_deinit(void)
-{
-    codec_init_flag = false;
-    audio_codec_volume_deinit(dac_vol_handle);
-    return ESP_OK;
-}
-
-esp_err_t es8156_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    esp_err_t ret = ESP_OK;
-    if (ctrl_state == AUDIO_HAL_CTRL_START) {
-        ret = es8156_resume();
-    } else {
-        ESP_LOGW(TAG, "The codec going to stop");
-        ret = es8156_standby();
-    }
-    return ret;
-}
-
-esp_err_t es8156_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    return ESP_OK;
-}
-
-esp_err_t es8156_codec_set_voice_mute(bool enable)
-{
-    int regv = es8156_read_reg(ES8156_DAC_MUTE_REG13);
-    if (enable) {
-        regv = regv | BIT(1) | BIT(2);
-    } else {
-        regv = regv & (~(BIT(1) | BIT(2))) ;
-    }
-    es8156_write_reg(ES8156_DAC_MUTE_REG13, regv);
-    return ESP_OK;
-}
-
-/**
- * @brief Set voice volume
- *
- * @note Register values. 0x00: -95.5 dB, 0x5B: -50 dB, 0xBF: 0 dB, 0xFF: 32 dB
- * @note Accuracy of gain is 0.5 dB
- *
- * @param volume: voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8156_codec_set_voice_volume(int volume)
-{
-    int ret = 0;
-    uint8_t reg = 0;
-    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
-    ret = es8156_write_reg(ES8156_VOLUME_CONTROL_REG14, reg);
-    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", dac_vol_handle->user_volume, reg,
-            audio_codec_cal_dac_volume(dac_vol_handle));
-    return ret;
-}
-
-esp_err_t es8156_codec_get_voice_volume(int *volume)
-{
-    int ret = 0;
-    int regv = 0;
-    *volume = 0;
-    regv = es8156_read_reg(ES8156_VOLUME_CONTROL_REG14);
-    if (regv == ESP_FAIL) {
-        ret = ESP_FAIL;
-    } else {
-        if (regv == dac_vol_handle->reg_value) {
-            *volume = dac_vol_handle->user_volume;
-        } else {
-            *volume = 0;
-            ret = ESP_FAIL;
-        }
-    }
-    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, regv);
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "string.h"
+#include "esp_log.h"
+#include "i2c_bus.h"
+#include "es8156.h"
+#include "driver/gpio.h"
+#include "board.h"
+#include "audio_volume.h"
+
+#define ES8156_ADDR         0x10
+
+static const char *TAG = "DRV8156";
+static bool codec_init_flag = 0;
+static i2c_bus_handle_t i2c_handle;
+static codec_dac_volume_config_t *dac_vol_handle;
+
+#define ES8156_DAC_VOL_CFG_DEFAULT() {                      \
+    .max_dac_volume = 32,                                   \
+    .min_dac_volume = -95.5,                                \
+    .board_pa_gain = BOARD_PA_GAIN,                         \
+    .volume_accuracy = 0.5,                                 \
+    .dac_vol_symbol = 1,                                    \
+    .zero_volume_reg = 0xBF,                                \
+    .reg_value = 0,                                         \
+    .user_volume = 0,                                       \
+    .offset_conv_volume = NULL,                             \
+}
+
+audio_hal_func_t AUDIO_CODEC_ES8156_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es8156_codec_init,
+    .audio_codec_deinitialize = es8156_codec_deinit,
+    .audio_codec_ctrl = es8156_codec_ctrl_state,
+    .audio_codec_config_iface = es8156_codec_config_i2s,
+    .audio_codec_set_mute = es8156_codec_set_voice_mute,
+    .audio_codec_set_volume = es8156_codec_set_voice_volume,
+    .audio_codec_get_volume = es8156_codec_get_voice_volume,
+    .audio_codec_enable_pa = es8156_pa_power,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static bool es8156_codec_initialized()
+{
+    return codec_init_flag;
+}
+
+static esp_err_t es8156_write_reg(uint8_t reg_addr, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, ES8156_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+}
+
+static int es8156_read_reg(uint8_t reg_addr)
+{
+    uint8_t data;
+    i2c_bus_read_bytes(i2c_handle, ES8156_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+    return (int)data;
+}
+
+static int i2c_init()
+{
+    int res = 0;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000,
+    };
+    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    if (res != ESP_OK) {
+        ESP_LOGE(TAG, "getting i2c pins error");
+    }
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+static esp_err_t es8156_standby(void)
+{
+    esp_err_t ret = 0;
+    ret = es8156_write_reg(0x14, 0x00);
+    ret |= es8156_write_reg(0x19, 0x02);
+    ret |= es8156_write_reg(0x21, 0x1F);
+    ret |= es8156_write_reg(0x22, 0x02);
+    ret |= es8156_write_reg(0x25, 0x21);
+    ret |= es8156_write_reg(0x25, 0xA1);
+    ret |= es8156_write_reg(0x18, 0x01);
+    ret |= es8156_write_reg(0x09, 0x02);
+    ret |= es8156_write_reg(0x09, 0x01);
+    ret |= es8156_write_reg(0x08, 0x00);
+    return ret;
+}
+
+static esp_err_t es8156_resume(void)
+{
+    esp_err_t ret = 0;
+    ret |= es8156_write_reg(0x08, 0x3F);
+    ret |= es8156_write_reg(0x09, 0x00);
+    ret |= es8156_write_reg(0x18, 0x00);
+
+    ret |= es8156_write_reg(0x25, 0x20);
+    ret |= es8156_write_reg(0x22, 0x00);
+    ret |= es8156_write_reg(0x21, 0x3C);
+    ret |= es8156_write_reg(0x19, 0x20);
+    ret |= es8156_write_reg(0x14, 179);
+    return ret;
+}
+
+esp_err_t es8156_pa_power(bool enable)
+{
+    esp_err_t ret = ESP_OK;
+    if (enable) {
+        ret = gpio_set_level(get_pa_enable_gpio(), 1);
+    } else {
+        ret = gpio_set_level(get_pa_enable_gpio(), 0);
+    }
+    return ret;
+}
+
+esp_err_t es8156_codec_init(audio_hal_codec_config_t *cfg)
+{
+    if (es8156_codec_initialized()) {
+        ESP_LOGW(TAG, "The es8156 DAC has been already initialized");
+        return ESP_OK;
+    }
+    codec_init_flag = true;
+
+    i2c_init();
+    es8156_write_reg(0x02, 0x04);
+    es8156_write_reg(0x20, 0x2A);
+    es8156_write_reg(0x21, 0x3C);
+    es8156_write_reg(0x22, 0x00);
+    es8156_write_reg(0x24, 0x07);
+    es8156_write_reg(0x23, 0x00);
+
+    es8156_write_reg(0x0A, 0x01);
+    es8156_write_reg(0x0B, 0x01);
+    es8156_write_reg(0x11, 0x00);
+    es8156_write_reg(0x14, 179);  // volume 70%
+
+    es8156_write_reg(0x0D, 0x14);
+    es8156_write_reg(0x18, 0x00);
+    es8156_write_reg(0x08, 0x3F);
+    es8156_write_reg(0x00, 0x02);
+    es8156_write_reg(0x00, 0x03);
+    es8156_write_reg(0x25, 0x20);
+
+    gpio_config_t io_conf;
+    memset(&io_conf, 0, sizeof(io_conf));
+    io_conf.mode = GPIO_MODE_OUTPUT;
+    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
+    io_conf.pull_down_en = 0;
+    io_conf.pull_up_en = 0;
+    gpio_config(&io_conf);
+    es8156_pa_power(true);
+
+    codec_dac_volume_config_t vol_cfg = ES8156_DAC_VOL_CFG_DEFAULT();
+    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
+    return ESP_OK;
+}
+
+esp_err_t es8156_codec_deinit(void)
+{
+    codec_init_flag = false;
+    audio_codec_volume_deinit(dac_vol_handle);
+    return ESP_OK;
+}
+
+esp_err_t es8156_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    esp_err_t ret = ESP_OK;
+    if (ctrl_state == AUDIO_HAL_CTRL_START) {
+        ret = es8156_resume();
+    } else {
+        ESP_LOGW(TAG, "The codec going to stop");
+        ret = es8156_standby();
+    }
+    return ret;
+}
+
+esp_err_t es8156_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    return ESP_OK;
+}
+
+esp_err_t es8156_codec_set_voice_mute(bool enable)
+{
+    int regv = es8156_read_reg(ES8156_DAC_MUTE_REG13);
+    if (enable) {
+        regv = regv | BIT(1) | BIT(2);
+    } else {
+        regv = regv & (~(BIT(1) | BIT(2))) ;
+    }
+    es8156_write_reg(ES8156_DAC_MUTE_REG13, regv);
+    return ESP_OK;
+}
+
+/**
+ * @brief Set voice volume
+ *
+ * @note Register values. 0x00: -95.5 dB, 0x5B: -50 dB, 0xBF: 0 dB, 0xFF: 32 dB
+ * @note Accuracy of gain is 0.5 dB
+ *
+ * @param volume: voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8156_codec_set_voice_volume(int volume)
+{
+    int ret = 0;
+    uint8_t reg = 0;
+    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
+    ret = es8156_write_reg(ES8156_VOLUME_CONTROL_REG14, reg);
+    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", dac_vol_handle->user_volume, reg,
+            audio_codec_cal_dac_volume(dac_vol_handle));
+    return ret;
+}
+
+esp_err_t es8156_codec_get_voice_volume(int *volume)
+{
+    int ret = 0;
+    int regv = 0;
+    *volume = 0;
+    regv = es8156_read_reg(ES8156_VOLUME_CONTROL_REG14);
+    if (regv == ESP_FAIL) {
+        ret = ESP_FAIL;
+    } else {
+        if (regv == dac_vol_handle->reg_value) {
+            *volume = dac_vol_handle->user_volume;
+        } else {
+            *volume = 0;
+            ret = ESP_FAIL;
+        }
+    }
+    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, regv);
+    return ret;
+}
diff --git a/components/audio_hal/driver/es8156/es8156.h b/components/audio_hal/driver/es8156/es8156.h
index 114a15be..cef08f26 100644
--- a/components/audio_hal/driver/es8156/es8156.h
+++ b/components/audio_hal/driver/es8156/es8156.h
@@ -1,186 +1,186 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ES8156_H
-#define _ES8156_H
-
-#include "audio_hal.h"
-#include "esp_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* ES8156 register space */
-/*
-* RESET Control
-*/
-#define ES8156_RESET_REG00             0x00
-/*
-* Clock Managerment
-*/
-#define ES8156_MAINCLOCK_CTL_REG01     0x01
-#define ES8156_SCLK_MODE_REG02         0x02
-#define ES8156_LRCLK_DIV_H_REG03       0x03
-#define ES8156_LRCLK_DIV_L_REG04       0x04
-#define ES8156_SCLK_DIV_REG05          0x05
-#define ES8156_NFS_CONFIG_REG06        0x06
-#define ES8156_MISC_CONTROL1_REG07     0x07
-#define ES8156_CLOCK_ON_OFF_REG08      0x08
-#define ES8156_MISC_CONTROL2_REG09     0x09
-#define ES8156_TIME_CONTROL1_REG0A     0x0a
-#define ES8156_TIME_CONTROL2_REG0B     0x0b
-/*
-* System Control
-*/
-#define ES8156_CHIP_STATUS_REG0C       0x0c
-#define ES8156_P2S_CONTROL_REG0D       0x0d
-#define ES8156_DAC_OSR_COUNTER_REG10   0x10
-/*
-* SDP Control
-*/
-#define ES8156_DAC_SDP_REG11           0x11
-#define ES8156_AUTOMUTE_SET_REG12      0x12
-#define ES8156_DAC_MUTE_REG13          0x13
-#define ES8156_VOLUME_CONTROL_REG14    0x14
-
-/*
-* ALC Control
-*/
-#define ES8156_ALC_CONFIG1_REG15       0x15
-#define ES8156_ALC_CONFIG2_REG16       0x16
-#define ES8156_ALC_CONFIG3_REG17       0x17
-#define ES8156_MISC_CONTROL3_REG18     0x18
-#define ES8156_EQ_CONTROL1_REG19       0x19
-#define ES8156_EQ_CONTROL2_REG1A       0x1a
-/*
-* Analog System Control
-*/
-#define ES8156_ANALOG_SYS1_REG20       0x20
-#define ES8156_ANALOG_SYS2_REG21       0x21
-#define ES8156_ANALOG_SYS3_REG22       0x22
-#define ES8156_ANALOG_SYS4_REG23       0x23
-#define ES8156_ANALOG_LP_REG24         0x24
-#define ES8156_ANALOG_SYS5_REG25       0x25
-/*
-* Chip Information
-*/
-#define ES8156_I2C_PAGESEL_REGFC       0xFC
-#define ES8156_CHIPID1_REGFD           0xFD
-#define ES8156_CHIPID0_REGFE           0xFE
-#define ES8156_CHIP_VERSION_REGFF      0xFF
-
-/*
- * @brief Enables or disables PA
- *
- * @param enable     true/false
- *
- * @return
- *      - ESP_ERR_INVALID_ARG
- *      - ESP_OK
- */
-esp_err_t es8156_pa_power(bool enable);
-
-/*
- * @brief Initialize ES8156 codec chip
- *
- * @param codec_cfg  configuration of ES8156
- *
- * @return
- *      - ESP_OK
- *      - ESP_FAIL
- */
-esp_err_t es8156_codec_init(audio_hal_codec_config_t *codec_cfg);
-
-/**
- * @brief Deinitialize ES8156 codec chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8156_codec_deinit(void);
-
-/**
- * @brief Control ES8156 codec chip
- *
- * @param mode codec mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8156_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief Configure ES8156 codec mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8156_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief Configure ES8156 DAC mute or not. Basically you can use this function to mute the output or unmute
- *
- * @param enable enable(1) or disable(0)
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8156_codec_set_voice_mute(bool enable);
-
-/**
- * @brief  Set voice volume
- *
- * @param volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8156_codec_set_voice_volume(int volume);
-
-/**
- * @brief Get voice volume
- *
- * @param[out] *volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8156_codec_get_voice_volume(int *volume);
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ES8156_H
+#define _ES8156_H
+
+#include "audio_hal.h"
+#include "esp_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ES8156 register space */
+/*
+* RESET Control
+*/
+#define ES8156_RESET_REG00             0x00
+/*
+* Clock Managerment
+*/
+#define ES8156_MAINCLOCK_CTL_REG01     0x01
+#define ES8156_SCLK_MODE_REG02         0x02
+#define ES8156_LRCLK_DIV_H_REG03       0x03
+#define ES8156_LRCLK_DIV_L_REG04       0x04
+#define ES8156_SCLK_DIV_REG05          0x05
+#define ES8156_NFS_CONFIG_REG06        0x06
+#define ES8156_MISC_CONTROL1_REG07     0x07
+#define ES8156_CLOCK_ON_OFF_REG08      0x08
+#define ES8156_MISC_CONTROL2_REG09     0x09
+#define ES8156_TIME_CONTROL1_REG0A     0x0a
+#define ES8156_TIME_CONTROL2_REG0B     0x0b
+/*
+* System Control
+*/
+#define ES8156_CHIP_STATUS_REG0C       0x0c
+#define ES8156_P2S_CONTROL_REG0D       0x0d
+#define ES8156_DAC_OSR_COUNTER_REG10   0x10
+/*
+* SDP Control
+*/
+#define ES8156_DAC_SDP_REG11           0x11
+#define ES8156_AUTOMUTE_SET_REG12      0x12
+#define ES8156_DAC_MUTE_REG13          0x13
+#define ES8156_VOLUME_CONTROL_REG14    0x14
+
+/*
+* ALC Control
+*/
+#define ES8156_ALC_CONFIG1_REG15       0x15
+#define ES8156_ALC_CONFIG2_REG16       0x16
+#define ES8156_ALC_CONFIG3_REG17       0x17
+#define ES8156_MISC_CONTROL3_REG18     0x18
+#define ES8156_EQ_CONTROL1_REG19       0x19
+#define ES8156_EQ_CONTROL2_REG1A       0x1a
+/*
+* Analog System Control
+*/
+#define ES8156_ANALOG_SYS1_REG20       0x20
+#define ES8156_ANALOG_SYS2_REG21       0x21
+#define ES8156_ANALOG_SYS3_REG22       0x22
+#define ES8156_ANALOG_SYS4_REG23       0x23
+#define ES8156_ANALOG_LP_REG24         0x24
+#define ES8156_ANALOG_SYS5_REG25       0x25
+/*
+* Chip Information
+*/
+#define ES8156_I2C_PAGESEL_REGFC       0xFC
+#define ES8156_CHIPID1_REGFD           0xFD
+#define ES8156_CHIPID0_REGFE           0xFE
+#define ES8156_CHIP_VERSION_REGFF      0xFF
+
+/*
+ * @brief Enables or disables PA
+ *
+ * @param enable     true/false
+ *
+ * @return
+ *      - ESP_ERR_INVALID_ARG
+ *      - ESP_OK
+ */
+esp_err_t es8156_pa_power(bool enable);
+
+/*
+ * @brief Initialize ES8156 codec chip
+ *
+ * @param codec_cfg  configuration of ES8156
+ *
+ * @return
+ *      - ESP_OK
+ *      - ESP_FAIL
+ */
+esp_err_t es8156_codec_init(audio_hal_codec_config_t *codec_cfg);
+
+/**
+ * @brief Deinitialize ES8156 codec chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8156_codec_deinit(void);
+
+/**
+ * @brief Control ES8156 codec chip
+ *
+ * @param mode codec mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8156_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief Configure ES8156 codec mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8156_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief Configure ES8156 DAC mute or not. Basically you can use this function to mute the output or unmute
+ *
+ * @param enable enable(1) or disable(0)
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8156_codec_set_voice_mute(bool enable);
+
+/**
+ * @brief  Set voice volume
+ *
+ * @param volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8156_codec_set_voice_volume(int volume);
+
+/**
+ * @brief Get voice volume
+ *
+ * @param[out] *volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8156_codec_get_voice_volume(int *volume);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/components/audio_hal/driver/es8311/es8311.c b/components/audio_hal/driver/es8311/es8311.c
index 71939dba..feb8d599 100644
--- a/components/audio_hal/driver/es8311/es8311.c
+++ b/components/audio_hal/driver/es8311/es8311.c
@@ -1,762 +1,762 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "i2c_bus.h"
-#include "board.h"
-#include "esp_log.h"
-#include "es8311.h"
-#include "audio_volume.h"
-
-/* ES8311 address
- * 0x32:CE=1;0x30:CE=0
- */
-#define ES8311_ADDR         0x30
-
-/*
- * to define the clock soure of MCLK
- */
-#define FROM_MCLK_PIN       0
-#define FROM_SCLK_PIN       1
-
-/*
- * to define whether to reverse the clock
- */
-#define INVERT_MCLK         0 // do not invert
-#define INVERT_SCLK         0
-
-#define IS_DMIC             0 // Is it a digital microphone
-
-#define MCLK_DIV_FRE        256
-
-static i2c_bus_handle_t i2c_handle;
-static codec_dac_volume_config_t *dac_vol_handle;
-
-#define ES8311_DAC_VOL_CFG_DEFAULT() {                      \
-    .max_dac_volume = 32,                                   \
-    .min_dac_volume = -95.5,                                \
-    .board_pa_gain = BOARD_PA_GAIN,                         \
-    .volume_accuracy = 0.5,                                 \
-    .dac_vol_symbol = 1,                                    \
-    .zero_volume_reg = 0xBF,                                \
-    .reg_value = 0,                                         \
-    .user_volume = 0,                                       \
-    .offset_conv_volume = NULL,                             \
-}
-
-/*
- * operate function of codec
- */
-audio_hal_func_t AUDIO_CODEC_ES8311_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es8311_codec_init,
-    .audio_codec_deinitialize = es8311_codec_deinit,
-    .audio_codec_ctrl = es8311_codec_ctrl_state,
-    .audio_codec_config_iface = es8311_codec_config_i2s,
-    .audio_codec_set_mute = es8311_set_voice_mute,
-    .audio_codec_set_volume = es8311_codec_set_voice_volume,
-    .audio_codec_get_volume = es8311_codec_get_voice_volume,
-    .audio_codec_enable_pa = es8311_pa_power,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-/*
- * Clock coefficient structer
- */
-struct _coeff_div {
-    uint32_t mclk;        /* mclk frequency */
-    uint32_t rate;        /* sample rate */
-    uint8_t pre_div;      /* the pre divider with range from 1 to 8 */
-    uint8_t pre_multi;    /* the pre multiplier with x1, x2, x4 and x8 selection */
-    uint8_t adc_div;      /* adcclk divider */
-    uint8_t dac_div;      /* dacclk divider */
-    uint8_t fs_mode;      /* double speed or single speed, =0, ss, =1, ds */
-    uint8_t lrck_h;       /* adclrck divider and daclrck divider */
-    uint8_t lrck_l;
-    uint8_t bclk_div;     /* sclk divider */
-    uint8_t adc_osr;      /* adc osr */
-    uint8_t dac_osr;      /* dac osr */
-};
-
-/* codec hifi mclk clock divider coefficients */
-static const struct _coeff_div coeff_div[] = {
-    //mclk     rate   pre_div  mult  adc_div dac_div fs_mode lrch  lrcl  bckdiv osr
-    /* 8k */
-    {12288000, 8000 , 0x06, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {18432000, 8000 , 0x03, 0x02, 0x03, 0x03, 0x00, 0x05, 0xff, 0x18, 0x10, 0x20},
-    {16384000, 8000 , 0x08, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {8192000 , 8000 , 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {6144000 , 8000 , 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {4096000 , 8000 , 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {3072000 , 8000 , 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {2048000 , 8000 , 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {1536000 , 8000 , 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {1024000 , 8000 , 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-
-    /* 11.025k */
-    {11289600, 11025, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {5644800 , 11025, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {2822400 , 11025, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {1411200 , 11025, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-
-    /* 12k */
-    {12288000, 12000, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {6144000 , 12000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {3072000 , 12000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {1536000 , 12000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-
-    /* 16k */
-    {12288000, 16000, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {18432000, 16000, 0x03, 0x02, 0x03, 0x03, 0x00, 0x02, 0xff, 0x0c, 0x10, 0x20},
-    {16384000, 16000, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {8192000 , 16000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {6144000 , 16000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {4096000 , 16000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {3072000 , 16000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {2048000 , 16000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {1536000 , 16000, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-    {1024000 , 16000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
-
-    /* 22.05k */
-    {11289600, 22050, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {5644800 , 22050, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {2822400 , 22050, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1411200 , 22050, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-
-    /* 24k */
-    {12288000, 24000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {18432000, 24000, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {6144000 , 24000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {3072000 , 24000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1536000 , 24000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-
-    /* 32k */
-    {12288000, 32000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {18432000, 32000, 0x03, 0x04, 0x03, 0x03, 0x00, 0x02, 0xff, 0x0c, 0x10, 0x10},
-    {16384000, 32000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {8192000 , 32000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {6144000 , 32000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {4096000 , 32000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {3072000 , 32000, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {2048000 , 32000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1536000 , 32000, 0x03, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
-    {1024000 , 32000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-
-    /* 44.1k */
-    {11289600, 44100, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {5644800 , 44100, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {2822400 , 44100, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1411200 , 44100, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-
-    /* 48k */
-    {12288000, 48000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {18432000, 48000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {6144000 , 48000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {3072000 , 48000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1536000 , 48000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-
-    /* 64k */
-    {12288000, 64000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {18432000, 64000, 0x03, 0x04, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
-    {16384000, 64000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {8192000 , 64000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {6144000 , 64000, 0x01, 0x04, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
-    {4096000 , 64000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {3072000 , 64000, 0x01, 0x08, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
-    {2048000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1536000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0xbf, 0x03, 0x18, 0x18},
-    {1024000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
-
-    /* 88.2k */
-    {11289600, 88200, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {5644800 , 88200, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {2822400 , 88200, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1411200 , 88200, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
-
-    /* 96k */
-    {12288000, 96000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {18432000, 96000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {6144000 , 96000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {3072000 , 96000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
-    {1536000 , 96000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
-};
-
-static char *TAG = "DRV8311";
-
-#define ES_ASSERT(a, format, b, ...) \
-    if ((a) != 0) { \
-        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
-        return b;\
-    }
-
-int8_t get_es8311_mclk_src(void);
-
-static esp_err_t es8311_write_reg(uint8_t reg_addr, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, ES8311_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-}
-
-static int es8311_read_reg(uint8_t reg_addr)
-{
-    uint8_t data;
-    i2c_bus_read_bytes(i2c_handle, ES8311_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-    return (int)data;
-}
-
-static int i2c_init()
-{
-    int res = 0;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000,
-    };
-    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    ES_ASSERT(res, "getting i2c pins error", -1);
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-/*
-* look for the coefficient in coeff_div[] table
-*/
-static int get_coeff(uint32_t mclk, uint32_t rate)
-{
-    for (int i = 0; i < (sizeof(coeff_div) / sizeof(coeff_div[0])); i++) {
-        if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
-            return i;
-    }
-    return -1;
-}
-
-/*
-* set es8311 dac mute or not
-* if mute = 0, dac un-mute
-* if mute = 1, dac mute
-*/
-static void es8311_mute(int mute)
-{
-    uint8_t regv;
-    ESP_LOGI(TAG, "Enter into es8311_mute(), mute = %d\n", mute);
-    regv = es8311_read_reg(ES8311_DAC_REG31) & 0x9f;
-    if (mute) {
-        es8311_write_reg(ES8311_DAC_REG31, regv | 0x60);
-    } else {
-        es8311_write_reg(ES8311_DAC_REG31, regv);
-    }
-}
-
-/*
-* set es8311 into suspend mode
-*/
-static void es8311_suspend(void)
-{
-    ESP_LOGI(TAG, "Enter into es8311_suspend()");
-    es8311_write_reg(ES8311_DAC_REG32, 0x00);
-    es8311_write_reg(ES8311_ADC_REG17, 0x00);
-    es8311_write_reg(ES8311_SYSTEM_REG0E, 0xFF);
-    es8311_write_reg(ES8311_SYSTEM_REG12, 0x02);
-    es8311_write_reg(ES8311_SYSTEM_REG14, 0x00);
-    es8311_write_reg(ES8311_SYSTEM_REG0D, 0xFA);
-    es8311_write_reg(ES8311_ADC_REG15, 0x00);
-    es8311_write_reg(ES8311_GP_REG45, 0x01);
-}
-
-/*
-* enable pa power
-*/
-esp_err_t es8311_pa_power(bool enable)
-{
-    esp_err_t ret = ESP_OK;
-    if (enable) {
-        ret = gpio_set_level(get_pa_enable_gpio(), 1);
-    } else {
-        ret = gpio_set_level(get_pa_enable_gpio(), 0);
-    }
-    return ret;
-}
-
-esp_err_t es8311_codec_init(audio_hal_codec_config_t *codec_cfg)
-{
-    uint8_t datmp, regv;
-    int coeff;
-    esp_err_t ret = ESP_OK;
-    i2c_init(); // ESP32 in master mode
-
-    /* Enhance ES8311 I2C noise immunity */
-    ret |= es8311_write_reg(ES8311_GPIO_REG44, 0x08);
-    /* Due to occasional failures during the first I2C write with the ES8311 chip, a second write is performed to ensure reliability */
-    ret |= es8311_write_reg(ES8311_GPIO_REG44, 0x08);
-
-    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, 0x30);
-    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG02, 0x00);
-    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG03, 0x10);
-    ret |= es8311_write_reg(ES8311_ADC_REG16, 0x24);
-    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG04, 0x10);
-    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG05, 0x00);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG0B, 0x00);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG0C, 0x00);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG10, 0x1F);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG11, 0x7F);
-    ret |= es8311_write_reg(ES8311_RESET_REG00, 0x80);
-    /*
-     * Set Codec into Master or Slave mode
-     */
-    regv = es8311_read_reg(ES8311_RESET_REG00);
-    /*
-     * Set master/slave audio interface
-     */
-    audio_hal_codec_i2s_iface_t *i2s_cfg = &(codec_cfg->i2s_iface);
-    switch (i2s_cfg->mode) {
-        case AUDIO_HAL_MODE_MASTER:    /* MASTER MODE */
-            ESP_LOGI(TAG, "ES8311 in Master mode");
-            regv |= 0x40;
-            break;
-        case AUDIO_HAL_MODE_SLAVE:    /* SLAVE MODE */
-            ESP_LOGI(TAG, "ES8311 in Slave mode");
-            regv &= 0xBF;
-            break;
-        default:
-            regv &= 0xBF;
-    }
-    ret |= es8311_write_reg(ES8311_RESET_REG00, regv);
-    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, 0x3F);
-    /*
-     * Select clock source for internal mclk
-     */
-    switch (get_es8311_mclk_src()) {
-        case FROM_MCLK_PIN:
-            regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
-            regv &= 0x7F;
-            ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
-            break;
-        case FROM_SCLK_PIN:
-            regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
-            regv |= 0x80;
-            ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
-            break;
-        default:
-            regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
-            regv &= 0x7F;
-            ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
-            break;
-    }
-    int sample_fre = 0;
-    int mclk_fre = 0;
-    switch (i2s_cfg->samples) {
-        case AUDIO_HAL_08K_SAMPLES:
-            sample_fre = 8000;
-            break;
-        case AUDIO_HAL_11K_SAMPLES:
-            sample_fre = 11025;
-            break;
-        case AUDIO_HAL_16K_SAMPLES:
-            sample_fre = 16000;
-            break;
-        case AUDIO_HAL_22K_SAMPLES:
-            sample_fre = 22050;
-            break;
-        case AUDIO_HAL_24K_SAMPLES:
-            sample_fre = 24000;
-            break;
-        case AUDIO_HAL_32K_SAMPLES:
-            sample_fre = 32000;
-            break;
-        case AUDIO_HAL_44K_SAMPLES:
-            sample_fre = 44100;
-            break;
-        case AUDIO_HAL_48K_SAMPLES:
-            sample_fre = 48000;
-            break;
-        default:
-            ESP_LOGE(TAG, "Unable to configure sample rate %dHz", sample_fre);
-            break;
-    }
-    mclk_fre = sample_fre * MCLK_DIV_FRE;
-    coeff = get_coeff(mclk_fre, sample_fre);
-    if (coeff < 0) {
-        ESP_LOGE(TAG, "Unable to configure sample rate %dHz with %dHz MCLK", sample_fre, mclk_fre);
-        return ESP_FAIL;
-    }
-    /*
-     * Set clock parammeters
-     */
-    if (coeff >= 0) {
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG02) & 0x07;
-        regv |= (coeff_div[coeff].pre_div - 1) << 5;
-        datmp = 0;
-        switch (coeff_div[coeff].pre_multi) {
-            case 1:
-                datmp = 0;
-                break;
-            case 2:
-                datmp = 1;
-                break;
-            case 4:
-                datmp = 2;
-                break;
-            case 8:
-                datmp = 3;
-                break;
-            default:
-                break;
-        }
-
-        if (get_es8311_mclk_src() == FROM_SCLK_PIN) {
-            datmp = 3;     /* DIG_MCLK = LRCK * 256 = BCLK * 8 */
-        }
-        regv |= (datmp) << 3;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG02, regv);
-
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG05) & 0x00;
-        regv |= (coeff_div[coeff].adc_div - 1) << 4;
-        regv |= (coeff_div[coeff].dac_div - 1) << 0;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG05, regv);
-
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG03) & 0x80;
-        regv |= coeff_div[coeff].fs_mode << 6;
-        regv |= coeff_div[coeff].adc_osr << 0;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG03, regv);
-
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG04) & 0x80;
-        regv |= coeff_div[coeff].dac_osr << 0;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG04, regv);
-
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG07) & 0xC0;
-        regv |= coeff_div[coeff].lrck_h << 0;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG07, regv);
-
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG08) & 0x00;
-        regv |= coeff_div[coeff].lrck_l << 0;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG08, regv);
-
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG06) & 0xE0;
-        if (coeff_div[coeff].bclk_div < 19) {
-            regv |= (coeff_div[coeff].bclk_div - 1) << 0;
-        } else {
-            regv |= (coeff_div[coeff].bclk_div) << 0;
-        }
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG06, regv);
-    }
-
-    /*
-     * mclk inverted or not
-     */
-    if (INVERT_MCLK) {
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
-        regv |= 0x40;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
-    } else {
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
-        regv &= ~(0x40);
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
-    }
-    /*
-     * sclk inverted or not
-     */
-    if (INVERT_SCLK) {
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG06);
-        regv |= 0x20;
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG06, regv);
-    } else {
-        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG06);
-        regv &= ~(0x20);
-        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG06, regv);
-    }
-
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG13, 0x10);
-    ret |= es8311_write_reg(ES8311_ADC_REG1B, 0x0A);
-    ret |= es8311_write_reg(ES8311_ADC_REG1C, 0x6A);
-    AUDIO_RET_ON_FALSE(TAG, ret, return ret, "es8311 initialize failed");
-
-    /* pa power gpio init */
-    gpio_config_t  io_conf;
-    memset(&io_conf, 0, sizeof(io_conf));
-    io_conf.mode = GPIO_MODE_OUTPUT;
-    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
-    io_conf.pull_down_en = 0;
-    io_conf.pull_up_en = 0;
-    gpio_config(&io_conf);
-    /* enable pa power */
-    es8311_pa_power(true);
-
-    codec_dac_volume_config_t vol_cfg = ES8311_DAC_VOL_CFG_DEFAULT();
-    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
-    return ESP_OK;
-}
-
-esp_err_t es8311_codec_deinit()
-{
-    i2c_bus_delete(i2c_handle);
-    audio_codec_volume_deinit(dac_vol_handle);
-    return ESP_OK;
-}
-
-esp_err_t es8311_config_fmt(es_i2s_fmt_t fmt)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t adc_iface = 0, dac_iface = 0;
-    dac_iface = es8311_read_reg(ES8311_SDPIN_REG09);
-    adc_iface = es8311_read_reg(ES8311_SDPOUT_REG0A);
-    switch (fmt) {
-        case AUDIO_HAL_I2S_NORMAL:
-            ESP_LOGD(TAG, "ES8311 in I2S Format");
-            dac_iface &= 0xFC;
-            adc_iface &= 0xFC;
-            break;
-        case AUDIO_HAL_I2S_LEFT:
-        case AUDIO_HAL_I2S_RIGHT:
-            ESP_LOGD(TAG, "ES8311 in LJ Format");
-            adc_iface &= 0xFC;
-            dac_iface &= 0xFC;
-            adc_iface |= 0x01;
-            dac_iface |= 0x01;
-            break;
-        case AUDIO_HAL_I2S_DSP:
-            ESP_LOGD(TAG, "ES8311 in DSP-A Format");
-            adc_iface &= 0xDC;
-            dac_iface &= 0xDC;
-            adc_iface |= 0x03;
-            dac_iface |= 0x03;
-            break;
-        default:
-            dac_iface &= 0xFC;
-            adc_iface &= 0xFC;
-            break;
-    }
-    ret |= es8311_write_reg(ES8311_SDPIN_REG09, dac_iface);
-    ret |= es8311_write_reg(ES8311_SDPOUT_REG0A, adc_iface);
-
-    return ret;
-}
-
-esp_err_t es8311_set_bits_per_sample(audio_hal_iface_bits_t bits)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t adc_iface = 0, dac_iface = 0;
-    dac_iface = es8311_read_reg(ES8311_SDPIN_REG09);
-    adc_iface = es8311_read_reg(ES8311_SDPOUT_REG0A);
-    switch (bits) {
-        case AUDIO_HAL_BIT_LENGTH_16BITS:
-            dac_iface |= 0x0c;
-            adc_iface |= 0x0c;
-            break;
-        case AUDIO_HAL_BIT_LENGTH_24BITS:
-            break;
-        case AUDIO_HAL_BIT_LENGTH_32BITS:
-            dac_iface |= 0x10;
-            adc_iface |= 0x10;
-            break;
-        default:
-            dac_iface |= 0x0c;
-            adc_iface |= 0x0c;
-            break;
-
-    }
-    ret |= es8311_write_reg(ES8311_SDPIN_REG09, dac_iface);
-    ret |= es8311_write_reg(ES8311_SDPOUT_REG0A, adc_iface);
-
-    return ret;
-}
-
-esp_err_t es8311_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    int ret = ESP_OK;
-    ret |= es8311_set_bits_per_sample(iface->bits);
-    ret |= es8311_config_fmt(iface->fmt);
-    return ret;
-}
-
-esp_err_t es8311_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    esp_err_t ret = ESP_OK;
-    es_module_t es_mode = ES_MODULE_MIN;
-
-    switch (mode) {
-        case AUDIO_HAL_CODEC_MODE_ENCODE:
-            es_mode  = ES_MODULE_ADC;
-            break;
-        case AUDIO_HAL_CODEC_MODE_LINE_IN:
-            es_mode  = ES_MODULE_LINE;
-            break;
-        case AUDIO_HAL_CODEC_MODE_DECODE:
-            es_mode  = ES_MODULE_DAC;
-            break;
-        case AUDIO_HAL_CODEC_MODE_BOTH:
-            es_mode  = ES_MODULE_ADC_DAC;
-            break;
-        default:
-            es_mode = ES_MODULE_DAC;
-            ESP_LOGW(TAG, "Codec mode not support, default is decode mode");
-            break;
-    }
-
-    if (ctrl_state == AUDIO_HAL_CTRL_START) {
-        ret |= es8311_start(es_mode);
-    } else {
-        ESP_LOGW(TAG, "The codec is about to stop");
-        ret |= es8311_stop(es_mode);
-    }
-
-    return ret;
-}
-
-esp_err_t es8311_start(es_module_t mode)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t adc_iface = 0, dac_iface = 0;
-
-    dac_iface = es8311_read_reg(ES8311_SDPIN_REG09) & 0xBF;
-    adc_iface = es8311_read_reg(ES8311_SDPOUT_REG0A) & 0xBF;
-    adc_iface |= BIT(6);
-    dac_iface |= BIT(6);
-
-    if (mode == ES_MODULE_LINE) {
-        ESP_LOGE(TAG, "The codec es8311 doesn't support ES_MODULE_LINE mode");
-        return ESP_FAIL;
-    }
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        adc_iface &= ~(BIT(6));
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        dac_iface &= ~(BIT(6));
-    }
-
-    ret |= es8311_write_reg(ES8311_SDPIN_REG09, dac_iface);
-    ret |= es8311_write_reg(ES8311_SDPOUT_REG0A, adc_iface);
-
-    ret |= es8311_write_reg(ES8311_ADC_REG17, 0xBF);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG0E, 0x02);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG12, 0x00);
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG14, 0x1A);
-
-    /*
-     * pdm dmic enable or disable
-     */
-    int regv = 0;
-    if (IS_DMIC) {
-        regv = es8311_read_reg(ES8311_SYSTEM_REG14);
-        regv |= 0x40;
-        ret |= es8311_write_reg(ES8311_SYSTEM_REG14, regv);
-    } else {
-        regv = es8311_read_reg(ES8311_SYSTEM_REG14);
-        regv &= ~(0x40);
-        ret |= es8311_write_reg(ES8311_SYSTEM_REG14, regv);
-    }
-
-    ret |= es8311_write_reg(ES8311_SYSTEM_REG0D, 0x01);
-    ret |= es8311_write_reg(ES8311_ADC_REG15, 0x40);
-    ret |= es8311_write_reg(ES8311_DAC_REG37, 0x08);
-    ret |= es8311_write_reg(ES8311_GP_REG45, 0x00);
-
-    /* set internal reference signal (ADCL + DACR) */
-    ret |= es8311_write_reg(ES8311_GPIO_REG44, 0x58);
-
-    return ret;
-}
-
-esp_err_t es8311_stop(es_module_t mode)
-{
-    esp_err_t ret = ESP_OK;
-    es8311_suspend();
-    return ret;
-}
-
-/**
- * @brief Set voice volume
- *
- * @note Register values. 0x00: -95.5 dB, 0x5B: -50 dB, 0xBF: 0 dB, 0xFF: 32 dB
- * @note Accuracy of gain is 0.5 dB
- *
- * @param volume: voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_codec_set_voice_volume(int volume)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
-    res = es8311_write_reg(ES8311_DAC_REG32, reg);
-    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", dac_vol_handle->user_volume, reg,
-            audio_codec_cal_dac_volume(dac_vol_handle));
-    return res;
-}
-
-esp_err_t es8311_codec_get_voice_volume(int *volume)
-{
-    esp_err_t res = ESP_OK;
-    int regv = 0;
-    regv = es8311_read_reg(ES8311_DAC_REG32);
-    if (regv == ESP_FAIL) {
-        *volume = 0;
-        res = ESP_FAIL;
-    } else {
-        if (regv == dac_vol_handle->reg_value) {
-            *volume = dac_vol_handle->user_volume;
-        } else {
-            *volume = 0;
-            res = ESP_FAIL;
-        }
-    }
-    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, regv);
-    return res;
-}
-
-esp_err_t es8311_set_voice_mute(bool enable)
-{
-    ESP_LOGD(TAG, "Es8311SetVoiceMute volume:%d", enable);
-    es8311_mute(enable);
-    return ESP_OK;
-}
-
-esp_err_t es8311_get_voice_mute(int *mute)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    res = es8311_read_reg(ES8311_DAC_REG31);
-    if (res != ESP_FAIL) {
-        reg = (res & 0x20) >> 5;
-    }
-    *mute = reg;
-    return res;
-}
-
-esp_err_t es8311_set_mic_gain(es8311_mic_gain_t gain_db)
-{
-    esp_err_t res = ESP_OK;
-    res = es8311_write_reg(ES8311_ADC_REG16, gain_db); // MIC gain scale
-    return res;
-}
-
-void es8311_read_all()
-{
-    for (int i = 0; i < 0x4A; i++) {
-        uint8_t reg = es8311_read_reg(i);
-        ESP_LOGI(TAG, "REG:%02x, %02x", reg, i);
-    }
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "i2c_bus.h"
+#include "board.h"
+#include "esp_log.h"
+#include "es8311.h"
+#include "audio_volume.h"
+
+/* ES8311 address
+ * 0x32:CE=1;0x30:CE=0
+ */
+#define ES8311_ADDR         0x30
+
+/*
+ * to define the clock soure of MCLK
+ */
+#define FROM_MCLK_PIN       0
+#define FROM_SCLK_PIN       1
+
+/*
+ * to define whether to reverse the clock
+ */
+#define INVERT_MCLK         0 // do not invert
+#define INVERT_SCLK         0
+
+#define IS_DMIC             0 // Is it a digital microphone
+
+#define MCLK_DIV_FRE        256
+
+static i2c_bus_handle_t i2c_handle;
+static codec_dac_volume_config_t *dac_vol_handle;
+
+#define ES8311_DAC_VOL_CFG_DEFAULT() {                      \
+    .max_dac_volume = 32,                                   \
+    .min_dac_volume = -95.5,                                \
+    .board_pa_gain = BOARD_PA_GAIN,                         \
+    .volume_accuracy = 0.5,                                 \
+    .dac_vol_symbol = 1,                                    \
+    .zero_volume_reg = 0xBF,                                \
+    .reg_value = 0,                                         \
+    .user_volume = 0,                                       \
+    .offset_conv_volume = NULL,                             \
+}
+
+/*
+ * operate function of codec
+ */
+audio_hal_func_t AUDIO_CODEC_ES8311_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es8311_codec_init,
+    .audio_codec_deinitialize = es8311_codec_deinit,
+    .audio_codec_ctrl = es8311_codec_ctrl_state,
+    .audio_codec_config_iface = es8311_codec_config_i2s,
+    .audio_codec_set_mute = es8311_set_voice_mute,
+    .audio_codec_set_volume = es8311_codec_set_voice_volume,
+    .audio_codec_get_volume = es8311_codec_get_voice_volume,
+    .audio_codec_enable_pa = es8311_pa_power,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+/*
+ * Clock coefficient structer
+ */
+struct _coeff_div {
+    uint32_t mclk;        /* mclk frequency */
+    uint32_t rate;        /* sample rate */
+    uint8_t pre_div;      /* the pre divider with range from 1 to 8 */
+    uint8_t pre_multi;    /* the pre multiplier with x1, x2, x4 and x8 selection */
+    uint8_t adc_div;      /* adcclk divider */
+    uint8_t dac_div;      /* dacclk divider */
+    uint8_t fs_mode;      /* double speed or single speed, =0, ss, =1, ds */
+    uint8_t lrck_h;       /* adclrck divider and daclrck divider */
+    uint8_t lrck_l;
+    uint8_t bclk_div;     /* sclk divider */
+    uint8_t adc_osr;      /* adc osr */
+    uint8_t dac_osr;      /* dac osr */
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+    //mclk     rate   pre_div  mult  adc_div dac_div fs_mode lrch  lrcl  bckdiv osr
+    /* 8k */
+    {12288000, 8000 , 0x06, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {18432000, 8000 , 0x03, 0x02, 0x03, 0x03, 0x00, 0x05, 0xff, 0x18, 0x10, 0x20},
+    {16384000, 8000 , 0x08, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {8192000 , 8000 , 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {6144000 , 8000 , 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {4096000 , 8000 , 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {3072000 , 8000 , 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {2048000 , 8000 , 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {1536000 , 8000 , 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {1024000 , 8000 , 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+
+    /* 11.025k */
+    {11289600, 11025, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {5644800 , 11025, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {2822400 , 11025, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {1411200 , 11025, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+
+    /* 12k */
+    {12288000, 12000, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {6144000 , 12000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {3072000 , 12000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {1536000 , 12000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+
+    /* 16k */
+    {12288000, 16000, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {18432000, 16000, 0x03, 0x02, 0x03, 0x03, 0x00, 0x02, 0xff, 0x0c, 0x10, 0x20},
+    {16384000, 16000, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {8192000 , 16000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {6144000 , 16000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {4096000 , 16000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {3072000 , 16000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {2048000 , 16000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {1536000 , 16000, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+    {1024000 , 16000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x20},
+
+    /* 22.05k */
+    {11289600, 22050, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 22050, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 22050, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 22050, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 24k */
+    {12288000, 24000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 24000, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 24000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 24000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 24000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 32k */
+    {12288000, 32000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 32000, 0x03, 0x04, 0x03, 0x03, 0x00, 0x02, 0xff, 0x0c, 0x10, 0x10},
+    {16384000, 32000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {8192000 , 32000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 32000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {4096000 , 32000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 32000, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2048000 , 32000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 32000, 0x03, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+    {1024000 , 32000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 44.1k */
+    {11289600, 44100, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 44100, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 44100, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 44100, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 48k */
+    {12288000, 48000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 48000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 48000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 48000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 48000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 64k */
+    {12288000, 64000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 64000, 0x03, 0x04, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
+    {16384000, 64000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {8192000 , 64000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 64000, 0x01, 0x04, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
+    {4096000 , 64000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 64000, 0x01, 0x08, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
+    {2048000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0xbf, 0x03, 0x18, 0x18},
+    {1024000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+
+    /* 88.2k */
+    {11289600, 88200, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 88200, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 88200, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 88200, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+
+    /* 96k */
+    {12288000, 96000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 96000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 96000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 96000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 96000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+};
+
+static char *TAG = "DRV8311";
+
+#define ES_ASSERT(a, format, b, ...) \
+    if ((a) != 0) { \
+        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
+        return b;\
+    }
+
+int8_t get_es8311_mclk_src(void);
+
+static esp_err_t es8311_write_reg(uint8_t reg_addr, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, ES8311_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+}
+
+static int es8311_read_reg(uint8_t reg_addr)
+{
+    uint8_t data;
+    i2c_bus_read_bytes(i2c_handle, ES8311_ADDR, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+    return (int)data;
+}
+
+static int i2c_init()
+{
+    int res = 0;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000,
+    };
+    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    ES_ASSERT(res, "getting i2c pins error", -1);
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+/*
+* look for the coefficient in coeff_div[] table
+*/
+static int get_coeff(uint32_t mclk, uint32_t rate)
+{
+    for (int i = 0; i < (sizeof(coeff_div) / sizeof(coeff_div[0])); i++) {
+        if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+            return i;
+    }
+    return -1;
+}
+
+/*
+* set es8311 dac mute or not
+* if mute = 0, dac un-mute
+* if mute = 1, dac mute
+*/
+static void es8311_mute(int mute)
+{
+    uint8_t regv;
+    ESP_LOGI(TAG, "Enter into es8311_mute(), mute = %d\n", mute);
+    regv = es8311_read_reg(ES8311_DAC_REG31) & 0x9f;
+    if (mute) {
+        es8311_write_reg(ES8311_DAC_REG31, regv | 0x60);
+    } else {
+        es8311_write_reg(ES8311_DAC_REG31, regv);
+    }
+}
+
+/*
+* set es8311 into suspend mode
+*/
+static void es8311_suspend(void)
+{
+    ESP_LOGI(TAG, "Enter into es8311_suspend()");
+    es8311_write_reg(ES8311_DAC_REG32, 0x00);
+    es8311_write_reg(ES8311_ADC_REG17, 0x00);
+    es8311_write_reg(ES8311_SYSTEM_REG0E, 0xFF);
+    es8311_write_reg(ES8311_SYSTEM_REG12, 0x02);
+    es8311_write_reg(ES8311_SYSTEM_REG14, 0x00);
+    es8311_write_reg(ES8311_SYSTEM_REG0D, 0xFA);
+    es8311_write_reg(ES8311_ADC_REG15, 0x00);
+    es8311_write_reg(ES8311_GP_REG45, 0x01);
+}
+
+/*
+* enable pa power
+*/
+esp_err_t es8311_pa_power(bool enable)
+{
+    esp_err_t ret = ESP_OK;
+    if (enable) {
+        ret = gpio_set_level(get_pa_enable_gpio(), 1);
+    } else {
+        ret = gpio_set_level(get_pa_enable_gpio(), 0);
+    }
+    return ret;
+}
+
+esp_err_t es8311_codec_init(audio_hal_codec_config_t *codec_cfg)
+{
+    uint8_t datmp, regv;
+    int coeff;
+    esp_err_t ret = ESP_OK;
+    i2c_init(); // ESP32 in master mode
+
+    /* Enhance ES8311 I2C noise immunity */
+    ret |= es8311_write_reg(ES8311_GPIO_REG44, 0x08);
+    /* Due to occasional failures during the first I2C write with the ES8311 chip, a second write is performed to ensure reliability */
+    ret |= es8311_write_reg(ES8311_GPIO_REG44, 0x08);
+
+    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, 0x30);
+    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG02, 0x00);
+    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG03, 0x10);
+    ret |= es8311_write_reg(ES8311_ADC_REG16, 0x24);
+    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG04, 0x10);
+    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG05, 0x00);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG0B, 0x00);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG0C, 0x00);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG10, 0x1F);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG11, 0x7F);
+    ret |= es8311_write_reg(ES8311_RESET_REG00, 0x80);
+    /*
+     * Set Codec into Master or Slave mode
+     */
+    regv = es8311_read_reg(ES8311_RESET_REG00);
+    /*
+     * Set master/slave audio interface
+     */
+    audio_hal_codec_i2s_iface_t *i2s_cfg = &(codec_cfg->i2s_iface);
+    switch (i2s_cfg->mode) {
+        case AUDIO_HAL_MODE_MASTER:    /* MASTER MODE */
+            ESP_LOGI(TAG, "ES8311 in Master mode");
+            regv |= 0x40;
+            break;
+        case AUDIO_HAL_MODE_SLAVE:    /* SLAVE MODE */
+            ESP_LOGI(TAG, "ES8311 in Slave mode");
+            regv &= 0xBF;
+            break;
+        default:
+            regv &= 0xBF;
+    }
+    ret |= es8311_write_reg(ES8311_RESET_REG00, regv);
+    ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, 0x3F);
+    /*
+     * Select clock source for internal mclk
+     */
+    switch (get_es8311_mclk_src()) {
+        case FROM_MCLK_PIN:
+            regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
+            regv &= 0x7F;
+            ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
+            break;
+        case FROM_SCLK_PIN:
+            regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
+            regv |= 0x80;
+            ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
+            break;
+        default:
+            regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
+            regv &= 0x7F;
+            ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
+            break;
+    }
+    int sample_fre = 0;
+    int mclk_fre = 0;
+    switch (i2s_cfg->samples) {
+        case AUDIO_HAL_08K_SAMPLES:
+            sample_fre = 8000;
+            break;
+        case AUDIO_HAL_11K_SAMPLES:
+            sample_fre = 11025;
+            break;
+        case AUDIO_HAL_16K_SAMPLES:
+            sample_fre = 16000;
+            break;
+        case AUDIO_HAL_22K_SAMPLES:
+            sample_fre = 22050;
+            break;
+        case AUDIO_HAL_24K_SAMPLES:
+            sample_fre = 24000;
+            break;
+        case AUDIO_HAL_32K_SAMPLES:
+            sample_fre = 32000;
+            break;
+        case AUDIO_HAL_44K_SAMPLES:
+            sample_fre = 44100;
+            break;
+        case AUDIO_HAL_48K_SAMPLES:
+            sample_fre = 48000;
+            break;
+        default:
+            ESP_LOGE(TAG, "Unable to configure sample rate %dHz", sample_fre);
+            break;
+    }
+    mclk_fre = sample_fre * MCLK_DIV_FRE;
+    coeff = get_coeff(mclk_fre, sample_fre);
+    if (coeff < 0) {
+        ESP_LOGE(TAG, "Unable to configure sample rate %dHz with %dHz MCLK", sample_fre, mclk_fre);
+        return ESP_FAIL;
+    }
+    /*
+     * Set clock parammeters
+     */
+    if (coeff >= 0) {
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG02) & 0x07;
+        regv |= (coeff_div[coeff].pre_div - 1) << 5;
+        datmp = 0;
+        switch (coeff_div[coeff].pre_multi) {
+            case 1:
+                datmp = 0;
+                break;
+            case 2:
+                datmp = 1;
+                break;
+            case 4:
+                datmp = 2;
+                break;
+            case 8:
+                datmp = 3;
+                break;
+            default:
+                break;
+        }
+
+        if (get_es8311_mclk_src() == FROM_SCLK_PIN) {
+            datmp = 3;     /* DIG_MCLK = LRCK * 256 = BCLK * 8 */
+        }
+        regv |= (datmp) << 3;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG02, regv);
+
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG05) & 0x00;
+        regv |= (coeff_div[coeff].adc_div - 1) << 4;
+        regv |= (coeff_div[coeff].dac_div - 1) << 0;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG05, regv);
+
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG03) & 0x80;
+        regv |= coeff_div[coeff].fs_mode << 6;
+        regv |= coeff_div[coeff].adc_osr << 0;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG03, regv);
+
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG04) & 0x80;
+        regv |= coeff_div[coeff].dac_osr << 0;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG04, regv);
+
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG07) & 0xC0;
+        regv |= coeff_div[coeff].lrck_h << 0;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG07, regv);
+
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG08) & 0x00;
+        regv |= coeff_div[coeff].lrck_l << 0;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG08, regv);
+
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG06) & 0xE0;
+        if (coeff_div[coeff].bclk_div < 19) {
+            regv |= (coeff_div[coeff].bclk_div - 1) << 0;
+        } else {
+            regv |= (coeff_div[coeff].bclk_div) << 0;
+        }
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG06, regv);
+    }
+
+    /*
+     * mclk inverted or not
+     */
+    if (INVERT_MCLK) {
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
+        regv |= 0x40;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
+    } else {
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG01);
+        regv &= ~(0x40);
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG01, regv);
+    }
+    /*
+     * sclk inverted or not
+     */
+    if (INVERT_SCLK) {
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG06);
+        regv |= 0x20;
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG06, regv);
+    } else {
+        regv = es8311_read_reg(ES8311_CLK_MANAGER_REG06);
+        regv &= ~(0x20);
+        ret |= es8311_write_reg(ES8311_CLK_MANAGER_REG06, regv);
+    }
+
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG13, 0x10);
+    ret |= es8311_write_reg(ES8311_ADC_REG1B, 0x0A);
+    ret |= es8311_write_reg(ES8311_ADC_REG1C, 0x6A);
+    AUDIO_RET_ON_FALSE(TAG, ret, return ret, "es8311 initialize failed");
+
+    /* pa power gpio init */
+    gpio_config_t  io_conf;
+    memset(&io_conf, 0, sizeof(io_conf));
+    io_conf.mode = GPIO_MODE_OUTPUT;
+    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
+    io_conf.pull_down_en = 0;
+    io_conf.pull_up_en = 0;
+    gpio_config(&io_conf);
+    /* enable pa power */
+    es8311_pa_power(true);
+
+    codec_dac_volume_config_t vol_cfg = ES8311_DAC_VOL_CFG_DEFAULT();
+    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
+    return ESP_OK;
+}
+
+esp_err_t es8311_codec_deinit()
+{
+    i2c_bus_delete(i2c_handle);
+    audio_codec_volume_deinit(dac_vol_handle);
+    return ESP_OK;
+}
+
+esp_err_t es8311_config_fmt(es_i2s_fmt_t fmt)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t adc_iface = 0, dac_iface = 0;
+    dac_iface = es8311_read_reg(ES8311_SDPIN_REG09);
+    adc_iface = es8311_read_reg(ES8311_SDPOUT_REG0A);
+    switch (fmt) {
+        case AUDIO_HAL_I2S_NORMAL:
+            ESP_LOGD(TAG, "ES8311 in I2S Format");
+            dac_iface &= 0xFC;
+            adc_iface &= 0xFC;
+            break;
+        case AUDIO_HAL_I2S_LEFT:
+        case AUDIO_HAL_I2S_RIGHT:
+            ESP_LOGD(TAG, "ES8311 in LJ Format");
+            adc_iface &= 0xFC;
+            dac_iface &= 0xFC;
+            adc_iface |= 0x01;
+            dac_iface |= 0x01;
+            break;
+        case AUDIO_HAL_I2S_DSP:
+            ESP_LOGD(TAG, "ES8311 in DSP-A Format");
+            adc_iface &= 0xDC;
+            dac_iface &= 0xDC;
+            adc_iface |= 0x03;
+            dac_iface |= 0x03;
+            break;
+        default:
+            dac_iface &= 0xFC;
+            adc_iface &= 0xFC;
+            break;
+    }
+    ret |= es8311_write_reg(ES8311_SDPIN_REG09, dac_iface);
+    ret |= es8311_write_reg(ES8311_SDPOUT_REG0A, adc_iface);
+
+    return ret;
+}
+
+esp_err_t es8311_set_bits_per_sample(audio_hal_iface_bits_t bits)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t adc_iface = 0, dac_iface = 0;
+    dac_iface = es8311_read_reg(ES8311_SDPIN_REG09);
+    adc_iface = es8311_read_reg(ES8311_SDPOUT_REG0A);
+    switch (bits) {
+        case AUDIO_HAL_BIT_LENGTH_16BITS:
+            dac_iface |= 0x0c;
+            adc_iface |= 0x0c;
+            break;
+        case AUDIO_HAL_BIT_LENGTH_24BITS:
+            break;
+        case AUDIO_HAL_BIT_LENGTH_32BITS:
+            dac_iface |= 0x10;
+            adc_iface |= 0x10;
+            break;
+        default:
+            dac_iface |= 0x0c;
+            adc_iface |= 0x0c;
+            break;
+
+    }
+    ret |= es8311_write_reg(ES8311_SDPIN_REG09, dac_iface);
+    ret |= es8311_write_reg(ES8311_SDPOUT_REG0A, adc_iface);
+
+    return ret;
+}
+
+esp_err_t es8311_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    int ret = ESP_OK;
+    ret |= es8311_set_bits_per_sample(iface->bits);
+    ret |= es8311_config_fmt(iface->fmt);
+    return ret;
+}
+
+esp_err_t es8311_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    esp_err_t ret = ESP_OK;
+    es_module_t es_mode = ES_MODULE_MIN;
+
+    switch (mode) {
+        case AUDIO_HAL_CODEC_MODE_ENCODE:
+            es_mode  = ES_MODULE_ADC;
+            break;
+        case AUDIO_HAL_CODEC_MODE_LINE_IN:
+            es_mode  = ES_MODULE_LINE;
+            break;
+        case AUDIO_HAL_CODEC_MODE_DECODE:
+            es_mode  = ES_MODULE_DAC;
+            break;
+        case AUDIO_HAL_CODEC_MODE_BOTH:
+            es_mode  = ES_MODULE_ADC_DAC;
+            break;
+        default:
+            es_mode = ES_MODULE_DAC;
+            ESP_LOGW(TAG, "Codec mode not support, default is decode mode");
+            break;
+    }
+
+    if (ctrl_state == AUDIO_HAL_CTRL_START) {
+        ret |= es8311_start(es_mode);
+    } else {
+        ESP_LOGW(TAG, "The codec is about to stop");
+        ret |= es8311_stop(es_mode);
+    }
+
+    return ret;
+}
+
+esp_err_t es8311_start(es_module_t mode)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t adc_iface = 0, dac_iface = 0;
+
+    dac_iface = es8311_read_reg(ES8311_SDPIN_REG09) & 0xBF;
+    adc_iface = es8311_read_reg(ES8311_SDPOUT_REG0A) & 0xBF;
+    adc_iface |= BIT(6);
+    dac_iface |= BIT(6);
+
+    if (mode == ES_MODULE_LINE) {
+        ESP_LOGE(TAG, "The codec es8311 doesn't support ES_MODULE_LINE mode");
+        return ESP_FAIL;
+    }
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        adc_iface &= ~(BIT(6));
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        dac_iface &= ~(BIT(6));
+    }
+
+    ret |= es8311_write_reg(ES8311_SDPIN_REG09, dac_iface);
+    ret |= es8311_write_reg(ES8311_SDPOUT_REG0A, adc_iface);
+
+    ret |= es8311_write_reg(ES8311_ADC_REG17, 0xBF);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG0E, 0x02);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG12, 0x00);
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG14, 0x1A);
+
+    /*
+     * pdm dmic enable or disable
+     */
+    int regv = 0;
+    if (IS_DMIC) {
+        regv = es8311_read_reg(ES8311_SYSTEM_REG14);
+        regv |= 0x40;
+        ret |= es8311_write_reg(ES8311_SYSTEM_REG14, regv);
+    } else {
+        regv = es8311_read_reg(ES8311_SYSTEM_REG14);
+        regv &= ~(0x40);
+        ret |= es8311_write_reg(ES8311_SYSTEM_REG14, regv);
+    }
+
+    ret |= es8311_write_reg(ES8311_SYSTEM_REG0D, 0x01);
+    ret |= es8311_write_reg(ES8311_ADC_REG15, 0x40);
+    ret |= es8311_write_reg(ES8311_DAC_REG37, 0x08);
+    ret |= es8311_write_reg(ES8311_GP_REG45, 0x00);
+
+    /* set internal reference signal (ADCL + DACR) */
+    ret |= es8311_write_reg(ES8311_GPIO_REG44, 0x58);
+
+    return ret;
+}
+
+esp_err_t es8311_stop(es_module_t mode)
+{
+    esp_err_t ret = ESP_OK;
+    es8311_suspend();
+    return ret;
+}
+
+/**
+ * @brief Set voice volume
+ *
+ * @note Register values. 0x00: -95.5 dB, 0x5B: -50 dB, 0xBF: 0 dB, 0xFF: 32 dB
+ * @note Accuracy of gain is 0.5 dB
+ *
+ * @param volume: voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_codec_set_voice_volume(int volume)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
+    res = es8311_write_reg(ES8311_DAC_REG32, reg);
+    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", dac_vol_handle->user_volume, reg,
+            audio_codec_cal_dac_volume(dac_vol_handle));
+    return res;
+}
+
+esp_err_t es8311_codec_get_voice_volume(int *volume)
+{
+    esp_err_t res = ESP_OK;
+    int regv = 0;
+    regv = es8311_read_reg(ES8311_DAC_REG32);
+    if (regv == ESP_FAIL) {
+        *volume = 0;
+        res = ESP_FAIL;
+    } else {
+        if (regv == dac_vol_handle->reg_value) {
+            *volume = dac_vol_handle->user_volume;
+        } else {
+            *volume = 0;
+            res = ESP_FAIL;
+        }
+    }
+    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, regv);
+    return res;
+}
+
+esp_err_t es8311_set_voice_mute(bool enable)
+{
+    ESP_LOGD(TAG, "Es8311SetVoiceMute volume:%d", enable);
+    es8311_mute(enable);
+    return ESP_OK;
+}
+
+esp_err_t es8311_get_voice_mute(int *mute)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    res = es8311_read_reg(ES8311_DAC_REG31);
+    if (res != ESP_FAIL) {
+        reg = (res & 0x20) >> 5;
+    }
+    *mute = reg;
+    return res;
+}
+
+esp_err_t es8311_set_mic_gain(es8311_mic_gain_t gain_db)
+{
+    esp_err_t res = ESP_OK;
+    res = es8311_write_reg(ES8311_ADC_REG16, gain_db); // MIC gain scale
+    return res;
+}
+
+void es8311_read_all()
+{
+    for (int i = 0; i < 0x4A; i++) {
+        uint8_t reg = es8311_read_reg(i);
+        ESP_LOGI(TAG, "REG:%02x, %02x", reg, i);
+    }
+}
diff --git a/components/audio_hal/driver/es8311/es8311.h b/components/audio_hal/driver/es8311/es8311.h
index 26d4d7b8..5417e258 100644
--- a/components/audio_hal/driver/es8311/es8311.h
+++ b/components/audio_hal/driver/es8311/es8311.h
@@ -1,284 +1,284 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ES8311_H
-#define _ES8311_H
-
-#include "audio_hal.h"
-#include "esp_types.h"
-#include "esxxx_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- *   ES8311_REGISTER NAME_REG_REGISTER ADDRESS
- */
-#define ES8311_RESET_REG00              0x00  /*reset digital,csm,clock manager etc.*/
-
-/*
- * Clock Scheme Register definition
- */
-#define ES8311_CLK_MANAGER_REG01        0x01 /* select clk src for mclk, enable clock for codec */
-#define ES8311_CLK_MANAGER_REG02        0x02 /* clk divider and clk multiplier */
-#define ES8311_CLK_MANAGER_REG03        0x03 /* adc fsmode and osr  */
-#define ES8311_CLK_MANAGER_REG04        0x04 /* dac osr */
-#define ES8311_CLK_MANAGER_REG05        0x05 /* clk divier for adc and dac */
-#define ES8311_CLK_MANAGER_REG06        0x06 /* bclk inverter and divider */
-#define ES8311_CLK_MANAGER_REG07        0x07 /* tri-state, lrck divider */
-#define ES8311_CLK_MANAGER_REG08        0x08 /* lrck divider */
-/*
- * SDP
- */
-#define ES8311_SDPIN_REG09              0x09 /* dac serial digital port */
-#define ES8311_SDPOUT_REG0A             0x0A /* adc serial digital port */
-/*
- * SYSTEM
- */
-#define ES8311_SYSTEM_REG0B             0x0B /* system */
-#define ES8311_SYSTEM_REG0C             0x0C /* system */
-#define ES8311_SYSTEM_REG0D             0x0D /* system, power up/down */
-#define ES8311_SYSTEM_REG0E             0x0E /* system, power up/down */
-#define ES8311_SYSTEM_REG0F             0x0F /* system, low power */
-#define ES8311_SYSTEM_REG10             0x10 /* system */
-#define ES8311_SYSTEM_REG11             0x11 /* system */
-#define ES8311_SYSTEM_REG12             0x12 /* system, Enable DAC */
-#define ES8311_SYSTEM_REG13             0x13 /* system */
-#define ES8311_SYSTEM_REG14             0x14 /* system, select DMIC, select analog pga gain */
-/*
- * ADC
- */
-#define ES8311_ADC_REG15                0x15 /* ADC, adc ramp rate, dmic sense */
-#define ES8311_ADC_REG16                0x16 /* ADC */
-#define ES8311_ADC_REG17                0x17 /* ADC, volume */
-#define ES8311_ADC_REG18                0x18 /* ADC, alc enable and winsize */
-#define ES8311_ADC_REG19                0x19 /* ADC, alc maxlevel */
-#define ES8311_ADC_REG1A                0x1A /* ADC, alc automute */
-#define ES8311_ADC_REG1B                0x1B /* ADC, alc automute, adc hpf s1 */
-#define ES8311_ADC_REG1C                0x1C /* ADC, equalizer, hpf s2 */
-/*
- * DAC
- */
-#define ES8311_DAC_REG31                0x31 /* DAC, mute */
-#define ES8311_DAC_REG32                0x32 /* DAC, volume */
-#define ES8311_DAC_REG33                0x33 /* DAC, offset */
-#define ES8311_DAC_REG34                0x34 /* DAC, drc enable, drc winsize */
-#define ES8311_DAC_REG35                0x35 /* DAC, drc maxlevel, minilevel */
-#define ES8311_DAC_REG37                0x37 /* DAC, ramprate */
-/*
- *GPIO
- */
-#define ES8311_GPIO_REG44               0x44 /* GPIO, dac2adc for test */
-#define ES8311_GP_REG45                 0x45 /* GP CONTROL */
-/*
- * CHIP
- */
-#define ES8311_CHD1_REGFD               0xFD /* CHIP ID1 */
-#define ES8311_CHD2_REGFE               0xFE /* CHIP ID2 */
-#define ES8311_CHVER_REGFF              0xFF /* VERSION */
-#define ES8311_CHD1_REGFD               0xFD /* CHIP ID1 */
-
-#define ES8311_MAX_REGISTER             0xFF
-
-typedef enum {
-    ES8311_MIC_GAIN_MIN = -1,
-    ES8311_MIC_GAIN_0DB,
-    ES8311_MIC_GAIN_6DB,
-    ES8311_MIC_GAIN_12DB,
-    ES8311_MIC_GAIN_18DB,
-    ES8311_MIC_GAIN_24DB,
-    ES8311_MIC_GAIN_30DB,
-    ES8311_MIC_GAIN_36DB,
-    ES8311_MIC_GAIN_42DB,
-    ES8311_MIC_GAIN_MAX
-} es8311_mic_gain_t;
-
-/*
- * @brief Enables or disables PA
- *
- * @param enable     true/false
- *
- * @return
- *      - ESP_ERR_INVALID_ARG
- *      - ESP_OK
- */
-esp_err_t es8311_pa_power(bool enable);
-
-/*
- * @brief Initialize ES8311 codec chip
- *
- * @param codec_cfg  configuration of ES8311
- *
- * @return
- *      - ESP_OK
- *      - ESP_FAIL
- */
-esp_err_t es8311_codec_init(audio_hal_codec_config_t *codec_cfg);
-
-/**
- * @brief Deinitialize ES8311 codec chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_codec_deinit(void);
-
-/**
- * @brief Control ES8311 codec chip
- *
- * @param mode codec mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8311_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief Configure ES8311 codec mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8311_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief Configure ES8311 DAC mute or not. Basically you can use this function to mute the output or unmute
- *
- * @param enable enable(1) or disable(0)
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8311_set_voice_mute(bool enable);
-
-/**
- * @brief Set voice volume
- *
- * @param volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_codec_set_voice_volume(int volume);
-
-/**
- * @brief Get voice volume
- *
- * @param[out] *volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_codec_get_voice_volume(int *volume);
-
-/**
- * @brief Configure ES8311 I2S format
- *
- * @param mod:  set ADC or DAC or both
- * @param cfg:   ES8388 I2S format
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_config_fmt(es_i2s_fmt_t fmt);
-
-/**
- * @brief Configure ES8311 data sample bits
- *
- * @param mode:  set ADC or DAC or both
- * @param bit_per_sample:  bit number of per sample
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_set_bits_per_sample(audio_hal_iface_bits_t bits);
-
-/**
- * @brief  Start ES8311 codec chip
- *
- * @param mode:  set ADC or DAC or both
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_start(es_module_t mode);
-
-/**
- * @brief  Stop ES8311 codec chip
- *
- * @param mode:  set ADC or DAC or both
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8311_stop(es_module_t mode);
-
-/**
- * @brief Get ES8311 DAC mute status
- *
- * @return
- *     - ESP_FAIL
- *     - ESP_OK
- */
-esp_err_t es8311_get_voice_mute(int *mute);
-
-/**
- * @brief Set ES8311 mic gain
- *
- * @param gain db of mic gain
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8311_set_mic_gain(es8311_mic_gain_t gain_db);
-
-/**
- * @brief Print all ES8311 registers
- *
- * @return
- *     - void
- */
-void es8311_read_all();
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ES8311_H
+#define _ES8311_H
+
+#include "audio_hal.h"
+#include "esp_types.h"
+#include "esxxx_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *   ES8311_REGISTER NAME_REG_REGISTER ADDRESS
+ */
+#define ES8311_RESET_REG00              0x00  /*reset digital,csm,clock manager etc.*/
+
+/*
+ * Clock Scheme Register definition
+ */
+#define ES8311_CLK_MANAGER_REG01        0x01 /* select clk src for mclk, enable clock for codec */
+#define ES8311_CLK_MANAGER_REG02        0x02 /* clk divider and clk multiplier */
+#define ES8311_CLK_MANAGER_REG03        0x03 /* adc fsmode and osr  */
+#define ES8311_CLK_MANAGER_REG04        0x04 /* dac osr */
+#define ES8311_CLK_MANAGER_REG05        0x05 /* clk divier for adc and dac */
+#define ES8311_CLK_MANAGER_REG06        0x06 /* bclk inverter and divider */
+#define ES8311_CLK_MANAGER_REG07        0x07 /* tri-state, lrck divider */
+#define ES8311_CLK_MANAGER_REG08        0x08 /* lrck divider */
+/*
+ * SDP
+ */
+#define ES8311_SDPIN_REG09              0x09 /* dac serial digital port */
+#define ES8311_SDPOUT_REG0A             0x0A /* adc serial digital port */
+/*
+ * SYSTEM
+ */
+#define ES8311_SYSTEM_REG0B             0x0B /* system */
+#define ES8311_SYSTEM_REG0C             0x0C /* system */
+#define ES8311_SYSTEM_REG0D             0x0D /* system, power up/down */
+#define ES8311_SYSTEM_REG0E             0x0E /* system, power up/down */
+#define ES8311_SYSTEM_REG0F             0x0F /* system, low power */
+#define ES8311_SYSTEM_REG10             0x10 /* system */
+#define ES8311_SYSTEM_REG11             0x11 /* system */
+#define ES8311_SYSTEM_REG12             0x12 /* system, Enable DAC */
+#define ES8311_SYSTEM_REG13             0x13 /* system */
+#define ES8311_SYSTEM_REG14             0x14 /* system, select DMIC, select analog pga gain */
+/*
+ * ADC
+ */
+#define ES8311_ADC_REG15                0x15 /* ADC, adc ramp rate, dmic sense */
+#define ES8311_ADC_REG16                0x16 /* ADC */
+#define ES8311_ADC_REG17                0x17 /* ADC, volume */
+#define ES8311_ADC_REG18                0x18 /* ADC, alc enable and winsize */
+#define ES8311_ADC_REG19                0x19 /* ADC, alc maxlevel */
+#define ES8311_ADC_REG1A                0x1A /* ADC, alc automute */
+#define ES8311_ADC_REG1B                0x1B /* ADC, alc automute, adc hpf s1 */
+#define ES8311_ADC_REG1C                0x1C /* ADC, equalizer, hpf s2 */
+/*
+ * DAC
+ */
+#define ES8311_DAC_REG31                0x31 /* DAC, mute */
+#define ES8311_DAC_REG32                0x32 /* DAC, volume */
+#define ES8311_DAC_REG33                0x33 /* DAC, offset */
+#define ES8311_DAC_REG34                0x34 /* DAC, drc enable, drc winsize */
+#define ES8311_DAC_REG35                0x35 /* DAC, drc maxlevel, minilevel */
+#define ES8311_DAC_REG37                0x37 /* DAC, ramprate */
+/*
+ *GPIO
+ */
+#define ES8311_GPIO_REG44               0x44 /* GPIO, dac2adc for test */
+#define ES8311_GP_REG45                 0x45 /* GP CONTROL */
+/*
+ * CHIP
+ */
+#define ES8311_CHD1_REGFD               0xFD /* CHIP ID1 */
+#define ES8311_CHD2_REGFE               0xFE /* CHIP ID2 */
+#define ES8311_CHVER_REGFF              0xFF /* VERSION */
+#define ES8311_CHD1_REGFD               0xFD /* CHIP ID1 */
+
+#define ES8311_MAX_REGISTER             0xFF
+
+typedef enum {
+    ES8311_MIC_GAIN_MIN = -1,
+    ES8311_MIC_GAIN_0DB,
+    ES8311_MIC_GAIN_6DB,
+    ES8311_MIC_GAIN_12DB,
+    ES8311_MIC_GAIN_18DB,
+    ES8311_MIC_GAIN_24DB,
+    ES8311_MIC_GAIN_30DB,
+    ES8311_MIC_GAIN_36DB,
+    ES8311_MIC_GAIN_42DB,
+    ES8311_MIC_GAIN_MAX
+} es8311_mic_gain_t;
+
+/*
+ * @brief Enables or disables PA
+ *
+ * @param enable     true/false
+ *
+ * @return
+ *      - ESP_ERR_INVALID_ARG
+ *      - ESP_OK
+ */
+esp_err_t es8311_pa_power(bool enable);
+
+/*
+ * @brief Initialize ES8311 codec chip
+ *
+ * @param codec_cfg  configuration of ES8311
+ *
+ * @return
+ *      - ESP_OK
+ *      - ESP_FAIL
+ */
+esp_err_t es8311_codec_init(audio_hal_codec_config_t *codec_cfg);
+
+/**
+ * @brief Deinitialize ES8311 codec chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_codec_deinit(void);
+
+/**
+ * @brief Control ES8311 codec chip
+ *
+ * @param mode codec mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8311_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief Configure ES8311 codec mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8311_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief Configure ES8311 DAC mute or not. Basically you can use this function to mute the output or unmute
+ *
+ * @param enable enable(1) or disable(0)
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8311_set_voice_mute(bool enable);
+
+/**
+ * @brief Set voice volume
+ *
+ * @param volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_codec_set_voice_volume(int volume);
+
+/**
+ * @brief Get voice volume
+ *
+ * @param[out] *volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_codec_get_voice_volume(int *volume);
+
+/**
+ * @brief Configure ES8311 I2S format
+ *
+ * @param mod:  set ADC or DAC or both
+ * @param cfg:   ES8388 I2S format
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_config_fmt(es_i2s_fmt_t fmt);
+
+/**
+ * @brief Configure ES8311 data sample bits
+ *
+ * @param mode:  set ADC or DAC or both
+ * @param bit_per_sample:  bit number of per sample
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_set_bits_per_sample(audio_hal_iface_bits_t bits);
+
+/**
+ * @brief  Start ES8311 codec chip
+ *
+ * @param mode:  set ADC or DAC or both
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_start(es_module_t mode);
+
+/**
+ * @brief  Stop ES8311 codec chip
+ *
+ * @param mode:  set ADC or DAC or both
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8311_stop(es_module_t mode);
+
+/**
+ * @brief Get ES8311 DAC mute status
+ *
+ * @return
+ *     - ESP_FAIL
+ *     - ESP_OK
+ */
+esp_err_t es8311_get_voice_mute(int *mute);
+
+/**
+ * @brief Set ES8311 mic gain
+ *
+ * @param gain db of mic gain
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8311_set_mic_gain(es8311_mic_gain_t gain_db);
+
+/**
+ * @brief Print all ES8311 registers
+ *
+ * @return
+ *     - void
+ */
+void es8311_read_all();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/es8374/es8374.c b/components/audio_hal/driver/es8374/es8374.c
old mode 100755
new mode 100644
index 15c62cef..3b0f4728
--- a/components/audio_hal/driver/es8374/es8374.c
+++ b/components/audio_hal/driver/es8374/es8374.c
@@ -1,811 +1,811 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_system.h"
-#include "esp_log.h"
-#include "i2c_bus.h"
-#include "es8374.h"
-#include "board_pins_config.h"
-
-#define ES8374_TAG "ES8374_DRIVER"
-
-#define ES_ASSERT(a, format, b, ...) \
-    if ((a) != 0) { \
-        ESP_LOGE(ES8374_TAG, format, ##__VA_ARGS__); \
-        return b;\
-    }
-
-#define LOG_8374(fmt, ...)   ESP_LOGW(ES8374_TAG, fmt, ##__VA_ARGS__)
-
-static int codec_init_flag = 0;
-static i2c_bus_handle_t i2c_handle;
-
-audio_hal_func_t AUDIO_CODEC_ES8374_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es8374_codec_init,
-    .audio_codec_deinitialize = es8374_codec_deinit,
-    .audio_codec_ctrl = es8374_codec_ctrl_state,
-    .audio_codec_config_iface = es8374_codec_config_i2s,
-    .audio_codec_set_mute = es8374_set_voice_mute,
-    .audio_codec_set_volume = es8374_codec_set_voice_volume,
-    .audio_codec_get_volume = es8374_codec_get_voice_volume,
-    .audio_codec_enable_pa = es8374_pa_power,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static bool es8374_codec_initialized()
-{
-    return codec_init_flag;
-}
-
-static esp_err_t es_write_reg(uint8_t slave_addr, uint8_t reg_add, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, slave_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
-}
-
-static esp_err_t es_read_reg(uint8_t slave_addr, uint8_t reg_add, uint8_t *p_data)
-{
-    return i2c_bus_read_bytes(i2c_handle, slave_addr, &reg_add, sizeof(reg_add), p_data, 1);
-}
-
-static int i2c_init()
-{
-    int res;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000
-    };
-    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    ES_ASSERT(res, "getting i2c pins error", -1);
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-esp_err_t es8374_write_reg(uint8_t reg_add, uint8_t data)
-{
-    return es_write_reg(ES8374_ADDR, reg_add, data);
-}
-
-int es8374_read_reg(uint8_t reg_add, uint8_t *regv)
-{
-    uint8_t regdata = 0xFF;
-    uint8_t res = 0;
-
-    if (es_read_reg(ES8374_ADDR, reg_add, &regdata) == 0) {
-        *regv = regdata;
-        return res;
-    } else {
-        LOG_8374("Read Audio Codec Register Failed!");
-        res = -1;
-        return res;
-    }
-}
-
-void es8374_read_all()
-{
-    for (int i = 0; i < 50; i++) {
-        uint8_t reg = 0;
-        es8374_read_reg(i, &reg);
-        ESP_LOGI(ES8374_TAG, "%x: %x", i, reg);
-    }
-}
-
-esp_err_t es8374_set_voice_mute(bool enable)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    res |= es8374_read_reg(0x36, &reg);
-    if (res == 0) {
-        reg = reg & 0xdf;
-        res |= es8374_write_reg(0x36, reg | (((int)enable) << 5));
-    }
-
-    return res;
-}
-
-esp_err_t es8374_get_voice_mute(void)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    res |= es8374_read_reg(0x36, &reg);
-    if (res == ESP_OK) {
-        reg = reg & 0x40;
-    }
-
-    return res == ESP_OK ? reg : res;
-}
-
-esp_err_t es8374_set_bits_per_sample(es_module_t mode, es_bits_length_t bit_per_sample)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    int bits = (int)bit_per_sample & 0x0f;
-
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_read_reg(0x10, &reg);
-        if (res == 0) {
-            reg = reg & 0xe3;
-            res |=  es8374_write_reg(0x10, reg | (bits << 2));
-        }
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_read_reg(0x11, &reg);
-        if (res == 0) {
-            reg = reg & 0xe3;
-            res |= es8374_write_reg(0x11, reg | (bits << 2));
-        }
-    }
-
-    return res;
-}
-
-esp_err_t es8374_config_fmt(es_module_t mode, es_i2s_fmt_t fmt)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    int fmt_tmp, fmt_i2s;
-
-    fmt_tmp = ((fmt & 0xf0) >> 4);
-    fmt_i2s =  fmt & 0x0f;
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_read_reg(0x10, &reg);
-        if (res == 0) {
-            reg = reg & 0xfc;
-            res |= es8374_write_reg(0x10, reg | fmt_i2s);
-            res |= es8374_set_bits_per_sample(mode, fmt_tmp);
-        }
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_read_reg(0x11, &reg);
-        if (res == 0) {
-            reg = reg & 0xfc;
-            res |= es8374_write_reg(0x11, reg | (fmt_i2s));
-            res |= es8374_set_bits_per_sample(mode, fmt_tmp);
-        }
-    }
-
-    return res;
-}
-
-esp_err_t es8374_start(es_module_t mode)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    if (mode == ES_MODULE_LINE) {
-        res |= es8374_read_reg(0x1a, &reg);       //set monomixer
-        reg |= 0x60;
-        reg |= 0x20;
-        reg &= 0xf7;
-        res |= es8374_write_reg( 0x1a, reg);
-        res |= es8374_read_reg(0x1c, &reg);        // set spk mixer
-        reg |= 0x40;
-        res |= es8374_write_reg( 0x1c, reg);
-        res |= es8374_write_reg(0x1D, 0x02);      // spk set
-        res |= es8374_write_reg(0x1F, 0x00);      // spk set
-        res |= es8374_write_reg(0x1E, 0xA0);      // spk on
-    }
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
-        res |= es8374_read_reg(0x21, &reg);       //power up adc and input
-        reg &= 0x3f;
-        res |= es8374_write_reg(0x21, reg);
-        res |= es8374_read_reg(0x10, &reg);       //power up adc and input
-        reg &= 0x3f;
-        res |= es8374_write_reg(0x10, reg);
-    }
-
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
-        res |= es8374_read_reg(0x1a, &reg);       //disable lout
-        reg |= 0x08;
-        res |= es8374_write_reg( 0x1a, reg);
-        reg &= 0xdf;
-        res |= es8374_write_reg( 0x1a, reg);
-        res |= es8374_write_reg(0x1D, 0x12);      // mute speaker
-        res |= es8374_write_reg(0x1E, 0x20);      // disable class d
-        res |= es8374_read_reg(0x15, &reg);        //power up dac
-        reg &= 0xdf;
-        res |= es8374_write_reg(0x15, reg);
-        res |= es8374_read_reg(0x1a, &reg);        //disable lout
-        reg |= 0x20;
-        res |= es8374_write_reg( 0x1a, reg);
-        reg &= 0xf7;
-        res |= es8374_write_reg( 0x1a, reg);
-        res |= es8374_write_reg(0x1D, 0x02);      // mute speaker
-        res |= es8374_write_reg(0x1E, 0xa0);      // disable class d
-
-        res |= es8374_set_voice_mute(false);
-    }
-
-    return res;
-}
-
-esp_err_t es8374_stop(es_module_t mode)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    if (mode == ES_MODULE_LINE) {
-        res |= es8374_read_reg(0x1a, &reg);       //disable lout
-        reg |= 0x08;
-        res |= es8374_write_reg( 0x1a, reg);
-        reg &= 0x9f;
-        res |= es8374_write_reg( 0x1a, reg);
-        res |= es8374_write_reg(0x1D, 0x12);      // mute speaker
-        res |= es8374_write_reg(0x1E, 0x20);      // disable class d
-        res |= es8374_read_reg(0x1c, &reg);        // disable spkmixer
-        reg &= 0xbf;
-        res |= es8374_write_reg( 0x1c, reg);
-        res |= es8374_write_reg(0x1F, 0x00);      // spk set
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_set_voice_mute(true);
-
-        res |= es8374_read_reg(0x1a, &reg);        //disable lout
-        reg |= 0x08;
-        res |= es8374_write_reg( 0x1a, reg);
-        reg &= 0xdf;
-        res |= es8374_write_reg( 0x1a, reg);
-        res |= es8374_write_reg(0x1D, 0x12);      // mute speaker
-        res |= es8374_write_reg(0x1E, 0x20);      // disable class d
-        res |= es8374_read_reg(0x15, &reg);        //power up dac
-        reg |= 0x20;
-        res |= es8374_write_reg(0x15, reg);
-    }
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-
-        res |= es8374_read_reg(0x10, &reg);       //power up adc and input
-        reg |= 0xc0;
-        res |= es8374_write_reg(0x10, reg);
-        res |= es8374_read_reg(0x21, &reg);       //power up adc and input
-        reg |= 0xc0;
-        res |= es8374_write_reg(0x21, reg);
-    }
-
-    return res;
-}
-
-esp_err_t es8374_i2s_config_clock(es_i2s_clock_t cfg)
-{
-
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    res |= es8374_read_reg(0x0f, &reg);       //power up adc and input
-    reg &= 0xe0;
-    int divratio = 0;
-    switch (cfg.sclk_div) {
-        case MCLK_DIV_1:
-            divratio = 1;
-            break;
-        case MCLK_DIV_2: // = 2,
-            divratio = 2;
-            break;
-        case MCLK_DIV_3: // = 3,
-            divratio = 3;
-            break;
-        case MCLK_DIV_4: // = 4,
-            divratio = 4;
-            break;
-        case MCLK_DIV_5: // = 20,
-            divratio = 5;
-            break;
-        case MCLK_DIV_6: // = 5,
-            divratio = 6;
-            break;
-        case MCLK_DIV_7: //  = 29,
-            divratio = 7;
-            break;
-        case MCLK_DIV_8: // = 6,
-            divratio = 8;
-            break;
-        case MCLK_DIV_9: // = 7,
-            divratio = 9;
-            break;
-        case MCLK_DIV_10: // = 21,
-            divratio = 10;
-            break;
-        case MCLK_DIV_11: // = 8,
-            divratio = 11;
-            break;
-        case MCLK_DIV_12: // = 9,
-            divratio = 12;
-            break;
-        case MCLK_DIV_13: // = 30,
-            divratio = 13;
-            break;
-        case MCLK_DIV_14: // = 31
-            divratio = 14;
-            break;
-        case MCLK_DIV_15: // = 22,
-            divratio = 15;
-            break;
-        case MCLK_DIV_16: // = 10,
-            divratio = 16;
-            break;
-        case MCLK_DIV_17: // = 23,
-            divratio = 17;
-            break;
-        case MCLK_DIV_18: // = 11,
-            divratio = 18;
-            break;
-        case MCLK_DIV_20: // = 24,
-            divratio = 19;
-            break;
-        case MCLK_DIV_22: // = 12,
-            divratio = 20;
-            break;
-        case MCLK_DIV_24: // = 13,
-            divratio = 21;
-            break;
-        case MCLK_DIV_25: // = 25,
-            divratio = 22;
-            break;
-        case MCLK_DIV_30: // = 26,
-            divratio = 23;
-            break;
-        case MCLK_DIV_32: // = 27,
-            divratio = 24;
-            break;
-        case MCLK_DIV_33: // = 14,
-            divratio = 25;
-            break;
-        case MCLK_DIV_34: // = 28,
-            divratio = 26;
-            break;
-        case MCLK_DIV_36: // = 15,
-            divratio = 27;
-            break;
-        case MCLK_DIV_44: // = 16,
-            divratio = 28;
-            break;
-        case MCLK_DIV_48: // = 17,
-            divratio = 29;
-            break;
-        case MCLK_DIV_66: // = 18,
-            divratio = 30;
-            break;
-        case MCLK_DIV_72: // = 19,
-            divratio = 31;
-            break;
-        default:
-            break;
-    }
-    reg |= divratio;
-    res |= es8374_write_reg(0x0f, reg);
-
-    int dacratio_l = 0;
-    int dacratio_h = 0;
-
-    switch (cfg.lclk_div) {
-        case LCLK_DIV_128:
-            dacratio_l = 128 % 256;
-            dacratio_h = 128 / 256;
-            break;
-        case LCLK_DIV_192:
-            dacratio_l = 192 % 256;
-            dacratio_h = 192 / 256;
-            break;
-        case LCLK_DIV_256:
-            dacratio_l = 256 % 256;
-            dacratio_h = 256 / 256;
-            break;
-        case LCLK_DIV_384:
-            dacratio_l = 384 % 256;
-            dacratio_h = 384 / 256;
-            break;
-        case LCLK_DIV_512:
-            dacratio_l = 512 % 256;
-            dacratio_h = 512 / 256;
-            break;
-        case LCLK_DIV_576:
-            dacratio_l = 576 % 256;
-            dacratio_h = 576 / 256;
-            break;
-        case LCLK_DIV_768:
-            dacratio_l = 768 % 256;
-            dacratio_h = 768 / 256;
-            break;
-        case LCLK_DIV_1024:
-            dacratio_l = 1024 % 256;
-            dacratio_h = 1024 / 256;
-            break;
-        case LCLK_DIV_1152:
-            dacratio_l = 1152 % 256;
-            dacratio_h = 1152 / 256;
-            break;
-        case LCLK_DIV_1408:
-            dacratio_l = 1408 % 256;
-            dacratio_h = 1408 / 256;
-            break;
-        case LCLK_DIV_1536:
-            dacratio_l = 1536 % 256;
-            dacratio_h = 1536 / 256;
-            break;
-        case LCLK_DIV_2112:
-            dacratio_l = 2112 % 256;
-            dacratio_h = 2112 / 256;
-            break;
-        case LCLK_DIV_2304:
-            dacratio_l = 2304 % 256;
-            dacratio_h = 2304 / 256;
-            break;
-        case LCLK_DIV_125:
-            dacratio_l = 125 % 256;
-            dacratio_h = 125 / 256;
-            break;
-        case LCLK_DIV_136:
-            dacratio_l = 136 % 256;
-            dacratio_h = 136 / 256;
-            break;
-        case LCLK_DIV_250:
-            dacratio_l = 250 % 256;
-            dacratio_h = 250 / 256;
-            break;
-        case LCLK_DIV_272:
-            dacratio_l = 272 % 256;
-            dacratio_h = 272 / 256;
-            break;
-        case LCLK_DIV_375:
-            dacratio_l = 375 % 256;
-            dacratio_h = 375 / 256;
-            break;
-        case LCLK_DIV_500:
-            dacratio_l = 500 % 256;
-            dacratio_h = 500 / 256;
-            break;
-        case LCLK_DIV_544:
-            dacratio_l = 544 % 256;
-            dacratio_h = 544 / 256;
-            break;
-        case LCLK_DIV_750:
-            dacratio_l = 750 % 256;
-            dacratio_h = 750 / 256;
-            break;
-        case LCLK_DIV_1000:
-            dacratio_l = 1000 % 256;
-            dacratio_h = 1000 / 256;
-            break;
-        case LCLK_DIV_1088:
-            dacratio_l = 1088 % 256;
-            dacratio_h = 1088 / 256;
-            break;
-        case LCLK_DIV_1496:
-            dacratio_l = 1496 % 256;
-            dacratio_h = 1496 / 256;
-            break;
-        case LCLK_DIV_1500:
-            dacratio_l = 1500 % 256;
-            dacratio_h = 1500 / 256;
-            break;
-        default:
-            break;
-    }
-    res |= es8374_write_reg( 0x06, dacratio_h);  //ADCFsMode,singel SPEED,RATIO=256
-    res |= es8374_write_reg( 0x07, dacratio_l);  //ADCFsMode,singel SPEED,RATIO=256
-
-    return res;
-}
-
-esp_err_t es8374_config_dac_output(es_dac_output_t output)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    reg = 0x1d;
-
-    res = es8374_write_reg(reg, 0x02);
-    res |= es8374_read_reg(0x1c, &reg); // set spk mixer
-    reg |= 0x80;
-    res |= es8374_write_reg(0x1c, reg);
-    res |= es8374_write_reg(0x1D, 0x02); // spk set
-    res |= es8374_write_reg(0x1F, 0x00); // spk set
-    res |= es8374_write_reg(0x1E, 0xA0); // spk on
-
-    return res;
-}
-
-esp_err_t es8374_config_adc_input(es_adc_input_t input)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-
-    res |= es8374_read_reg(0x21, &reg);
-    if (res == 0) {
-        reg = (reg & 0xcf) | 0x14;
-        res |= es8374_write_reg( 0x21, reg);
-    }
-
-    return res;
-}
-
-esp_err_t es8374_set_mic_gain(es_mic_gain_t gain)
-{
-    esp_err_t res = ESP_OK;
-
-    if (gain > MIC_GAIN_MIN && gain < MIC_GAIN_24DB) {
-        int gain_n = 0;
-        gain_n = (int)gain / 3;
-        res = es8374_write_reg(0x22, gain_n | (gain_n << 4)); //MIC PGA
-    } else {
-        res = -1;
-        LOG_8374("invalid microphone gain!");
-    }
-
-    return res;
-}
-
-esp_err_t es8374_codec_set_voice_volume(int volume)
-{
-    esp_err_t res = ESP_OK;
-
-    if (volume < 0) {
-        volume = 192;
-    } else if (volume > 96) {
-        volume = 0;
-    } else {
-        volume = 192 - volume * 2;
-    }
-
-    res = es8374_write_reg(0x38, volume);
-
-    return res;
-}
-
-esp_err_t es8374_codec_get_voice_volume(int *volume)
-{
-    esp_err_t res = 0;
-    uint8_t reg = 0;
-
-    res = es8374_read_reg(0x38, &reg);
-
-    if (res == ESP_FAIL) {
-        *volume = 0;
-    } else {
-        *volume = (192 - reg) / 2;
-        if (*volume > 96) {
-            *volume = 100;
-        }
-    }
-
-    return res;
-}
-
-static int es8374_set_adc_dac_volume(int mode, int volume, int dot)
-{
-    int res = 0;
-
-    if ( volume < -96 || volume > 0 ) {
-        LOG_8374("Warning: volume < -96! or > 0!");
-        if (volume < -96) {
-            volume = -96;
-        } else {
-            volume = 0;
-        }
-    }
-    dot = (dot >= 5 ? 1 : 0);
-    volume = (-volume << 1) + dot;
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_write_reg(0x25, volume);
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res |= es8374_write_reg(0x38, volume);
-    }
-
-    return res;
-}
-
-static int es8374_set_d2se_pga(es_d2se_pga_t gain)
-{
-    int res = 0;
-    uint8_t reg = 0;
-
-    if (gain > D2SE_PGA_GAIN_MIN && gain < D2SE_PGA_GAIN_MAX) {
-        res = es8374_read_reg(0x21, &reg);
-        reg &= 0xfb;
-        reg |= gain << 2;
-        res |= es8374_write_reg(0x21, reg); //MIC PGA
-    } else {
-        res = 0xff;
-        LOG_8374("invalid microphone gain!");
-    }
-
-    return res;
-}
-
-static int es8374_init_reg(audio_hal_codec_mode_t ms_mode, es_i2s_fmt_t fmt, es_i2s_clock_t cfg, es_dac_output_t out_channel, es_adc_input_t in_channel)
-{
-    int res = 0;
-    uint8_t reg = 0;
-
-    res |= es8374_write_reg(0x00, 0x3F); //IC Rst start
-    res |= es8374_write_reg(0x00, 0x03); //IC Rst stop
-    res |= es8374_write_reg(0x01, 0x7F); //IC clk on
-
-    res |= es8374_read_reg(0x0F, &reg);
-    reg &= 0x7f;
-    reg |=  (ms_mode << 7);
-    res |= es8374_write_reg( 0x0f, reg); //CODEC IN I2S SLAVE MODE
-
-    res |= es8374_write_reg(0x6F, 0xA0); //pll set:mode enable
-    res |= es8374_write_reg(0x72, 0x41); //pll set:mode set
-    res |= es8374_write_reg(0x09, 0x01); //pll set:reset on ,set start
-    res |= es8374_write_reg(0x0C, 0x22); //pll set:k
-    res |= es8374_write_reg(0x0D, 0x2E); //pll set:k
-    res |= es8374_write_reg(0x0E, 0xC6); //pll set:k
-    res |= es8374_write_reg(0x0A, 0x3A); //pll set:
-    res |= es8374_write_reg(0x0B, 0x07); //pll set:n
-    res |= es8374_write_reg(0x09, 0x41); //pll set:reset off ,set stop
-
-    res |= es8374_i2s_config_clock(cfg);
-
-    res |= es8374_write_reg(0x24, 0x08); //adc set
-    res |= es8374_write_reg(0x36, 0x00); //dac set
-    res |= es8374_write_reg(0x12, 0x30); //timming set
-    res |= es8374_write_reg(0x13, 0x20); //timming set
-
-    res |= es8374_config_fmt(ES_MODULE_ADC, fmt);
-    res |= es8374_config_fmt(ES_MODULE_DAC, fmt);
-
-    res |= es8374_write_reg(0x21, 0x50); //adc set: SEL LIN1 CH+PGAGAIN=0DB
-    res |= es8374_write_reg(0x22, 0xFF); //adc set: PGA GAIN=0DB
-    res |= es8374_write_reg(0x21, 0x14); //adc set: SEL LIN1 CH+PGAGAIN=18DB
-    res |= es8374_write_reg(0x22, 0x55); //pga = +15db
-    res |= es8374_write_reg(0x08, 0x21); //set class d divider = 33, to avoid the high frequency tone on laudspeaker
-    res |= es8374_write_reg(0x00, 0x80); // IC START
-
-    res |= es8374_set_adc_dac_volume(ES_MODULE_ADC, 0, 0);      // 0db
-    res |= es8374_set_adc_dac_volume(ES_MODULE_DAC, 0, 0);      // 0db
-
-    res |= es8374_write_reg(0x14, 0x8A); // IC START
-    res |= es8374_write_reg(0x15, 0x40); // IC START
-    res |= es8374_write_reg(0x1A, 0xA0); // monoout set
-    res |= es8374_write_reg(0x1B, 0x19); // monoout set
-    res |= es8374_write_reg(0x1C, 0x90); // spk set
-    res |= es8374_write_reg(0x1D, 0x01); // spk set
-    res |= es8374_write_reg(0x1F, 0x00); // spk set
-    res |= es8374_write_reg(0x1E, 0x20); // spk on
-    res |= es8374_write_reg(0x28, 0x00); // alc set
-    res |= es8374_write_reg(0x25, 0x00); // ADCVOLUME on
-    res |= es8374_write_reg(0x38, 0x00); // DACVOLUME on
-    res |= es8374_write_reg(0x37, 0x30); // dac set
-    res |= es8374_write_reg(0x6D, 0x60); //SEL:GPIO1=DMIC CLK OUT+SEL:GPIO2=PLL CLK OUT
-    res |= es8374_write_reg(0x71, 0x05); //for automute setting
-    res |= es8374_write_reg(0x73, 0x70);
-
-    res |= es8374_config_dac_output(out_channel);  //0x3c Enable DAC and Enable Lout/Rout/1/2
-    res |= es8374_config_adc_input(in_channel);  //0x00 LINSEL & RINSEL, LIN1/RIN1 as ADC Input; DSSEL,use one DS Reg11; DSR, LINPUT1-RINPUT1
-    res |= es8374_codec_set_voice_volume(0);
-
-    res |= es8374_write_reg(0x37, 0x00); // dac set
-
-    return res;
-}
-
-esp_err_t es8374_codec_init(audio_hal_codec_config_t *cfg)
-{
-    if (es8374_codec_initialized()) {
-        ESP_LOGW(ES8374_TAG, "The es8374 codec has already been initialized!");
-        return ESP_FAIL;
-    }
-    esp_err_t res = ESP_OK;
-    es_i2s_clock_t clkdiv;
-
-    clkdiv.lclk_div = LCLK_DIV_256;
-    clkdiv.sclk_div = MCLK_DIV_4;
-
-    i2c_init(); // ESP32 in master mode
-
-    res |= es8374_stop(cfg->codec_mode);
-    res |= es8374_init_reg(cfg->i2s_iface.mode, (BIT_LENGTH_16BITS << 4) | cfg->i2s_iface.fmt, clkdiv,
-                           cfg->dac_output, cfg->adc_input);
-    res |= es8374_set_mic_gain(MIC_GAIN_15DB);
-    res |= es8374_set_d2se_pga(D2SE_PGA_GAIN_EN);
-    res |= es8374_config_fmt(cfg->codec_mode, cfg->i2s_iface.fmt);
-    res |= es8374_codec_config_i2s(cfg->codec_mode, &(cfg->i2s_iface));
-    codec_init_flag = 1;
-    return res;
-}
-
-esp_err_t es8374_codec_deinit(void)
-{
-    if (!es8374_codec_initialized()) {
-        ESP_LOGW(ES8374_TAG, "The es8374 codec has already been deinit!");
-        return ESP_FAIL;
-    }
-    esp_err_t res = ESP_OK;
-    codec_init_flag = 0;
-    res = es8374_write_reg(0x00, 0x7F); // IC Reset and STOP
-    res |= i2c_bus_delete(i2c_handle);
-    return res;
-}
-
-esp_err_t es8374_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    esp_err_t res = ESP_OK;
-    int tmp = 0;
-    res |= es8374_config_fmt(ES_MODULE_ADC_DAC, iface->fmt);
-    if (iface->bits == AUDIO_HAL_BIT_LENGTH_16BITS) {
-        tmp = BIT_LENGTH_16BITS;
-    } else if (iface->bits == AUDIO_HAL_BIT_LENGTH_24BITS) {
-        tmp = BIT_LENGTH_24BITS;
-    } else {
-        tmp = BIT_LENGTH_32BITS;
-    }
-    res |= es8374_set_bits_per_sample(ES_MODULE_ADC_DAC, tmp);
-    return res;
-}
-
-esp_err_t es8374_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    esp_err_t res = ESP_OK;
-    int es_mode_t = 0;
-    switch (mode) {
-        case AUDIO_HAL_CODEC_MODE_ENCODE:
-            es_mode_t  = ES_MODULE_ADC;
-            break;
-        case AUDIO_HAL_CODEC_MODE_LINE_IN:
-            es_mode_t  = ES_MODULE_LINE;
-            break;
-        case AUDIO_HAL_CODEC_MODE_DECODE:
-            es_mode_t  = ES_MODULE_DAC;
-            break;
-        case AUDIO_HAL_CODEC_MODE_BOTH:
-            es_mode_t  = ES_MODULE_ADC_DAC;
-            break;
-        default:
-            es_mode_t = ES_MODULE_DAC;
-            ESP_LOGW(ES8374_TAG, "Codec mode not support, default is decode mode");
-            break;
-    }
-    if (AUDIO_HAL_CTRL_STOP == ctrl_state) {
-        res = es8374_stop(es_mode_t);
-    } else {
-        res = es8374_start(es_mode_t);
-        ESP_LOGD(ES8374_TAG, "start default is decode mode:%d", es_mode_t);
-    }
-    return res;
-}
-
-esp_err_t es8374_pa_power(bool enable)
-{
-    esp_err_t ret = ESP_OK;
-    gpio_config_t  io_conf;
-    memset(&io_conf, 0, sizeof(io_conf));
-    io_conf.mode = GPIO_MODE_OUTPUT;
-    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
-    io_conf.pull_down_en = 0;
-    io_conf.pull_up_en = 0;
-    gpio_config(&io_conf);
-    if (enable) {
-        ret = gpio_set_level(get_pa_enable_gpio(), 1);
-    } else {
-        ret = gpio_set_level(get_pa_enable_gpio(), 0);
-    }
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_system.h"
+#include "esp_log.h"
+#include "i2c_bus.h"
+#include "es8374.h"
+#include "board_pins_config.h"
+
+#define ES8374_TAG "ES8374_DRIVER"
+
+#define ES_ASSERT(a, format, b, ...) \
+    if ((a) != 0) { \
+        ESP_LOGE(ES8374_TAG, format, ##__VA_ARGS__); \
+        return b;\
+    }
+
+#define LOG_8374(fmt, ...)   ESP_LOGW(ES8374_TAG, fmt, ##__VA_ARGS__)
+
+static int codec_init_flag = 0;
+static i2c_bus_handle_t i2c_handle;
+
+audio_hal_func_t AUDIO_CODEC_ES8374_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es8374_codec_init,
+    .audio_codec_deinitialize = es8374_codec_deinit,
+    .audio_codec_ctrl = es8374_codec_ctrl_state,
+    .audio_codec_config_iface = es8374_codec_config_i2s,
+    .audio_codec_set_mute = es8374_set_voice_mute,
+    .audio_codec_set_volume = es8374_codec_set_voice_volume,
+    .audio_codec_get_volume = es8374_codec_get_voice_volume,
+    .audio_codec_enable_pa = es8374_pa_power,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static bool es8374_codec_initialized()
+{
+    return codec_init_flag;
+}
+
+static esp_err_t es_write_reg(uint8_t slave_addr, uint8_t reg_add, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, slave_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
+}
+
+static esp_err_t es_read_reg(uint8_t slave_addr, uint8_t reg_add, uint8_t *p_data)
+{
+    return i2c_bus_read_bytes(i2c_handle, slave_addr, &reg_add, sizeof(reg_add), p_data, 1);
+}
+
+static int i2c_init()
+{
+    int res;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000
+    };
+    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    ES_ASSERT(res, "getting i2c pins error", -1);
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+esp_err_t es8374_write_reg(uint8_t reg_add, uint8_t data)
+{
+    return es_write_reg(ES8374_ADDR, reg_add, data);
+}
+
+int es8374_read_reg(uint8_t reg_add, uint8_t *regv)
+{
+    uint8_t regdata = 0xFF;
+    uint8_t res = 0;
+
+    if (es_read_reg(ES8374_ADDR, reg_add, &regdata) == 0) {
+        *regv = regdata;
+        return res;
+    } else {
+        LOG_8374("Read Audio Codec Register Failed!");
+        res = -1;
+        return res;
+    }
+}
+
+void es8374_read_all()
+{
+    for (int i = 0; i < 50; i++) {
+        uint8_t reg = 0;
+        es8374_read_reg(i, &reg);
+        ESP_LOGI(ES8374_TAG, "%x: %x", i, reg);
+    }
+}
+
+esp_err_t es8374_set_voice_mute(bool enable)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    res |= es8374_read_reg(0x36, &reg);
+    if (res == 0) {
+        reg = reg & 0xdf;
+        res |= es8374_write_reg(0x36, reg | (((int)enable) << 5));
+    }
+
+    return res;
+}
+
+esp_err_t es8374_get_voice_mute(void)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    res |= es8374_read_reg(0x36, &reg);
+    if (res == ESP_OK) {
+        reg = reg & 0x40;
+    }
+
+    return res == ESP_OK ? reg : res;
+}
+
+esp_err_t es8374_set_bits_per_sample(es_module_t mode, es_bits_length_t bit_per_sample)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    int bits = (int)bit_per_sample & 0x0f;
+
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_read_reg(0x10, &reg);
+        if (res == 0) {
+            reg = reg & 0xe3;
+            res |=  es8374_write_reg(0x10, reg | (bits << 2));
+        }
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_read_reg(0x11, &reg);
+        if (res == 0) {
+            reg = reg & 0xe3;
+            res |= es8374_write_reg(0x11, reg | (bits << 2));
+        }
+    }
+
+    return res;
+}
+
+esp_err_t es8374_config_fmt(es_module_t mode, es_i2s_fmt_t fmt)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    int fmt_tmp, fmt_i2s;
+
+    fmt_tmp = ((fmt & 0xf0) >> 4);
+    fmt_i2s =  fmt & 0x0f;
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_read_reg(0x10, &reg);
+        if (res == 0) {
+            reg = reg & 0xfc;
+            res |= es8374_write_reg(0x10, reg | fmt_i2s);
+            res |= es8374_set_bits_per_sample(mode, fmt_tmp);
+        }
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_read_reg(0x11, &reg);
+        if (res == 0) {
+            reg = reg & 0xfc;
+            res |= es8374_write_reg(0x11, reg | (fmt_i2s));
+            res |= es8374_set_bits_per_sample(mode, fmt_tmp);
+        }
+    }
+
+    return res;
+}
+
+esp_err_t es8374_start(es_module_t mode)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    if (mode == ES_MODULE_LINE) {
+        res |= es8374_read_reg(0x1a, &reg);       //set monomixer
+        reg |= 0x60;
+        reg |= 0x20;
+        reg &= 0xf7;
+        res |= es8374_write_reg( 0x1a, reg);
+        res |= es8374_read_reg(0x1c, &reg);        // set spk mixer
+        reg |= 0x40;
+        res |= es8374_write_reg( 0x1c, reg);
+        res |= es8374_write_reg(0x1D, 0x02);      // spk set
+        res |= es8374_write_reg(0x1F, 0x00);      // spk set
+        res |= es8374_write_reg(0x1E, 0xA0);      // spk on
+    }
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
+        res |= es8374_read_reg(0x21, &reg);       //power up adc and input
+        reg &= 0x3f;
+        res |= es8374_write_reg(0x21, reg);
+        res |= es8374_read_reg(0x10, &reg);       //power up adc and input
+        reg &= 0x3f;
+        res |= es8374_write_reg(0x10, reg);
+    }
+
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
+        res |= es8374_read_reg(0x1a, &reg);       //disable lout
+        reg |= 0x08;
+        res |= es8374_write_reg( 0x1a, reg);
+        reg &= 0xdf;
+        res |= es8374_write_reg( 0x1a, reg);
+        res |= es8374_write_reg(0x1D, 0x12);      // mute speaker
+        res |= es8374_write_reg(0x1E, 0x20);      // disable class d
+        res |= es8374_read_reg(0x15, &reg);        //power up dac
+        reg &= 0xdf;
+        res |= es8374_write_reg(0x15, reg);
+        res |= es8374_read_reg(0x1a, &reg);        //disable lout
+        reg |= 0x20;
+        res |= es8374_write_reg( 0x1a, reg);
+        reg &= 0xf7;
+        res |= es8374_write_reg( 0x1a, reg);
+        res |= es8374_write_reg(0x1D, 0x02);      // mute speaker
+        res |= es8374_write_reg(0x1E, 0xa0);      // disable class d
+
+        res |= es8374_set_voice_mute(false);
+    }
+
+    return res;
+}
+
+esp_err_t es8374_stop(es_module_t mode)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    if (mode == ES_MODULE_LINE) {
+        res |= es8374_read_reg(0x1a, &reg);       //disable lout
+        reg |= 0x08;
+        res |= es8374_write_reg( 0x1a, reg);
+        reg &= 0x9f;
+        res |= es8374_write_reg( 0x1a, reg);
+        res |= es8374_write_reg(0x1D, 0x12);      // mute speaker
+        res |= es8374_write_reg(0x1E, 0x20);      // disable class d
+        res |= es8374_read_reg(0x1c, &reg);        // disable spkmixer
+        reg &= 0xbf;
+        res |= es8374_write_reg( 0x1c, reg);
+        res |= es8374_write_reg(0x1F, 0x00);      // spk set
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_set_voice_mute(true);
+
+        res |= es8374_read_reg(0x1a, &reg);        //disable lout
+        reg |= 0x08;
+        res |= es8374_write_reg( 0x1a, reg);
+        reg &= 0xdf;
+        res |= es8374_write_reg( 0x1a, reg);
+        res |= es8374_write_reg(0x1D, 0x12);      // mute speaker
+        res |= es8374_write_reg(0x1E, 0x20);      // disable class d
+        res |= es8374_read_reg(0x15, &reg);        //power up dac
+        reg |= 0x20;
+        res |= es8374_write_reg(0x15, reg);
+    }
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+
+        res |= es8374_read_reg(0x10, &reg);       //power up adc and input
+        reg |= 0xc0;
+        res |= es8374_write_reg(0x10, reg);
+        res |= es8374_read_reg(0x21, &reg);       //power up adc and input
+        reg |= 0xc0;
+        res |= es8374_write_reg(0x21, reg);
+    }
+
+    return res;
+}
+
+esp_err_t es8374_i2s_config_clock(es_i2s_clock_t cfg)
+{
+
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    res |= es8374_read_reg(0x0f, &reg);       //power up adc and input
+    reg &= 0xe0;
+    int divratio = 0;
+    switch (cfg.sclk_div) {
+        case MCLK_DIV_1:
+            divratio = 1;
+            break;
+        case MCLK_DIV_2: // = 2,
+            divratio = 2;
+            break;
+        case MCLK_DIV_3: // = 3,
+            divratio = 3;
+            break;
+        case MCLK_DIV_4: // = 4,
+            divratio = 4;
+            break;
+        case MCLK_DIV_5: // = 20,
+            divratio = 5;
+            break;
+        case MCLK_DIV_6: // = 5,
+            divratio = 6;
+            break;
+        case MCLK_DIV_7: //  = 29,
+            divratio = 7;
+            break;
+        case MCLK_DIV_8: // = 6,
+            divratio = 8;
+            break;
+        case MCLK_DIV_9: // = 7,
+            divratio = 9;
+            break;
+        case MCLK_DIV_10: // = 21,
+            divratio = 10;
+            break;
+        case MCLK_DIV_11: // = 8,
+            divratio = 11;
+            break;
+        case MCLK_DIV_12: // = 9,
+            divratio = 12;
+            break;
+        case MCLK_DIV_13: // = 30,
+            divratio = 13;
+            break;
+        case MCLK_DIV_14: // = 31
+            divratio = 14;
+            break;
+        case MCLK_DIV_15: // = 22,
+            divratio = 15;
+            break;
+        case MCLK_DIV_16: // = 10,
+            divratio = 16;
+            break;
+        case MCLK_DIV_17: // = 23,
+            divratio = 17;
+            break;
+        case MCLK_DIV_18: // = 11,
+            divratio = 18;
+            break;
+        case MCLK_DIV_20: // = 24,
+            divratio = 19;
+            break;
+        case MCLK_DIV_22: // = 12,
+            divratio = 20;
+            break;
+        case MCLK_DIV_24: // = 13,
+            divratio = 21;
+            break;
+        case MCLK_DIV_25: // = 25,
+            divratio = 22;
+            break;
+        case MCLK_DIV_30: // = 26,
+            divratio = 23;
+            break;
+        case MCLK_DIV_32: // = 27,
+            divratio = 24;
+            break;
+        case MCLK_DIV_33: // = 14,
+            divratio = 25;
+            break;
+        case MCLK_DIV_34: // = 28,
+            divratio = 26;
+            break;
+        case MCLK_DIV_36: // = 15,
+            divratio = 27;
+            break;
+        case MCLK_DIV_44: // = 16,
+            divratio = 28;
+            break;
+        case MCLK_DIV_48: // = 17,
+            divratio = 29;
+            break;
+        case MCLK_DIV_66: // = 18,
+            divratio = 30;
+            break;
+        case MCLK_DIV_72: // = 19,
+            divratio = 31;
+            break;
+        default:
+            break;
+    }
+    reg |= divratio;
+    res |= es8374_write_reg(0x0f, reg);
+
+    int dacratio_l = 0;
+    int dacratio_h = 0;
+
+    switch (cfg.lclk_div) {
+        case LCLK_DIV_128:
+            dacratio_l = 128 % 256;
+            dacratio_h = 128 / 256;
+            break;
+        case LCLK_DIV_192:
+            dacratio_l = 192 % 256;
+            dacratio_h = 192 / 256;
+            break;
+        case LCLK_DIV_256:
+            dacratio_l = 256 % 256;
+            dacratio_h = 256 / 256;
+            break;
+        case LCLK_DIV_384:
+            dacratio_l = 384 % 256;
+            dacratio_h = 384 / 256;
+            break;
+        case LCLK_DIV_512:
+            dacratio_l = 512 % 256;
+            dacratio_h = 512 / 256;
+            break;
+        case LCLK_DIV_576:
+            dacratio_l = 576 % 256;
+            dacratio_h = 576 / 256;
+            break;
+        case LCLK_DIV_768:
+            dacratio_l = 768 % 256;
+            dacratio_h = 768 / 256;
+            break;
+        case LCLK_DIV_1024:
+            dacratio_l = 1024 % 256;
+            dacratio_h = 1024 / 256;
+            break;
+        case LCLK_DIV_1152:
+            dacratio_l = 1152 % 256;
+            dacratio_h = 1152 / 256;
+            break;
+        case LCLK_DIV_1408:
+            dacratio_l = 1408 % 256;
+            dacratio_h = 1408 / 256;
+            break;
+        case LCLK_DIV_1536:
+            dacratio_l = 1536 % 256;
+            dacratio_h = 1536 / 256;
+            break;
+        case LCLK_DIV_2112:
+            dacratio_l = 2112 % 256;
+            dacratio_h = 2112 / 256;
+            break;
+        case LCLK_DIV_2304:
+            dacratio_l = 2304 % 256;
+            dacratio_h = 2304 / 256;
+            break;
+        case LCLK_DIV_125:
+            dacratio_l = 125 % 256;
+            dacratio_h = 125 / 256;
+            break;
+        case LCLK_DIV_136:
+            dacratio_l = 136 % 256;
+            dacratio_h = 136 / 256;
+            break;
+        case LCLK_DIV_250:
+            dacratio_l = 250 % 256;
+            dacratio_h = 250 / 256;
+            break;
+        case LCLK_DIV_272:
+            dacratio_l = 272 % 256;
+            dacratio_h = 272 / 256;
+            break;
+        case LCLK_DIV_375:
+            dacratio_l = 375 % 256;
+            dacratio_h = 375 / 256;
+            break;
+        case LCLK_DIV_500:
+            dacratio_l = 500 % 256;
+            dacratio_h = 500 / 256;
+            break;
+        case LCLK_DIV_544:
+            dacratio_l = 544 % 256;
+            dacratio_h = 544 / 256;
+            break;
+        case LCLK_DIV_750:
+            dacratio_l = 750 % 256;
+            dacratio_h = 750 / 256;
+            break;
+        case LCLK_DIV_1000:
+            dacratio_l = 1000 % 256;
+            dacratio_h = 1000 / 256;
+            break;
+        case LCLK_DIV_1088:
+            dacratio_l = 1088 % 256;
+            dacratio_h = 1088 / 256;
+            break;
+        case LCLK_DIV_1496:
+            dacratio_l = 1496 % 256;
+            dacratio_h = 1496 / 256;
+            break;
+        case LCLK_DIV_1500:
+            dacratio_l = 1500 % 256;
+            dacratio_h = 1500 / 256;
+            break;
+        default:
+            break;
+    }
+    res |= es8374_write_reg( 0x06, dacratio_h);  //ADCFsMode,singel SPEED,RATIO=256
+    res |= es8374_write_reg( 0x07, dacratio_l);  //ADCFsMode,singel SPEED,RATIO=256
+
+    return res;
+}
+
+esp_err_t es8374_config_dac_output(es_dac_output_t output)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    reg = 0x1d;
+
+    res = es8374_write_reg(reg, 0x02);
+    res |= es8374_read_reg(0x1c, &reg); // set spk mixer
+    reg |= 0x80;
+    res |= es8374_write_reg(0x1c, reg);
+    res |= es8374_write_reg(0x1D, 0x02); // spk set
+    res |= es8374_write_reg(0x1F, 0x00); // spk set
+    res |= es8374_write_reg(0x1E, 0xA0); // spk on
+
+    return res;
+}
+
+esp_err_t es8374_config_adc_input(es_adc_input_t input)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+
+    res |= es8374_read_reg(0x21, &reg);
+    if (res == 0) {
+        reg = (reg & 0xcf) | 0x14;
+        res |= es8374_write_reg( 0x21, reg);
+    }
+
+    return res;
+}
+
+esp_err_t es8374_set_mic_gain(es_mic_gain_t gain)
+{
+    esp_err_t res = ESP_OK;
+
+    if (gain > MIC_GAIN_MIN && gain < MIC_GAIN_24DB) {
+        int gain_n = 0;
+        gain_n = (int)gain / 3;
+        res = es8374_write_reg(0x22, gain_n | (gain_n << 4)); //MIC PGA
+    } else {
+        res = -1;
+        LOG_8374("invalid microphone gain!");
+    }
+
+    return res;
+}
+
+esp_err_t es8374_codec_set_voice_volume(int volume)
+{
+    esp_err_t res = ESP_OK;
+
+    if (volume < 0) {
+        volume = 192;
+    } else if (volume > 96) {
+        volume = 0;
+    } else {
+        volume = 192 - volume * 2;
+    }
+
+    res = es8374_write_reg(0x38, volume);
+
+    return res;
+}
+
+esp_err_t es8374_codec_get_voice_volume(int *volume)
+{
+    esp_err_t res = 0;
+    uint8_t reg = 0;
+
+    res = es8374_read_reg(0x38, &reg);
+
+    if (res == ESP_FAIL) {
+        *volume = 0;
+    } else {
+        *volume = (192 - reg) / 2;
+        if (*volume > 96) {
+            *volume = 100;
+        }
+    }
+
+    return res;
+}
+
+static int es8374_set_adc_dac_volume(int mode, int volume, int dot)
+{
+    int res = 0;
+
+    if ( volume < -96 || volume > 0 ) {
+        LOG_8374("Warning: volume < -96! or > 0!");
+        if (volume < -96) {
+            volume = -96;
+        } else {
+            volume = 0;
+        }
+    }
+    dot = (dot >= 5 ? 1 : 0);
+    volume = (-volume << 1) + dot;
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_write_reg(0x25, volume);
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res |= es8374_write_reg(0x38, volume);
+    }
+
+    return res;
+}
+
+static int es8374_set_d2se_pga(es_d2se_pga_t gain)
+{
+    int res = 0;
+    uint8_t reg = 0;
+
+    if (gain > D2SE_PGA_GAIN_MIN && gain < D2SE_PGA_GAIN_MAX) {
+        res = es8374_read_reg(0x21, &reg);
+        reg &= 0xfb;
+        reg |= gain << 2;
+        res |= es8374_write_reg(0x21, reg); //MIC PGA
+    } else {
+        res = 0xff;
+        LOG_8374("invalid microphone gain!");
+    }
+
+    return res;
+}
+
+static int es8374_init_reg(audio_hal_codec_mode_t ms_mode, es_i2s_fmt_t fmt, es_i2s_clock_t cfg, es_dac_output_t out_channel, es_adc_input_t in_channel)
+{
+    int res = 0;
+    uint8_t reg = 0;
+
+    res |= es8374_write_reg(0x00, 0x3F); //IC Rst start
+    res |= es8374_write_reg(0x00, 0x03); //IC Rst stop
+    res |= es8374_write_reg(0x01, 0x7F); //IC clk on
+
+    res |= es8374_read_reg(0x0F, &reg);
+    reg &= 0x7f;
+    reg |=  (ms_mode << 7);
+    res |= es8374_write_reg( 0x0f, reg); //CODEC IN I2S SLAVE MODE
+
+    res |= es8374_write_reg(0x6F, 0xA0); //pll set:mode enable
+    res |= es8374_write_reg(0x72, 0x41); //pll set:mode set
+    res |= es8374_write_reg(0x09, 0x01); //pll set:reset on ,set start
+    res |= es8374_write_reg(0x0C, 0x22); //pll set:k
+    res |= es8374_write_reg(0x0D, 0x2E); //pll set:k
+    res |= es8374_write_reg(0x0E, 0xC6); //pll set:k
+    res |= es8374_write_reg(0x0A, 0x3A); //pll set:
+    res |= es8374_write_reg(0x0B, 0x07); //pll set:n
+    res |= es8374_write_reg(0x09, 0x41); //pll set:reset off ,set stop
+
+    res |= es8374_i2s_config_clock(cfg);
+
+    res |= es8374_write_reg(0x24, 0x08); //adc set
+    res |= es8374_write_reg(0x36, 0x00); //dac set
+    res |= es8374_write_reg(0x12, 0x30); //timming set
+    res |= es8374_write_reg(0x13, 0x20); //timming set
+
+    res |= es8374_config_fmt(ES_MODULE_ADC, fmt);
+    res |= es8374_config_fmt(ES_MODULE_DAC, fmt);
+
+    res |= es8374_write_reg(0x21, 0x50); //adc set: SEL LIN1 CH+PGAGAIN=0DB
+    res |= es8374_write_reg(0x22, 0xFF); //adc set: PGA GAIN=0DB
+    res |= es8374_write_reg(0x21, 0x14); //adc set: SEL LIN1 CH+PGAGAIN=18DB
+    res |= es8374_write_reg(0x22, 0x55); //pga = +15db
+    res |= es8374_write_reg(0x08, 0x21); //set class d divider = 33, to avoid the high frequency tone on laudspeaker
+    res |= es8374_write_reg(0x00, 0x80); // IC START
+
+    res |= es8374_set_adc_dac_volume(ES_MODULE_ADC, 0, 0);      // 0db
+    res |= es8374_set_adc_dac_volume(ES_MODULE_DAC, 0, 0);      // 0db
+
+    res |= es8374_write_reg(0x14, 0x8A); // IC START
+    res |= es8374_write_reg(0x15, 0x40); // IC START
+    res |= es8374_write_reg(0x1A, 0xA0); // monoout set
+    res |= es8374_write_reg(0x1B, 0x19); // monoout set
+    res |= es8374_write_reg(0x1C, 0x90); // spk set
+    res |= es8374_write_reg(0x1D, 0x01); // spk set
+    res |= es8374_write_reg(0x1F, 0x00); // spk set
+    res |= es8374_write_reg(0x1E, 0x20); // spk on
+    res |= es8374_write_reg(0x28, 0x00); // alc set
+    res |= es8374_write_reg(0x25, 0x00); // ADCVOLUME on
+    res |= es8374_write_reg(0x38, 0x00); // DACVOLUME on
+    res |= es8374_write_reg(0x37, 0x30); // dac set
+    res |= es8374_write_reg(0x6D, 0x60); //SEL:GPIO1=DMIC CLK OUT+SEL:GPIO2=PLL CLK OUT
+    res |= es8374_write_reg(0x71, 0x05); //for automute setting
+    res |= es8374_write_reg(0x73, 0x70);
+
+    res |= es8374_config_dac_output(out_channel);  //0x3c Enable DAC and Enable Lout/Rout/1/2
+    res |= es8374_config_adc_input(in_channel);  //0x00 LINSEL & RINSEL, LIN1/RIN1 as ADC Input; DSSEL,use one DS Reg11; DSR, LINPUT1-RINPUT1
+    res |= es8374_codec_set_voice_volume(0);
+
+    res |= es8374_write_reg(0x37, 0x00); // dac set
+
+    return res;
+}
+
+esp_err_t es8374_codec_init(audio_hal_codec_config_t *cfg)
+{
+    if (es8374_codec_initialized()) {
+        ESP_LOGW(ES8374_TAG, "The es8374 codec has already been initialized!");
+        return ESP_FAIL;
+    }
+    esp_err_t res = ESP_OK;
+    es_i2s_clock_t clkdiv;
+
+    clkdiv.lclk_div = LCLK_DIV_256;
+    clkdiv.sclk_div = MCLK_DIV_4;
+
+    i2c_init(); // ESP32 in master mode
+
+    res |= es8374_stop(cfg->codec_mode);
+    res |= es8374_init_reg(cfg->i2s_iface.mode, (BIT_LENGTH_16BITS << 4) | cfg->i2s_iface.fmt, clkdiv,
+                           cfg->dac_output, cfg->adc_input);
+    res |= es8374_set_mic_gain(MIC_GAIN_15DB);
+    res |= es8374_set_d2se_pga(D2SE_PGA_GAIN_EN);
+    res |= es8374_config_fmt(cfg->codec_mode, cfg->i2s_iface.fmt);
+    res |= es8374_codec_config_i2s(cfg->codec_mode, &(cfg->i2s_iface));
+    codec_init_flag = 1;
+    return res;
+}
+
+esp_err_t es8374_codec_deinit(void)
+{
+    if (!es8374_codec_initialized()) {
+        ESP_LOGW(ES8374_TAG, "The es8374 codec has already been deinit!");
+        return ESP_FAIL;
+    }
+    esp_err_t res = ESP_OK;
+    codec_init_flag = 0;
+    res = es8374_write_reg(0x00, 0x7F); // IC Reset and STOP
+    res |= i2c_bus_delete(i2c_handle);
+    return res;
+}
+
+esp_err_t es8374_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    esp_err_t res = ESP_OK;
+    int tmp = 0;
+    res |= es8374_config_fmt(ES_MODULE_ADC_DAC, iface->fmt);
+    if (iface->bits == AUDIO_HAL_BIT_LENGTH_16BITS) {
+        tmp = BIT_LENGTH_16BITS;
+    } else if (iface->bits == AUDIO_HAL_BIT_LENGTH_24BITS) {
+        tmp = BIT_LENGTH_24BITS;
+    } else {
+        tmp = BIT_LENGTH_32BITS;
+    }
+    res |= es8374_set_bits_per_sample(ES_MODULE_ADC_DAC, tmp);
+    return res;
+}
+
+esp_err_t es8374_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    esp_err_t res = ESP_OK;
+    int es_mode_t = 0;
+    switch (mode) {
+        case AUDIO_HAL_CODEC_MODE_ENCODE:
+            es_mode_t  = ES_MODULE_ADC;
+            break;
+        case AUDIO_HAL_CODEC_MODE_LINE_IN:
+            es_mode_t  = ES_MODULE_LINE;
+            break;
+        case AUDIO_HAL_CODEC_MODE_DECODE:
+            es_mode_t  = ES_MODULE_DAC;
+            break;
+        case AUDIO_HAL_CODEC_MODE_BOTH:
+            es_mode_t  = ES_MODULE_ADC_DAC;
+            break;
+        default:
+            es_mode_t = ES_MODULE_DAC;
+            ESP_LOGW(ES8374_TAG, "Codec mode not support, default is decode mode");
+            break;
+    }
+    if (AUDIO_HAL_CTRL_STOP == ctrl_state) {
+        res = es8374_stop(es_mode_t);
+    } else {
+        res = es8374_start(es_mode_t);
+        ESP_LOGD(ES8374_TAG, "start default is decode mode:%d", es_mode_t);
+    }
+    return res;
+}
+
+esp_err_t es8374_pa_power(bool enable)
+{
+    esp_err_t ret = ESP_OK;
+    gpio_config_t  io_conf;
+    memset(&io_conf, 0, sizeof(io_conf));
+    io_conf.mode = GPIO_MODE_OUTPUT;
+    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
+    io_conf.pull_down_en = 0;
+    io_conf.pull_up_en = 0;
+    gpio_config(&io_conf);
+    if (enable) {
+        ret = gpio_set_level(get_pa_enable_gpio(), 1);
+    } else {
+        ret = gpio_set_level(get_pa_enable_gpio(), 0);
+    }
+    return ret;
+}
diff --git a/components/audio_hal/driver/es8374/es8374.h b/components/audio_hal/driver/es8374/es8374.h
old mode 100755
new mode 100644
index 6fb3c994..8414fc06
--- a/components/audio_hal/driver/es8374/es8374.h
+++ b/components/audio_hal/driver/es8374/es8374.h
@@ -1,247 +1,247 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __ES8374_H__
-#define __ES8374_H__
-
-#include "esp_types.h"
-#include "audio_hal.h"
-#include "esxxx_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif  /* __cplusplus */
-
-/* ES8374 address */
-#define ES8374_ADDR 0x20  // 0x22:CE=1;0x20:CE=0
-
-/**
- * @brief  Initialize ES8374 codec chip
- *
- * @param  cfg  configuration of ES8374
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_codec_init(audio_hal_codec_config_t *cfg);
-
-/**
- * @brief  Deinitialize ES8374 codec chip
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_codec_deinit(void);
-
-/**
- * @brief  Configure ES8374 I2S format
- *
- * @param  mode  Set ADC or DAC or both
- * @param  fmt   ES8374 I2S format
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_config_fmt(es_module_t mode, es_i2s_fmt_t fmt);
-
-/**
- * @brief  Configure I2S clock in MSATER mode
- *
- * @param  cfg  Set bits clock and WS clock
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_i2s_config_clock(es_i2s_clock_t cfg);
-
-/**
- * @brief  Configure ES8374 data sample bits
- *
- * @param  mode            Set ADC or DAC or both
- * @param  bit_per_sample  Bit number of per sample
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_set_bits_per_sample(es_module_t mode, es_bits_length_t bit_per_sample);
-
-/**
- * @brief  Start ES8374 codec chip
- *
- * @param  mode  Set ADC or DAC or both
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_start(es_module_t mode);
-
-/**
- * @brief  Stop ES8374 codec chip
- *
- * @param  mode  Set ADC or DAC or both
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_stop(es_module_t mode);
-
-/**
- * @brief  Set voice volume
- *
- * @param  volume  Voice volume (0~100)
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_codec_set_voice_volume(int volume);
-
-/**
- * @brief  Get voice volume
- *
- * @param[out]  *volume  Voice volume (0~100)
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t es8374_codec_get_voice_volume(int *volume);
-
-/**
- * @brief  Mute or unmute ES8374 DAC. Basically you can use this function to mute or unmute the output
- *
- * @param[in,out]  enable  Enable Mute(1) or Unmute(0)
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_set_voice_mute(bool enable);
-
-/**
- * @brief  Get ES8374 DAC mute status
- *
- * @return
- *       - ESP_FAIL
- *       - ESP_OK
- */
-esp_err_t es8374_get_voice_mute(void);
-
-/**
- * @brief  Set ES8374 mic gain
- *
- * @param[in,out]  gain  gain db of mic gain
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_set_mic_gain(es_mic_gain_t gain);
-
-/**
- * @brief  Set ES8374 ADC input mode
- *
- * @param[in]  input  ADC input mode
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_config_adc_input(es_adc_input_t input);
-
-/**
- * @brief  Set ES8374 DAC output mode
- *
- * @param[in]  output  DAC output mode
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_config_dac_output(es_dac_output_t output);
-
-/**
- * @brief  Write ES8374 register
- *
- * @param  reg_add  Address of register
- * @param  data     Data of register
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_write_reg(uint8_t reg_add, uint8_t data);
-
-/**
- * @brief  Print all ES8374 registers
- */
-void es8374_read_all(void);
-
-/**
- * @brief  Configure ES8374 codec mode and I2S interface
- *
- * @param  mode   Codec mode
- * @param  iface  I2S config
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief  Control ES8374 codec chip
- *
- * @param  mode        Codec mode
- * @param  ctrl_state  Start or stop decode or encode progress
- *
- * @return
- *       - ESP_FAIL  Parameter error
- *       - ESP_OK    Success
- */
-esp_err_t es8374_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief  Set ES8374 PA power
- *
- * @param  enable  True for enable PA power, false for disable PA power
- *
- * @return
- *       - ESP_ERR_INVALID_ARG
- *       - ESP_OK
- */
-esp_err_t es8374_pa_power(bool enable);
-
-#ifdef __cplusplus
-}
-#endif  /* __cplusplus */
-
-#endif  //__ES8374_H__
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __ES8374_H__
+#define __ES8374_H__
+
+#include "esp_types.h"
+#include "audio_hal.h"
+#include "esxxx_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* ES8374 address */
+#define ES8374_ADDR 0x20  // 0x22:CE=1;0x20:CE=0
+
+/**
+ * @brief  Initialize ES8374 codec chip
+ *
+ * @param  cfg  configuration of ES8374
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_codec_init(audio_hal_codec_config_t *cfg);
+
+/**
+ * @brief  Deinitialize ES8374 codec chip
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_codec_deinit(void);
+
+/**
+ * @brief  Configure ES8374 I2S format
+ *
+ * @param  mode  Set ADC or DAC or both
+ * @param  fmt   ES8374 I2S format
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_config_fmt(es_module_t mode, es_i2s_fmt_t fmt);
+
+/**
+ * @brief  Configure I2S clock in MSATER mode
+ *
+ * @param  cfg  Set bits clock and WS clock
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_i2s_config_clock(es_i2s_clock_t cfg);
+
+/**
+ * @brief  Configure ES8374 data sample bits
+ *
+ * @param  mode            Set ADC or DAC or both
+ * @param  bit_per_sample  Bit number of per sample
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_set_bits_per_sample(es_module_t mode, es_bits_length_t bit_per_sample);
+
+/**
+ * @brief  Start ES8374 codec chip
+ *
+ * @param  mode  Set ADC or DAC or both
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_start(es_module_t mode);
+
+/**
+ * @brief  Stop ES8374 codec chip
+ *
+ * @param  mode  Set ADC or DAC or both
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_stop(es_module_t mode);
+
+/**
+ * @brief  Set voice volume
+ *
+ * @param  volume  Voice volume (0~100)
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_codec_set_voice_volume(int volume);
+
+/**
+ * @brief  Get voice volume
+ *
+ * @param[out]  *volume  Voice volume (0~100)
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t es8374_codec_get_voice_volume(int *volume);
+
+/**
+ * @brief  Mute or unmute ES8374 DAC. Basically you can use this function to mute or unmute the output
+ *
+ * @param[in,out]  enable  Enable Mute(1) or Unmute(0)
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_set_voice_mute(bool enable);
+
+/**
+ * @brief  Get ES8374 DAC mute status
+ *
+ * @return
+ *       - ESP_FAIL
+ *       - ESP_OK
+ */
+esp_err_t es8374_get_voice_mute(void);
+
+/**
+ * @brief  Set ES8374 mic gain
+ *
+ * @param[in,out]  gain  gain db of mic gain
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_set_mic_gain(es_mic_gain_t gain);
+
+/**
+ * @brief  Set ES8374 ADC input mode
+ *
+ * @param[in]  input  ADC input mode
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_config_adc_input(es_adc_input_t input);
+
+/**
+ * @brief  Set ES8374 DAC output mode
+ *
+ * @param[in]  output  DAC output mode
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_config_dac_output(es_dac_output_t output);
+
+/**
+ * @brief  Write ES8374 register
+ *
+ * @param  reg_add  Address of register
+ * @param  data     Data of register
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_write_reg(uint8_t reg_add, uint8_t data);
+
+/**
+ * @brief  Print all ES8374 registers
+ */
+void es8374_read_all(void);
+
+/**
+ * @brief  Configure ES8374 codec mode and I2S interface
+ *
+ * @param  mode   Codec mode
+ * @param  iface  I2S config
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief  Control ES8374 codec chip
+ *
+ * @param  mode        Codec mode
+ * @param  ctrl_state  Start or stop decode or encode progress
+ *
+ * @return
+ *       - ESP_FAIL  Parameter error
+ *       - ESP_OK    Success
+ */
+esp_err_t es8374_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief  Set ES8374 PA power
+ *
+ * @param  enable  True for enable PA power, false for disable PA power
+ *
+ * @return
+ *       - ESP_ERR_INVALID_ARG
+ *       - ESP_OK
+ */
+esp_err_t es8374_pa_power(bool enable);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  //__ES8374_H__
diff --git a/components/audio_hal/driver/es8388/es8388.c b/components/audio_hal/driver/es8388/es8388.c
old mode 100755
new mode 100644
index 144e7281..438652c4
--- a/components/audio_hal/driver/es8388/es8388.c
+++ b/components/audio_hal/driver/es8388/es8388.c
@@ -1,582 +1,582 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "i2c_bus.h"
-#include "es8388.h"
-#include "board.h"
-#include "audio_volume.h"
-
-#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
-#include "headphone_detect.h"
-#endif
-
-static const char *ES_TAG = "ES8388_DRIVER";
-static i2c_bus_handle_t i2c_handle;
-static codec_dac_volume_config_t *dac_vol_handle;
-
-#define ES8388_DAC_VOL_CFG_DEFAULT() {                      \
-    .max_dac_volume = 0,                                    \
-    .min_dac_volume = -96,                                  \
-    .board_pa_gain = BOARD_PA_GAIN,                         \
-    .volume_accuracy = 0.5,                                 \
-    .dac_vol_symbol = -1,                                   \
-    .zero_volume_reg = 0,                                   \
-    .reg_value = 0,                                         \
-    .user_volume = 0,                                       \
-    .offset_conv_volume = NULL,                             \
-}
-
-#define ES_ASSERT(a, format, b, ...) \
-    if ((a) != 0) { \
-        ESP_LOGE(ES_TAG, format, ##__VA_ARGS__); \
-        return b;\
-    }
-
-audio_hal_func_t AUDIO_CODEC_ES8388_DEFAULT_HANDLE = {
-    .audio_codec_initialize = es8388_init,
-    .audio_codec_deinitialize = es8388_deinit,
-    .audio_codec_ctrl = es8388_ctrl_state,
-    .audio_codec_config_iface = es8388_config_i2s,
-    .audio_codec_set_mute = es8388_set_voice_mute,
-    .audio_codec_set_volume = es8388_set_voice_volume,
-    .audio_codec_get_volume = es8388_get_voice_volume,
-    .audio_codec_enable_pa = es8388_pa_power,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static esp_err_t es_write_reg(uint8_t slave_addr, uint8_t reg_add, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, slave_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
-}
-
-static esp_err_t es_read_reg(uint8_t reg_add, uint8_t *p_data)
-{
-    return i2c_bus_read_bytes(i2c_handle, ES8388_ADDR, &reg_add, sizeof(reg_add), p_data, 1);
-}
-
-static int i2c_init()
-{
-    int res;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000
-    };
-    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
-    ES_ASSERT(res, "getting i2c pins error", -1);
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-void es8388_read_all()
-{
-    for (int i = 0; i < 50; i++) {
-        uint8_t reg = 0;
-        es_read_reg(i, &reg);
-        ESP_LOGI(ES_TAG, "%x: %x", i, reg);
-    }
-}
-
-esp_err_t es8388_write_reg(uint8_t reg_add, uint8_t data)
-{
-    return es_write_reg(ES8388_ADDR, reg_add, data);
-}
-
-/**
- * @brief Configure ES8388 ADC and DAC volume. Basicly you can consider this as ADC and DAC gain
- *
- * @param mode:             set ADC or DAC or all
- * @param volume:           -96 ~ 0              for example Es8388SetAdcDacVolume(ES_MODULE_ADC, 30, 6); means set ADC volume -30.5db
- * @param dot:              whether include 0.5. for example Es8388SetAdcDacVolume(ES_MODULE_ADC, 30, 4); means set ADC volume -30db
- *
- * @return
- *     - (-1) Parameter error
- *     - (0)   Success
- */
-static int es8388_set_adc_dac_volume(int mode, int volume, int dot)
-{
-    int res = 0;
-    if ( volume < -96 || volume > 0 ) {
-        ESP_LOGW(ES_TAG, "Warning: volume < -96! or > 0!\n");
-        if (volume < -96)
-            volume = -96;
-        else
-            volume = 0;
-    }
-    dot = (dot >= 5 ? 1 : 0);
-    volume = (-volume << 1) + dot;
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL8, volume);
-        res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL9, volume);  //ADC Right Volume=0db
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL5, volume);
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL4, volume);
-    }
-    return res;
-}
-
-
-/**
- * @brief Power Management
- *
- * @param mod:      if ES_POWER_CHIP, the whole chip including ADC and DAC is enabled
- * @param enable:   false to disable true to enable
- *
- * @return
- *     - (-1)  Error
- *     - (0)   Success
- */
-esp_err_t es8388_start(es_module_t mode)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t prev_data = 0, data = 0;
-    es_read_reg(ES8388_DACCONTROL21, &prev_data);
-    if (mode == ES_MODULE_LINE) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x09); // 0x00 audio on LIN1&RIN1,  0x09 LIN2&RIN2 by pass enable
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x50); // left DAC to left mixer enable  and  LIN signal to left mixer enable 0db  : bupass enable
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x50); // right DAC to right mixer enable  and  LIN signal to right mixer enable 0db : bupass enable
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0xC0); //enable adc
-    } else {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80);   //enable dac
-    }
-    es_read_reg(ES8388_DACCONTROL21, &data);
-    if (prev_data != data) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0xF0);   //start state machine
-        // res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, 0x16);
-        // res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0x50);
-        res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0x00);   //start state machine
-    }
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0x00);   //power up adc and line in
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0x3c);   //power up dac and line out
-        res |= es8388_set_voice_mute(false);
-        ESP_LOGD(ES_TAG, "es8388_start default is mode:%d", mode);
-    }
-
-    return res;
-}
-
-/**
- * @brief Power Management
- *
- * @param mod:      if ES_POWER_CHIP, the whole chip including ADC and DAC is enabled
- * @param enable:   false to disable true to enable
- *
- * @return
- *     - (-1)  Error
- *     - (0)   Success
- */
-esp_err_t es8388_stop(es_module_t mode)
-{
-    esp_err_t res = ESP_OK;
-    if (mode == ES_MODULE_LINE) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80); //enable dac
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x00); // 0x00 audio on LIN1&RIN1,  0x09 LIN2&RIN2
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x90); // only left DAC to left mixer enable 0db
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x90); // only right DAC to right mixer enable 0db
-        return res;
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0x00);
-        res |= es8388_set_voice_mute(true); //res |= Es8388SetAdcDacVolume(ES_MODULE_DAC, -96, 5);      // 0db
-        //res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0xC0);  //power down dac and line out
-    }
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        //res |= Es8388SetAdcDacVolume(ES_MODULE_ADC, -96, 5);      // 0db
-        res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0xFF);  //power down adc and line in
-    }
-    if (mode == ES_MODULE_ADC_DAC) {
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x9C);  //disable mclk
-//        res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, 0x00);
-//        res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0x58);
-//        res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0xF3);  //stop state machine
-    }
-
-    return res;
-}
-
-
-/**
- * @brief Config I2s clock in MSATER mode
- *
- * @param cfg.sclkDiv:      generate SCLK by dividing MCLK in MSATER mode
- * @param cfg.lclkDiv:      generate LCLK by dividing MCLK in MSATER mode
- *
- * @return
- *     - (-1)  Error
- *     - (0)   Success
- */
-esp_err_t es8388_i2s_config_clock(es_i2s_clock_t cfg)
-{
-    esp_err_t res = ESP_OK;
-    res |= es_write_reg(ES8388_ADDR, ES8388_MASTERMODE, cfg.sclk_div);
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL5, cfg.lclk_div);  //ADCFsMode,singel SPEED,RATIO=256
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL2, cfg.lclk_div);  //ADCFsMode,singel SPEED,RATIO=256
-    return res;
-}
-
-esp_err_t es8388_deinit(void)
-{
-    int res = 0;
-    res = es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0xFF);  //reset and stop es8388
-    i2c_bus_delete(i2c_handle);
-#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
-    headphone_detect_deinit();
-#endif
-
-    audio_codec_volume_deinit(dac_vol_handle);
-    return res;
-}
-
-/**
- * @return
- *     - (-1)  Error
- *     - (0)   Success
- */
-esp_err_t es8388_init(audio_hal_codec_config_t *cfg)
-{
-    int res = 0;
-#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
-    headphone_detect_init(get_headphone_detect_gpio());
-#endif
-
-    res = i2c_init(); // ESP32 in master mode
-
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL3, 0x04);  // 0x04 mute/0x00 unmute&ramp;DAC unmute and  disabled digital volume control soft ramp
-    /* Chip Control and Power Management */
-    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0x50);
-    res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0x00); //normal all and power up all
-
-    // Disable the internal DLL to improve 8K sample rate
-    res |= es_write_reg(ES8388_ADDR, 0x35, 0xA0);
-    res |= es_write_reg(ES8388_ADDR, 0x37, 0xD0);
-    res |= es_write_reg(ES8388_ADDR, 0x39, 0xD0);
-
-    res |= es_write_reg(ES8388_ADDR, ES8388_MASTERMODE, cfg->i2s_iface.mode); //CODEC IN I2S SLAVE MODE
-
-    /* dac */
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0xC0);  //disable DAC and disable Lout/Rout/1/2
-    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, 0x12);  //Enfr=0,Play&Record Mode,(0x17-both of mic&paly)
-//    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0);  //LPVrefBuf=0,Pdn_ana=0
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, 0x18);//1a 0x18:16bit iis , 0x00:24
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL2, 0x02);  //DACFsMode,SINGLE SPEED; DACFsRatio,256
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x00); // 0x00 audio on LIN1&RIN1,  0x09 LIN2&RIN2
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x90); // only left DAC to left mixer enable 0db
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x90); // only right DAC to right mixer enable 0db
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80); // set internal ADC and DAC use the same LRCK clock, ADC LRCK as internal LRCK
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL23, 0x00); // vroi=0
-
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL24, 0x1E); // Set L1 R1 L2 R2 volume. 0x00: -30dB, 0x1E: 0dB, 0x21: 3dB
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL25, 0x1E);
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL26, 0);
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL27, 0);
-    // res |= es8388_set_adc_dac_volume(ES_MODULE_DAC, 0, 0);       // 0db
-    int tmp = 0;
-    if (AUDIO_HAL_DAC_OUTPUT_LINE2 == cfg->dac_output) {
-        tmp = DAC_OUTPUT_LOUT1 | DAC_OUTPUT_ROUT1;
-    } else if (AUDIO_HAL_DAC_OUTPUT_LINE1 == cfg->dac_output) {
-        tmp = DAC_OUTPUT_LOUT2 | DAC_OUTPUT_ROUT2;
-    } else {
-        tmp = DAC_OUTPUT_LOUT1 | DAC_OUTPUT_LOUT2 | DAC_OUTPUT_ROUT1 | DAC_OUTPUT_ROUT2;
-    }
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, tmp);  //0x3c Enable DAC and Enable Lout/Rout/1/2
-    /* adc */
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0xFF);
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL1, 0xbb); // MIC Left and Right channel PGA gain
-    tmp = 0;
-    if (AUDIO_HAL_ADC_INPUT_LINE1 == cfg->adc_input) {
-        tmp = ADC_INPUT_LINPUT1_RINPUT1;
-    } else if (AUDIO_HAL_ADC_INPUT_LINE2 == cfg->adc_input) {
-        tmp = ADC_INPUT_LINPUT2_RINPUT2;
-    } else {
-        tmp = ADC_INPUT_DIFFERENCE;
-    }
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL2, tmp);  //0x00 LINSEL & RINSEL, LIN1/RIN1 as ADC Input; DSSEL,use one DS Reg11; DSR, LINPUT1-RINPUT1
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL3, 0x02);
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, 0x0c); // 16 Bits length and I2S serial audio data format
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL5, 0x02);  //ADCFsMode,singel SPEED,RATIO=256
-    //ALC for Microphone
-    res |= es8388_set_adc_dac_volume(ES_MODULE_ADC, 0, 0);      // 0db
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0x09);    // Power on ADC, enable LIN&RIN, power off MICBIAS, and set int1lp to low power mode
-    
-    /* es8388 PA gpio_config */
-    gpio_config_t  io_conf;
-    memset(&io_conf, 0, sizeof(io_conf));
-    io_conf.mode = GPIO_MODE_OUTPUT;
-    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
-    io_conf.pull_down_en = 0;
-    io_conf.pull_up_en = 0;
-    gpio_config(&io_conf);
-    /* enable es8388 PA */
-    es8388_pa_power(true);
-
-    codec_dac_volume_config_t vol_cfg = ES8388_DAC_VOL_CFG_DEFAULT();
-    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
-    ESP_LOGI(ES_TAG, "init,out:%02x, in:%02x", cfg->dac_output, cfg->adc_input);
-    return res;
-}
-
-/**
- * @brief Configure ES8388 I2S format
- *
- * @param mode:           set ADC or DAC or all
- * @param bitPerSample:   see Es8388I2sFmt
- *
- * @return
- *     - (-1) Error
- *     - (0)  Success
- */
-esp_err_t es8388_config_fmt(es_module_t mode, es_i2s_fmt_t fmt)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        res = es_read_reg(ES8388_ADCCONTROL4, &reg);
-        reg = reg & 0xfc;
-        res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, reg | fmt);
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res = es_read_reg(ES8388_DACCONTROL1, &reg);
-        reg = reg & 0xf9;
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, reg | (fmt << 1));
-    }
-    return res;
-}
-
-/**
- * @brief Set voice volume
- *
- * @note Register values. 0xC0: -96 dB, 0x64: -50 dB, 0x00: 0 dB
- * @note Accuracy of gain is 0.5 dB
- *
- * @param volume: voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_set_voice_volume(int volume)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL5, reg);
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL4, reg);
-    ESP_LOGD(ES_TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", (int)dac_vol_handle->user_volume, reg,
-            audio_codec_cal_dac_volume(dac_vol_handle));
-    return res;
-}
-
-esp_err_t es8388_get_voice_volume(int *volume)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    res = es_read_reg(ES8388_DACCONTROL4, &reg);
-    if (res == ESP_FAIL) {
-        *volume = 0;
-    } else {
-        if (reg == dac_vol_handle->reg_value) {
-            *volume = dac_vol_handle->user_volume;
-        } else {
-            *volume = 0;
-            res = ESP_FAIL;
-        }
-    }
-    ESP_LOGD(ES_TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, reg);
-    return res;
-}
-
-/**
- * @brief Configure ES8388 data sample bits
- *
- * @param mode:             set ADC or DAC or all
- * @param bitPerSample:   see BitsLength
- *
- * @return
- *     - (-1) Parameter error
- *     - (0)   Success
- */
-esp_err_t es8388_set_bits_per_sample(es_module_t mode, es_bits_length_t bits_length)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    int bits = (int)bits_length;
-
-    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
-        res = es_read_reg(ES8388_ADCCONTROL4, &reg);
-        reg = reg & 0xe3;
-        res |=  es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, reg | (bits << 2));
-    }
-    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
-        res = es_read_reg(ES8388_DACCONTROL1, &reg);
-        reg = reg & 0xc7;
-        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, reg | (bits << 3));
-    }
-    return res;
-}
-
-/**
- * @brief Configure ES8388 DAC mute or not. Basically you can use this function to mute the output or unmute
- *
- * @param enable: enable or disable
- *
- * @return
- *     - (-1) Parameter error
- *     - (0)   Success
- */
-esp_err_t es8388_set_voice_mute(bool enable)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    res = es_read_reg(ES8388_DACCONTROL3, &reg);
-    reg = reg & 0xFB;
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL3, reg | (((int)enable) << 2));
-    return res;
-}
-
-esp_err_t es8388_get_voice_mute(void)
-{
-    esp_err_t res = ESP_OK;
-    uint8_t reg = 0;
-    res = es_read_reg(ES8388_DACCONTROL3, &reg);
-    if (res == ESP_OK) {
-        reg = (reg & 0x04) >> 2;
-    }
-    return res == ESP_OK ? reg : res;
-}
-
-/**
- * @param gain: Config DAC Output
- *
- * @return
- *     - (-1) Parameter error
- *     - (0)   Success
- */
-esp_err_t es8388_config_dac_output(es_dac_output_t output)
-{
-    esp_err_t res;
-    uint8_t reg = 0;
-    res = es_read_reg(ES8388_DACPOWER, &reg);
-    reg = reg & 0xc3;
-    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, reg | output);
-    return res;
-}
-
-/**
- * @param gain: Config ADC input
- *
- * @return
- *     - (-1) Parameter error
- *     - (0)   Success
- */
-esp_err_t es8388_config_adc_input(es_adc_input_t input)
-{
-    esp_err_t res;
-    uint8_t reg = 0;
-    res = es_read_reg(ES8388_ADCCONTROL2, &reg);
-    reg = reg & 0x0f;
-    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL2, reg | input);
-    return res;
-}
-
-/**
- * @param gain: see es_mic_gain_t
- *
- * @return
- *     - (-1) Parameter error
- *     - (0)   Success
- */
-esp_err_t es8388_set_mic_gain(es_mic_gain_t gain)
-{
-    esp_err_t res, gain_n;
-    gain_n = (int)gain / 3;
-    gain_n = (gain_n << 4) + gain_n;
-    res = es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL1, gain_n); //MIC PGA
-    return res;
-}
-
-int es8388_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    int res = 0;
-    int es_mode_t = 0;
-    switch (mode) {
-        case AUDIO_HAL_CODEC_MODE_ENCODE:
-            es_mode_t  = ES_MODULE_ADC;
-            break;
-        case AUDIO_HAL_CODEC_MODE_LINE_IN:
-            es_mode_t  = ES_MODULE_LINE;
-            break;
-        case AUDIO_HAL_CODEC_MODE_DECODE:
-            es_mode_t  = ES_MODULE_DAC;
-            break;
-        case AUDIO_HAL_CODEC_MODE_BOTH:
-            es_mode_t  = ES_MODULE_ADC_DAC;
-            break;
-        default:
-            es_mode_t = ES_MODULE_DAC;
-            ESP_LOGW(ES_TAG, "Codec mode not support, default is decode mode");
-            break;
-    }
-    if (AUDIO_HAL_CTRL_STOP == ctrl_state) {
-        res = es8388_stop(es_mode_t);
-    } else {
-        res = es8388_start(es_mode_t);
-        ESP_LOGD(ES_TAG, "start default is decode mode:%d", es_mode_t);
-    }
-    return res;
-}
-
-esp_err_t es8388_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    esp_err_t res = ESP_OK;
-    int tmp = 0;
-    res |= es8388_config_fmt(ES_MODULE_ADC_DAC, iface->fmt);
-    if (iface->bits == AUDIO_HAL_BIT_LENGTH_16BITS) {
-        tmp = BIT_LENGTH_16BITS;
-    } else if (iface->bits == AUDIO_HAL_BIT_LENGTH_24BITS) {
-        tmp = BIT_LENGTH_24BITS;
-    } else {
-        tmp = BIT_LENGTH_32BITS;
-    }
-    res |= es8388_set_bits_per_sample(ES_MODULE_ADC_DAC, tmp);
-    return res;
-}
-
-esp_err_t es8388_pa_power(bool enable)
-{
-    esp_err_t res = ESP_OK;
-    if (enable) {
-        res = gpio_set_level(get_pa_enable_gpio(), 1);
-    } else {
-        res = gpio_set_level(get_pa_enable_gpio(), 0);
-    }
-    return res;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "i2c_bus.h"
+#include "es8388.h"
+#include "board.h"
+#include "audio_volume.h"
+
+#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
+#include "headphone_detect.h"
+#endif
+
+static const char *ES_TAG = "ES8388_DRIVER";
+static i2c_bus_handle_t i2c_handle;
+static codec_dac_volume_config_t *dac_vol_handle;
+
+#define ES8388_DAC_VOL_CFG_DEFAULT() {                      \
+    .max_dac_volume = 0,                                    \
+    .min_dac_volume = -96,                                  \
+    .board_pa_gain = BOARD_PA_GAIN,                         \
+    .volume_accuracy = 0.5,                                 \
+    .dac_vol_symbol = -1,                                   \
+    .zero_volume_reg = 0,                                   \
+    .reg_value = 0,                                         \
+    .user_volume = 0,                                       \
+    .offset_conv_volume = NULL,                             \
+}
+
+#define ES_ASSERT(a, format, b, ...) \
+    if ((a) != 0) { \
+        ESP_LOGE(ES_TAG, format, ##__VA_ARGS__); \
+        return b;\
+    }
+
+audio_hal_func_t AUDIO_CODEC_ES8388_DEFAULT_HANDLE = {
+    .audio_codec_initialize = es8388_init,
+    .audio_codec_deinitialize = es8388_deinit,
+    .audio_codec_ctrl = es8388_ctrl_state,
+    .audio_codec_config_iface = es8388_config_i2s,
+    .audio_codec_set_mute = es8388_set_voice_mute,
+    .audio_codec_set_volume = es8388_set_voice_volume,
+    .audio_codec_get_volume = es8388_get_voice_volume,
+    .audio_codec_enable_pa = es8388_pa_power,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static esp_err_t es_write_reg(uint8_t slave_addr, uint8_t reg_add, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, slave_addr, &reg_add, sizeof(reg_add), &data, sizeof(data));
+}
+
+static esp_err_t es_read_reg(uint8_t reg_add, uint8_t *p_data)
+{
+    return i2c_bus_read_bytes(i2c_handle, ES8388_ADDR, &reg_add, sizeof(reg_add), p_data, 1);
+}
+
+static int i2c_init()
+{
+    int res;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000
+    };
+    res = get_i2c_pins(I2C_NUM_0, &es_i2c_cfg);
+    ES_ASSERT(res, "getting i2c pins error", -1);
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+void es8388_read_all()
+{
+    for (int i = 0; i < 50; i++) {
+        uint8_t reg = 0;
+        es_read_reg(i, &reg);
+        ESP_LOGI(ES_TAG, "%x: %x", i, reg);
+    }
+}
+
+esp_err_t es8388_write_reg(uint8_t reg_add, uint8_t data)
+{
+    return es_write_reg(ES8388_ADDR, reg_add, data);
+}
+
+/**
+ * @brief Configure ES8388 ADC and DAC volume. Basicly you can consider this as ADC and DAC gain
+ *
+ * @param mode:             set ADC or DAC or all
+ * @param volume:           -96 ~ 0              for example Es8388SetAdcDacVolume(ES_MODULE_ADC, 30, 6); means set ADC volume -30.5db
+ * @param dot:              whether include 0.5. for example Es8388SetAdcDacVolume(ES_MODULE_ADC, 30, 4); means set ADC volume -30db
+ *
+ * @return
+ *     - (-1) Parameter error
+ *     - (0)   Success
+ */
+static int es8388_set_adc_dac_volume(int mode, int volume, int dot)
+{
+    int res = 0;
+    if ( volume < -96 || volume > 0 ) {
+        ESP_LOGW(ES_TAG, "Warning: volume < -96! or > 0!\n");
+        if (volume < -96)
+            volume = -96;
+        else
+            volume = 0;
+    }
+    dot = (dot >= 5 ? 1 : 0);
+    volume = (-volume << 1) + dot;
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL8, volume);
+        res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL9, volume);  //ADC Right Volume=0db
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL5, volume);
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL4, volume);
+    }
+    return res;
+}
+
+
+/**
+ * @brief Power Management
+ *
+ * @param mod:      if ES_POWER_CHIP, the whole chip including ADC and DAC is enabled
+ * @param enable:   false to disable true to enable
+ *
+ * @return
+ *     - (-1)  Error
+ *     - (0)   Success
+ */
+esp_err_t es8388_start(es_module_t mode)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t prev_data = 0, data = 0;
+    es_read_reg(ES8388_DACCONTROL21, &prev_data);
+    if (mode == ES_MODULE_LINE) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x09); // 0x00 audio on LIN1&RIN1,  0x09 LIN2&RIN2 by pass enable
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x50); // left DAC to left mixer enable  and  LIN signal to left mixer enable 0db  : bupass enable
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x50); // right DAC to right mixer enable  and  LIN signal to right mixer enable 0db : bupass enable
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0xC0); //enable adc
+    } else {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80);   //enable dac
+    }
+    es_read_reg(ES8388_DACCONTROL21, &data);
+    if (prev_data != data) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0xF0);   //start state machine
+        // res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, 0x16);
+        // res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0x50);
+        res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0x00);   //start state machine
+    }
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0x00);   //power up adc and line in
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC || mode == ES_MODULE_LINE) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0x3c);   //power up dac and line out
+        res |= es8388_set_voice_mute(false);
+        ESP_LOGD(ES_TAG, "es8388_start default is mode:%d", mode);
+    }
+
+    return res;
+}
+
+/**
+ * @brief Power Management
+ *
+ * @param mod:      if ES_POWER_CHIP, the whole chip including ADC and DAC is enabled
+ * @param enable:   false to disable true to enable
+ *
+ * @return
+ *     - (-1)  Error
+ *     - (0)   Success
+ */
+esp_err_t es8388_stop(es_module_t mode)
+{
+    esp_err_t res = ESP_OK;
+    if (mode == ES_MODULE_LINE) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80); //enable dac
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x00); // 0x00 audio on LIN1&RIN1,  0x09 LIN2&RIN2
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x90); // only left DAC to left mixer enable 0db
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x90); // only right DAC to right mixer enable 0db
+        return res;
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0x00);
+        res |= es8388_set_voice_mute(true); //res |= Es8388SetAdcDacVolume(ES_MODULE_DAC, -96, 5);      // 0db
+        //res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0xC0);  //power down dac and line out
+    }
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        //res |= Es8388SetAdcDacVolume(ES_MODULE_ADC, -96, 5);      // 0db
+        res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0xFF);  //power down adc and line in
+    }
+    if (mode == ES_MODULE_ADC_DAC) {
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x9C);  //disable mclk
+//        res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, 0x00);
+//        res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0x58);
+//        res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0xF3);  //stop state machine
+    }
+
+    return res;
+}
+
+
+/**
+ * @brief Config I2s clock in MSATER mode
+ *
+ * @param cfg.sclkDiv:      generate SCLK by dividing MCLK in MSATER mode
+ * @param cfg.lclkDiv:      generate LCLK by dividing MCLK in MSATER mode
+ *
+ * @return
+ *     - (-1)  Error
+ *     - (0)   Success
+ */
+esp_err_t es8388_i2s_config_clock(es_i2s_clock_t cfg)
+{
+    esp_err_t res = ESP_OK;
+    res |= es_write_reg(ES8388_ADDR, ES8388_MASTERMODE, cfg.sclk_div);
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL5, cfg.lclk_div);  //ADCFsMode,singel SPEED,RATIO=256
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL2, cfg.lclk_div);  //ADCFsMode,singel SPEED,RATIO=256
+    return res;
+}
+
+esp_err_t es8388_deinit(void)
+{
+    int res = 0;
+    res = es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0xFF);  //reset and stop es8388
+    i2c_bus_delete(i2c_handle);
+#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
+    headphone_detect_deinit();
+#endif
+
+    audio_codec_volume_deinit(dac_vol_handle);
+    return res;
+}
+
+/**
+ * @return
+ *     - (-1)  Error
+ *     - (0)   Success
+ */
+esp_err_t es8388_init(audio_hal_codec_config_t *cfg)
+{
+    int res = 0;
+#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
+    headphone_detect_init(get_headphone_detect_gpio());
+#endif
+
+    res = i2c_init(); // ESP32 in master mode
+
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL3, 0x04);  // 0x04 mute/0x00 unmute&ramp;DAC unmute and  disabled digital volume control soft ramp
+    /* Chip Control and Power Management */
+    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0x50);
+    res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0x00); //normal all and power up all
+
+    // Disable the internal DLL to improve 8K sample rate
+    res |= es_write_reg(ES8388_ADDR, 0x35, 0xA0);
+    res |= es_write_reg(ES8388_ADDR, 0x37, 0xD0);
+    res |= es_write_reg(ES8388_ADDR, 0x39, 0xD0);
+
+    res |= es_write_reg(ES8388_ADDR, ES8388_MASTERMODE, cfg->i2s_iface.mode); //CODEC IN I2S SLAVE MODE
+
+    /* dac */
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, 0xC0);  //disable DAC and disable Lout/Rout/1/2
+    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, 0x12);  //Enfr=0,Play&Record Mode,(0x17-both of mic&paly)
+//    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, 0);  //LPVrefBuf=0,Pdn_ana=0
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, 0x18);//1a 0x18:16bit iis , 0x00:24
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL2, 0x02);  //DACFsMode,SINGLE SPEED; DACFsRatio,256
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x00); // 0x00 audio on LIN1&RIN1,  0x09 LIN2&RIN2
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x90); // only left DAC to left mixer enable 0db
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x90); // only right DAC to right mixer enable 0db
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80); // set internal ADC and DAC use the same LRCK clock, ADC LRCK as internal LRCK
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL23, 0x00); // vroi=0
+
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL24, 0x1E); // Set L1 R1 L2 R2 volume. 0x00: -30dB, 0x1E: 0dB, 0x21: 3dB
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL25, 0x1E);
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL26, 0);
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL27, 0);
+    // res |= es8388_set_adc_dac_volume(ES_MODULE_DAC, 0, 0);       // 0db
+    int tmp = 0;
+    if (AUDIO_HAL_DAC_OUTPUT_LINE2 == cfg->dac_output) {
+        tmp = DAC_OUTPUT_LOUT1 | DAC_OUTPUT_ROUT1;
+    } else if (AUDIO_HAL_DAC_OUTPUT_LINE1 == cfg->dac_output) {
+        tmp = DAC_OUTPUT_LOUT2 | DAC_OUTPUT_ROUT2;
+    } else {
+        tmp = DAC_OUTPUT_LOUT1 | DAC_OUTPUT_LOUT2 | DAC_OUTPUT_ROUT1 | DAC_OUTPUT_ROUT2;
+    }
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, tmp);  //0x3c Enable DAC and Enable Lout/Rout/1/2
+    /* adc */
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0xFF);
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL1, 0xbb); // MIC Left and Right channel PGA gain
+    tmp = 0;
+    if (AUDIO_HAL_ADC_INPUT_LINE1 == cfg->adc_input) {
+        tmp = ADC_INPUT_LINPUT1_RINPUT1;
+    } else if (AUDIO_HAL_ADC_INPUT_LINE2 == cfg->adc_input) {
+        tmp = ADC_INPUT_LINPUT2_RINPUT2;
+    } else {
+        tmp = ADC_INPUT_DIFFERENCE;
+    }
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL2, tmp);  //0x00 LINSEL & RINSEL, LIN1/RIN1 as ADC Input; DSSEL,use one DS Reg11; DSR, LINPUT1-RINPUT1
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL3, 0x02);
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, 0x0c); // 16 Bits length and I2S serial audio data format
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL5, 0x02);  //ADCFsMode,singel SPEED,RATIO=256
+    //ALC for Microphone
+    res |= es8388_set_adc_dac_volume(ES_MODULE_ADC, 0, 0);      // 0db
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, 0x09);    // Power on ADC, enable LIN&RIN, power off MICBIAS, and set int1lp to low power mode
+    
+    /* es8388 PA gpio_config */
+    gpio_config_t  io_conf;
+    memset(&io_conf, 0, sizeof(io_conf));
+    io_conf.mode = GPIO_MODE_OUTPUT;
+    io_conf.pin_bit_mask = BIT64(get_pa_enable_gpio());
+    io_conf.pull_down_en = 0;
+    io_conf.pull_up_en = 0;
+    gpio_config(&io_conf);
+    /* enable es8388 PA */
+    es8388_pa_power(true);
+
+    codec_dac_volume_config_t vol_cfg = ES8388_DAC_VOL_CFG_DEFAULT();
+    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
+    ESP_LOGI(ES_TAG, "init,out:%02x, in:%02x", cfg->dac_output, cfg->adc_input);
+    return res;
+}
+
+/**
+ * @brief Configure ES8388 I2S format
+ *
+ * @param mode:           set ADC or DAC or all
+ * @param bitPerSample:   see Es8388I2sFmt
+ *
+ * @return
+ *     - (-1) Error
+ *     - (0)  Success
+ */
+esp_err_t es8388_config_fmt(es_module_t mode, es_i2s_fmt_t fmt)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        res = es_read_reg(ES8388_ADCCONTROL4, &reg);
+        reg = reg & 0xfc;
+        res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, reg | fmt);
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res = es_read_reg(ES8388_DACCONTROL1, &reg);
+        reg = reg & 0xf9;
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, reg | (fmt << 1));
+    }
+    return res;
+}
+
+/**
+ * @brief Set voice volume
+ *
+ * @note Register values. 0xC0: -96 dB, 0x64: -50 dB, 0x00: 0 dB
+ * @note Accuracy of gain is 0.5 dB
+ *
+ * @param volume: voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_set_voice_volume(int volume)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL5, reg);
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL4, reg);
+    ESP_LOGD(ES_TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", (int)dac_vol_handle->user_volume, reg,
+            audio_codec_cal_dac_volume(dac_vol_handle));
+    return res;
+}
+
+esp_err_t es8388_get_voice_volume(int *volume)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    res = es_read_reg(ES8388_DACCONTROL4, &reg);
+    if (res == ESP_FAIL) {
+        *volume = 0;
+    } else {
+        if (reg == dac_vol_handle->reg_value) {
+            *volume = dac_vol_handle->user_volume;
+        } else {
+            *volume = 0;
+            res = ESP_FAIL;
+        }
+    }
+    ESP_LOGD(ES_TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, reg);
+    return res;
+}
+
+/**
+ * @brief Configure ES8388 data sample bits
+ *
+ * @param mode:             set ADC or DAC or all
+ * @param bitPerSample:   see BitsLength
+ *
+ * @return
+ *     - (-1) Parameter error
+ *     - (0)   Success
+ */
+esp_err_t es8388_set_bits_per_sample(es_module_t mode, es_bits_length_t bits_length)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    int bits = (int)bits_length;
+
+    if (mode == ES_MODULE_ADC || mode == ES_MODULE_ADC_DAC) {
+        res = es_read_reg(ES8388_ADCCONTROL4, &reg);
+        reg = reg & 0xe3;
+        res |=  es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, reg | (bits << 2));
+    }
+    if (mode == ES_MODULE_DAC || mode == ES_MODULE_ADC_DAC) {
+        res = es_read_reg(ES8388_DACCONTROL1, &reg);
+        reg = reg & 0xc7;
+        res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, reg | (bits << 3));
+    }
+    return res;
+}
+
+/**
+ * @brief Configure ES8388 DAC mute or not. Basically you can use this function to mute the output or unmute
+ *
+ * @param enable: enable or disable
+ *
+ * @return
+ *     - (-1) Parameter error
+ *     - (0)   Success
+ */
+esp_err_t es8388_set_voice_mute(bool enable)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    res = es_read_reg(ES8388_DACCONTROL3, &reg);
+    reg = reg & 0xFB;
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL3, reg | (((int)enable) << 2));
+    return res;
+}
+
+esp_err_t es8388_get_voice_mute(void)
+{
+    esp_err_t res = ESP_OK;
+    uint8_t reg = 0;
+    res = es_read_reg(ES8388_DACCONTROL3, &reg);
+    if (res == ESP_OK) {
+        reg = (reg & 0x04) >> 2;
+    }
+    return res == ESP_OK ? reg : res;
+}
+
+/**
+ * @param gain: Config DAC Output
+ *
+ * @return
+ *     - (-1) Parameter error
+ *     - (0)   Success
+ */
+esp_err_t es8388_config_dac_output(es_dac_output_t output)
+{
+    esp_err_t res;
+    uint8_t reg = 0;
+    res = es_read_reg(ES8388_DACPOWER, &reg);
+    reg = reg & 0xc3;
+    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, reg | output);
+    return res;
+}
+
+/**
+ * @param gain: Config ADC input
+ *
+ * @return
+ *     - (-1) Parameter error
+ *     - (0)   Success
+ */
+esp_err_t es8388_config_adc_input(es_adc_input_t input)
+{
+    esp_err_t res;
+    uint8_t reg = 0;
+    res = es_read_reg(ES8388_ADCCONTROL2, &reg);
+    reg = reg & 0x0f;
+    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL2, reg | input);
+    return res;
+}
+
+/**
+ * @param gain: see es_mic_gain_t
+ *
+ * @return
+ *     - (-1) Parameter error
+ *     - (0)   Success
+ */
+esp_err_t es8388_set_mic_gain(es_mic_gain_t gain)
+{
+    esp_err_t res, gain_n;
+    gain_n = (int)gain / 3;
+    gain_n = (gain_n << 4) + gain_n;
+    res = es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL1, gain_n); //MIC PGA
+    return res;
+}
+
+int es8388_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    int res = 0;
+    int es_mode_t = 0;
+    switch (mode) {
+        case AUDIO_HAL_CODEC_MODE_ENCODE:
+            es_mode_t  = ES_MODULE_ADC;
+            break;
+        case AUDIO_HAL_CODEC_MODE_LINE_IN:
+            es_mode_t  = ES_MODULE_LINE;
+            break;
+        case AUDIO_HAL_CODEC_MODE_DECODE:
+            es_mode_t  = ES_MODULE_DAC;
+            break;
+        case AUDIO_HAL_CODEC_MODE_BOTH:
+            es_mode_t  = ES_MODULE_ADC_DAC;
+            break;
+        default:
+            es_mode_t = ES_MODULE_DAC;
+            ESP_LOGW(ES_TAG, "Codec mode not support, default is decode mode");
+            break;
+    }
+    if (AUDIO_HAL_CTRL_STOP == ctrl_state) {
+        res = es8388_stop(es_mode_t);
+    } else {
+        res = es8388_start(es_mode_t);
+        ESP_LOGD(ES_TAG, "start default is decode mode:%d", es_mode_t);
+    }
+    return res;
+}
+
+esp_err_t es8388_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    esp_err_t res = ESP_OK;
+    int tmp = 0;
+    res |= es8388_config_fmt(ES_MODULE_ADC_DAC, iface->fmt);
+    if (iface->bits == AUDIO_HAL_BIT_LENGTH_16BITS) {
+        tmp = BIT_LENGTH_16BITS;
+    } else if (iface->bits == AUDIO_HAL_BIT_LENGTH_24BITS) {
+        tmp = BIT_LENGTH_24BITS;
+    } else {
+        tmp = BIT_LENGTH_32BITS;
+    }
+    res |= es8388_set_bits_per_sample(ES_MODULE_ADC_DAC, tmp);
+    return res;
+}
+
+esp_err_t es8388_pa_power(bool enable)
+{
+    esp_err_t res = ESP_OK;
+    if (enable) {
+        res = gpio_set_level(get_pa_enable_gpio(), 1);
+    } else {
+        res = gpio_set_level(get_pa_enable_gpio(), 0);
+    }
+    return res;
+}
diff --git a/components/audio_hal/driver/es8388/es8388.h b/components/audio_hal/driver/es8388/es8388.h
old mode 100755
new mode 100644
index 3015aad4..275414fa
--- a/components/audio_hal/driver/es8388/es8388.h
+++ b/components/audio_hal/driver/es8388/es8388.h
@@ -1,310 +1,310 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __ES8388_H__
-#define __ES8388_H__
-
-#include "esp_types.h"
-#include "audio_hal.h"
-#include "driver/i2c.h"
-#include "esxxx_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* ES8388 address */
-#define ES8388_ADDR 0x20  /*!< 0x22:CE=1;0x20:CE=0*/
-
-/* ES8388 register */
-#define ES8388_CONTROL1         0x00
-#define ES8388_CONTROL2         0x01
-
-#define ES8388_CHIPPOWER        0x02
-
-#define ES8388_ADCPOWER         0x03
-#define ES8388_DACPOWER         0x04
-
-#define ES8388_CHIPLOPOW1       0x05
-#define ES8388_CHIPLOPOW2       0x06
-
-#define ES8388_ANAVOLMANAG      0x07
-
-#define ES8388_MASTERMODE       0x08
-/* ADC */
-#define ES8388_ADCCONTROL1      0x09
-#define ES8388_ADCCONTROL2      0x0a
-#define ES8388_ADCCONTROL3      0x0b
-#define ES8388_ADCCONTROL4      0x0c
-#define ES8388_ADCCONTROL5      0x0d
-#define ES8388_ADCCONTROL6      0x0e
-#define ES8388_ADCCONTROL7      0x0f
-#define ES8388_ADCCONTROL8      0x10
-#define ES8388_ADCCONTROL9      0x11
-#define ES8388_ADCCONTROL10     0x12
-#define ES8388_ADCCONTROL11     0x13
-#define ES8388_ADCCONTROL12     0x14
-#define ES8388_ADCCONTROL13     0x15
-#define ES8388_ADCCONTROL14     0x16
-/* DAC */
-#define ES8388_DACCONTROL1      0x17
-#define ES8388_DACCONTROL2      0x18
-#define ES8388_DACCONTROL3      0x19
-#define ES8388_DACCONTROL4      0x1a
-#define ES8388_DACCONTROL5      0x1b
-#define ES8388_DACCONTROL6      0x1c
-#define ES8388_DACCONTROL7      0x1d
-#define ES8388_DACCONTROL8      0x1e
-#define ES8388_DACCONTROL9      0x1f
-#define ES8388_DACCONTROL10     0x20
-#define ES8388_DACCONTROL11     0x21
-#define ES8388_DACCONTROL12     0x22
-#define ES8388_DACCONTROL13     0x23
-#define ES8388_DACCONTROL14     0x24
-#define ES8388_DACCONTROL15     0x25
-#define ES8388_DACCONTROL16     0x26
-#define ES8388_DACCONTROL17     0x27
-#define ES8388_DACCONTROL18     0x28
-#define ES8388_DACCONTROL19     0x29
-#define ES8388_DACCONTROL20     0x2a
-#define ES8388_DACCONTROL21     0x2b
-#define ES8388_DACCONTROL22     0x2c
-#define ES8388_DACCONTROL23     0x2d
-#define ES8388_DACCONTROL24     0x2e
-#define ES8388_DACCONTROL25     0x2f
-#define ES8388_DACCONTROL26     0x30
-#define ES8388_DACCONTROL27     0x31
-#define ES8388_DACCONTROL28     0x32
-#define ES8388_DACCONTROL29     0x33
-#define ES8388_DACCONTROL30     0x34
-
-/**
- * @brief Initialize ES8388 codec chip
- *
- * @param cfg configuration of ES8388
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_init(audio_hal_codec_config_t *cfg);
-
-/**
- * @brief Deinitialize ES8388 codec chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_deinit(void);
-
-/**
- * @brief Configure ES8388 I2S format
- *
- * @param mod:  set ADC or DAC or both
- * @param cfg:   ES8388 I2S format
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_config_fmt(es_module_t mod, es_i2s_fmt_t cfg);
-
-/**
- * @brief Configure I2s clock in MSATER mode
- *
- * @param cfg:  set bits clock and WS clock
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_i2s_config_clock(es_i2s_clock_t cfg);
-
-/**
- * @brief Configure ES8388 data sample bits
- *
- * @param mode:  set ADC or DAC or both
- * @param bit_per_sample:  bit number of per sample
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_set_bits_per_sample(es_module_t mode, es_bits_length_t bit_per_sample);
-
-/**
- * @brief  Start ES8388 codec chip
- *
- * @param mode:  set ADC or DAC or both
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_start(es_module_t mode);
-
-/**
- * @brief  Stop ES8388 codec chip
- *
- * @param mode:  set ADC or DAC or both
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_stop(es_module_t mode);
-
-/**
- * @brief  Set voice volume
- *
- * @param volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_set_voice_volume(int volume);
-
-/**
- * @brief Get voice volume
- *
- * @param[out] *volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t es8388_get_voice_volume(int *volume);
-
-/**
- * @brief Configure ES8388 DAC mute or not. Basically you can use this function to mute the output or unmute
- *
- * @param enable enable(1) or disable(0)
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_set_voice_mute(bool enable);
-
-/**
- * @brief Get ES8388 DAC mute status
- *
- *  @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_get_voice_mute(void);
-
-/**
- * @brief Set ES8388 mic gain
- *
- * @param gain db of mic gain
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_set_mic_gain(es_mic_gain_t gain);
-
-/**
- * @brief Set ES8388 adc input mode
- *
- * @param input adc input mode
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_config_adc_input(es_adc_input_t input);
-
-/**
- * @brief Set ES8388 dac output mode
- *
- * @param output dac output mode
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_config_dac_output(es_dac_output_t output);
-
-/**
- * @brief Write ES8388 register
- *
- * @param reg_add address of register
- * @param data data of register
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_write_reg(uint8_t reg_add, uint8_t data);
-
-/**
- * @brief  Print all ES8388 registers
- */
-void es8388_read_all(void);
-
-/**
- * @brief Configure ES8388 codec mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief Control ES8388 codec chip
- *
- * @param mode codec mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t es8388_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-
-/**
- * @brief Set ES8388 PA power
- *
- * @param enable true for enable PA power, false for disable PA power
- *
- * @return
- *     - ESP_ERR_INVALID_ARG
- *     - ESP_OK
- */
-esp_err_t es8388_pa_power(bool enable);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //__ES8388_H__
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __ES8388_H__
+#define __ES8388_H__
+
+#include "esp_types.h"
+#include "audio_hal.h"
+#include "driver/i2c.h"
+#include "esxxx_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ES8388 address */
+#define ES8388_ADDR 0x20  /*!< 0x22:CE=1;0x20:CE=0*/
+
+/* ES8388 register */
+#define ES8388_CONTROL1         0x00
+#define ES8388_CONTROL2         0x01
+
+#define ES8388_CHIPPOWER        0x02
+
+#define ES8388_ADCPOWER         0x03
+#define ES8388_DACPOWER         0x04
+
+#define ES8388_CHIPLOPOW1       0x05
+#define ES8388_CHIPLOPOW2       0x06
+
+#define ES8388_ANAVOLMANAG      0x07
+
+#define ES8388_MASTERMODE       0x08
+/* ADC */
+#define ES8388_ADCCONTROL1      0x09
+#define ES8388_ADCCONTROL2      0x0a
+#define ES8388_ADCCONTROL3      0x0b
+#define ES8388_ADCCONTROL4      0x0c
+#define ES8388_ADCCONTROL5      0x0d
+#define ES8388_ADCCONTROL6      0x0e
+#define ES8388_ADCCONTROL7      0x0f
+#define ES8388_ADCCONTROL8      0x10
+#define ES8388_ADCCONTROL9      0x11
+#define ES8388_ADCCONTROL10     0x12
+#define ES8388_ADCCONTROL11     0x13
+#define ES8388_ADCCONTROL12     0x14
+#define ES8388_ADCCONTROL13     0x15
+#define ES8388_ADCCONTROL14     0x16
+/* DAC */
+#define ES8388_DACCONTROL1      0x17
+#define ES8388_DACCONTROL2      0x18
+#define ES8388_DACCONTROL3      0x19
+#define ES8388_DACCONTROL4      0x1a
+#define ES8388_DACCONTROL5      0x1b
+#define ES8388_DACCONTROL6      0x1c
+#define ES8388_DACCONTROL7      0x1d
+#define ES8388_DACCONTROL8      0x1e
+#define ES8388_DACCONTROL9      0x1f
+#define ES8388_DACCONTROL10     0x20
+#define ES8388_DACCONTROL11     0x21
+#define ES8388_DACCONTROL12     0x22
+#define ES8388_DACCONTROL13     0x23
+#define ES8388_DACCONTROL14     0x24
+#define ES8388_DACCONTROL15     0x25
+#define ES8388_DACCONTROL16     0x26
+#define ES8388_DACCONTROL17     0x27
+#define ES8388_DACCONTROL18     0x28
+#define ES8388_DACCONTROL19     0x29
+#define ES8388_DACCONTROL20     0x2a
+#define ES8388_DACCONTROL21     0x2b
+#define ES8388_DACCONTROL22     0x2c
+#define ES8388_DACCONTROL23     0x2d
+#define ES8388_DACCONTROL24     0x2e
+#define ES8388_DACCONTROL25     0x2f
+#define ES8388_DACCONTROL26     0x30
+#define ES8388_DACCONTROL27     0x31
+#define ES8388_DACCONTROL28     0x32
+#define ES8388_DACCONTROL29     0x33
+#define ES8388_DACCONTROL30     0x34
+
+/**
+ * @brief Initialize ES8388 codec chip
+ *
+ * @param cfg configuration of ES8388
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_init(audio_hal_codec_config_t *cfg);
+
+/**
+ * @brief Deinitialize ES8388 codec chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_deinit(void);
+
+/**
+ * @brief Configure ES8388 I2S format
+ *
+ * @param mod:  set ADC or DAC or both
+ * @param cfg:   ES8388 I2S format
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_config_fmt(es_module_t mod, es_i2s_fmt_t cfg);
+
+/**
+ * @brief Configure I2s clock in MSATER mode
+ *
+ * @param cfg:  set bits clock and WS clock
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_i2s_config_clock(es_i2s_clock_t cfg);
+
+/**
+ * @brief Configure ES8388 data sample bits
+ *
+ * @param mode:  set ADC or DAC or both
+ * @param bit_per_sample:  bit number of per sample
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_set_bits_per_sample(es_module_t mode, es_bits_length_t bit_per_sample);
+
+/**
+ * @brief  Start ES8388 codec chip
+ *
+ * @param mode:  set ADC or DAC or both
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_start(es_module_t mode);
+
+/**
+ * @brief  Stop ES8388 codec chip
+ *
+ * @param mode:  set ADC or DAC or both
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_stop(es_module_t mode);
+
+/**
+ * @brief  Set voice volume
+ *
+ * @param volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_set_voice_volume(int volume);
+
+/**
+ * @brief Get voice volume
+ *
+ * @param[out] *volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t es8388_get_voice_volume(int *volume);
+
+/**
+ * @brief Configure ES8388 DAC mute or not. Basically you can use this function to mute the output or unmute
+ *
+ * @param enable enable(1) or disable(0)
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_set_voice_mute(bool enable);
+
+/**
+ * @brief Get ES8388 DAC mute status
+ *
+ *  @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_get_voice_mute(void);
+
+/**
+ * @brief Set ES8388 mic gain
+ *
+ * @param gain db of mic gain
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_set_mic_gain(es_mic_gain_t gain);
+
+/**
+ * @brief Set ES8388 adc input mode
+ *
+ * @param input adc input mode
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_config_adc_input(es_adc_input_t input);
+
+/**
+ * @brief Set ES8388 dac output mode
+ *
+ * @param output dac output mode
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_config_dac_output(es_dac_output_t output);
+
+/**
+ * @brief Write ES8388 register
+ *
+ * @param reg_add address of register
+ * @param data data of register
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_write_reg(uint8_t reg_add, uint8_t data);
+
+/**
+ * @brief  Print all ES8388 registers
+ */
+void es8388_read_all(void);
+
+/**
+ * @brief Configure ES8388 codec mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief Control ES8388 codec chip
+ *
+ * @param mode codec mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t es8388_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+
+/**
+ * @brief Set ES8388 PA power
+ *
+ * @param enable true for enable PA power, false for disable PA power
+ *
+ * @return
+ *     - ESP_ERR_INVALID_ARG
+ *     - ESP_OK
+ */
+esp_err_t es8388_pa_power(bool enable);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__ES8388_H__
diff --git a/components/audio_hal/driver/es8388/headphone_detect.c b/components/audio_hal/driver/es8388/headphone_detect.c
index a97aeeb1..591632c6 100644
--- a/components/audio_hal/driver/es8388/headphone_detect.c
+++ b/components/audio_hal/driver/es8388/headphone_detect.c
@@ -1,98 +1,98 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/queue.h"
-#include "freertos/timers.h"
-#include "driver/gpio.h"
-#include "esp_log.h"
-#include "es8388.h"
-#include "board.h"
-
-
-#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
-
-#define HP_DELAY_TIME_MS       1000
-
-static const char *TAG = "HEADPHONE";
-static xTimerHandle timer_headphone;
-
-static void hp_timer_cb(TimerHandle_t xTimer)
-{
-    int num = (int)pvTimerGetTimerID(xTimer);
-    int res = gpio_get_level(num);
-    es8388_pa_power(res);
-}
-
-static int hp_timer_init(int num)
-{
-    timer_headphone = xTimerCreate("hp_timer0", HP_DELAY_TIME_MS / portTICK_RATE_MS, pdFALSE, (void *) num, hp_timer_cb);
-    if (timer_headphone == NULL) {
-        ESP_LOGE(TAG, "hp_timer create err");
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-static void IRAM_ATTR headphone_gpio_intr_handler(void *arg)
-{
-    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
-    xTimerResetFromISR(timer_headphone, &xHigherPriorityTaskWoken);
-    if ( xHigherPriorityTaskWoken != pdFALSE ) {
-        portYIELD_FROM_ISR();
-    }
-}
-
-void headphone_detect_deinit()
-{
-    xTimerDelete(timer_headphone, HP_DELAY_TIME_MS / portTICK_RATE_MS);
-    gpio_uninstall_isr_service();
-    timer_headphone = NULL;
-}
-
-int headphone_status_get()
-{
-    return gpio_get_level(get_headphone_detect_gpio());
-}
-
-void headphone_detect_init(int num)
-{
-    hp_timer_init(num);
-    gpio_config_t  io_conf;
-    memset(&io_conf, 0, sizeof(io_conf));
-    io_conf.intr_type = GPIO_INTR_ANYEDGE;
-    io_conf.mode = GPIO_MODE_INPUT;
-    io_conf.pin_bit_mask = BIT64(num);
-    io_conf.pull_down_en = 0;
-    io_conf.pull_up_en = 1;
-    gpio_config(&io_conf);
-
-    gpio_install_isr_service(0);
-    gpio_isr_handler_add(num, headphone_gpio_intr_handler, (void *)num);
-}
-#endif /* CONFIG_ESP_LYRAT_V4_3_BOARD */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/queue.h"
+#include "freertos/timers.h"
+#include "driver/gpio.h"
+#include "esp_log.h"
+#include "es8388.h"
+#include "board.h"
+
+
+#ifdef CONFIG_ESP_LYRAT_V4_3_BOARD
+
+#define HP_DELAY_TIME_MS       1000
+
+static const char *TAG = "HEADPHONE";
+static TimerHandle_t timer_headphone;
+
+static void hp_timer_cb(TimerHandle_t xTimer)
+{
+    int num = (int)pvTimerGetTimerID(xTimer);
+    int res = gpio_get_level(num);
+    es8388_pa_power(res);
+}
+
+static int hp_timer_init(int num)
+{
+    timer_headphone = xTimerCreate("hp_timer0", HP_DELAY_TIME_MS / portTICK_PERIOD_MS, pdFALSE, (void *) num, hp_timer_cb);
+    if (timer_headphone == NULL) {
+        ESP_LOGE(TAG, "hp_timer create err");
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+static void IRAM_ATTR headphone_gpio_intr_handler(void *arg)
+{
+    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+    xTimerResetFromISR(timer_headphone, &xHigherPriorityTaskWoken);
+    if ( xHigherPriorityTaskWoken != pdFALSE ) {
+        portYIELD_FROM_ISR();
+    }
+}
+
+void headphone_detect_deinit()
+{
+    xTimerDelete(timer_headphone, HP_DELAY_TIME_MS / portTICK_PERIOD_MS);
+    gpio_uninstall_isr_service();
+    timer_headphone = NULL;
+}
+
+int headphone_status_get()
+{
+    return gpio_get_level(get_headphone_detect_gpio());
+}
+
+void headphone_detect_init(int num)
+{
+    hp_timer_init(num);
+    gpio_config_t  io_conf;
+    memset(&io_conf, 0, sizeof(io_conf));
+    io_conf.intr_type = GPIO_INTR_ANYEDGE;
+    io_conf.mode = GPIO_MODE_INPUT;
+    io_conf.pin_bit_mask = BIT64(num);
+    io_conf.pull_down_en = 0;
+    io_conf.pull_up_en = 1;
+    gpio_config(&io_conf);
+
+    gpio_install_isr_service(0);
+    gpio_isr_handler_add(num, headphone_gpio_intr_handler, (void *)num);
+}
+#endif /* CONFIG_ESP_LYRAT_V4_3_BOARD */
diff --git a/components/audio_hal/driver/es8388/headphone_detect.h b/components/audio_hal/driver/es8388/headphone_detect.h
index 2ee97e73..16c22028 100644
--- a/components/audio_hal/driver/es8388/headphone_detect.h
+++ b/components/audio_hal/driver/es8388/headphone_detect.h
@@ -1,64 +1,64 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_HEADPHONE_DETECT_H_
-#define _AUDIO_HEADPHONE_DETECT_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Get headphone insertion status
- *
- * @param None.
- *
- * @return  int, 0:headphone inserted, 1:headphone not inserted.
- */
-int headphone_status_get();
-
-/**
- * @brief Initialize headphone detect gpio.
- *
- * @param None.
- *
- * @return None.
- */
-void headphone_detect_init(int num);
-
-/**
- * @brief Delete headphone detect timer.
- *
- * @param None.
- *
- * @return None.
- */
-void headphone_detect_deinit();
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_HEADPHONE_DETECT_H_
+#define _AUDIO_HEADPHONE_DETECT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Get headphone insertion status
+ *
+ * @param None.
+ *
+ * @return  int, 0:headphone inserted, 1:headphone not inserted.
+ */
+int headphone_status_get();
+
+/**
+ * @brief Initialize headphone detect gpio.
+ *
+ * @param None.
+ *
+ * @return None.
+ */
+void headphone_detect_init(int num);
+
+/**
+ * @brief Delete headphone detect timer.
+ *
+ * @param None.
+ *
+ * @return None.
+ */
+void headphone_detect_deinit();
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/include/esxxx_common.h b/components/audio_hal/driver/include/esxxx_common.h
index 34c042ed..11793a66 100644
--- a/components/audio_hal/driver/include/esxxx_common.h
+++ b/components/audio_hal/driver/include/esxxx_common.h
@@ -1,188 +1,188 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ESXXX_COMMON_H_
-#define _ESXXX_COMMON_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum {
-    BIT_LENGTH_MIN = -1,
-    BIT_LENGTH_16BITS = 0x03,
-    BIT_LENGTH_18BITS = 0x02,
-    BIT_LENGTH_20BITS = 0x01,
-    BIT_LENGTH_24BITS = 0x00,
-    BIT_LENGTH_32BITS = 0x04,
-    BIT_LENGTH_MAX,
-} es_bits_length_t;
-
-typedef enum {
-    MCLK_DIV_MIN = -1,
-    MCLK_DIV_1 = 1,
-    MCLK_DIV_2 = 2,
-    MCLK_DIV_3 = 3,
-    MCLK_DIV_4 = 4,
-    MCLK_DIV_6 = 5,
-    MCLK_DIV_8 = 6,
-    MCLK_DIV_9 = 7,
-    MCLK_DIV_11 = 8,
-    MCLK_DIV_12 = 9,
-    MCLK_DIV_16 = 10,
-    MCLK_DIV_18 = 11,
-    MCLK_DIV_22 = 12,
-    MCLK_DIV_24 = 13,
-    MCLK_DIV_33 = 14,
-    MCLK_DIV_36 = 15,
-    MCLK_DIV_44 = 16,
-    MCLK_DIV_48 = 17,
-    MCLK_DIV_66 = 18,
-    MCLK_DIV_72 = 19,
-    MCLK_DIV_5 = 20,
-    MCLK_DIV_10 = 21,
-    MCLK_DIV_15 = 22,
-    MCLK_DIV_17 = 23,
-    MCLK_DIV_20 = 24,
-    MCLK_DIV_25 = 25,
-    MCLK_DIV_30 = 26,
-    MCLK_DIV_32 = 27,
-    MCLK_DIV_34 = 28,
-    MCLK_DIV_7  = 29,
-    MCLK_DIV_13 = 30,
-    MCLK_DIV_14 = 31,
-    MCLK_DIV_MAX,
-} es_sclk_div_t;
-
-typedef enum {
-    LCLK_DIV_MIN = -1,
-    LCLK_DIV_128 = 0,
-    LCLK_DIV_192 = 1,
-    LCLK_DIV_256 = 2,
-    LCLK_DIV_384 = 3,
-    LCLK_DIV_512 = 4,
-    LCLK_DIV_576 = 5,
-    LCLK_DIV_768 = 6,
-    LCLK_DIV_1024 = 7,
-    LCLK_DIV_1152 = 8,
-    LCLK_DIV_1408 = 9,
-    LCLK_DIV_1536 = 10,
-    LCLK_DIV_2112 = 11,
-    LCLK_DIV_2304 = 12,
-
-    LCLK_DIV_125 = 16,
-    LCLK_DIV_136 = 17,
-    LCLK_DIV_250 = 18,
-    LCLK_DIV_272 = 19,
-    LCLK_DIV_375 = 20,
-    LCLK_DIV_500 = 21,
-    LCLK_DIV_544 = 22,
-    LCLK_DIV_750 = 23,
-    LCLK_DIV_1000 = 24,
-    LCLK_DIV_1088 = 25,
-    LCLK_DIV_1496 = 26,
-    LCLK_DIV_1500 = 27,
-    LCLK_DIV_MAX,
-} es_lclk_div_t;
-
-typedef enum {
-    D2SE_PGA_GAIN_MIN = -1,
-    D2SE_PGA_GAIN_DIS = 0,
-    D2SE_PGA_GAIN_EN = 1,
-    D2SE_PGA_GAIN_MAX = 2,
-} es_d2se_pga_t;
-
-typedef enum {
-    ADC_INPUT_MIN = -1,
-    ADC_INPUT_LINPUT1_RINPUT1 = 0x00,
-    ADC_INPUT_MIC1  = 0x05,
-    ADC_INPUT_MIC2  = 0x06,
-    ADC_INPUT_LINPUT2_RINPUT2 = 0x50,
-    ADC_INPUT_DIFFERENCE = 0xf0,
-    ADC_INPUT_MAX,
-} es_adc_input_t;
-
-typedef enum {
-    DAC_OUTPUT_MIN = -1,
-    DAC_OUTPUT_LOUT1 = 0x04,
-    DAC_OUTPUT_LOUT2 = 0x08,
-    DAC_OUTPUT_SPK   = 0x09,
-    DAC_OUTPUT_ROUT1 = 0x10,
-    DAC_OUTPUT_ROUT2 = 0x20,
-    DAC_OUTPUT_ALL = 0x3c,
-    DAC_OUTPUT_MAX,
-} es_dac_output_t;
-
-typedef enum {
-    MIC_GAIN_MIN = -1,
-    MIC_GAIN_0DB = 0,
-    MIC_GAIN_3DB = 3,
-    MIC_GAIN_6DB = 6,
-    MIC_GAIN_9DB = 9,
-    MIC_GAIN_12DB = 12,
-    MIC_GAIN_15DB = 15,
-    MIC_GAIN_18DB = 18,
-    MIC_GAIN_21DB = 21,
-    MIC_GAIN_24DB = 24,
-    MIC_GAIN_MAX,
-} es_mic_gain_t;
-
-typedef enum {
-    ES_MODULE_MIN = -1,
-    ES_MODULE_ADC = 0x01,
-    ES_MODULE_DAC = 0x02,
-    ES_MODULE_ADC_DAC = 0x03,
-    ES_MODULE_LINE = 0x04,
-    ES_MODULE_MAX
-} es_module_t;
-
-typedef enum {
-    ES_MODE_MIN = -1,
-    ES_MODE_SLAVE = 0x00,
-    ES_MODE_MASTER = 0x01,
-    ES_MODE_MAX,
-} es_mode_t;
-
-typedef enum {
-    ES_I2S_MIN = -1,
-    ES_I2S_NORMAL = 0,
-    ES_I2S_LEFT = 1,
-    ES_I2S_RIGHT = 2,
-    ES_I2S_DSP = 3,
-    ES_I2S_MAX
-} es_i2s_fmt_t;
-
-/**
- * @brief Configure ES8388 clock
- */
-typedef struct {
-    es_sclk_div_t sclk_div;    /*!< bits clock divide */
-    es_lclk_div_t lclk_div;    /*!< WS clock divide */
-} es_i2s_clock_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ESXXX_COMMON_H_
+#define _ESXXX_COMMON_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    BIT_LENGTH_MIN = -1,
+    BIT_LENGTH_16BITS = 0x03,
+    BIT_LENGTH_18BITS = 0x02,
+    BIT_LENGTH_20BITS = 0x01,
+    BIT_LENGTH_24BITS = 0x00,
+    BIT_LENGTH_32BITS = 0x04,
+    BIT_LENGTH_MAX,
+} es_bits_length_t;
+
+typedef enum {
+    MCLK_DIV_MIN = -1,
+    MCLK_DIV_1 = 1,
+    MCLK_DIV_2 = 2,
+    MCLK_DIV_3 = 3,
+    MCLK_DIV_4 = 4,
+    MCLK_DIV_6 = 5,
+    MCLK_DIV_8 = 6,
+    MCLK_DIV_9 = 7,
+    MCLK_DIV_11 = 8,
+    MCLK_DIV_12 = 9,
+    MCLK_DIV_16 = 10,
+    MCLK_DIV_18 = 11,
+    MCLK_DIV_22 = 12,
+    MCLK_DIV_24 = 13,
+    MCLK_DIV_33 = 14,
+    MCLK_DIV_36 = 15,
+    MCLK_DIV_44 = 16,
+    MCLK_DIV_48 = 17,
+    MCLK_DIV_66 = 18,
+    MCLK_DIV_72 = 19,
+    MCLK_DIV_5 = 20,
+    MCLK_DIV_10 = 21,
+    MCLK_DIV_15 = 22,
+    MCLK_DIV_17 = 23,
+    MCLK_DIV_20 = 24,
+    MCLK_DIV_25 = 25,
+    MCLK_DIV_30 = 26,
+    MCLK_DIV_32 = 27,
+    MCLK_DIV_34 = 28,
+    MCLK_DIV_7  = 29,
+    MCLK_DIV_13 = 30,
+    MCLK_DIV_14 = 31,
+    MCLK_DIV_MAX,
+} es_sclk_div_t;
+
+typedef enum {
+    LCLK_DIV_MIN = -1,
+    LCLK_DIV_128 = 0,
+    LCLK_DIV_192 = 1,
+    LCLK_DIV_256 = 2,
+    LCLK_DIV_384 = 3,
+    LCLK_DIV_512 = 4,
+    LCLK_DIV_576 = 5,
+    LCLK_DIV_768 = 6,
+    LCLK_DIV_1024 = 7,
+    LCLK_DIV_1152 = 8,
+    LCLK_DIV_1408 = 9,
+    LCLK_DIV_1536 = 10,
+    LCLK_DIV_2112 = 11,
+    LCLK_DIV_2304 = 12,
+
+    LCLK_DIV_125 = 16,
+    LCLK_DIV_136 = 17,
+    LCLK_DIV_250 = 18,
+    LCLK_DIV_272 = 19,
+    LCLK_DIV_375 = 20,
+    LCLK_DIV_500 = 21,
+    LCLK_DIV_544 = 22,
+    LCLK_DIV_750 = 23,
+    LCLK_DIV_1000 = 24,
+    LCLK_DIV_1088 = 25,
+    LCLK_DIV_1496 = 26,
+    LCLK_DIV_1500 = 27,
+    LCLK_DIV_MAX,
+} es_lclk_div_t;
+
+typedef enum {
+    D2SE_PGA_GAIN_MIN = -1,
+    D2SE_PGA_GAIN_DIS = 0,
+    D2SE_PGA_GAIN_EN = 1,
+    D2SE_PGA_GAIN_MAX = 2,
+} es_d2se_pga_t;
+
+typedef enum {
+    ADC_INPUT_MIN = -1,
+    ADC_INPUT_LINPUT1_RINPUT1 = 0x00,
+    ADC_INPUT_MIC1  = 0x05,
+    ADC_INPUT_MIC2  = 0x06,
+    ADC_INPUT_LINPUT2_RINPUT2 = 0x50,
+    ADC_INPUT_DIFFERENCE = 0xf0,
+    ADC_INPUT_MAX,
+} es_adc_input_t;
+
+typedef enum {
+    DAC_OUTPUT_MIN = -1,
+    DAC_OUTPUT_LOUT1 = 0x04,
+    DAC_OUTPUT_LOUT2 = 0x08,
+    DAC_OUTPUT_SPK   = 0x09,
+    DAC_OUTPUT_ROUT1 = 0x10,
+    DAC_OUTPUT_ROUT2 = 0x20,
+    DAC_OUTPUT_ALL = 0x3c,
+    DAC_OUTPUT_MAX,
+} es_dac_output_t;
+
+typedef enum {
+    MIC_GAIN_MIN = -1,
+    MIC_GAIN_0DB = 0,
+    MIC_GAIN_3DB = 3,
+    MIC_GAIN_6DB = 6,
+    MIC_GAIN_9DB = 9,
+    MIC_GAIN_12DB = 12,
+    MIC_GAIN_15DB = 15,
+    MIC_GAIN_18DB = 18,
+    MIC_GAIN_21DB = 21,
+    MIC_GAIN_24DB = 24,
+    MIC_GAIN_MAX,
+} es_mic_gain_t;
+
+typedef enum {
+    ES_MODULE_MIN = -1,
+    ES_MODULE_ADC = 0x01,
+    ES_MODULE_DAC = 0x02,
+    ES_MODULE_ADC_DAC = 0x03,
+    ES_MODULE_LINE = 0x04,
+    ES_MODULE_MAX
+} es_module_t;
+
+typedef enum {
+    ES_MODE_MIN = -1,
+    ES_MODE_SLAVE = 0x00,
+    ES_MODE_MASTER = 0x01,
+    ES_MODE_MAX,
+} es_mode_t;
+
+typedef enum {
+    ES_I2S_MIN = -1,
+    ES_I2S_NORMAL = 0,
+    ES_I2S_LEFT = 1,
+    ES_I2S_RIGHT = 2,
+    ES_I2S_DSP = 3,
+    ES_I2S_MAX
+} es_i2s_fmt_t;
+
+/**
+ * @brief Configure ES8388 clock
+ */
+typedef struct {
+    es_sclk_div_t sclk_div;    /*!< bits clock divide */
+    es_lclk_div_t lclk_div;    /*!< WS clock divide */
+} es_i2s_clock_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/tas5805m/tas5805m.c b/components/audio_hal/driver/tas5805m/tas5805m.c
index fef4fe3c..8f9be664 100644
--- a/components/audio_hal/driver/tas5805m/tas5805m.c
+++ b/components/audio_hal/driver/tas5805m/tas5805m.c
@@ -1,292 +1,292 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "i2c_bus.h"
-#include "board.h"
-#include "esp_log.h"
-#include "tas5805m.h"
-#include "tas5805m_reg_cfg.h"
-#include "audio_volume.h"
-
-static const char *TAG = "TAS5805M";
-
-#define TAS5805M_ADDR          0x5c
-#define TAS5805M_RST_GPIO      get_pa_enable_gpio()
-
-#define TAS5805M_ASSERT(a, format, b, ...) \
-    if ((a) != 0) { \
-        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
-        return b;\
-    }
-
-esp_err_t tas5805m_ctrl(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-esp_err_t tas5805m_config_iface(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-static i2c_bus_handle_t     i2c_handler;
-static codec_dac_volume_config_t *dac_vol_handle;
-
-#define TAS5805M_DAC_VOL_CFG_DEFAULT() {                     \
-    .max_dac_volume = 24,                                    \
-    .min_dac_volume = -103,                                  \
-    .board_pa_gain = BOARD_PA_GAIN,                          \
-    .volume_accuracy = 0.5,                                  \
-    .dac_vol_symbol = -1,                                    \
-    .zero_volume_reg = 0x30,                                 \
-    .reg_value = 0,                                          \
-    .user_volume = 0,                                        \
-    .offset_conv_volume = NULL,                              \
-}
-
-/*
- * i2c default configuration
- */
-static i2c_config_t i2c_cfg = {
-    .mode = I2C_MODE_MASTER,
-    .sda_pullup_en = GPIO_PULLUP_ENABLE,
-    .scl_pullup_en = GPIO_PULLUP_ENABLE,
-    .master.clk_speed = 100000,
-};
-
-/*
- * Operate fuction of PA
- */
-audio_hal_func_t AUDIO_CODEC_TAS5805M_DEFAULT_HANDLE = {
-    .audio_codec_initialize = tas5805m_init,
-    .audio_codec_deinitialize = tas5805m_deinit,
-    .audio_codec_ctrl = tas5805m_ctrl,
-    .audio_codec_config_iface = tas5805m_config_iface,
-    .audio_codec_set_mute = tas5805m_set_mute,
-    .audio_codec_set_volume = tas5805m_set_volume,
-    .audio_codec_get_volume = tas5805m_get_volume,
-    .audio_codec_enable_pa = NULL,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static esp_err_t tas5805m_transmit_registers(const tas5805m_cfg_reg_t *conf_buf, int size)
-{
-    int i = 0;
-    esp_err_t ret = ESP_OK;
-    while (i < size) {
-        switch (conf_buf[i].offset) {
-            case CFG_META_SWITCH:
-                // Used in legacy applications.  Ignored here.
-                break;
-            case CFG_META_DELAY:
-                vTaskDelay(conf_buf[i].value / portTICK_RATE_MS);
-                break;
-            case CFG_META_BURST:
-                ret = i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, (unsigned char *)(&conf_buf[i + 1].offset), 1, (unsigned char *)(&conf_buf[i + 1].value), conf_buf[i].value);
-                i +=  (conf_buf[i].value / 2) + 1;
-                break;
-            case CFG_END_1:
-                if (CFG_END_2 == conf_buf[i + 1].offset && CFG_END_3 == conf_buf[i + 2].offset) {
-                    ESP_LOGI(TAG, "End of tms5805m reg: %d\n", i);
-                }
-                break;
-            default:
-                ret = i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, (unsigned char *)(&conf_buf[i].offset), 1, (unsigned char *)(&conf_buf[i].value), 1);
-                break;
-        }
-        i++;
-    }
-    if (ret != ESP_OK) {
-        ESP_LOGE(TAG, "Fail to load configuration to tas5805m");
-        return ESP_FAIL;
-    }
-    ESP_LOGI(TAG, "%s:  write %d reg done", __FUNCTION__, i);
-    return ret;
-}
-
-esp_err_t tas5805m_init(audio_hal_codec_config_t *codec_cfg)
-{
-    esp_err_t ret = ESP_OK;
-    ESP_LOGI(TAG, "Power ON CODEC with GPIO %d", TAS5805M_RST_GPIO);
-    gpio_config_t io_conf;
-    io_conf.pin_bit_mask = BIT64(TAS5805M_RST_GPIO);
-    io_conf.mode = GPIO_MODE_OUTPUT;
-    io_conf.intr_type = GPIO_INTR_DISABLE;
-    gpio_config(&io_conf);
-    gpio_set_level(TAS5805M_RST_GPIO, 0);
-    vTaskDelay(20 / portTICK_RATE_MS);
-    gpio_set_level(TAS5805M_RST_GPIO, 1);
-    vTaskDelay(200 / portTICK_RATE_MS);
-
-    ret = get_i2c_pins(I2C_NUM_0, &i2c_cfg);
-    i2c_handler = i2c_bus_create(I2C_NUM_0, &i2c_cfg);
-    if (i2c_handler == NULL) {
-        ESP_LOGW(TAG, "failed to create i2c bus handler\n");
-        return ESP_FAIL;
-    }
-
-    ret |= tas5805m_transmit_registers(tas5805m_registers, sizeof(tas5805m_registers) / sizeof(tas5805m_registers[0]));
-
-    TAS5805M_ASSERT(ret, "Fail to iniitialize tas5805m PA", ESP_FAIL);
-
-    codec_dac_volume_config_t vol_cfg = TAS5805M_DAC_VOL_CFG_DEFAULT();
-    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
-    return ret;
-}
-
-/**
- * @brief Set voice volume
- *
- * @note Register values. 0xFE: -103 dB, 0x94: -50 dB, 0x30: 0 dB, 0x00: 24 dB
- * @note Accuracy of gain is 0.5 dB
- *
- * @param volume: voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tas5805m_set_volume(int volume)
-{
-    uint8_t reg = 0;
-    uint8_t cmd[2] = {0, 0};
-    esp_err_t ret = ESP_OK;
-
-    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
-
-    cmd[0] = MASTER_VOL_REG_ADDR;
-    cmd[1] = reg;
-
-    ret = i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-
-    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", (int)dac_vol_handle->user_volume, reg,
-            audio_codec_cal_dac_volume(dac_vol_handle));
-    return ret;
-}
-
-esp_err_t tas5805m_get_volume(int *volume)
-{
-    /// FIXME: Got the digit volume is not right.
-    uint8_t cmd[2] = {MASTER_VOL_REG_ADDR, 0x00};
-    esp_err_t ret = i2c_bus_read_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-    TAS5805M_ASSERT(ret, "Fail to get volume", ESP_FAIL);
-    if (cmd[1] == dac_vol_handle->reg_value) {
-        *volume = dac_vol_handle->user_volume;
-    } else {
-        *volume = 0;
-        ret = ESP_FAIL;
-    }
-    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, cmd[1]);
-    return ret;
-}
-
-esp_err_t tas5805m_set_mute(bool enable)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t cmd[2] = {TAS5805M_REG_03, 0x00};
-    ret |= i2c_bus_read_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-
-    if (enable) {
-        cmd[1] |= 0x8;
-    } else {
-        cmd[1] &= (~0x08);
-    }
-    ret |= i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-
-    TAS5805M_ASSERT(ret, "Fail to set mute", ESP_FAIL);
-    return ret;
-}
-
-esp_err_t tas5805m_get_mute(int *value)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t cmd[2] = {TAS5805M_REG_03, 0x00};
-    ret |= i2c_bus_read_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-
-    TAS5805M_ASSERT(ret, "Fail to get mute", ESP_FAIL);
-    *value = (cmd[1] & 0x08) >> 4;
-    ESP_LOGI(TAG, "Get mute value: 0x%x", *value);
-    return ret;
-}
-
-esp_err_t tas5805m_set_mute_fade(int value)
-{
-    esp_err_t ret = 0;
-    unsigned char cmd[2] = {MUTE_TIME_REG_ADDR, 0x00};
-    /* Time for register value
-    *   000: 11.5 ms
-    *   001: 53 ms
-    *   010: 106.5 ms
-    *   011: 266.5 ms
-    *   100: 0.535 sec
-    *   101: 1.065 sec
-    *   110: 2.665 sec
-    *   111: 5.33 sec
-    */
-    if (value <= 12) {
-        cmd[1] = 0;
-    } else if (value <= 53) {
-        cmd[1] = 1;
-    } else if (value <= 107) {
-        cmd[1] = 2;
-    } else if (value <= 267) {
-        cmd[1] = 3;
-    } else if (value <= 535) {
-        cmd[1] = 4;
-    } else if (value <= 1065) {
-        cmd[1] = 5;
-    } else if (value <= 2665) {
-        cmd[1] = 6;
-    } else {
-        cmd[1] = 7;
-    }
-    cmd[1] |= (cmd[1] << 4);
-
-    ret |= i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-    TAS5805M_ASSERT(ret, "Fail to set mute fade", ESP_FAIL);
-    ESP_LOGI(TAG, "Set mute fade, value:%d, 0x%x", value, cmd[1]);
-    return ret;
-}
-
-esp_err_t tas5805m_set_damp_mode(int value)
-{
-    unsigned char cmd[2] = {0};
-    cmd[0] = TAS5805M_REG_02;
-    cmd[1] = 0x10 | value;
-    return i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
-}
-
-esp_err_t tas5805m_deinit(void)
-{
-    // TODO
-    i2c_bus_delete(i2c_handler);
-    audio_codec_volume_deinit(dac_vol_handle);
-    return ESP_OK;
-}
-
-esp_err_t tas5805m_ctrl(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    // TODO
-    return ESP_OK;
-}
-
-esp_err_t tas5805m_config_iface(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    //TODO
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "i2c_bus.h"
+#include "board.h"
+#include "esp_log.h"
+#include "tas5805m.h"
+#include "tas5805m_reg_cfg.h"
+#include "audio_volume.h"
+
+static const char *TAG = "TAS5805M";
+
+#define TAS5805M_ADDR          0x5c
+#define TAS5805M_RST_GPIO      get_pa_enable_gpio()
+
+#define TAS5805M_ASSERT(a, format, b, ...) \
+    if ((a) != 0) { \
+        ESP_LOGE(TAG, format, ##__VA_ARGS__); \
+        return b;\
+    }
+
+esp_err_t tas5805m_ctrl(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+esp_err_t tas5805m_config_iface(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+static i2c_bus_handle_t     i2c_handler;
+static codec_dac_volume_config_t *dac_vol_handle;
+
+#define TAS5805M_DAC_VOL_CFG_DEFAULT() {                     \
+    .max_dac_volume = 24,                                    \
+    .min_dac_volume = -103,                                  \
+    .board_pa_gain = BOARD_PA_GAIN,                          \
+    .volume_accuracy = 0.5,                                  \
+    .dac_vol_symbol = -1,                                    \
+    .zero_volume_reg = 0x30,                                 \
+    .reg_value = 0,                                          \
+    .user_volume = 0,                                        \
+    .offset_conv_volume = NULL,                              \
+}
+
+/*
+ * i2c default configuration
+ */
+static i2c_config_t i2c_cfg = {
+    .mode = I2C_MODE_MASTER,
+    .sda_pullup_en = GPIO_PULLUP_ENABLE,
+    .scl_pullup_en = GPIO_PULLUP_ENABLE,
+    .master.clk_speed = 100000,
+};
+
+/*
+ * Operate fuction of PA
+ */
+audio_hal_func_t AUDIO_CODEC_TAS5805M_DEFAULT_HANDLE = {
+    .audio_codec_initialize = tas5805m_init,
+    .audio_codec_deinitialize = tas5805m_deinit,
+    .audio_codec_ctrl = tas5805m_ctrl,
+    .audio_codec_config_iface = tas5805m_config_iface,
+    .audio_codec_set_mute = tas5805m_set_mute,
+    .audio_codec_set_volume = tas5805m_set_volume,
+    .audio_codec_get_volume = tas5805m_get_volume,
+    .audio_codec_enable_pa = NULL,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static esp_err_t tas5805m_transmit_registers(const tas5805m_cfg_reg_t *conf_buf, int size)
+{
+    int i = 0;
+    esp_err_t ret = ESP_OK;
+    while (i < size) {
+        switch (conf_buf[i].offset) {
+            case CFG_META_SWITCH:
+                // Used in legacy applications.  Ignored here.
+                break;
+            case CFG_META_DELAY:
+                vTaskDelay(conf_buf[i].value / portTICK_PERIOD_MS);
+                break;
+            case CFG_META_BURST:
+                ret = i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, (unsigned char *)(&conf_buf[i + 1].offset), 1, (unsigned char *)(&conf_buf[i + 1].value), conf_buf[i].value);
+                i +=  (conf_buf[i].value / 2) + 1;
+                break;
+            case CFG_END_1:
+                if (CFG_END_2 == conf_buf[i + 1].offset && CFG_END_3 == conf_buf[i + 2].offset) {
+                    ESP_LOGI(TAG, "End of tms5805m reg: %d\n", i);
+                }
+                break;
+            default:
+                ret = i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, (unsigned char *)(&conf_buf[i].offset), 1, (unsigned char *)(&conf_buf[i].value), 1);
+                break;
+        }
+        i++;
+    }
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Fail to load configuration to tas5805m");
+        return ESP_FAIL;
+    }
+    ESP_LOGI(TAG, "%s:  write %d reg done", __FUNCTION__, i);
+    return ret;
+}
+
+esp_err_t tas5805m_init(audio_hal_codec_config_t *codec_cfg)
+{
+    esp_err_t ret = ESP_OK;
+    ESP_LOGI(TAG, "Power ON CODEC with GPIO %d", TAS5805M_RST_GPIO);
+    gpio_config_t io_conf;
+    io_conf.pin_bit_mask = BIT64(TAS5805M_RST_GPIO);
+    io_conf.mode = GPIO_MODE_OUTPUT;
+    io_conf.intr_type = GPIO_INTR_DISABLE;
+    gpio_config(&io_conf);
+    gpio_set_level(TAS5805M_RST_GPIO, 0);
+    vTaskDelay(20 / portTICK_PERIOD_MS);
+    gpio_set_level(TAS5805M_RST_GPIO, 1);
+    vTaskDelay(200 / portTICK_PERIOD_MS);
+
+    ret = get_i2c_pins(I2C_NUM_0, &i2c_cfg);
+    i2c_handler = i2c_bus_create(I2C_NUM_0, &i2c_cfg);
+    if (i2c_handler == NULL) {
+        ESP_LOGW(TAG, "failed to create i2c bus handler\n");
+        return ESP_FAIL;
+    }
+
+    ret |= tas5805m_transmit_registers(tas5805m_registers, sizeof(tas5805m_registers) / sizeof(tas5805m_registers[0]));
+
+    TAS5805M_ASSERT(ret, "Fail to iniitialize tas5805m PA", ESP_FAIL);
+
+    codec_dac_volume_config_t vol_cfg = TAS5805M_DAC_VOL_CFG_DEFAULT();
+    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
+    return ret;
+}
+
+/**
+ * @brief Set voice volume
+ *
+ * @note Register values. 0xFE: -103 dB, 0x94: -50 dB, 0x30: 0 dB, 0x00: 24 dB
+ * @note Accuracy of gain is 0.5 dB
+ *
+ * @param volume: voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tas5805m_set_volume(int volume)
+{
+    uint8_t reg = 0;
+    uint8_t cmd[2] = {0, 0};
+    esp_err_t ret = ESP_OK;
+
+    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
+
+    cmd[0] = MASTER_VOL_REG_ADDR;
+    cmd[1] = reg;
+
+    ret = i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+
+    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", (int)dac_vol_handle->user_volume, reg,
+            audio_codec_cal_dac_volume(dac_vol_handle));
+    return ret;
+}
+
+esp_err_t tas5805m_get_volume(int *volume)
+{
+    /// FIXME: Got the digit volume is not right.
+    uint8_t cmd[2] = {MASTER_VOL_REG_ADDR, 0x00};
+    esp_err_t ret = i2c_bus_read_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+    TAS5805M_ASSERT(ret, "Fail to get volume", ESP_FAIL);
+    if (cmd[1] == dac_vol_handle->reg_value) {
+        *volume = dac_vol_handle->user_volume;
+    } else {
+        *volume = 0;
+        ret = ESP_FAIL;
+    }
+    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%.2x", *volume, cmd[1]);
+    return ret;
+}
+
+esp_err_t tas5805m_set_mute(bool enable)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t cmd[2] = {TAS5805M_REG_03, 0x00};
+    ret |= i2c_bus_read_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+
+    if (enable) {
+        cmd[1] |= 0x8;
+    } else {
+        cmd[1] &= (~0x08);
+    }
+    ret |= i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+
+    TAS5805M_ASSERT(ret, "Fail to set mute", ESP_FAIL);
+    return ret;
+}
+
+esp_err_t tas5805m_get_mute(int *value)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t cmd[2] = {TAS5805M_REG_03, 0x00};
+    ret |= i2c_bus_read_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+
+    TAS5805M_ASSERT(ret, "Fail to get mute", ESP_FAIL);
+    *value = (cmd[1] & 0x08) >> 4;
+    ESP_LOGI(TAG, "Get mute value: 0x%x", *value);
+    return ret;
+}
+
+esp_err_t tas5805m_set_mute_fade(int value)
+{
+    esp_err_t ret = 0;
+    unsigned char cmd[2] = {MUTE_TIME_REG_ADDR, 0x00};
+    /* Time for register value
+    *   000: 11.5 ms
+    *   001: 53 ms
+    *   010: 106.5 ms
+    *   011: 266.5 ms
+    *   100: 0.535 sec
+    *   101: 1.065 sec
+    *   110: 2.665 sec
+    *   111: 5.33 sec
+    */
+    if (value <= 12) {
+        cmd[1] = 0;
+    } else if (value <= 53) {
+        cmd[1] = 1;
+    } else if (value <= 107) {
+        cmd[1] = 2;
+    } else if (value <= 267) {
+        cmd[1] = 3;
+    } else if (value <= 535) {
+        cmd[1] = 4;
+    } else if (value <= 1065) {
+        cmd[1] = 5;
+    } else if (value <= 2665) {
+        cmd[1] = 6;
+    } else {
+        cmd[1] = 7;
+    }
+    cmd[1] |= (cmd[1] << 4);
+
+    ret |= i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+    TAS5805M_ASSERT(ret, "Fail to set mute fade", ESP_FAIL);
+    ESP_LOGI(TAG, "Set mute fade, value:%d, 0x%x", value, cmd[1]);
+    return ret;
+}
+
+esp_err_t tas5805m_set_damp_mode(int value)
+{
+    unsigned char cmd[2] = {0};
+    cmd[0] = TAS5805M_REG_02;
+    cmd[1] = 0x10 | value;
+    return i2c_bus_write_bytes(i2c_handler, TAS5805M_ADDR, &cmd[0], 1, &cmd[1], 1);
+}
+
+esp_err_t tas5805m_deinit(void)
+{
+    // TODO
+    i2c_bus_delete(i2c_handler);
+    audio_codec_volume_deinit(dac_vol_handle);
+    return ESP_OK;
+}
+
+esp_err_t tas5805m_ctrl(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    // TODO
+    return ESP_OK;
+}
+
+esp_err_t tas5805m_config_iface(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    //TODO
+    return ESP_OK;
+}
diff --git a/components/audio_hal/driver/tas5805m/tas5805m.h b/components/audio_hal/driver/tas5805m/tas5805m.h
index 9796bcf9..2c36b6e6 100644
--- a/components/audio_hal/driver/tas5805m/tas5805m.h
+++ b/components/audio_hal/driver/tas5805m/tas5805m.h
@@ -1,151 +1,151 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TAS5805M_H_
-#define _TAS5805M_H_
-
-#include "audio_hal.h"
-#include "esp_err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define TAS5805M_REG_00      0x00
-#define TAS5805M_REG_02      0x02
-#define TAS5805M_REG_03      0x03
-#define TAS5805M_REG_24      0x24
-#define TAS5805M_REG_25      0x25
-#define TAS5805M_REG_26      0x26
-#define TAS5805M_REG_27      0x27
-#define TAS5805M_REG_28      0x28
-#define TAS5805M_REG_29      0x29
-#define TAS5805M_REG_2A      0x2a
-#define TAS5805M_REG_2B      0x2b
-#define TAS5805M_REG_35      0x35
-#define TAS5805M_REG_7E      0x7e
-#define TAS5805M_REG_7F      0x7f
-
-#define TAS5805M_PAGE_00     0x00
-#define TAS5805M_PAGE_2A     0x2a
-
-#define TAS5805M_BOOK_00     0x00
-#define TAS5805M_BOOK_8C     0x8c
-
-#define  MASTER_VOL_REG_ADDR    0X4C
-#define  MUTE_TIME_REG_ADDR     0X51
-
-#define  TAS5805M_DAMP_MODE_BTL      0x0
-#define  TAS5805M_DAMP_MODE_PBTL     0x04
-
-/**
- * @brief Initialize TAS5805 codec chip
- *
- * @param cfg configuration of TAS5805
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tas5805m_init(audio_hal_codec_config_t *codec_cfg);
-
-/**
- * @brief Deinitialize TAS5805 codec chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tas5805m_deinit(void);
-
-/**
- * @brief  Set voice volume
- *
- * @param volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tas5805m_set_volume(int vol);
-
-/**
- * @brief Get voice volume
- *
- * @param[out] *volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tas5805m_get_volume(int *value);
-
-/**
- * @brief Set TAS5805 mute or not
- *        Continuously call should have an interval time determined by tas5805m_set_mute_fade()
- *
- * @param enable enable(1) or disable(0)
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t tas5805m_set_mute(bool enable);
-
-/**
- * @brief Mute gradually by (value)ms
- *
- * @param value  Time for mute with millisecond.
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- *
- */
-esp_err_t tas5805m_set_mute_fade(int value);
-
-/**
- * @brief Get TAS5805 mute status
- *
- *  @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t tas5805m_get_mute(int *value);
-
-/**
- * @brief Set DAMP mode
- *
- * @param value  TAS5805M_DAMP_MODE_BTL or TAS5805M_DAMP_MODE_PBTL
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- *
- */
-esp_err_t tas5805m_set_damp_mode(int value);
-
-#ifdef __cplusplus
-}
-#endif
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TAS5805M_H_
+#define _TAS5805M_H_
+
+#include "audio_hal.h"
+#include "esp_err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TAS5805M_REG_00      0x00
+#define TAS5805M_REG_02      0x02
+#define TAS5805M_REG_03      0x03
+#define TAS5805M_REG_24      0x24
+#define TAS5805M_REG_25      0x25
+#define TAS5805M_REG_26      0x26
+#define TAS5805M_REG_27      0x27
+#define TAS5805M_REG_28      0x28
+#define TAS5805M_REG_29      0x29
+#define TAS5805M_REG_2A      0x2a
+#define TAS5805M_REG_2B      0x2b
+#define TAS5805M_REG_35      0x35
+#define TAS5805M_REG_7E      0x7e
+#define TAS5805M_REG_7F      0x7f
+
+#define TAS5805M_PAGE_00     0x00
+#define TAS5805M_PAGE_2A     0x2a
+
+#define TAS5805M_BOOK_00     0x00
+#define TAS5805M_BOOK_8C     0x8c
+
+#define  MASTER_VOL_REG_ADDR    0X4C
+#define  MUTE_TIME_REG_ADDR     0X51
+
+#define  TAS5805M_DAMP_MODE_BTL      0x0
+#define  TAS5805M_DAMP_MODE_PBTL     0x04
+
+/**
+ * @brief Initialize TAS5805 codec chip
+ *
+ * @param cfg configuration of TAS5805
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tas5805m_init(audio_hal_codec_config_t *codec_cfg);
+
+/**
+ * @brief Deinitialize TAS5805 codec chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tas5805m_deinit(void);
+
+/**
+ * @brief  Set voice volume
+ *
+ * @param volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tas5805m_set_volume(int vol);
+
+/**
+ * @brief Get voice volume
+ *
+ * @param[out] *volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tas5805m_get_volume(int *value);
+
+/**
+ * @brief Set TAS5805 mute or not
+ *        Continuously call should have an interval time determined by tas5805m_set_mute_fade()
+ *
+ * @param enable enable(1) or disable(0)
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t tas5805m_set_mute(bool enable);
+
+/**
+ * @brief Mute gradually by (value)ms
+ *
+ * @param value  Time for mute with millisecond.
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ *
+ */
+esp_err_t tas5805m_set_mute_fade(int value);
+
+/**
+ * @brief Get TAS5805 mute status
+ *
+ *  @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t tas5805m_get_mute(int *value);
+
+/**
+ * @brief Set DAMP mode
+ *
+ * @param value  TAS5805M_DAMP_MODE_BTL or TAS5805M_DAMP_MODE_PBTL
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ *
+ */
+esp_err_t tas5805m_set_damp_mode(int value);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif
\ No newline at end of file
diff --git a/components/audio_hal/driver/tas5805m/tas5805m_reg_cfg.h b/components/audio_hal/driver/tas5805m/tas5805m_reg_cfg.h
index 4a54f341..d4cbc61c 100644
--- a/components/audio_hal/driver/tas5805m/tas5805m_reg_cfg.h
+++ b/components/audio_hal/driver/tas5805m/tas5805m_reg_cfg.h
@@ -1,1748 +1,1748 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TAS5805M_REG_CFG_
-#define _TAS5805M_REG_CFG_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CFG_META_SWITCH (255)
-#define CFG_META_DELAY  (254)
-#define CFG_META_BURST  (253)
-#define CFG_END_1       (0Xaa)
-#define CFG_END_2       (0Xcc)
-#define CFG_END_3       (0Xee)
-
-typedef struct {
-    uint8_t offset;
-    uint8_t value;
-} tas5805m_cfg_reg_t;
-
-static const uint8_t tas5805m_volume[] = {
-    0xff, 0x9f, 0x8f, 0x7f, 0x6f, 0x5f, 0x5c, 0x5a,
-    0x58, 0x54, 0x50, 0x4c, 0x4a, 0x48, 0x44, 0x40,
-    0x3d, 0x3b, 0x39, 0x37, 0x35
-};
-
-static const tas5805m_cfg_reg_t tas5805m_registers[] = {
-    //RESET
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x03, 0x02 },
-    { 0x01, 0x11 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x03, 0x02 },
-    { CFG_META_DELAY, 5 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x03, 0x00 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x46, 0x11 },
-
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x03, 0x02 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x78, 0x80 },
-
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x61, 0x0b },
-    { 0x60, 0x01 },
-    { 0x7d, 0x11 },
-    { 0x7e, 0xff },
-    { 0x00, 0x01 },
-    { 0x51, 0x05 },
-
-
-    { 0x00, 0x00 },
-#if CONFIG_ESP32_KORVO_DU1906_BOARD
-    { 0x02, 0x10 },
-#else
-    { 0x02, 0x14 },
-#endif
-    { 0x53, 0x00 },
-    { 0x54, 0x13 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-    { 0x00, 0x00 },
-
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x66, 0x86 },
-    { 0x7f, 0x8c },
-    { 0x00, 0x29 },
-    { 0x18, 0x00 },
-    { 0x19, 0x40 },
-    { 0x1a, 0x26 },
-    { 0x1b, 0xe7 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x40 },
-    { 0x1e, 0x26 },
-    { 0x1f, 0xe7 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x00, 0x2a },
-    { 0x24, 0x00 },
-    { 0x25, 0x65 },
-    { 0x26, 0xac },
-    { 0x27, 0x8c },
-    { 0x28, 0x00 },
-    { 0x29, 0x65 },
-    { 0x2a, 0xac },
-    { 0x2b, 0x8c },
-    { 0x30, 0x00 },
-    { 0x31, 0xe2 },
-    { 0x32, 0xc4 },
-    { 0x33, 0x6b },
-    { 0x00, 0x2c },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x80 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x00 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x80 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x80 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x80 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x80 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0xae },
-    { 0x5f, 0xc3 },
-    { 0x60, 0x00 },
-    { 0x61, 0x45 },
-    { 0x62, 0xa1 },
-    { 0x63, 0xcb },
-    { 0x64, 0x04 },
-    { 0x65, 0x0c },
-    { 0x66, 0x37 },
-    { 0x67, 0x14 },
-    { 0x68, 0xc0 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x04 },
-    { 0x6d, 0xc1 },
-    { 0x6e, 0xff },
-    { 0x6f, 0x93 },
-    { 0x74, 0x00 },
-    { 0x75, 0x80 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x00, 0x2d },
-    { 0x18, 0x7b },
-    { 0x19, 0x3e },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x6d },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0xae },
-    { 0x1f, 0xc3 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x80 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x00, 0x2e },
-    { 0x24, 0x20 },
-    { 0x25, 0x29 },
-    { 0x26, 0x00 },
-    { 0x27, 0x94 },
-    { 0x00, 0x31 },
-    { 0x48, 0x40 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x00 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x00 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x32 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x00 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x00 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x00 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x00 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x33 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x00 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x00 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x00 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x00 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x34 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x00 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x00 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x00 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x00 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x35 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x00 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x00 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x00, 0x00 },
-    { 0x7f, 0xaa },
-    { 0x00, 0x24 },
-    { 0x18, 0x07 },
-    { 0x19, 0xf0 },
-    { 0x1a, 0xe4 },
-    { 0x1b, 0x16 },
-    { 0x1c, 0xf0 },
-    { 0x1d, 0x1e },
-    { 0x1e, 0x37 },
-    { 0x1f, 0xd3 },
-    { 0x20, 0x07 },
-    { 0x21, 0xf0 },
-    { 0x22, 0xe4 },
-    { 0x23, 0x16 },
-    { 0x24, 0x0f },
-    { 0x25, 0xe1 },
-    { 0x26, 0xab },
-    { 0x27, 0xa4 },
-    { 0x28, 0xf8 },
-    { 0x29, 0x1e },
-    { 0x2a, 0x1b },
-    { 0x2b, 0x4a },
-    { 0x2c, 0x07 },
-    { 0x2d, 0xf2 },
-    { 0x2e, 0xc6 },
-    { 0x2f, 0x03 },
-    { 0x30, 0xf0 },
-    { 0x31, 0x1a },
-    { 0x32, 0x73 },
-    { 0x33, 0xfa },
-    { 0x34, 0x07 },
-    { 0x35, 0xf2 },
-    { 0x36, 0xc6 },
-    { 0x37, 0x03 },
-    { 0x38, 0x0f },
-    { 0x39, 0xe5 },
-    { 0x3a, 0x76 },
-    { 0x3b, 0x28 },
-    { 0x3c, 0xf8 },
-    { 0x3d, 0x1a },
-    { 0x3e, 0x5e },
-    { 0x3f, 0x1c },
-    { 0x40, 0x08 },
-    { 0x41, 0x28 },
-    { 0x42, 0x01 },
-    { 0x43, 0xe1 },
-    { 0x44, 0xf0 },
-    { 0x45, 0x35 },
-    { 0x46, 0x45 },
-    { 0x47, 0x27 },
-    { 0x48, 0x07 },
-    { 0x49, 0xa3 },
-    { 0x4a, 0x11 },
-    { 0x4b, 0xa4 },
-    { 0x4c, 0x0f },
-    { 0x4d, 0xca },
-    { 0x4e, 0xba },
-    { 0x4f, 0xd9 },
-    { 0x50, 0xf8 },
-    { 0x51, 0x34 },
-    { 0x52, 0xec },
-    { 0x53, 0x7b },
-    { 0x54, 0x07 },
-    { 0x55, 0xfd },
-    { 0x56, 0x56 },
-    { 0x57, 0xbd },
-    { 0x58, 0xf0 },
-    { 0x59, 0x0d },
-    { 0x5a, 0x69 },
-    { 0x5b, 0xed },
-    { 0x5c, 0x07 },
-    { 0x5d, 0xf7 },
-    { 0x5e, 0xfd },
-    { 0x5f, 0xbb },
-    { 0x60, 0x0f },
-    { 0x61, 0xf2 },
-    { 0x62, 0x96 },
-    { 0x63, 0x13 },
-    { 0x64, 0xf8 },
-    { 0x65, 0x0a },
-    { 0x66, 0xab },
-    { 0x67, 0x87 },
-    { 0x68, 0x07 },
-    { 0x69, 0xe1 },
-    { 0x6a, 0xc2 },
-    { 0x6b, 0x69 },
-    { 0x6c, 0xf0 },
-    { 0x6d, 0xac },
-    { 0x6e, 0x0d },
-    { 0x6f, 0x58 },
-    { 0x70, 0x07 },
-    { 0x71, 0x94 },
-    { 0x72, 0x0c },
-    { 0x73, 0x4d },
-    { 0x74, 0x0f },
-    { 0x75, 0x53 },
-    { 0x76, 0xf2 },
-    { 0x77, 0xa8 },
-    { 0x78, 0xf8 },
-    { 0x79, 0x8a },
-    { 0x7a, 0x31 },
-    { 0x7b, 0x49 },
-    { 0x7c, 0x08 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x25 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x08 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0xf1 },
-    { 0x1d, 0x79 },
-    { 0x1e, 0xcb },
-    { 0x1f, 0xec },
-    { 0x20, 0x06 },
-    { 0x21, 0xa6 },
-    { 0x22, 0x49 },
-    { 0x23, 0xa5 },
-    { 0x24, 0x0e },
-    { 0x25, 0x86 },
-    { 0x26, 0x34 },
-    { 0x27, 0x14 },
-    { 0x28, 0xf9 },
-    { 0x29, 0x59 },
-    { 0x2a, 0xb6 },
-    { 0x2b, 0x5b },
-    { 0x2c, 0x09 },
-    { 0x2d, 0x63 },
-    { 0x2e, 0x61 },
-    { 0x2f, 0x75 },
-    { 0x30, 0xf8 },
-    { 0x31, 0x28 },
-    { 0x32, 0x33 },
-    { 0x33, 0x32 },
-    { 0x34, 0x02 },
-    { 0x35, 0xcb },
-    { 0x36, 0xa2 },
-    { 0x37, 0x07 },
-    { 0x38, 0x05 },
-    { 0x39, 0xc8 },
-    { 0x3a, 0x94 },
-    { 0x3b, 0x61 },
-    { 0x3c, 0xfd },
-    { 0x3d, 0xe0 },
-    { 0x3e, 0x34 },
-    { 0x3f, 0xf0 },
-    { 0x40, 0x08 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0xf1 },
-    { 0x45, 0x79 },
-    { 0x46, 0xcb },
-    { 0x47, 0xec },
-    { 0x48, 0x06 },
-    { 0x49, 0xa6 },
-    { 0x4a, 0x49 },
-    { 0x4b, 0xa5 },
-    { 0x4c, 0x0e },
-    { 0x4d, 0x86 },
-    { 0x4e, 0x34 },
-    { 0x4f, 0x14 },
-    { 0x50, 0xf9 },
-    { 0x51, 0x59 },
-    { 0x52, 0xb6 },
-    { 0x53, 0x5b },
-    { 0x54, 0x07 },
-    { 0x55, 0xd8 },
-    { 0x56, 0xc2 },
-    { 0x57, 0x5c },
-    { 0x58, 0xf1 },
-    { 0x59, 0x09 },
-    { 0x5a, 0x84 },
-    { 0x5b, 0x20 },
-    { 0x5c, 0x07 },
-    { 0x5d, 0xa4 },
-    { 0x5e, 0xd9 },
-    { 0x5f, 0x7a },
-    { 0x60, 0x0e },
-    { 0x61, 0xf6 },
-    { 0x62, 0x7b },
-    { 0x63, 0xe0 },
-    { 0x64, 0xf8 },
-    { 0x65, 0x82 },
-    { 0x66, 0x64 },
-    { 0x67, 0x2a },
-    { 0x68, 0x07 },
-    { 0x69, 0xc6 },
-    { 0x6a, 0x16 },
-    { 0x6b, 0x0b },
-    { 0x6c, 0xf3 },
-    { 0x6d, 0x04 },
-    { 0x6e, 0x30 },
-    { 0x6f, 0xd8 },
-    { 0x70, 0x07 },
-    { 0x71, 0x00 },
-    { 0x72, 0x0d },
-    { 0x73, 0xc1 },
-    { 0x74, 0x0c },
-    { 0x75, 0xfb },
-    { 0x76, 0xcf },
-    { 0x77, 0x28 },
-    { 0x78, 0xf9 },
-    { 0x79, 0x39 },
-    { 0x7a, 0xdc },
-    { 0x7b, 0x34 },
-    { 0x7c, 0x07 },
-    { 0x7d, 0xfc },
-    { 0x7e, 0x8e },
-    { 0x7f, 0xc5 },
-    { 0x00, 0x26 },
-    { 0x08, 0xf0 },
-    { 0x09, 0x91 },
-    { 0x0a, 0xb8 },
-    { 0x0b, 0xc2 },
-    { 0x0c, 0x07 },
-    { 0x0d, 0xe1 },
-    { 0x0e, 0xf7 },
-    { 0x0f, 0xf1 },
-    { 0x10, 0x0f },
-    { 0x11, 0x6e },
-    { 0x12, 0x47 },
-    { 0x13, 0x3e },
-    { 0x14, 0xf8 },
-    { 0x15, 0x21 },
-    { 0x16, 0x79 },
-    { 0x17, 0x4a },
-    { 0x18, 0x08 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x08 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x08 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x08 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x08 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x08 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x27 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x08 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x08 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x08 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x08 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x08 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x08 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x28 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x18, 0x08 },
-    { 0x19, 0x00 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x00 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x08 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x31, 0x00 },
-    { 0x32, 0x00 },
-    { 0x33, 0x00 },
-    { 0x34, 0x00 },
-    { 0x35, 0x00 },
-    { 0x36, 0x00 },
-    { 0x37, 0x00 },
-    { 0x38, 0x00 },
-    { 0x39, 0x00 },
-    { 0x3a, 0x00 },
-    { 0x3b, 0x00 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x08 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x00 },
-    { 0x47, 0x00 },
-    { 0x48, 0x00 },
-    { 0x49, 0x00 },
-    { 0x4a, 0x00 },
-    { 0x4b, 0x00 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x00 },
-    { 0x4e, 0x00 },
-    { 0x4f, 0x00 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x08 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x00 },
-    { 0x5a, 0x00 },
-    { 0x5b, 0x00 },
-    { 0x5c, 0x00 },
-    { 0x5d, 0x00 },
-    { 0x5e, 0x00 },
-    { 0x5f, 0x00 },
-    { 0x60, 0x00 },
-    { 0x61, 0x00 },
-    { 0x62, 0x00 },
-    { 0x63, 0x00 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x08 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0x00 },
-    { 0x6d, 0x00 },
-    { 0x6e, 0x00 },
-    { 0x6f, 0x00 },
-    { 0x70, 0x00 },
-    { 0x71, 0x00 },
-    { 0x72, 0x00 },
-    { 0x73, 0x00 },
-    { 0x74, 0x00 },
-    { 0x75, 0x00 },
-    { 0x76, 0x00 },
-    { 0x77, 0x00 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x08 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x29 },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x00, 0x2e },
-    { 0x7c, 0x08 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x2f },
-    { 0x08, 0x00 },
-    { 0x09, 0x00 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x00 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x10, 0x00 },
-    { 0x11, 0x00 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x14, 0x00 },
-    { 0x15, 0x00 },
-    { 0x16, 0x00 },
-    { 0x17, 0x00 },
-    { 0x1c, 0x08 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x00 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-    { 0x24, 0x00 },
-    { 0x25, 0x00 },
-    { 0x26, 0x00 },
-    { 0x27, 0x00 },
-    { 0x28, 0x00 },
-    { 0x29, 0x00 },
-    { 0x2a, 0x00 },
-    { 0x2b, 0x00 },
-    { 0x2c, 0x00 },
-    { 0x2d, 0x00 },
-    { 0x2e, 0x00 },
-    { 0x2f, 0x00 },
-    { 0x00, 0x2a },
-    { 0x48, 0x00 },
-    { 0x49, 0x15 },
-    { 0x4a, 0xa7 },
-    { 0x4b, 0x04 },
-    { 0x4c, 0x00 },
-    { 0x4d, 0x15 },
-    { 0x4e, 0xa7 },
-    { 0x4f, 0x04 },
-    { 0x50, 0x00 },
-    { 0x51, 0x15 },
-    { 0x52, 0xa7 },
-    { 0x53, 0x04 },
-    { 0x54, 0x7b },
-    { 0x55, 0x43 },
-    { 0x56, 0x52 },
-    { 0x57, 0x44 },
-    { 0x58, 0x89 },
-    { 0x59, 0x22 },
-    { 0x5a, 0xbf },
-    { 0x5b, 0x66 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x8c },
-    { 0x00, 0x2b },
-    { 0x34, 0x00 },
-    { 0x35, 0x22 },
-    { 0x36, 0x1d },
-    { 0x37, 0x95 },
-    { 0x38, 0x02 },
-    { 0x39, 0xa3 },
-    { 0x3a, 0x9a },
-    { 0x3b, 0xcc },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x06 },
-    { 0x3e, 0xd3 },
-    { 0x3f, 0x72 },
-    { 0x40, 0x00 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0x00 },
-    { 0x45, 0x00 },
-    { 0x46, 0x4e },
-    { 0x47, 0xa5 },
-    { 0x48, 0xff },
-    { 0x49, 0x81 },
-    { 0x4a, 0x47 },
-    { 0x4b, 0xae },
-    { 0x4c, 0xf9 },
-    { 0x4d, 0x06 },
-    { 0x4e, 0x21 },
-    { 0x4f, 0xa9 },
-    { 0x50, 0xfc },
-    { 0x51, 0xc2 },
-    { 0x52, 0xd8 },
-    { 0x53, 0xc5 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x58, 0x00 },
-    { 0x59, 0x02 },
-    { 0x5a, 0x4b },
-    { 0x5b, 0xce },
-    { 0x00, 0x2d },
-    { 0x58, 0x02 },
-    { 0x59, 0xa3 },
-    { 0x5a, 0x9a },
-    { 0x5b, 0xcc },
-    { 0x5c, 0x02 },
-    { 0x5d, 0xa3 },
-    { 0x5e, 0x9a },
-    { 0x5f, 0xcc },
-    { 0x60, 0x00 },
-    { 0x61, 0x44 },
-    { 0x62, 0x32 },
-    { 0x63, 0x13 },
-    { 0x64, 0x00 },
-    { 0x65, 0x00 },
-    { 0x66, 0x00 },
-    { 0x67, 0x00 },
-    { 0x68, 0x00 },
-    { 0x69, 0x00 },
-    { 0x6a, 0x00 },
-    { 0x6b, 0x00 },
-    { 0x6c, 0xff },
-    { 0x6d, 0x81 },
-    { 0x6e, 0x47 },
-    { 0x6f, 0xae },
-    { 0x70, 0xf9 },
-    { 0x71, 0x06 },
-    { 0x72, 0x21 },
-    { 0x73, 0xa9 },
-    { 0x74, 0xfc },
-    { 0x75, 0xad },
-    { 0x76, 0x96 },
-    { 0x77, 0x20 },
-    { 0x78, 0x00 },
-    { 0x79, 0x00 },
-    { 0x7a, 0x00 },
-    { 0x7b, 0x00 },
-    { 0x7c, 0x00 },
-    { 0x7d, 0x00 },
-    { 0x7e, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x00, 0x00 },
-    { 0x7f, 0xaa },
-    { 0x00, 0x2e },
-    { 0x40, 0x58 },
-    { 0x41, 0x3b },
-    { 0x42, 0x2f },
-    { 0x43, 0x3d },
-    { 0x44, 0x58 },
-    { 0x45, 0x3b },
-    { 0x46, 0x2f },
-    { 0x47, 0x3d },
-    { 0x48, 0x58 },
-    { 0x49, 0x3b },
-    { 0x4a, 0x2f },
-    { 0x4b, 0x3d },
-    { 0x4c, 0xae },
-    { 0x4d, 0x1a },
-    { 0x4e, 0x80 },
-    { 0x4f, 0x9b },
-    { 0x50, 0xc2 },
-    { 0x51, 0xde },
-    { 0x52, 0x41 },
-    { 0x53, 0xd5 },
-    { 0x00, 0x2b },
-    { 0x20, 0x06 },
-    { 0x21, 0x55 },
-    { 0x22, 0xaf },
-    { 0x23, 0xd8 },
-    { 0x24, 0xf9 },
-    { 0x25, 0xaa },
-    { 0x26, 0x50 },
-    { 0x27, 0x28 },
-    { 0x28, 0x06 },
-    { 0x29, 0x55 },
-    { 0x2a, 0xaf },
-    { 0x2b, 0xd8 },
-    { 0x2c, 0xae },
-    { 0x2d, 0x1a },
-    { 0x2e, 0x80 },
-    { 0x2f, 0x9b },
-    { 0x30, 0xc2 },
-    { 0x31, 0xde },
-    { 0x32, 0x41 },
-    { 0x33, 0xd5 },
-    { 0x0c, 0x06 },
-    { 0x0d, 0x55 },
-    { 0x0e, 0xaf },
-    { 0x0f, 0xd8 },
-    { 0x10, 0xf9 },
-    { 0x11, 0xaa },
-    { 0x12, 0x50 },
-    { 0x13, 0x28 },
-    { 0x14, 0x06 },
-    { 0x15, 0x55 },
-    { 0x16, 0xaf },
-    { 0x17, 0xd8 },
-    { 0x18, 0xae },
-    { 0x19, 0x1a },
-    { 0x1a, 0x80 },
-    { 0x1b, 0x9b },
-    { 0x1c, 0xc2 },
-    { 0x1d, 0xde },
-    { 0x1e, 0x41 },
-    { 0x1f, 0xd5 },
-    { 0x00, 0x2a },
-    { 0x34, 0x00 },
-    { 0x35, 0x15 },
-    { 0x36, 0xa7 },
-    { 0x37, 0x04 },
-    { 0x38, 0x00 },
-    { 0x39, 0x15 },
-    { 0x3a, 0xa7 },
-    { 0x3b, 0x04 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x15 },
-    { 0x3e, 0xa7 },
-    { 0x3f, 0x04 },
-    { 0x40, 0x7b },
-    { 0x41, 0x43 },
-    { 0x42, 0x52 },
-    { 0x43, 0x44 },
-    { 0x44, 0x89 },
-    { 0x45, 0x22 },
-    { 0x46, 0xbf },
-    { 0x47, 0x66 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x8c },
-    { 0x00, 0x2d },
-    { 0x30, 0x02 },
-    { 0x31, 0xa3 },
-    { 0x32, 0x9a },
-    { 0x33, 0xcc },
-    { 0x34, 0x02 },
-    { 0x35, 0xa3 },
-    { 0x36, 0x9a },
-    { 0x37, 0xcc },
-    { 0x38, 0x00 },
-    { 0x39, 0x06 },
-    { 0x3a, 0xd3 },
-    { 0x3b, 0x72 },
-    { 0x3c, 0x00 },
-    { 0x3d, 0x00 },
-    { 0x3e, 0x00 },
-    { 0x3f, 0x00 },
-    { 0x40, 0x00 },
-    { 0x41, 0x00 },
-    { 0x42, 0x00 },
-    { 0x43, 0x00 },
-    { 0x44, 0xff },
-    { 0x45, 0x81 },
-    { 0x46, 0x47 },
-    { 0x47, 0xae },
-    { 0x48, 0xf9 },
-    { 0x49, 0x06 },
-    { 0x4a, 0x21 },
-    { 0x4b, 0xa9 },
-    { 0x4c, 0xfc },
-    { 0x4d, 0xc2 },
-    { 0x4e, 0xd8 },
-    { 0x4f, 0xc5 },
-    { 0x50, 0x00 },
-    { 0x51, 0x00 },
-    { 0x52, 0x00 },
-    { 0x53, 0x00 },
-    { 0x54, 0x00 },
-    { 0x55, 0x00 },
-    { 0x56, 0x00 },
-    { 0x57, 0x00 },
-    { 0x00, 0x00 },
-    { 0x7f, 0xaa },
-    { 0x00, 0x2a },
-    { 0x5c, 0x7b },
-    { 0x5d, 0x58 },
-    { 0x5e, 0xf9 },
-    { 0x5f, 0x48 },
-    { 0x60, 0x84 },
-    { 0x61, 0xa7 },
-    { 0x62, 0x06 },
-    { 0x63, 0xb8 },
-    { 0x64, 0x7b },
-    { 0x65, 0x58 },
-    { 0x66, 0xf9 },
-    { 0x67, 0x48 },
-    { 0x68, 0x7b },
-    { 0x69, 0x43 },
-    { 0x6a, 0x52 },
-    { 0x6b, 0x44 },
-    { 0x6c, 0x89 },
-    { 0x6d, 0x22 },
-    { 0x6e, 0xbf },
-    { 0x6f, 0x66 },
-    { 0x70, 0x7b },
-    { 0x71, 0x58 },
-    { 0x72, 0xf9 },
-    { 0x73, 0x48 },
-    { 0x74, 0x84 },
-    { 0x75, 0xa7 },
-    { 0x76, 0x06 },
-    { 0x77, 0xb8 },
-    { 0x78, 0x7b },
-    { 0x79, 0x58 },
-    { 0x7a, 0xf9 },
-    { 0x7b, 0x48 },
-    { 0x7c, 0x7b },
-    { 0x7d, 0x43 },
-    { 0x7e, 0x52 },
-    { 0x7f, 0x44 },
-    { 0x00, 0x2b },
-    { 0x08, 0x89 },
-    { 0x09, 0x22 },
-    { 0x0a, 0xbf },
-    { 0x0b, 0x66 },
-    { 0x00, 0x2e },
-    { 0x54, 0x58 },
-    { 0x55, 0x3b },
-    { 0x56, 0x2f },
-    { 0x57, 0x3d },
-    { 0x58, 0x58 },
-    { 0x59, 0x3b },
-    { 0x5a, 0x2f },
-    { 0x5b, 0x3d },
-    { 0x5c, 0x58 },
-    { 0x5d, 0x3b },
-    { 0x5e, 0x2f },
-    { 0x5f, 0x3d },
-    { 0x60, 0xae },
-    { 0x61, 0x1a },
-    { 0x62, 0x80 },
-    { 0x63, 0x9b },
-    { 0x64, 0xc2 },
-    { 0x65, 0xde },
-    { 0x66, 0x41 },
-    { 0x67, 0xd5 },
-    { 0x00, 0x00 },
-    { 0x7f, 0x8c },
-    { 0x00, 0x2e },
-    { 0x10, 0x00 },
-    { 0x11, 0x80 },
-    { 0x12, 0x00 },
-    { 0x13, 0x00 },
-    { 0x0c, 0x00 },
-    { 0x0d, 0x80 },
-    { 0x0e, 0x00 },
-    { 0x0f, 0x00 },
-    { 0x08, 0x00 },
-    { 0x09, 0x80 },
-    { 0x0a, 0x00 },
-    { 0x0b, 0x00 },
-    { 0x18, 0x00 },
-    { 0x19, 0x80 },
-    { 0x1a, 0x00 },
-    { 0x1b, 0x00 },
-    { 0x1c, 0x40 },
-    { 0x1d, 0x00 },
-    { 0x1e, 0x00 },
-    { 0x1f, 0x00 },
-    { 0x20, 0x40 },
-    { 0x21, 0x00 },
-    { 0x22, 0x00 },
-    { 0x23, 0x00 },
-
-    //Register Tuning
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x30, 0x00 },
-    { 0x4c, 0x30 },
-    { 0x03, 0x03 },
-
-    { 0x00, 0x00 },
-    { 0x7f, 0x00 },
-    { 0x78, 0x80 },
-
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TAS5805M_REG_CFG_
+#define _TAS5805M_REG_CFG_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CFG_META_SWITCH (255)
+#define CFG_META_DELAY  (254)
+#define CFG_META_BURST  (253)
+#define CFG_END_1       (0Xaa)
+#define CFG_END_2       (0Xcc)
+#define CFG_END_3       (0Xee)
+
+typedef struct {
+    uint8_t offset;
+    uint8_t value;
+} tas5805m_cfg_reg_t;
+
+static const uint8_t tas5805m_volume[] = {
+    0xff, 0x9f, 0x8f, 0x7f, 0x6f, 0x5f, 0x5c, 0x5a,
+    0x58, 0x54, 0x50, 0x4c, 0x4a, 0x48, 0x44, 0x40,
+    0x3d, 0x3b, 0x39, 0x37, 0x35
+};
+
+static const tas5805m_cfg_reg_t tas5805m_registers[] = {
+    //RESET
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x03, 0x02 },
+    { 0x01, 0x11 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x03, 0x02 },
+    { CFG_META_DELAY, 5 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x03, 0x00 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x46, 0x11 },
+
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x03, 0x02 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x78, 0x80 },
+
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x61, 0x0b },
+    { 0x60, 0x01 },
+    { 0x7d, 0x11 },
+    { 0x7e, 0xff },
+    { 0x00, 0x01 },
+    { 0x51, 0x05 },
+
+
+    { 0x00, 0x00 },
+#if CONFIG_ESP32_KORVO_DU1906_BOARD
+    { 0x02, 0x10 },
+#else
+    { 0x02, 0x14 },
+#endif
+    { 0x53, 0x00 },
+    { 0x54, 0x13 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+    { 0x00, 0x00 },
+
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x66, 0x86 },
+    { 0x7f, 0x8c },
+    { 0x00, 0x29 },
+    { 0x18, 0x00 },
+    { 0x19, 0x40 },
+    { 0x1a, 0x26 },
+    { 0x1b, 0xe7 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x40 },
+    { 0x1e, 0x26 },
+    { 0x1f, 0xe7 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x00, 0x2a },
+    { 0x24, 0x00 },
+    { 0x25, 0x65 },
+    { 0x26, 0xac },
+    { 0x27, 0x8c },
+    { 0x28, 0x00 },
+    { 0x29, 0x65 },
+    { 0x2a, 0xac },
+    { 0x2b, 0x8c },
+    { 0x30, 0x00 },
+    { 0x31, 0xe2 },
+    { 0x32, 0xc4 },
+    { 0x33, 0x6b },
+    { 0x00, 0x2c },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x80 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x80 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x80 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x80 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x80 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0xae },
+    { 0x5f, 0xc3 },
+    { 0x60, 0x00 },
+    { 0x61, 0x45 },
+    { 0x62, 0xa1 },
+    { 0x63, 0xcb },
+    { 0x64, 0x04 },
+    { 0x65, 0x0c },
+    { 0x66, 0x37 },
+    { 0x67, 0x14 },
+    { 0x68, 0xc0 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x04 },
+    { 0x6d, 0xc1 },
+    { 0x6e, 0xff },
+    { 0x6f, 0x93 },
+    { 0x74, 0x00 },
+    { 0x75, 0x80 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x00, 0x2d },
+    { 0x18, 0x7b },
+    { 0x19, 0x3e },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x6d },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0xae },
+    { 0x1f, 0xc3 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x80 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x00, 0x2e },
+    { 0x24, 0x20 },
+    { 0x25, 0x29 },
+    { 0x26, 0x00 },
+    { 0x27, 0x94 },
+    { 0x00, 0x31 },
+    { 0x48, 0x40 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x00 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x00 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x32 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x00 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x00 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x33 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x00 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x00 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x34 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x00 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x00 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x35 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x00, 0x00 },
+    { 0x7f, 0xaa },
+    { 0x00, 0x24 },
+    { 0x18, 0x07 },
+    { 0x19, 0xf0 },
+    { 0x1a, 0xe4 },
+    { 0x1b, 0x16 },
+    { 0x1c, 0xf0 },
+    { 0x1d, 0x1e },
+    { 0x1e, 0x37 },
+    { 0x1f, 0xd3 },
+    { 0x20, 0x07 },
+    { 0x21, 0xf0 },
+    { 0x22, 0xe4 },
+    { 0x23, 0x16 },
+    { 0x24, 0x0f },
+    { 0x25, 0xe1 },
+    { 0x26, 0xab },
+    { 0x27, 0xa4 },
+    { 0x28, 0xf8 },
+    { 0x29, 0x1e },
+    { 0x2a, 0x1b },
+    { 0x2b, 0x4a },
+    { 0x2c, 0x07 },
+    { 0x2d, 0xf2 },
+    { 0x2e, 0xc6 },
+    { 0x2f, 0x03 },
+    { 0x30, 0xf0 },
+    { 0x31, 0x1a },
+    { 0x32, 0x73 },
+    { 0x33, 0xfa },
+    { 0x34, 0x07 },
+    { 0x35, 0xf2 },
+    { 0x36, 0xc6 },
+    { 0x37, 0x03 },
+    { 0x38, 0x0f },
+    { 0x39, 0xe5 },
+    { 0x3a, 0x76 },
+    { 0x3b, 0x28 },
+    { 0x3c, 0xf8 },
+    { 0x3d, 0x1a },
+    { 0x3e, 0x5e },
+    { 0x3f, 0x1c },
+    { 0x40, 0x08 },
+    { 0x41, 0x28 },
+    { 0x42, 0x01 },
+    { 0x43, 0xe1 },
+    { 0x44, 0xf0 },
+    { 0x45, 0x35 },
+    { 0x46, 0x45 },
+    { 0x47, 0x27 },
+    { 0x48, 0x07 },
+    { 0x49, 0xa3 },
+    { 0x4a, 0x11 },
+    { 0x4b, 0xa4 },
+    { 0x4c, 0x0f },
+    { 0x4d, 0xca },
+    { 0x4e, 0xba },
+    { 0x4f, 0xd9 },
+    { 0x50, 0xf8 },
+    { 0x51, 0x34 },
+    { 0x52, 0xec },
+    { 0x53, 0x7b },
+    { 0x54, 0x07 },
+    { 0x55, 0xfd },
+    { 0x56, 0x56 },
+    { 0x57, 0xbd },
+    { 0x58, 0xf0 },
+    { 0x59, 0x0d },
+    { 0x5a, 0x69 },
+    { 0x5b, 0xed },
+    { 0x5c, 0x07 },
+    { 0x5d, 0xf7 },
+    { 0x5e, 0xfd },
+    { 0x5f, 0xbb },
+    { 0x60, 0x0f },
+    { 0x61, 0xf2 },
+    { 0x62, 0x96 },
+    { 0x63, 0x13 },
+    { 0x64, 0xf8 },
+    { 0x65, 0x0a },
+    { 0x66, 0xab },
+    { 0x67, 0x87 },
+    { 0x68, 0x07 },
+    { 0x69, 0xe1 },
+    { 0x6a, 0xc2 },
+    { 0x6b, 0x69 },
+    { 0x6c, 0xf0 },
+    { 0x6d, 0xac },
+    { 0x6e, 0x0d },
+    { 0x6f, 0x58 },
+    { 0x70, 0x07 },
+    { 0x71, 0x94 },
+    { 0x72, 0x0c },
+    { 0x73, 0x4d },
+    { 0x74, 0x0f },
+    { 0x75, 0x53 },
+    { 0x76, 0xf2 },
+    { 0x77, 0xa8 },
+    { 0x78, 0xf8 },
+    { 0x79, 0x8a },
+    { 0x7a, 0x31 },
+    { 0x7b, 0x49 },
+    { 0x7c, 0x08 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x25 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x08 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0xf1 },
+    { 0x1d, 0x79 },
+    { 0x1e, 0xcb },
+    { 0x1f, 0xec },
+    { 0x20, 0x06 },
+    { 0x21, 0xa6 },
+    { 0x22, 0x49 },
+    { 0x23, 0xa5 },
+    { 0x24, 0x0e },
+    { 0x25, 0x86 },
+    { 0x26, 0x34 },
+    { 0x27, 0x14 },
+    { 0x28, 0xf9 },
+    { 0x29, 0x59 },
+    { 0x2a, 0xb6 },
+    { 0x2b, 0x5b },
+    { 0x2c, 0x09 },
+    { 0x2d, 0x63 },
+    { 0x2e, 0x61 },
+    { 0x2f, 0x75 },
+    { 0x30, 0xf8 },
+    { 0x31, 0x28 },
+    { 0x32, 0x33 },
+    { 0x33, 0x32 },
+    { 0x34, 0x02 },
+    { 0x35, 0xcb },
+    { 0x36, 0xa2 },
+    { 0x37, 0x07 },
+    { 0x38, 0x05 },
+    { 0x39, 0xc8 },
+    { 0x3a, 0x94 },
+    { 0x3b, 0x61 },
+    { 0x3c, 0xfd },
+    { 0x3d, 0xe0 },
+    { 0x3e, 0x34 },
+    { 0x3f, 0xf0 },
+    { 0x40, 0x08 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0xf1 },
+    { 0x45, 0x79 },
+    { 0x46, 0xcb },
+    { 0x47, 0xec },
+    { 0x48, 0x06 },
+    { 0x49, 0xa6 },
+    { 0x4a, 0x49 },
+    { 0x4b, 0xa5 },
+    { 0x4c, 0x0e },
+    { 0x4d, 0x86 },
+    { 0x4e, 0x34 },
+    { 0x4f, 0x14 },
+    { 0x50, 0xf9 },
+    { 0x51, 0x59 },
+    { 0x52, 0xb6 },
+    { 0x53, 0x5b },
+    { 0x54, 0x07 },
+    { 0x55, 0xd8 },
+    { 0x56, 0xc2 },
+    { 0x57, 0x5c },
+    { 0x58, 0xf1 },
+    { 0x59, 0x09 },
+    { 0x5a, 0x84 },
+    { 0x5b, 0x20 },
+    { 0x5c, 0x07 },
+    { 0x5d, 0xa4 },
+    { 0x5e, 0xd9 },
+    { 0x5f, 0x7a },
+    { 0x60, 0x0e },
+    { 0x61, 0xf6 },
+    { 0x62, 0x7b },
+    { 0x63, 0xe0 },
+    { 0x64, 0xf8 },
+    { 0x65, 0x82 },
+    { 0x66, 0x64 },
+    { 0x67, 0x2a },
+    { 0x68, 0x07 },
+    { 0x69, 0xc6 },
+    { 0x6a, 0x16 },
+    { 0x6b, 0x0b },
+    { 0x6c, 0xf3 },
+    { 0x6d, 0x04 },
+    { 0x6e, 0x30 },
+    { 0x6f, 0xd8 },
+    { 0x70, 0x07 },
+    { 0x71, 0x00 },
+    { 0x72, 0x0d },
+    { 0x73, 0xc1 },
+    { 0x74, 0x0c },
+    { 0x75, 0xfb },
+    { 0x76, 0xcf },
+    { 0x77, 0x28 },
+    { 0x78, 0xf9 },
+    { 0x79, 0x39 },
+    { 0x7a, 0xdc },
+    { 0x7b, 0x34 },
+    { 0x7c, 0x07 },
+    { 0x7d, 0xfc },
+    { 0x7e, 0x8e },
+    { 0x7f, 0xc5 },
+    { 0x00, 0x26 },
+    { 0x08, 0xf0 },
+    { 0x09, 0x91 },
+    { 0x0a, 0xb8 },
+    { 0x0b, 0xc2 },
+    { 0x0c, 0x07 },
+    { 0x0d, 0xe1 },
+    { 0x0e, 0xf7 },
+    { 0x0f, 0xf1 },
+    { 0x10, 0x0f },
+    { 0x11, 0x6e },
+    { 0x12, 0x47 },
+    { 0x13, 0x3e },
+    { 0x14, 0xf8 },
+    { 0x15, 0x21 },
+    { 0x16, 0x79 },
+    { 0x17, 0x4a },
+    { 0x18, 0x08 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x08 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x08 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x08 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x08 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x08 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x27 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x08 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x08 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x08 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x08 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x08 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x08 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x28 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x18, 0x08 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x00 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x08 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x00 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x08 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x00 },
+    { 0x47, 0x00 },
+    { 0x48, 0x00 },
+    { 0x49, 0x00 },
+    { 0x4a, 0x00 },
+    { 0x4b, 0x00 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x00 },
+    { 0x4e, 0x00 },
+    { 0x4f, 0x00 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x08 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x00 },
+    { 0x5a, 0x00 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x63, 0x00 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x08 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0x00 },
+    { 0x6d, 0x00 },
+    { 0x6e, 0x00 },
+    { 0x6f, 0x00 },
+    { 0x70, 0x00 },
+    { 0x71, 0x00 },
+    { 0x72, 0x00 },
+    { 0x73, 0x00 },
+    { 0x74, 0x00 },
+    { 0x75, 0x00 },
+    { 0x76, 0x00 },
+    { 0x77, 0x00 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x08 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x29 },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x00, 0x2e },
+    { 0x7c, 0x08 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x2f },
+    { 0x08, 0x00 },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x00 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x10, 0x00 },
+    { 0x11, 0x00 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x14, 0x00 },
+    { 0x15, 0x00 },
+    { 0x16, 0x00 },
+    { 0x17, 0x00 },
+    { 0x1c, 0x08 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+    { 0x00, 0x2a },
+    { 0x48, 0x00 },
+    { 0x49, 0x15 },
+    { 0x4a, 0xa7 },
+    { 0x4b, 0x04 },
+    { 0x4c, 0x00 },
+    { 0x4d, 0x15 },
+    { 0x4e, 0xa7 },
+    { 0x4f, 0x04 },
+    { 0x50, 0x00 },
+    { 0x51, 0x15 },
+    { 0x52, 0xa7 },
+    { 0x53, 0x04 },
+    { 0x54, 0x7b },
+    { 0x55, 0x43 },
+    { 0x56, 0x52 },
+    { 0x57, 0x44 },
+    { 0x58, 0x89 },
+    { 0x59, 0x22 },
+    { 0x5a, 0xbf },
+    { 0x5b, 0x66 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x8c },
+    { 0x00, 0x2b },
+    { 0x34, 0x00 },
+    { 0x35, 0x22 },
+    { 0x36, 0x1d },
+    { 0x37, 0x95 },
+    { 0x38, 0x02 },
+    { 0x39, 0xa3 },
+    { 0x3a, 0x9a },
+    { 0x3b, 0xcc },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x06 },
+    { 0x3e, 0xd3 },
+    { 0x3f, 0x72 },
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+    { 0x46, 0x4e },
+    { 0x47, 0xa5 },
+    { 0x48, 0xff },
+    { 0x49, 0x81 },
+    { 0x4a, 0x47 },
+    { 0x4b, 0xae },
+    { 0x4c, 0xf9 },
+    { 0x4d, 0x06 },
+    { 0x4e, 0x21 },
+    { 0x4f, 0xa9 },
+    { 0x50, 0xfc },
+    { 0x51, 0xc2 },
+    { 0x52, 0xd8 },
+    { 0x53, 0xc5 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x58, 0x00 },
+    { 0x59, 0x02 },
+    { 0x5a, 0x4b },
+    { 0x5b, 0xce },
+    { 0x00, 0x2d },
+    { 0x58, 0x02 },
+    { 0x59, 0xa3 },
+    { 0x5a, 0x9a },
+    { 0x5b, 0xcc },
+    { 0x5c, 0x02 },
+    { 0x5d, 0xa3 },
+    { 0x5e, 0x9a },
+    { 0x5f, 0xcc },
+    { 0x60, 0x00 },
+    { 0x61, 0x44 },
+    { 0x62, 0x32 },
+    { 0x63, 0x13 },
+    { 0x64, 0x00 },
+    { 0x65, 0x00 },
+    { 0x66, 0x00 },
+    { 0x67, 0x00 },
+    { 0x68, 0x00 },
+    { 0x69, 0x00 },
+    { 0x6a, 0x00 },
+    { 0x6b, 0x00 },
+    { 0x6c, 0xff },
+    { 0x6d, 0x81 },
+    { 0x6e, 0x47 },
+    { 0x6f, 0xae },
+    { 0x70, 0xf9 },
+    { 0x71, 0x06 },
+    { 0x72, 0x21 },
+    { 0x73, 0xa9 },
+    { 0x74, 0xfc },
+    { 0x75, 0xad },
+    { 0x76, 0x96 },
+    { 0x77, 0x20 },
+    { 0x78, 0x00 },
+    { 0x79, 0x00 },
+    { 0x7a, 0x00 },
+    { 0x7b, 0x00 },
+    { 0x7c, 0x00 },
+    { 0x7d, 0x00 },
+    { 0x7e, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x00, 0x00 },
+    { 0x7f, 0xaa },
+    { 0x00, 0x2e },
+    { 0x40, 0x58 },
+    { 0x41, 0x3b },
+    { 0x42, 0x2f },
+    { 0x43, 0x3d },
+    { 0x44, 0x58 },
+    { 0x45, 0x3b },
+    { 0x46, 0x2f },
+    { 0x47, 0x3d },
+    { 0x48, 0x58 },
+    { 0x49, 0x3b },
+    { 0x4a, 0x2f },
+    { 0x4b, 0x3d },
+    { 0x4c, 0xae },
+    { 0x4d, 0x1a },
+    { 0x4e, 0x80 },
+    { 0x4f, 0x9b },
+    { 0x50, 0xc2 },
+    { 0x51, 0xde },
+    { 0x52, 0x41 },
+    { 0x53, 0xd5 },
+    { 0x00, 0x2b },
+    { 0x20, 0x06 },
+    { 0x21, 0x55 },
+    { 0x22, 0xaf },
+    { 0x23, 0xd8 },
+    { 0x24, 0xf9 },
+    { 0x25, 0xaa },
+    { 0x26, 0x50 },
+    { 0x27, 0x28 },
+    { 0x28, 0x06 },
+    { 0x29, 0x55 },
+    { 0x2a, 0xaf },
+    { 0x2b, 0xd8 },
+    { 0x2c, 0xae },
+    { 0x2d, 0x1a },
+    { 0x2e, 0x80 },
+    { 0x2f, 0x9b },
+    { 0x30, 0xc2 },
+    { 0x31, 0xde },
+    { 0x32, 0x41 },
+    { 0x33, 0xd5 },
+    { 0x0c, 0x06 },
+    { 0x0d, 0x55 },
+    { 0x0e, 0xaf },
+    { 0x0f, 0xd8 },
+    { 0x10, 0xf9 },
+    { 0x11, 0xaa },
+    { 0x12, 0x50 },
+    { 0x13, 0x28 },
+    { 0x14, 0x06 },
+    { 0x15, 0x55 },
+    { 0x16, 0xaf },
+    { 0x17, 0xd8 },
+    { 0x18, 0xae },
+    { 0x19, 0x1a },
+    { 0x1a, 0x80 },
+    { 0x1b, 0x9b },
+    { 0x1c, 0xc2 },
+    { 0x1d, 0xde },
+    { 0x1e, 0x41 },
+    { 0x1f, 0xd5 },
+    { 0x00, 0x2a },
+    { 0x34, 0x00 },
+    { 0x35, 0x15 },
+    { 0x36, 0xa7 },
+    { 0x37, 0x04 },
+    { 0x38, 0x00 },
+    { 0x39, 0x15 },
+    { 0x3a, 0xa7 },
+    { 0x3b, 0x04 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x15 },
+    { 0x3e, 0xa7 },
+    { 0x3f, 0x04 },
+    { 0x40, 0x7b },
+    { 0x41, 0x43 },
+    { 0x42, 0x52 },
+    { 0x43, 0x44 },
+    { 0x44, 0x89 },
+    { 0x45, 0x22 },
+    { 0x46, 0xbf },
+    { 0x47, 0x66 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x8c },
+    { 0x00, 0x2d },
+    { 0x30, 0x02 },
+    { 0x31, 0xa3 },
+    { 0x32, 0x9a },
+    { 0x33, 0xcc },
+    { 0x34, 0x02 },
+    { 0x35, 0xa3 },
+    { 0x36, 0x9a },
+    { 0x37, 0xcc },
+    { 0x38, 0x00 },
+    { 0x39, 0x06 },
+    { 0x3a, 0xd3 },
+    { 0x3b, 0x72 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0xff },
+    { 0x45, 0x81 },
+    { 0x46, 0x47 },
+    { 0x47, 0xae },
+    { 0x48, 0xf9 },
+    { 0x49, 0x06 },
+    { 0x4a, 0x21 },
+    { 0x4b, 0xa9 },
+    { 0x4c, 0xfc },
+    { 0x4d, 0xc2 },
+    { 0x4e, 0xd8 },
+    { 0x4f, 0xc5 },
+    { 0x50, 0x00 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0x00 },
+    { 0x57, 0x00 },
+    { 0x00, 0x00 },
+    { 0x7f, 0xaa },
+    { 0x00, 0x2a },
+    { 0x5c, 0x7b },
+    { 0x5d, 0x58 },
+    { 0x5e, 0xf9 },
+    { 0x5f, 0x48 },
+    { 0x60, 0x84 },
+    { 0x61, 0xa7 },
+    { 0x62, 0x06 },
+    { 0x63, 0xb8 },
+    { 0x64, 0x7b },
+    { 0x65, 0x58 },
+    { 0x66, 0xf9 },
+    { 0x67, 0x48 },
+    { 0x68, 0x7b },
+    { 0x69, 0x43 },
+    { 0x6a, 0x52 },
+    { 0x6b, 0x44 },
+    { 0x6c, 0x89 },
+    { 0x6d, 0x22 },
+    { 0x6e, 0xbf },
+    { 0x6f, 0x66 },
+    { 0x70, 0x7b },
+    { 0x71, 0x58 },
+    { 0x72, 0xf9 },
+    { 0x73, 0x48 },
+    { 0x74, 0x84 },
+    { 0x75, 0xa7 },
+    { 0x76, 0x06 },
+    { 0x77, 0xb8 },
+    { 0x78, 0x7b },
+    { 0x79, 0x58 },
+    { 0x7a, 0xf9 },
+    { 0x7b, 0x48 },
+    { 0x7c, 0x7b },
+    { 0x7d, 0x43 },
+    { 0x7e, 0x52 },
+    { 0x7f, 0x44 },
+    { 0x00, 0x2b },
+    { 0x08, 0x89 },
+    { 0x09, 0x22 },
+    { 0x0a, 0xbf },
+    { 0x0b, 0x66 },
+    { 0x00, 0x2e },
+    { 0x54, 0x58 },
+    { 0x55, 0x3b },
+    { 0x56, 0x2f },
+    { 0x57, 0x3d },
+    { 0x58, 0x58 },
+    { 0x59, 0x3b },
+    { 0x5a, 0x2f },
+    { 0x5b, 0x3d },
+    { 0x5c, 0x58 },
+    { 0x5d, 0x3b },
+    { 0x5e, 0x2f },
+    { 0x5f, 0x3d },
+    { 0x60, 0xae },
+    { 0x61, 0x1a },
+    { 0x62, 0x80 },
+    { 0x63, 0x9b },
+    { 0x64, 0xc2 },
+    { 0x65, 0xde },
+    { 0x66, 0x41 },
+    { 0x67, 0xd5 },
+    { 0x00, 0x00 },
+    { 0x7f, 0x8c },
+    { 0x00, 0x2e },
+    { 0x10, 0x00 },
+    { 0x11, 0x80 },
+    { 0x12, 0x00 },
+    { 0x13, 0x00 },
+    { 0x0c, 0x00 },
+    { 0x0d, 0x80 },
+    { 0x0e, 0x00 },
+    { 0x0f, 0x00 },
+    { 0x08, 0x00 },
+    { 0x09, 0x80 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x80 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x00 },
+    { 0x1c, 0x40 },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+    { 0x20, 0x40 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+
+    //Register Tuning
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x30, 0x00 },
+    { 0x4c, 0x30 },
+    { 0x03, 0x03 },
+
+    { 0x00, 0x00 },
+    { 0x7f, 0x00 },
+    { 0x78, 0x80 },
+
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/driver/zl38063/api_lib/vproc_data_types.h b/components/audio_hal/driver/zl38063/api_lib/vproc_data_types.h
index e034179a..1ef39684 100644
--- a/components/audio_hal/driver/zl38063/api_lib/vproc_data_types.h
+++ b/components/audio_hal/driver/zl38063/api_lib/vproc_data_types.h
@@ -1,122 +1,122 @@
-/** \file vproc_data_types.h
-* vproc_data_types.h
-*
-*  This file is the header for all standard types used in the API code.
-*
-****************************************************************************
-* Copyright Microsemi Inc, 2018. All rights reserved.
-* Licensed under the MIT License. See LICENSE.txt in the project
-* root for license information.
-*
-***************************************************************************/
-
-#ifndef VP_API_TYPES_H
-#define VP_API_TYPES_H
-/* For maximum that can be stored in an int - if file exists in library */
-#include "limits.h"
-#include "esp_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef NULL
-#define NULL (0)
-#endif
-
-#ifdef EXTERN
-#undef EXTERN
-#error EXTERN was redefined!
-#endif /* undef EXTERN */
-
-#ifdef __cplusplus
-#define EXTERN extern "C"
-#else
-#define EXTERN extern
-#endif /* __cplusplus */
-
-/********************* DECLARATIONS ***************************/
-/* Constants */
-#define FALSE   (0)     /* Boolean constant */
-#define TRUE    (1)     /* Boolean constant */
-#ifndef __cplusplus
-/* C++ language provides a boolean data type; So no need to define
- * one more data type; Make use of it
- * NOTE: The 'C' potions of the VP-API assume C++ "bool" to be of the
- * same size as that of "char". Please make sure this assumption is correct.
- */
-
-//typedef unsigned char bool;
-#endif /* __cplusplus */
-/****************** typedefs ***********************************/
-/* These are the basic number types used */
-/* for uint8, uint16, uint32, int8, int16, int32, bool */
-//  PLATFORM SPECIFIC DEFINITIONS
-typedef unsigned char   uchar;
-typedef signed char    int8;
-typedef unsigned char   UCharT;       // 8 bits unsigned -  PLATFORM SPECIFIC
-typedef unsigned char   UInt8T;       // 8 bits unsigned -  PLATFORM SPECIFIC
-typedef unsigned short  UInt16T;      // 16 bits unsigned -  PLATFORM SPECIFIC
-typedef unsigned long   UInt32T;      // 32 bits unsigned -  PLATFORM SPECIFIC
-typedef signed long     Int32T;       // 32 bits signed -  PLATFORM SPECIFIC
-typedef unsigned char   uint8;        // 8 bits unsigned -  PLATFORM SPECIFIC
-typedef unsigned short  uint16;       // 16 bits unsigned -  PLATFORM SPECIFIC
-typedef   uint8*  uint8p;             // pointer to 8 bits unsigned -  PLATFORM SPECIFIC
-typedef   uint16* uint16p;            // pointer to 16 bits unsigned -  PLATFORM SPECIFIC
-typedef uint32_t   uint32;            // 32 bits unsigned -  PLATFORM SPECIFIC
-typedef signed short    int16;        // 32 bits unsigned -  PLATFORM SPECIFIC
-typedef   uint32* uint32p;
-typedef   int8*   int8p;
-typedef   int16*  int16p;
-typedef   Int32T*  int32p;
-
-/* external types */
-/* Some compilers optimize the size of enumeration data types based on
- * the maximum data value assigned to the members of that data type.
- * 'Standard C' requires enumeration data types to be of the same size
- * as that of native 'int' implementation.
- * The VP-API from a portability persepective adds a 'dummy' member to
- * all enumeration data types that force the compilers to allocate the size
- * of enumeration data types to be equal to that of native 'int'
- * implementation */
-#define FORCE_STANDARD_C_ENUM_SIZE  (INT_MAX)
-
-/* Eliminate error messages that occur when comparing an enumeration constant
-   < 0 */
-#define FORCE_SIGNED_ENUM  (INT_MIN)
-
-/* Define any API specific basic data type ranges (that are necessary) */
-#define VP_INT16_MAX    (SHRT_MAX)
-#define VP_INT16_MIN    (SHRT_MIN)
-#define VP_INT32_MAX    (LONG_MAX)
-#define VP_INT32_MIN    (LONG_MIN)
-
-/*firmware data structures*/
-typedef struct {
-    uint16 buf[16];      /*the firmware data block to send to the device*/
-    uint16  numWords;    /*the number of words within the block of data stored in buf[]*/
-    uint32 targetAddr;   /*the target base address to write to register 0x00c of the device*/
-    uint8 useTargetAddr; /*this value is either 0 or 1. When 1 the tarGetAddr must be written to the device*/
-} twFwr;
-
-typedef struct {
-    twFwr* st_Fwr;
-    uint32 byteCount;   /*The total number of bytes within the firmware - NOT USED*/
-    uint8 havePrgmBase;
-    uint32 prgmBase;
-    uint32 execAddr;   /*The execution start address of the firmware in RAM*/
-    uint16 twFirmwareStreamLen;  /*The number of blocks within the firmware*/
-} twFirmware;
-
-/*config record structures*/
-typedef struct {
-    uint16 reg;   /*the register */
-    uint16 value; /*the value to write into reg */
-} dataArr;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* VP_API_TYPES_H */
-
+/** \file vproc_data_types.h
+* vproc_data_types.h
+*
+*  This file is the header for all standard types used in the API code.
+*
+****************************************************************************
+* Copyright Microsemi Inc, 2018. All rights reserved.
+* Licensed under the MIT License. See LICENSE.txt in the project
+* root for license information.
+*
+***************************************************************************/
+
+#ifndef VP_API_TYPES_H
+#define VP_API_TYPES_H
+/* For maximum that can be stored in an int - if file exists in library */
+#include "limits.h"
+#include "esp_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef NULL
+#define NULL (0)
+#endif
+
+#ifdef EXTERN
+#undef EXTERN
+#error EXTERN was redefined!
+#endif /* undef EXTERN */
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN extern
+#endif /* __cplusplus */
+
+/********************* DECLARATIONS ***************************/
+/* Constants */
+#define FALSE   (0)     /* Boolean constant */
+#define TRUE    (1)     /* Boolean constant */
+#ifndef __cplusplus
+/* C++ language provides a boolean data type; So no need to define
+ * one more data type; Make use of it
+ * NOTE: The 'C' potions of the VP-API assume C++ "bool" to be of the
+ * same size as that of "char". Please make sure this assumption is correct.
+ */
+
+//typedef unsigned char bool;
+#endif /* __cplusplus */
+/****************** typedefs ***********************************/
+/* These are the basic number types used */
+/* for uint8, uint16, uint32, int8, int16, int32, bool */
+//  PLATFORM SPECIFIC DEFINITIONS
+typedef unsigned char   uchar;
+typedef signed char    int8;
+typedef unsigned char   UCharT;       // 8 bits unsigned -  PLATFORM SPECIFIC
+typedef unsigned char   UInt8T;       // 8 bits unsigned -  PLATFORM SPECIFIC
+typedef unsigned short  UInt16T;      // 16 bits unsigned -  PLATFORM SPECIFIC
+typedef unsigned long   UInt32T;      // 32 bits unsigned -  PLATFORM SPECIFIC
+typedef signed long     Int32T;       // 32 bits signed -  PLATFORM SPECIFIC
+typedef unsigned char   uint8;        // 8 bits unsigned -  PLATFORM SPECIFIC
+typedef unsigned short  uint16;       // 16 bits unsigned -  PLATFORM SPECIFIC
+typedef   uint8*  uint8p;             // pointer to 8 bits unsigned -  PLATFORM SPECIFIC
+typedef   uint16* uint16p;            // pointer to 16 bits unsigned -  PLATFORM SPECIFIC
+typedef uint32_t   uint32;            // 32 bits unsigned -  PLATFORM SPECIFIC
+typedef signed short    int16;        // 32 bits unsigned -  PLATFORM SPECIFIC
+typedef   uint32* uint32p;
+typedef   int8*   int8p;
+typedef   int16*  int16p;
+typedef   Int32T*  int32p;
+
+/* external types */
+/* Some compilers optimize the size of enumeration data types based on
+ * the maximum data value assigned to the members of that data type.
+ * 'Standard C' requires enumeration data types to be of the same size
+ * as that of native 'int' implementation.
+ * The VP-API from a portability persepective adds a 'dummy' member to
+ * all enumeration data types that force the compilers to allocate the size
+ * of enumeration data types to be equal to that of native 'int'
+ * implementation */
+#define FORCE_STANDARD_C_ENUM_SIZE  (INT_MAX)
+
+/* Eliminate error messages that occur when comparing an enumeration constant
+   < 0 */
+#define FORCE_SIGNED_ENUM  (INT_MIN)
+
+/* Define any API specific basic data type ranges (that are necessary) */
+#define VP_INT16_MAX    (SHRT_MAX)
+#define VP_INT16_MIN    (SHRT_MIN)
+#define VP_INT32_MAX    (LONG_MAX)
+#define VP_INT32_MIN    (LONG_MIN)
+
+/*firmware data structures*/
+typedef struct {
+    uint16 buf[16];      /*the firmware data block to send to the device*/
+    uint16  numWords;    /*the number of words within the block of data stored in buf[]*/
+    uint32 targetAddr;   /*the target base address to write to register 0x00c of the device*/
+    uint8 useTargetAddr; /*this value is either 0 or 1. When 1 the tarGetAddr must be written to the device*/
+} twFwr;
+
+typedef struct {
+    twFwr* st_Fwr;
+    uint32 byteCount;   /*The total number of bytes within the firmware - NOT USED*/
+    uint8 havePrgmBase;
+    uint32 prgmBase;
+    uint32 execAddr;   /*The execution start address of the firmware in RAM*/
+    uint16 twFirmwareStreamLen;  /*The number of blocks within the firmware*/
+} twFirmware;
+
+/*config record structures*/
+typedef struct {
+    uint16 reg;   /*the register */
+    uint16 value; /*the value to write into reg */
+} dataArr;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VP_API_TYPES_H */
+
diff --git a/components/audio_hal/driver/zl38063/zl38063.c b/components/audio_hal/driver/zl38063/zl38063.c
index 003ca085..63e64e65 100644
--- a/components/audio_hal/driver/zl38063/zl38063.c
+++ b/components/audio_hal/driver/zl38063/zl38063.c
@@ -1,161 +1,161 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "driver/i2c.h"
-#include "zl38063.h"
-#include "vprocTwolf_access.h"
-#include "driver/gpio.h"
-#include "tw_spi_access.h"
-#include "board.h"
-#include "audio_volume.h"
-
-static const char *TAG = "zl38063";
-
-static int codec_init_flag = 0;
-static codec_dac_volume_config_t *dac_vol_handle;
-
-#define ZL38063_DAC_VOL_CFG_DEFAULT() {                     \
-    .max_dac_volume = 6,                                    \
-    .min_dac_volume = -90,                                  \
-    .board_pa_gain = BOARD_PA_GAIN,                         \
-    .volume_accuracy = 1,                                   \
-    .dac_vol_symbol = 1,                                    \
-    .zero_volume_reg = 0,                                   \
-    .reg_value = 0,                                         \
-    .user_volume = 0,                                       \
-    .offset_conv_volume = NULL,                             \
-}
-
-audio_hal_func_t AUDIO_CODEC_ZL38063_DEFAULT_HANDLE = {
-    .audio_codec_initialize = zl38063_codec_init,
-    .audio_codec_deinitialize = zl38063_codec_deinit,
-    .audio_codec_ctrl = zl38063_codec_ctrl_state,
-    .audio_codec_config_iface = zl38063_codec_config_i2s,
-    .audio_codec_set_mute = zl38063_codec_set_voice_mute,
-    .audio_codec_set_volume = zl38063_codec_set_voice_volume,
-    .audio_codec_get_volume = zl38063_codec_get_voice_volume,
-    .audio_codec_enable_pa = NULL,
-    .audio_hal_lock = NULL,
-    .handle = NULL,
-};
-
-static bool zl38063_codec_initialized()
-{
-    return codec_init_flag;
-}
-
-esp_err_t zl38063_codec_init(audio_hal_codec_config_t *cfg)
-{
-    if (zl38063_codec_initialized()) {
-        ESP_LOGW(TAG, "The zl38063 codec has been already initialized");
-        return ESP_OK;
-    }
-    tw_upload_dsp_firmware(0);
-    gpio_config_t  borad_conf;
-    memset(&borad_conf, 0, sizeof(borad_conf));
-    borad_conf.mode = GPIO_MODE_OUTPUT;
-    borad_conf.pin_bit_mask = 1UL << (get_reset_board_gpio());
-    borad_conf.pull_down_en = 0;
-    borad_conf.pull_up_en = 0;
-
-    gpio_config_t  pa_conf;
-    memset(&pa_conf, 0, sizeof(pa_conf));
-    pa_conf.mode = GPIO_MODE_OUTPUT;
-    pa_conf.pin_bit_mask = 1UL << (get_pa_enable_gpio());
-    pa_conf.pull_down_en = 0;
-    pa_conf.pull_up_en = 0;
-
-    gpio_config(&pa_conf);
-    gpio_config(&borad_conf);
-    gpio_set_level(get_pa_enable_gpio(), 1);            //enable PA
-    gpio_set_level(get_reset_board_gpio(), 0);      //enable DSP
-    codec_init_flag = 1;
-
-    codec_dac_volume_config_t vol_cfg = ZL38063_DAC_VOL_CFG_DEFAULT();
-    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
-    return ESP_OK;
-}
-
-esp_err_t zl38063_codec_deinit(void)
-{
-    gpio_set_level(get_pa_enable_gpio(), 0);
-    gpio_set_level(get_reset_board_gpio(), 1);
-    codec_init_flag = 0;
-    audio_codec_volume_deinit(dac_vol_handle);
-    return ESP_OK;
-}
-
-esp_err_t zl38063_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
-{
-    return ESP_OK;
-}
-
-esp_err_t zl38063_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
-{
-    return ESP_OK;
-}
-
-esp_err_t zl38063_codec_set_voice_mute(bool mute)
-{
-    /* For now we do not have implementation for this */
-    return ESP_OK;
-}
-
-/**
- * @param volume: 0 ~ 100, 0 means mute
- *
- * @note Register values. 0xA6: -90 dB, 0xCE: -50 dB, 0x00: 0 dB, 0x06: 6 dB
- * @note Accuracy of gain is 1 dB
- *
- * @return
- *     - (-1)  Error
- *     - (0)   Success
- */
-esp_err_t zl38063_codec_set_voice_volume(int volume)
-{
-    int ret = 0;
-    uint8_t reg = 0;
-    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
-    ret = VprocTwolfSetVolume(reg);
-    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", dac_vol_handle->user_volume, reg,
-            (int8_t) reg * 1.0);
-    return ret;
-}
-
-esp_err_t zl38063_codec_get_voice_volume(int *volume)
-{
-    int ret = 0;
-    int8_t reg = 0;
-    ret = VprocTwolfGetVolume(&reg);
-    if (reg == (int8_t) dac_vol_handle->reg_value) {
-        *volume = dac_vol_handle->user_volume;
-    } else {
-        *volume = 0;
-        ret = ESP_FAIL;
-    }
-    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%x", *volume, (uint8_t)reg);
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "driver/i2c.h"
+#include "zl38063.h"
+#include "vprocTwolf_access.h"
+#include "driver/gpio.h"
+#include "tw_spi_access.h"
+#include "board.h"
+#include "audio_volume.h"
+
+static const char *TAG = "zl38063";
+
+static int codec_init_flag = 0;
+static codec_dac_volume_config_t *dac_vol_handle;
+
+#define ZL38063_DAC_VOL_CFG_DEFAULT() {                     \
+    .max_dac_volume = 6,                                    \
+    .min_dac_volume = -90,                                  \
+    .board_pa_gain = BOARD_PA_GAIN,                         \
+    .volume_accuracy = 1,                                   \
+    .dac_vol_symbol = 1,                                    \
+    .zero_volume_reg = 0,                                   \
+    .reg_value = 0,                                         \
+    .user_volume = 0,                                       \
+    .offset_conv_volume = NULL,                             \
+}
+
+audio_hal_func_t AUDIO_CODEC_ZL38063_DEFAULT_HANDLE = {
+    .audio_codec_initialize = zl38063_codec_init,
+    .audio_codec_deinitialize = zl38063_codec_deinit,
+    .audio_codec_ctrl = zl38063_codec_ctrl_state,
+    .audio_codec_config_iface = zl38063_codec_config_i2s,
+    .audio_codec_set_mute = zl38063_codec_set_voice_mute,
+    .audio_codec_set_volume = zl38063_codec_set_voice_volume,
+    .audio_codec_get_volume = zl38063_codec_get_voice_volume,
+    .audio_codec_enable_pa = NULL,
+    .audio_hal_lock = NULL,
+    .handle = NULL,
+};
+
+static bool zl38063_codec_initialized()
+{
+    return codec_init_flag;
+}
+
+esp_err_t zl38063_codec_init(audio_hal_codec_config_t *cfg)
+{
+    if (zl38063_codec_initialized()) {
+        ESP_LOGW(TAG, "The zl38063 codec has been already initialized");
+        return ESP_OK;
+    }
+    tw_upload_dsp_firmware(0);
+    gpio_config_t  borad_conf;
+    memset(&borad_conf, 0, sizeof(borad_conf));
+    borad_conf.mode = GPIO_MODE_OUTPUT;
+    borad_conf.pin_bit_mask = 1UL << (get_reset_board_gpio());
+    borad_conf.pull_down_en = 0;
+    borad_conf.pull_up_en = 0;
+
+    gpio_config_t  pa_conf;
+    memset(&pa_conf, 0, sizeof(pa_conf));
+    pa_conf.mode = GPIO_MODE_OUTPUT;
+    pa_conf.pin_bit_mask = 1UL << (get_pa_enable_gpio());
+    pa_conf.pull_down_en = 0;
+    pa_conf.pull_up_en = 0;
+
+    gpio_config(&pa_conf);
+    gpio_config(&borad_conf);
+    gpio_set_level(get_pa_enable_gpio(), 1);            //enable PA
+    gpio_set_level(get_reset_board_gpio(), 0);      //enable DSP
+    codec_init_flag = 1;
+
+    codec_dac_volume_config_t vol_cfg = ZL38063_DAC_VOL_CFG_DEFAULT();
+    dac_vol_handle = audio_codec_volume_init(&vol_cfg);
+    return ESP_OK;
+}
+
+esp_err_t zl38063_codec_deinit(void)
+{
+    gpio_set_level(get_pa_enable_gpio(), 0);
+    gpio_set_level(get_reset_board_gpio(), 1);
+    codec_init_flag = 0;
+    audio_codec_volume_deinit(dac_vol_handle);
+    return ESP_OK;
+}
+
+esp_err_t zl38063_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state)
+{
+    return ESP_OK;
+}
+
+esp_err_t zl38063_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface)
+{
+    return ESP_OK;
+}
+
+esp_err_t zl38063_codec_set_voice_mute(bool mute)
+{
+    /* For now we do not have implementation for this */
+    return ESP_OK;
+}
+
+/**
+ * @param volume: 0 ~ 100, 0 means mute
+ *
+ * @note Register values. 0xA6: -90 dB, 0xCE: -50 dB, 0x00: 0 dB, 0x06: 6 dB
+ * @note Accuracy of gain is 1 dB
+ *
+ * @return
+ *     - (-1)  Error
+ *     - (0)   Success
+ */
+esp_err_t zl38063_codec_set_voice_volume(int volume)
+{
+    int ret = 0;
+    uint8_t reg = 0;
+    reg = audio_codec_get_dac_reg_value(dac_vol_handle, volume);
+    ret = VprocTwolfSetVolume(reg);
+    ESP_LOGD(TAG, "Set volume:%.2d reg_value:0x%.2x dB:%.1f", dac_vol_handle->user_volume, reg,
+            (int8_t) reg * 1.0);
+    return ret;
+}
+
+esp_err_t zl38063_codec_get_voice_volume(int *volume)
+{
+    int ret = 0;
+    int8_t reg = 0;
+    ret = VprocTwolfGetVolume(&reg);
+    if (reg == (int8_t) dac_vol_handle->reg_value) {
+        *volume = dac_vol_handle->user_volume;
+    } else {
+        *volume = 0;
+        ret = ESP_FAIL;
+    }
+    ESP_LOGD(TAG, "Get volume:%.2d reg_value:0x%x", *volume, (uint8_t)reg);
+    return ret;
+}
diff --git a/components/audio_hal/driver/zl38063/zl38063.h b/components/audio_hal/driver/zl38063/zl38063.h
index 3d981770..0c048dbf 100644
--- a/components/audio_hal/driver/zl38063/zl38063.h
+++ b/components/audio_hal/driver/zl38063/zl38063.h
@@ -1,119 +1,119 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __ZL38063_H__
-#define __ZL38063_H__
-
-#include "audio_hal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Initialize ZL38063 chip
- *
- * @param cfg configuration of ZL38063
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t zl38063_codec_init(audio_hal_codec_config_t *cfg);
-/**
- * @brief Deinitialize ZL38063 chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t zl38063_codec_deinit(void);
-/**
- * The functions zl38063_ctrl_state and zl38063_config_i2s are not used by this driver.
- * They are kept here to maintain the uniformity and convenience of the interface
- * of the ADF project.
- * These settings for zl38063 are burned in firmware and configuration files.
- * Default i2s configuration: 48000Hz, 16bit, Left-Right channels.
- * Use resampling to be compatible with different file types.
- *
- * @brief Control ZL38063 chip
- *
- * @param mode codec mode
- * @param ctrl_state start or stop decode or encode progress
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t zl38063_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
-/**
- * @brief Configure ZL38063 codec mode and I2S interface
- *
- * @param mode codec mode
- * @param iface I2S config
- *
- * @return
- *     - ESP_FAIL Parameter error
- *     - ESP_OK   Success
- */
-esp_err_t zl38063_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief mute or unmute the codec
- *
- * @param mute:  true, false
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t zl38063_codec_set_voice_mute(bool mute);
-
-/**
- * @brief  Set voice volume
- *
- * @param volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t zl38063_codec_set_voice_volume(int volume);
-
-/**
- * @brief Get voice volume
- *
- * @param[out] *volume:  voice volume (0~100)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t zl38063_codec_get_voice_volume(int *volume);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __ZL38063_H__
+#define __ZL38063_H__
+
+#include "audio_hal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initialize ZL38063 chip
+ *
+ * @param cfg configuration of ZL38063
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t zl38063_codec_init(audio_hal_codec_config_t *cfg);
+/**
+ * @brief Deinitialize ZL38063 chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t zl38063_codec_deinit(void);
+/**
+ * The functions zl38063_ctrl_state and zl38063_config_i2s are not used by this driver.
+ * They are kept here to maintain the uniformity and convenience of the interface
+ * of the ADF project.
+ * These settings for zl38063 are burned in firmware and configuration files.
+ * Default i2s configuration: 48000Hz, 16bit, Left-Right channels.
+ * Use resampling to be compatible with different file types.
+ *
+ * @brief Control ZL38063 chip
+ *
+ * @param mode codec mode
+ * @param ctrl_state start or stop decode or encode progress
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t zl38063_codec_ctrl_state(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);
+/**
+ * @brief Configure ZL38063 codec mode and I2S interface
+ *
+ * @param mode codec mode
+ * @param iface I2S config
+ *
+ * @return
+ *     - ESP_FAIL Parameter error
+ *     - ESP_OK   Success
+ */
+esp_err_t zl38063_codec_config_i2s(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief mute or unmute the codec
+ *
+ * @param mute:  true, false
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t zl38063_codec_set_voice_mute(bool mute);
+
+/**
+ * @brief  Set voice volume
+ *
+ * @param volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t zl38063_codec_set_voice_volume(int volume);
+
+/**
+ * @brief Get voice volume
+ *
+ * @param[out] *volume:  voice volume (0~100)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t zl38063_codec_get_voice_volume(int *volume);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_hal/include/audio_hal.h b/components/audio_hal/include/audio_hal.h
old mode 100755
new mode 100644
index 1a9cf12a..470a0d73
--- a/components/audio_hal/include/audio_hal.h
+++ b/components/audio_hal/include/audio_hal.h
@@ -1,247 +1,247 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_HAL_H_
-#define _AUDIO_HAL_H_
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-#include "audio_error.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define AUDIO_HAL_VOL_DEFAULT 70
-
-typedef struct audio_hal *audio_hal_handle_t;
-
-/**
- * @brief Select media hal codec mode
- */
-typedef enum {
-    AUDIO_HAL_CODEC_MODE_ENCODE = 1,  /*!< select adc */
-    AUDIO_HAL_CODEC_MODE_DECODE,      /*!< select dac */
-    AUDIO_HAL_CODEC_MODE_BOTH,        /*!< select both adc and dac */
-    AUDIO_HAL_CODEC_MODE_LINE_IN,     /*!< set adc channel */
-} audio_hal_codec_mode_t;
-
-/**
- * @brief Select adc channel for input mic signal
- */
-typedef enum {
-    AUDIO_HAL_ADC_INPUT_LINE1 = 0x00,  /*!< mic input to adc channel 1 */
-    AUDIO_HAL_ADC_INPUT_LINE2,         /*!< mic input to adc channel 2 */
-    AUDIO_HAL_ADC_INPUT_ALL,           /*!< mic input to both channels of adc */
-    AUDIO_HAL_ADC_INPUT_DIFFERENCE,    /*!< mic input to adc difference channel */
-} audio_hal_adc_input_t;
-
-/**
- * @brief Select channel for dac output
- */
-typedef enum {
-    AUDIO_HAL_DAC_OUTPUT_LINE1 = 0x00,  /*!< dac output signal to channel 1 */
-    AUDIO_HAL_DAC_OUTPUT_LINE2,         /*!< dac output signal to channel 2 */
-    AUDIO_HAL_DAC_OUTPUT_ALL,           /*!< dac output signal to both channels */
-} audio_hal_dac_output_t;
-
-/**
- * @brief Select operating mode i.e. start or stop for audio codec chip
- */
-typedef enum {
-    AUDIO_HAL_CTRL_STOP  = 0x00,  /*!< set stop mode */
-    AUDIO_HAL_CTRL_START = 0x01,  /*!< set start mode */
-} audio_hal_ctrl_t;
-
-/**
- * @brief Select I2S interface operating mode i.e. master or slave for audio codec chip
- */
-typedef enum {
-    AUDIO_HAL_MODE_SLAVE = 0x00,   /*!< set slave mode */
-    AUDIO_HAL_MODE_MASTER = 0x01,  /*!< set master mode */
-} audio_hal_iface_mode_t;
-
-/**
- * @brief Select I2S interface samples per second
- */
-typedef enum {
-    AUDIO_HAL_08K_SAMPLES,   /*!< set to  8k samples per second */
-    AUDIO_HAL_11K_SAMPLES,   /*!< set to 11.025k samples per second */
-    AUDIO_HAL_16K_SAMPLES,   /*!< set to 16k samples in per second */
-    AUDIO_HAL_22K_SAMPLES,   /*!< set to 22.050k samples per second */
-    AUDIO_HAL_24K_SAMPLES,   /*!< set to 24k samples in per second */
-    AUDIO_HAL_32K_SAMPLES,   /*!< set to 32k samples in per second */
-    AUDIO_HAL_44K_SAMPLES,   /*!< set to 44.1k samples per second */
-    AUDIO_HAL_48K_SAMPLES,   /*!< set to 48k samples per second */
-} audio_hal_iface_samples_t;
-
-/**
- * @brief Select I2S interface number of bits per sample
- */
-typedef enum {
-    AUDIO_HAL_BIT_LENGTH_16BITS = 1,   /*!< set 16 bits per sample */
-    AUDIO_HAL_BIT_LENGTH_24BITS,       /*!< set 24 bits per sample */
-    AUDIO_HAL_BIT_LENGTH_32BITS,       /*!< set 32 bits per sample */
-} audio_hal_iface_bits_t;
-
-/**
- * @brief Select I2S interface format for audio codec chip
- */
-typedef enum {
-    AUDIO_HAL_I2S_NORMAL = 0,  /*!< set normal I2S format */
-    AUDIO_HAL_I2S_LEFT,        /*!< set all left format */
-    AUDIO_HAL_I2S_RIGHT,       /*!< set all right format */
-    AUDIO_HAL_I2S_DSP,         /*!< set dsp/pcm format */
-} audio_hal_iface_format_t;
-
-/**
- * @brief I2s interface configuration for audio codec chip
- */
-typedef struct {
-    audio_hal_iface_mode_t mode;        /*!< audio codec chip mode */
-    audio_hal_iface_format_t fmt;       /*!< I2S interface format */
-    audio_hal_iface_samples_t samples;  /*!< I2S interface samples per second */
-    audio_hal_iface_bits_t bits;        /*!< i2s interface number of bits per sample */
-} audio_hal_codec_i2s_iface_t;
-
-/**
- * @brief Configure media hal for initialization of audio codec chip
- */
-typedef struct {
-    audio_hal_adc_input_t adc_input;       /*!< set adc channel */
-    audio_hal_dac_output_t dac_output;     /*!< set dac channel */
-    audio_hal_codec_mode_t codec_mode;     /*!< select codec mode: adc, dac or both */
-    audio_hal_codec_i2s_iface_t i2s_iface; /*!< set I2S interface configuration */
-} audio_hal_codec_config_t;
-
-/**
- * @brief Configuration of functions and variables used to operate audio codec chip
- */
-typedef struct audio_hal {
-    esp_err_t (*audio_codec_initialize)(audio_hal_codec_config_t *codec_cfg);                                /*!< initialize codec */
-    esp_err_t (*audio_codec_deinitialize)(void);                                                             /*!< deinitialize codec */
-    esp_err_t (*audio_codec_ctrl)(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);                 /*!< control codec mode and state */
-    esp_err_t (*audio_codec_config_iface)(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);  /*!< configure i2s interface */
-    esp_err_t (*audio_codec_set_mute) (bool mute);                                                           /*!< set codec mute */
-    esp_err_t (*audio_codec_set_volume)(int volume);                                                         /*!< set codec volume */
-    esp_err_t (*audio_codec_get_volume)(int *volume);                                                        /*!< get codec volume */
-    esp_err_t (*audio_codec_enable_pa) (bool enable);                                                        /*!< enable pa */
-    xSemaphoreHandle audio_hal_lock;                                                                         /*!< semaphore of codec */
-    void *handle;                                                                                            /*!< handle of audio codec */
-} audio_hal_func_t;
-
-
-/**
- * @brief Initialize media codec driver
- *
- * @note If selected codec has already been installed, it'll return the audio_hal handle.
- *
- * @param audio_hal_conf Configure structure audio_hal_config_t
- * @param audio_hal_func Structure containing functions used to operate audio the codec chip
- *
- * @return  int, 0--success, others--fail
- */
-audio_hal_handle_t audio_hal_init(audio_hal_codec_config_t *audio_hal_conf, audio_hal_func_t *audio_hal_func);
-
-/**
- * @brief Uninitialize media codec driver
- *
- * @param audio_hal reference function pointer for selected audio codec
- *
- * @return  int, 0--success, others--fail
- */
-esp_err_t audio_hal_deinit(audio_hal_handle_t audio_hal);
-
-/**
- * @brief Start/stop codec driver
- *
- * @param audio_hal reference function pointer for selected audio codec
- * @param mode select media hal codec mode either encode/decode/or both to start from audio_hal_codec_mode_t
- * @param audio_hal_ctrl select start stop state for specific mode
- *
- * @return     int, 0--success, others--fail
- */
-esp_err_t audio_hal_ctrl_codec(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_ctrl_t audio_hal_ctrl);
-
-/**
- * @brief Set codec I2S interface samples rate & bit width and format either I2S or PCM/DSP.
- *
- * @param audio_hal reference function pointer for selected audio codec
- * @param mode select media hal codec mode either encode/decode/or both to start from audio_hal_codec_mode_t
- * @param iface I2S sample rate (ex: 16000, 44100), I2S bit width (16, 24, 32),I2s format (I2S, PCM, DSP).
- *
- * @return
- *     - 0   Success
- *     - -1  Error
- */
-esp_err_t audio_hal_codec_iface_config(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
-
-/**
- * @brief Set voice mute. Enables or disables DAC mute of a codec.
- *        @note `audio_hal_get_volume` will still give a non-zero number in mute state. It will be set to that number when speaker is unmuted.
- *
- * @param audio_hal reference function pointer for selected audio codec
- * @param mute      true/false. If true speaker will be muted and if false speaker will be unmuted.
- *
- * @return     int, 0--success, others--fail
- */
-esp_err_t audio_hal_set_mute(audio_hal_handle_t audio_hal, bool mute);
-
-/**
- * @brief Set voice volume.
- *        @note if volume is 0, mute is enabled,range is 0-100.
- *
- * @param audio_hal reference function pointer for selected audio codec
- * @param volume value of volume in percent(%)
- *
- * @return     int, 0--success, others--fail
- */
-esp_err_t audio_hal_set_volume(audio_hal_handle_t audio_hal, int volume);
-
-/**
- * @brief get voice volume.
- *        @note if volume is 0, mute is enabled, range is 0-100.
- *
- * @param audio_hal reference function pointer for selected audio codec
- * @param volume value of volume in percent returned(%)
- *
- * @return     int, 0--success, others--fail
- */
-esp_err_t audio_hal_get_volume(audio_hal_handle_t audio_hal, int *volume);
-
-/**
- * @brief Enables or disables PA.
- *
- * @param audio_hal reference function pointer for selected audio codec
- * @param enable    true/false.
- *
- * @return     int, 0--success, others--fail
- */
-esp_err_t audio_hal_enable_pa(audio_hal_handle_t audio_hal, bool enable);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //__AUDIO_HAL_H__
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_HAL_H_
+#define _AUDIO_HAL_H_
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+#include "audio_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define AUDIO_HAL_VOL_DEFAULT 70
+
+typedef struct audio_hal *audio_hal_handle_t;
+
+/**
+ * @brief Select media hal codec mode
+ */
+typedef enum {
+    AUDIO_HAL_CODEC_MODE_ENCODE = 1,  /*!< select adc */
+    AUDIO_HAL_CODEC_MODE_DECODE,      /*!< select dac */
+    AUDIO_HAL_CODEC_MODE_BOTH,        /*!< select both adc and dac */
+    AUDIO_HAL_CODEC_MODE_LINE_IN,     /*!< set adc channel */
+} audio_hal_codec_mode_t;
+
+/**
+ * @brief Select adc channel for input mic signal
+ */
+typedef enum {
+    AUDIO_HAL_ADC_INPUT_LINE1 = 0x00,  /*!< mic input to adc channel 1 */
+    AUDIO_HAL_ADC_INPUT_LINE2,         /*!< mic input to adc channel 2 */
+    AUDIO_HAL_ADC_INPUT_ALL,           /*!< mic input to both channels of adc */
+    AUDIO_HAL_ADC_INPUT_DIFFERENCE,    /*!< mic input to adc difference channel */
+} audio_hal_adc_input_t;
+
+/**
+ * @brief Select channel for dac output
+ */
+typedef enum {
+    AUDIO_HAL_DAC_OUTPUT_LINE1 = 0x00,  /*!< dac output signal to channel 1 */
+    AUDIO_HAL_DAC_OUTPUT_LINE2,         /*!< dac output signal to channel 2 */
+    AUDIO_HAL_DAC_OUTPUT_ALL,           /*!< dac output signal to both channels */
+} audio_hal_dac_output_t;
+
+/**
+ * @brief Select operating mode i.e. start or stop for audio codec chip
+ */
+typedef enum {
+    AUDIO_HAL_CTRL_STOP  = 0x00,  /*!< set stop mode */
+    AUDIO_HAL_CTRL_START = 0x01,  /*!< set start mode */
+} audio_hal_ctrl_t;
+
+/**
+ * @brief Select I2S interface operating mode i.e. master or slave for audio codec chip
+ */
+typedef enum {
+    AUDIO_HAL_MODE_SLAVE = 0x00,   /*!< set slave mode */
+    AUDIO_HAL_MODE_MASTER = 0x01,  /*!< set master mode */
+} audio_hal_iface_mode_t;
+
+/**
+ * @brief Select I2S interface samples per second
+ */
+typedef enum {
+    AUDIO_HAL_08K_SAMPLES,   /*!< set to  8k samples per second */
+    AUDIO_HAL_11K_SAMPLES,   /*!< set to 11.025k samples per second */
+    AUDIO_HAL_16K_SAMPLES,   /*!< set to 16k samples in per second */
+    AUDIO_HAL_22K_SAMPLES,   /*!< set to 22.050k samples per second */
+    AUDIO_HAL_24K_SAMPLES,   /*!< set to 24k samples in per second */
+    AUDIO_HAL_32K_SAMPLES,   /*!< set to 32k samples in per second */
+    AUDIO_HAL_44K_SAMPLES,   /*!< set to 44.1k samples per second */
+    AUDIO_HAL_48K_SAMPLES,   /*!< set to 48k samples per second */
+} audio_hal_iface_samples_t;
+
+/**
+ * @brief Select I2S interface number of bits per sample
+ */
+typedef enum {
+    AUDIO_HAL_BIT_LENGTH_16BITS = 1,   /*!< set 16 bits per sample */
+    AUDIO_HAL_BIT_LENGTH_24BITS,       /*!< set 24 bits per sample */
+    AUDIO_HAL_BIT_LENGTH_32BITS,       /*!< set 32 bits per sample */
+} audio_hal_iface_bits_t;
+
+/**
+ * @brief Select I2S interface format for audio codec chip
+ */
+typedef enum {
+    AUDIO_HAL_I2S_NORMAL = 0,  /*!< set normal I2S format */
+    AUDIO_HAL_I2S_LEFT,        /*!< set all left format */
+    AUDIO_HAL_I2S_RIGHT,       /*!< set all right format */
+    AUDIO_HAL_I2S_DSP,         /*!< set dsp/pcm format */
+} audio_hal_iface_format_t;
+
+/**
+ * @brief I2s interface configuration for audio codec chip
+ */
+typedef struct {
+    audio_hal_iface_mode_t mode;        /*!< audio codec chip mode */
+    audio_hal_iface_format_t fmt;       /*!< I2S interface format */
+    audio_hal_iface_samples_t samples;  /*!< I2S interface samples per second */
+    audio_hal_iface_bits_t bits;        /*!< i2s interface number of bits per sample */
+} audio_hal_codec_i2s_iface_t;
+
+/**
+ * @brief Configure media hal for initialization of audio codec chip
+ */
+typedef struct {
+    audio_hal_adc_input_t adc_input;       /*!< set adc channel */
+    audio_hal_dac_output_t dac_output;     /*!< set dac channel */
+    audio_hal_codec_mode_t codec_mode;     /*!< select codec mode: adc, dac or both */
+    audio_hal_codec_i2s_iface_t i2s_iface; /*!< set I2S interface configuration */
+} audio_hal_codec_config_t;
+
+/**
+ * @brief Configuration of functions and variables used to operate audio codec chip
+ */
+typedef struct audio_hal {
+    esp_err_t (*audio_codec_initialize)(audio_hal_codec_config_t *codec_cfg);                                /*!< initialize codec */
+    esp_err_t (*audio_codec_deinitialize)(void);                                                             /*!< deinitialize codec */
+    esp_err_t (*audio_codec_ctrl)(audio_hal_codec_mode_t mode, audio_hal_ctrl_t ctrl_state);                 /*!< control codec mode and state */
+    esp_err_t (*audio_codec_config_iface)(audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);  /*!< configure i2s interface */
+    esp_err_t (*audio_codec_set_mute) (bool mute);                                                           /*!< set codec mute */
+    esp_err_t (*audio_codec_set_volume)(int volume);                                                         /*!< set codec volume */
+    esp_err_t (*audio_codec_get_volume)(int *volume);                                                        /*!< get codec volume */
+    esp_err_t (*audio_codec_enable_pa) (bool enable);                                                        /*!< enable pa */
+    SemaphoreHandle_t audio_hal_lock;                                                                         /*!< semaphore of codec */
+    void *handle;                                                                                            /*!< handle of audio codec */
+} audio_hal_func_t;
+
+
+/**
+ * @brief Initialize media codec driver
+ *
+ * @note If selected codec has already been installed, it'll return the audio_hal handle.
+ *
+ * @param audio_hal_conf Configure structure audio_hal_config_t
+ * @param audio_hal_func Structure containing functions used to operate audio the codec chip
+ *
+ * @return  int, 0--success, others--fail
+ */
+audio_hal_handle_t audio_hal_init(audio_hal_codec_config_t *audio_hal_conf, audio_hal_func_t *audio_hal_func);
+
+/**
+ * @brief Uninitialize media codec driver
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ *
+ * @return  int, 0--success, others--fail
+ */
+esp_err_t audio_hal_deinit(audio_hal_handle_t audio_hal);
+
+/**
+ * @brief Start/stop codec driver
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ * @param mode select media hal codec mode either encode/decode/or both to start from audio_hal_codec_mode_t
+ * @param audio_hal_ctrl select start stop state for specific mode
+ *
+ * @return     int, 0--success, others--fail
+ */
+esp_err_t audio_hal_ctrl_codec(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_ctrl_t audio_hal_ctrl);
+
+/**
+ * @brief Set codec I2S interface samples rate & bit width and format either I2S or PCM/DSP.
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ * @param mode select media hal codec mode either encode/decode/or both to start from audio_hal_codec_mode_t
+ * @param iface I2S sample rate (ex: 16000, 44100), I2S bit width (16, 24, 32),I2s format (I2S, PCM, DSP).
+ *
+ * @return
+ *     - 0   Success
+ *     - -1  Error
+ */
+esp_err_t audio_hal_codec_iface_config(audio_hal_handle_t audio_hal, audio_hal_codec_mode_t mode, audio_hal_codec_i2s_iface_t *iface);
+
+/**
+ * @brief Set voice mute. Enables or disables DAC mute of a codec.
+ *        @note `audio_hal_get_volume` will still give a non-zero number in mute state. It will be set to that number when speaker is unmuted.
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ * @param mute      true/false. If true speaker will be muted and if false speaker will be unmuted.
+ *
+ * @return     int, 0--success, others--fail
+ */
+esp_err_t audio_hal_set_mute(audio_hal_handle_t audio_hal, bool mute);
+
+/**
+ * @brief Set voice volume.
+ *        @note if volume is 0, mute is enabled,range is 0-100.
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ * @param volume value of volume in percent(%)
+ *
+ * @return     int, 0--success, others--fail
+ */
+esp_err_t audio_hal_set_volume(audio_hal_handle_t audio_hal, int volume);
+
+/**
+ * @brief get voice volume.
+ *        @note if volume is 0, mute is enabled, range is 0-100.
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ * @param volume value of volume in percent returned(%)
+ *
+ * @return     int, 0--success, others--fail
+ */
+esp_err_t audio_hal_get_volume(audio_hal_handle_t audio_hal, int *volume);
+
+/**
+ * @brief Enables or disables PA.
+ *
+ * @param audio_hal reference function pointer for selected audio codec
+ * @param enable    true/false.
+ *
+ * @return     int, 0--success, others--fail
+ */
+esp_err_t audio_hal_enable_pa(audio_hal_handle_t audio_hal, bool enable);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__AUDIO_HAL_H__
diff --git a/components/audio_hal/include/audio_volume.h b/components/audio_hal/include/audio_volume.h
index 3a4b2a85..7efdd5d8 100644
--- a/components/audio_hal/include/audio_volume.h
+++ b/components/audio_hal/include/audio_volume.h
@@ -1,95 +1,95 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_VOLUME_H_
-#define _AUDIO_VOLUME_H_
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Map of user volume to codec dac volume offset
- */
-typedef float (*audio_codec_dac_vol_offset)(int volume);
-
-typedef void *volume_handle_t;
-
-/**
- * @brief Codec dac volume configurations
- */
-typedef struct {
-    float   max_dac_volume;  /*!< Codec support max volume */
-    float   min_dac_volume;  /*!< Codec support min volume */
-    float   board_pa_gain;   /*!< Board power amplifier gain */
-    float   volume_accuracy; /*!< Codec dac volume accuracy(0.5 or 1) */
-    int8_t  dac_vol_symbol;  /*!< Whether the dac volume is positively correlated with the register value */
-    uint8_t zero_volume_reg; /*!< Codec register value for zero dac volume */
-    uint8_t reg_value;       /*!< Record current dac volume register value */
-    int     user_volume;     /*!< Record the user set volume */
-    audio_codec_dac_vol_offset offset_conv_volume; /*!<  Convert user volume to dac volume offset */
-} codec_dac_volume_config_t;
-
-/**
- * @brief Init the audio dac volume by config
- *
- * @param config Codec dac volume config
- *
- * @return volume_handle_t
- */
-volume_handle_t audio_codec_volume_init(codec_dac_volume_config_t *config);
-
-/**
- * @brief Calculate codec register value by a linear formula
- *
- * @param vol_handle The dac volume handle
- * @param volume User set volume (0-100)
- *
- * @return Codec dac register value
- */
-uint8_t audio_codec_get_dac_reg_value(volume_handle_t vol_handle, int volume);
-
-/**
- * @brief Calculate codec dac volume by a linear formula
- *
- * @param vol_handle The dac volume handle
- *
- * @return Codec dac volume
- */
-float audio_codec_cal_dac_volume(volume_handle_t vol_handle);
-
-/**
- * @brief Deinit the dac volume handle
- *
- * @param vol_handle The dac volume handle
- */
-void audio_codec_volume_deinit(volume_handle_t vol_handle);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //_AUDIO_VOLUME_H_
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_VOLUME_H_
+#define _AUDIO_VOLUME_H_
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Map of user volume to codec dac volume offset
+ */
+typedef float (*audio_codec_dac_vol_offset)(int volume);
+
+typedef void *volume_handle_t;
+
+/**
+ * @brief Codec dac volume configurations
+ */
+typedef struct {
+    float   max_dac_volume;  /*!< Codec support max volume */
+    float   min_dac_volume;  /*!< Codec support min volume */
+    float   board_pa_gain;   /*!< Board power amplifier gain */
+    float   volume_accuracy; /*!< Codec dac volume accuracy(0.5 or 1) */
+    int8_t  dac_vol_symbol;  /*!< Whether the dac volume is positively correlated with the register value */
+    uint8_t zero_volume_reg; /*!< Codec register value for zero dac volume */
+    uint8_t reg_value;       /*!< Record current dac volume register value */
+    int     user_volume;     /*!< Record the user set volume */
+    audio_codec_dac_vol_offset offset_conv_volume; /*!<  Convert user volume to dac volume offset */
+} codec_dac_volume_config_t;
+
+/**
+ * @brief Init the audio dac volume by config
+ *
+ * @param config Codec dac volume config
+ *
+ * @return volume_handle_t
+ */
+volume_handle_t audio_codec_volume_init(codec_dac_volume_config_t *config);
+
+/**
+ * @brief Calculate codec register value by a linear formula
+ *
+ * @param vol_handle The dac volume handle
+ * @param volume User set volume (0-100)
+ *
+ * @return Codec dac register value
+ */
+uint8_t audio_codec_get_dac_reg_value(volume_handle_t vol_handle, int volume);
+
+/**
+ * @brief Calculate codec dac volume by a linear formula
+ *
+ * @param vol_handle The dac volume handle
+ *
+ * @return Codec dac volume
+ */
+float audio_codec_cal_dac_volume(volume_handle_t vol_handle);
+
+/**
+ * @brief Deinit the dac volume handle
+ *
+ * @param vol_handle The dac volume handle
+ */
+void audio_codec_volume_deinit(volume_handle_t vol_handle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //_AUDIO_VOLUME_H_
diff --git a/components/audio_hal/test/component.mk b/components/audio_hal/test/component.mk
index 797fff88..c27e7f8e 100644
--- a/components/audio_hal/test/component.mk
+++ b/components/audio_hal/test/component.mk
@@ -1,2 +1,2 @@
-COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
+COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
 COMPONENT_EMBED_TXTFILES := test.pcm
\ No newline at end of file
diff --git a/components/audio_hal/test/test_audio_hal.c b/components/audio_hal/test/test_audio_hal.c
index d7219d8e..ba70f9a3 100644
--- a/components/audio_hal/test/test_audio_hal.c
+++ b/components/audio_hal/test/test_audio_hal.c
@@ -1,168 +1,168 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "board.h"
-#include "audio_hal.h"
-#include "driver/i2s.h"
-#include "driver/gpio.h"
-#include "unity.h"
-#include "es8311.h"
-#include "es8388.h"
-#include "zl38063.h"
-
-
-#define TEST_I2S_NUM  I2S_NUM_0
-
-static const char *TAG = "TEST_AUDIO_HAL";
-
-extern const uint8_t test_pcm_start[] asm("_binary_test_pcm_start");
-extern const uint8_t test_pcm_end[]   asm("_binary_test_pcm_end");
-
-static void i2s_init()
-{
-    i2s_config_t i2s_cfg = {
-        .mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX,
-        .sample_rate = 16000,
-        .bits_per_sample = 16,
-        .channel_format = I2S_CHANNEL_FMT_ONLY_RIGHT,
-        .communication_format = I2S_COMM_FORMAT_I2S,
-        .dma_buf_count = 3,
-        .dma_buf_len = 300,
-        .use_apll = 1,
-        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2,
-    };
-
-    i2s_driver_install(TEST_I2S_NUM, &i2s_cfg, 0, NULL);
-    i2s_pin_config_t i2s_pin_cfg = {0};
-    if (sizeof(board_i2s_pin_t) == sizeof(i2s_pin_config_t)) {
-        get_i2s_pins(TEST_I2S_NUM, (board_i2s_pin_t*)&i2s_pin_cfg);
-        i2s_set_pin(TEST_I2S_NUM, &i2s_pin_cfg);
-    }
-}
-
-static void i2s_deinit()
-{
-    i2s_driver_uninstall(TEST_I2S_NUM);
-}
-
-TEST_CASE("Usage test", "[audio_hal]")
-{
-    ESP_LOGI(TAG, "Initialize i2s");
-    i2s_init();
-
-    ESP_LOGI(TAG, "Start codec chip");
-    audio_board_handle_t board_handle = audio_board_init();
-    TEST_ASSERT_NOT_NULL(board_handle);
-    TEST_ASSERT_FALSE(audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START));
-
-    ESP_LOGI(TAG, "Set codec volume");
-    TEST_ASSERT_FALSE(audio_hal_set_volume(board_handle->audio_hal, 65));
-
-    int volume = 0;
-    TEST_ASSERT_FALSE(audio_hal_get_volume(board_handle->audio_hal, &volume));
-    ESP_LOGI(TAG, "Get codec volume: %d", volume);
-
-    size_t bytes_written = 0;
-    ESP_LOGI(TAG, "Start to play music");
-    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
-
-    ESP_LOGW(TAG, "Reach the end of music, release all resource");
-    TEST_ASSERT_FALSE(audio_board_deinit(board_handle));
-    i2c_driver_delete(I2C_NUM_0);
-    i2s_deinit();
-}
-
-/*
- * To run this case, please choose Lyrat_v4.3 in menuconfig and run on lyrat_v4.3 board
- */
-TEST_CASE("Test for es8388 driver", "[audio_hal]")
-{
-    ESP_LOGI(TAG, "Initialize i2s");
-    i2s_init();
-
-    ESP_LOGI(TAG, "Start es8388 codec chip");
-    audio_hal_codec_config_t es8388_cfg = AUDIO_CODEC_DEFAULT_CONFIG();
-    TEST_ASSERT_FALSE(es8388_init(&es8388_cfg));
-    TEST_ASSERT_FALSE(es8388_config_i2s(es8388_cfg.codec_mode, &es8388_cfg.i2s_iface));
-    TEST_ASSERT_FALSE(es8388_ctrl_state(AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START));
-    TEST_ASSERT_FALSE(es8388_set_voice_volume(50));
-
-    size_t bytes_written = 0;
-    ESP_LOGI(TAG, "Start to play music");
-    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
-
-    ESP_LOGW(TAG, "Reach the end of music, release all resource");
-    i2c_driver_delete(I2C_NUM_0);
-    i2s_deinit();
-}
-
-/*
- * To run this case, please choose Lyrat_mini in menuconfig and run on lyrat_mini board
- */
-TEST_CASE("Test for es8311 driver", "[audio_hal]")
-{
-    ESP_LOGI(TAG, "Initialize i2s");
-    i2s_init();
-
-    ESP_LOGI(TAG, "Start es8311 codec chip");
-    audio_hal_codec_config_t es8311_cfg = AUDIO_CODEC_DEFAULT_CONFIG();
-    TEST_ASSERT_FALSE(es8311_codec_init(&es8311_cfg));
-    TEST_ASSERT_FALSE(es8311_codec_config_i2s(es8311_cfg.codec_mode, &es8311_cfg.i2s_iface));
-    TEST_ASSERT_FALSE(es8311_codec_ctrl_state(AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START));
-    TEST_ASSERT_FALSE(es8311_codec_set_voice_volume(50));
-
-    size_t bytes_written = 0;
-    ESP_LOGI(TAG, "Start to play music");
-    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
-
-    ESP_LOGW(TAG, "Reach the end of music, release all resource");
-    i2c_driver_delete(I2C_NUM_0);
-    i2s_deinit();
-}
-
-/*
- * To run this case, please choose LyratD_MSC in menuconfig and run on lyratD_MSC board
- */
-TEST_CASE("Test for zl38063 driver", "[audio_hal]")
-{
-    ESP_LOGI(TAG, "Initialize i2s");
-    i2s_init();
-
-    ESP_LOGI(TAG, "Start zl38063 DSP");
-    audio_hal_codec_config_t zl38063_cfg = AUDIO_CODEC_DEFAULT_CONFIG();
-    TEST_ASSERT_FALSE(zl38063_codec_init(&zl38063_cfg));
-    TEST_ASSERT_FALSE(zl38063_codec_config_i2s(zl38063_cfg.codec_mode, &zl38063_cfg.i2s_iface));
-    TEST_ASSERT_FALSE(zl38063_codec_ctrl_state(AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START));
-    TEST_ASSERT_FALSE(zl38063_codec_set_voice_volume(50));
-
-    size_t bytes_written = 0;
-    ESP_LOGI(TAG, "Start to play music");
-    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
-
-    ESP_LOGW(TAG, "Reach the end of music, release all resource");
-    i2c_driver_delete(I2C_NUM_0);
-    i2s_deinit();
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "board.h"
+#include "audio_hal.h"
+#include "driver/i2s.h"
+#include "driver/gpio.h"
+#include "unity.h"
+#include "es8311.h"
+#include "es8388.h"
+#include "zl38063.h"
+
+
+#define TEST_I2S_NUM  I2S_NUM_0
+
+static const char *TAG = "TEST_AUDIO_HAL";
+
+extern const uint8_t test_pcm_start[] asm("_binary_test_pcm_start");
+extern const uint8_t test_pcm_end[]   asm("_binary_test_pcm_end");
+
+static void i2s_init()
+{
+    i2s_config_t i2s_cfg = {
+        .mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX,
+        .sample_rate = 16000,
+        .bits_per_sample = 16,
+        .channel_format = I2S_CHANNEL_FMT_ONLY_RIGHT,
+        .communication_format = I2S_COMM_FORMAT_I2S,
+        .dma_buf_count = 3,
+        .dma_buf_len = 300,
+        .use_apll = 1,
+        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2,
+    };
+
+    i2s_driver_install(TEST_I2S_NUM, &i2s_cfg, 0, NULL);
+    i2s_pin_config_t i2s_pin_cfg = {0};
+    if (sizeof(board_i2s_pin_t) == sizeof(i2s_pin_config_t)) {
+        get_i2s_pins(TEST_I2S_NUM, (board_i2s_pin_t*)&i2s_pin_cfg);
+        i2s_set_pin(TEST_I2S_NUM, &i2s_pin_cfg);
+    }
+}
+
+static void i2s_deinit()
+{
+    i2s_driver_uninstall(TEST_I2S_NUM);
+}
+
+TEST_CASE("Usage test", "[audio_hal]")
+{
+    ESP_LOGI(TAG, "Initialize i2s");
+    i2s_init();
+
+    ESP_LOGI(TAG, "Start codec chip");
+    audio_board_handle_t board_handle = audio_board_init();
+    TEST_ASSERT_NOT_NULL(board_handle);
+    TEST_ASSERT_FALSE(audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START));
+
+    ESP_LOGI(TAG, "Set codec volume");
+    TEST_ASSERT_FALSE(audio_hal_set_volume(board_handle->audio_hal, 65));
+
+    int volume = 0;
+    TEST_ASSERT_FALSE(audio_hal_get_volume(board_handle->audio_hal, &volume));
+    ESP_LOGI(TAG, "Get codec volume: %d", volume);
+
+    size_t bytes_written = 0;
+    ESP_LOGI(TAG, "Start to play music");
+    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
+
+    ESP_LOGW(TAG, "Reach the end of music, release all resource");
+    TEST_ASSERT_FALSE(audio_board_deinit(board_handle));
+    i2c_driver_delete(I2C_NUM_0);
+    i2s_deinit();
+}
+
+/*
+ * To run this case, please choose Lyrat_v4.3 in menuconfig and run on lyrat_v4.3 board
+ */
+TEST_CASE("Test for es8388 driver", "[audio_hal]")
+{
+    ESP_LOGI(TAG, "Initialize i2s");
+    i2s_init();
+
+    ESP_LOGI(TAG, "Start es8388 codec chip");
+    audio_hal_codec_config_t es8388_cfg = AUDIO_CODEC_DEFAULT_CONFIG();
+    TEST_ASSERT_FALSE(es8388_init(&es8388_cfg));
+    TEST_ASSERT_FALSE(es8388_config_i2s(es8388_cfg.codec_mode, &es8388_cfg.i2s_iface));
+    TEST_ASSERT_FALSE(es8388_ctrl_state(AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START));
+    TEST_ASSERT_FALSE(es8388_set_voice_volume(50));
+
+    size_t bytes_written = 0;
+    ESP_LOGI(TAG, "Start to play music");
+    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
+
+    ESP_LOGW(TAG, "Reach the end of music, release all resource");
+    i2c_driver_delete(I2C_NUM_0);
+    i2s_deinit();
+}
+
+/*
+ * To run this case, please choose Lyrat_mini in menuconfig and run on lyrat_mini board
+ */
+TEST_CASE("Test for es8311 driver", "[audio_hal]")
+{
+    ESP_LOGI(TAG, "Initialize i2s");
+    i2s_init();
+
+    ESP_LOGI(TAG, "Start es8311 codec chip");
+    audio_hal_codec_config_t es8311_cfg = AUDIO_CODEC_DEFAULT_CONFIG();
+    TEST_ASSERT_FALSE(es8311_codec_init(&es8311_cfg));
+    TEST_ASSERT_FALSE(es8311_codec_config_i2s(es8311_cfg.codec_mode, &es8311_cfg.i2s_iface));
+    TEST_ASSERT_FALSE(es8311_codec_ctrl_state(AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START));
+    TEST_ASSERT_FALSE(es8311_codec_set_voice_volume(50));
+
+    size_t bytes_written = 0;
+    ESP_LOGI(TAG, "Start to play music");
+    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
+
+    ESP_LOGW(TAG, "Reach the end of music, release all resource");
+    i2c_driver_delete(I2C_NUM_0);
+    i2s_deinit();
+}
+
+/*
+ * To run this case, please choose LyratD_MSC in menuconfig and run on lyratD_MSC board
+ */
+TEST_CASE("Test for zl38063 driver", "[audio_hal]")
+{
+    ESP_LOGI(TAG, "Initialize i2s");
+    i2s_init();
+
+    ESP_LOGI(TAG, "Start zl38063 DSP");
+    audio_hal_codec_config_t zl38063_cfg = AUDIO_CODEC_DEFAULT_CONFIG();
+    TEST_ASSERT_FALSE(zl38063_codec_init(&zl38063_cfg));
+    TEST_ASSERT_FALSE(zl38063_codec_config_i2s(zl38063_cfg.codec_mode, &zl38063_cfg.i2s_iface));
+    TEST_ASSERT_FALSE(zl38063_codec_ctrl_state(AUDIO_HAL_CODEC_MODE_BOTH, AUDIO_HAL_CTRL_START));
+    TEST_ASSERT_FALSE(zl38063_codec_set_voice_volume(50));
+
+    size_t bytes_written = 0;
+    ESP_LOGI(TAG, "Start to play music");
+    TEST_ASSERT_FALSE(i2s_write(TEST_I2S_NUM, test_pcm_start, test_pcm_end - test_pcm_start, &bytes_written, portMAX_DELAY));
+
+    ESP_LOGW(TAG, "Reach the end of music, release all resource");
+    i2c_driver_delete(I2C_NUM_0);
+    i2s_deinit();
+}
diff --git a/components/audio_pipeline/CMakeLists.txt b/components/audio_pipeline/CMakeLists.txt
index da246fe5..0b876f85 100644
--- a/components/audio_pipeline/CMakeLists.txt
+++ b/components/audio_pipeline/CMakeLists.txt
@@ -1,11 +1,12 @@
-
-set(COMPONENT_ADD_INCLUDEDIRS "include")
-
-set(COMPONENT_SRCS "audio_element.c"
-                    "audio_event_iface.c"
-                    "audio_pipeline.c"
-                    "ringbuf.c")
-
-set(COMPONENT_REQUIRES audio_sal esp-adf-libs)
-
-register_component()
+
+set(COMPONENT_ADD_INCLUDEDIRS "include")
+
+set(COMPONENT_SRCS "audio_element.c"
+                    "audio_event_iface.c"
+                    "audio_pipeline.c"
+                    "ringbuf.c"
+                    "i2s_debug.c")
+
+set(COMPONENT_REQUIRES audio_sal esp-adf-libs driver)
+
+register_component()
diff --git a/components/audio_pipeline/audio_element.c b/components/audio_pipeline/audio_element.c
index 39b24468..eaded0d0 100644
--- a/components/audio_pipeline/audio_element.c
+++ b/components/audio_pipeline/audio_element.c
@@ -1,1522 +1,1522 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/event_groups.h"
-
-#include "esp_log.h"
-#include "audio_element.h"
-#include "audio_mem.h"
-#include "audio_mutex.h"
-#include "audio_error.h"
-#include "audio_thread.h"
-
-static const char *TAG = "AUDIO_ELEMENT";
-#define DEFAULT_MAX_WAIT_TIME       (2000/portTICK_RATE_MS)
-
-/**
- *  I/O Element Abstract
- */
-typedef struct io_callback {
-    stream_func                 cb;
-    void                        *ctx;
-} io_callback_t;
-
-/**
- *  Audio Callback Abstract
- */
-typedef struct audio_callback {
-    event_cb_func               cb;
-    void                        *ctx;
-} audio_callback_t;
-
-typedef struct audio_multi_rb {
-    ringbuf_handle_t            *rb;
-    int                         max_rb_num;
-} audio_multi_rb_t;
-
-typedef enum {
-    IO_TYPE_RB = 1, /* I/O through ringbuffer */
-    IO_TYPE_CB,     /* I/O through callback */
-} io_type_t;
-
-typedef enum {
-    EVENTS_TYPE_Q = 1,  /* Events through MessageQueue */
-    EVENTS_TYPE_CB,     /* Events through Callback function */
-} events_type_t;
-
-struct audio_element {
-    /* Functions/RingBuffers */
-    el_io_func                  open;
-    ctrl_func                   seek;
-    process_func                process;
-    el_io_func                  close;
-    el_io_func                  destroy;
-    io_type_t                   read_type;
-    union {
-        ringbuf_handle_t        input_rb;
-        io_callback_t           read_cb;
-    } in;
-    io_type_t                   write_type;
-    union {
-        ringbuf_handle_t        output_rb;
-        io_callback_t           write_cb;
-    } out;
-
-    audio_multi_rb_t            multi_in;
-    audio_multi_rb_t            multi_out;
-
-    /* Properties */
-    volatile bool               is_open;
-    audio_element_state_t       state;
-
-    events_type_t               events_type;
-    audio_event_iface_handle_t  iface_event;
-    audio_callback_t            callback_event;
-
-    int                         buf_size;
-    char                        *buf;
-
-    char                        *tag;
-    int                         task_stack;
-    int                         task_prio;
-    int                         task_core;
-    xSemaphoreHandle            lock;
-    audio_element_info_t        info;
-    audio_element_info_t        *report_info;
-
-    bool                        stack_in_ext;
-    audio_thread_t              audio_thread;
-
-    /* PrivateData */
-    void                        *data;
-    EventGroupHandle_t          state_event;
-    int                         input_wait_time;
-    int                         output_wait_time;
-    int                         out_buf_size_expect;
-    int                         out_rb_size;
-    volatile bool               is_running;
-    volatile bool               task_run;
-    volatile bool               stopping;
-};
-
-const static int STOPPED_BIT = BIT0;
-const static int STARTED_BIT = BIT1;
-const static int BUFFER_REACH_LEVEL_BIT = BIT2;
-const static int TASK_CREATED_BIT = BIT3;
-const static int TASK_DESTROYED_BIT = BIT4;
-const static int PAUSED_BIT = BIT5;
-const static int RESUMED_BIT = BIT6;
-
-static esp_err_t audio_element_on_cmd_error(audio_element_handle_t el);
-static esp_err_t audio_element_on_cmd_stop(audio_element_handle_t el);
-
-static esp_err_t audio_element_force_set_state(audio_element_handle_t el, audio_element_state_t new_state)
-{
-    el->state = new_state;
-    return ESP_OK;
-}
-
-static esp_err_t audio_element_cmd_send(audio_element_handle_t el, audio_element_msg_cmd_t cmd)
-{
-    audio_event_iface_msg_t msg = {
-        .source = el,
-        .source_type = AUDIO_ELEMENT_TYPE_ELEMENT,
-        .cmd = cmd,
-    };
-    ESP_LOGV(TAG, "[%s]evt internal cmd = %d", el->tag, msg.cmd);
-    return audio_event_iface_cmd(el->iface_event, &msg);
-}
-
-static esp_err_t audio_element_msg_sendout(audio_element_handle_t el, audio_event_iface_msg_t *msg)
-{
-    msg->source = el;
-    msg->source_type = AUDIO_ELEMENT_TYPE_ELEMENT;
-    if (el->events_type == EVENTS_TYPE_CB && el->callback_event.cb) {
-        return el->callback_event.cb(el, msg, el->callback_event.ctx);
-    }
-    return audio_event_iface_sendout(el->iface_event, msg);
-}
-
-esp_err_t audio_element_process_init(audio_element_handle_t el)
-{
-    if (el->open == NULL) {
-        el->is_open = true;
-        xEventGroupSetBits(el->state_event, STARTED_BIT);
-        return ESP_OK;
-    }
-    el->is_open = true;
-    audio_element_force_set_state(el, AEL_STATE_INITIALIZING);
-    esp_err_t ret = el->open(el);
-    if (ret == ESP_OK) {
-        ESP_LOGD(TAG, "[%s] el opened", el->tag);
-        audio_element_force_set_state(el, AEL_STATE_RUNNING);
-        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
-        xEventGroupSetBits(el->state_event, STARTED_BIT);
-        return ESP_OK;
-    } else if (ret == AEL_IO_DONE) {
-        ESP_LOGW(TAG, "[%s] OPEN AEL_IO_DONE", el->tag);
-        audio_element_force_set_state(el, AEL_STATE_RUNNING);
-        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
-        return ESP_OK;
-    } else if (ret == AEL_IO_ABORT) {
-        ESP_LOGW(TAG, "[%s] AEL_IO_ABORT, %d", el->tag, ret);
-        audio_element_on_cmd_stop(el);
-    } else {
-        ESP_LOGE(TAG, "[%s] AEL_STATUS_ERROR_OPEN,%d", el->tag, ret);
-        audio_element_force_set_state(el, AEL_STATE_ERROR);
-        audio_element_report_status(el, AEL_STATUS_ERROR_OPEN);
-        audio_element_on_cmd_error(el);
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_process_deinit(audio_element_handle_t el)
-{
-    if (el->is_open && el->close) {
-        ESP_LOGV(TAG, "[%s] will be closed, line %d", el->tag, __LINE__);
-        el->close(el);
-    }
-    el->is_open = false;
-    return ESP_OK;
-}
-
-static esp_err_t audio_element_on_cmd_error(audio_element_handle_t el)
-{
-    if (el->state != AEL_STATE_STOPPED) {
-        ESP_LOGW(TAG, "[%s] audio_element_on_cmd_error,%d", el->tag, el->state);
-        audio_element_process_deinit(el);
-        el->state = AEL_STATE_ERROR;
-        audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
-        el->is_running = false;
-        xEventGroupSetBits(el->state_event, STOPPED_BIT);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t audio_element_on_cmd_stop(audio_element_handle_t el)
-{
-    if (el->state == AEL_STATE_INIT) {
-        ESP_LOGW(TAG, "[%p-%s] is already in the AEL_STATE_INIT state", el, el->tag);
-        return ESP_OK;
-    }
-    if ((el->state != AEL_STATE_FINISHED) && (el->state != AEL_STATE_STOPPED)) {
-        audio_element_process_deinit(el);
-        el->state = AEL_STATE_STOPPED;
-        audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
-        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
-        el->is_running = false;
-        el->stopping = false;
-        ESP_LOGD(TAG, "[%p-%s] audio_element_on_cmd_stop, line: %d, state: %d", el, el->tag, __LINE__, el->state);
-        xEventGroupSetBits(el->state_event, STOPPED_BIT);
-    } else {
-        // Change element state to AEL_STATE_STOPPED, even if AEL_STATE_ERROR or AEL_STATE_FINISHED
-        // Except AEL_STATE_STOPPED and is not running
-        ESP_LOGD(TAG, "[%p-%s] audio_element_on_cmd_stop, line: %d, state: %d", el, el->tag, __LINE__, el->state);
-        if ((el->is_running == false) && (el->state == AEL_STATE_STOPPED)) {
-            el->stopping = false;
-            return ESP_OK;
-        }
-        el->state = AEL_STATE_STOPPED;
-        el->is_running = false;
-        el->stopping = false;
-        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
-        xEventGroupSetBits(el->state_event, STOPPED_BIT);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t audio_element_on_cmd_finish(audio_element_handle_t el)
-{
-    if ((el->state == AEL_STATE_ERROR)
-        || (el->state == AEL_STATE_STOPPED)) {
-        ESP_LOGD(TAG, "[%s] audio_element_on_cmd_finish, state:%d", el->tag, el->state);
-        return ESP_OK;
-    }
-    audio_element_process_deinit(el);
-    el->state = AEL_STATE_FINISHED;
-    audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
-    audio_element_report_status(el, AEL_STATUS_STATE_FINISHED);
-    el->is_running = false;
-    xEventGroupSetBits(el->state_event, STOPPED_BIT);
-    ESP_LOGD(TAG, "[%s] audio_element_on_cmd_finish", el->tag);
-    return ESP_OK;
-}
-
-static esp_err_t audio_element_on_cmd_resume(audio_element_handle_t el)
-{
-    if (el->state == AEL_STATE_RUNNING) {
-        el->is_running = true;
-        xEventGroupSetBits(el->state_event, RESUMED_BIT);
-        return ESP_OK;
-    }
-    if (el->state != AEL_STATE_INIT && el->state != AEL_STATE_RUNNING && el->state != AEL_STATE_PAUSED) {
-        audio_element_reset_output_ringbuf(el);
-    }
-    el->is_running = true;
-    xEventGroupSetBits(el->state_event, RESUMED_BIT);
-    if (audio_element_process_init(el) != ESP_OK) {
-        audio_element_abort_output_ringbuf(el);
-        audio_element_abort_input_ringbuf(el);
-        el->is_running = false;
-        return ESP_FAIL;
-    }
-    audio_event_iface_set_cmd_waiting_timeout(el->iface_event, 0);
-    xEventGroupClearBits(el->state_event, STOPPED_BIT);
-    return ESP_OK;
-}
-
-static esp_err_t audio_element_on_cmd(audio_event_iface_msg_t *msg, void *context)
-{
-    audio_element_handle_t el = (audio_element_handle_t)context;
-
-    if (msg->source_type != AUDIO_ELEMENT_TYPE_ELEMENT) {
-        ESP_LOGE(TAG, "[%s] Invalid event type, this event should be ELEMENT type", el->tag);
-        return ESP_FAIL;
-    }
-    esp_err_t ret = ESP_OK;
-    //process an event
-    switch (msg->cmd) {
-        case AEL_MSG_CMD_FINISH:
-            ESP_LOGD(TAG, "[%s] AEL_MSG_CMD_FINISH, state:%d", el->tag, el->state);
-            ret = audio_element_on_cmd_finish(el);
-            break;
-        case AEL_MSG_CMD_STOP:
-            ESP_LOGD(TAG, "[%s] AEL_MSG_CMD_STOP, state:%d", el->tag, el->state);
-            ret = audio_element_on_cmd_stop(el);
-            break;
-        case AEL_MSG_CMD_PAUSE:
-            el->state = AEL_STATE_PAUSED;
-            audio_element_process_deinit(el);
-            audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
-            audio_element_report_status(el, AEL_STATUS_STATE_PAUSED);
-            el->is_running = false;
-            ESP_LOGI(TAG, "[%s] AEL_MSG_CMD_PAUSE", el->tag);
-            xEventGroupSetBits(el->state_event, PAUSED_BIT);
-            break;
-        case AEL_MSG_CMD_RESUME:
-            ESP_LOGI(TAG, "[%s] AEL_MSG_CMD_RESUME,state:%d", el->tag, el->state);
-            ret = audio_element_on_cmd_resume(el);
-            break;
-        case AEL_MSG_CMD_DESTROY:
-            el->is_running = false;
-            ESP_LOGD(TAG, "[%s] AEL_MSG_CMD_DESTROY", el->tag);
-            ret = AEL_IO_ABORT;
-    }
-    return ret;
-}
-
-static esp_err_t audio_element_process_running(audio_element_handle_t el)
-{
-    int process_len = -1;
-    if (el->state < AEL_STATE_RUNNING || !el->is_running) {
-        return ESP_ERR_INVALID_STATE;
-    }
-    process_len = el->process(el, el->buf, el->buf_size);
-    if (process_len <= 0) {
-        switch (process_len) {
-            case AEL_IO_ABORT:
-                ESP_LOGD(TAG, "[%s] ERROR_PROCESS, AEL_IO_ABORT", el->tag);
-                audio_element_on_cmd_stop(el);
-                break;
-            case AEL_IO_DONE:
-            case AEL_IO_OK:
-                // Re-open if reset_state function called
-                if (audio_element_get_state(el) == AEL_STATE_INIT) {
-                    return audio_element_on_cmd_resume(el);
-                }
-                audio_element_set_ringbuf_done(el);
-                audio_element_on_cmd_finish(el);
-                break;
-            case AEL_IO_FAIL:
-                ESP_LOGE(TAG, "[%s] ERROR_PROCESS, AEL_IO_FAIL", el->tag);
-                audio_element_report_status(el, AEL_STATUS_ERROR_PROCESS);
-                audio_element_on_cmd_error(el);
-                break;
-            case AEL_IO_TIMEOUT:
-                ESP_LOGD(TAG, "[%s] ERROR_PROCESS, AEL_IO_TIMEOUT", el->tag);
-                break;
-            case AEL_PROCESS_FAIL:
-                ESP_LOGE(TAG, "[%s] ERROR_PROCESS, AEL_PROCESS_FAIL", el->tag);
-                audio_element_report_status(el, AEL_STATUS_ERROR_PROCESS);
-                audio_element_on_cmd_error(el);
-                break;
-            default:
-                ESP_LOGW(TAG, "[%s] Process return error,ret:%d", el->tag, process_len);
-                break;
-        }
-    }
-    return ESP_OK;
-}
-
-audio_element_err_t audio_element_input(audio_element_handle_t el, char *buffer, int wanted_size)
-{
-    int in_len = 0;
-    if (el->read_type == IO_TYPE_CB) {
-        if (el->in.read_cb.cb == NULL) {
-            ESP_LOGE(TAG, "[%s] Read IO Type callback but callback not set", el->tag);
-            return ESP_FAIL;
-        }
-        in_len = el->in.read_cb.cb(el, buffer, wanted_size, el->input_wait_time,
-                                   el->in.read_cb.ctx);
-    } else if (el->read_type == IO_TYPE_RB) {
-        if (el->in.input_rb == NULL) {
-            ESP_LOGE(TAG, "[%s] Read IO type ringbuf but ringbuf not set", el->tag);
-            return ESP_FAIL;
-        }
-        in_len = rb_read(el->in.input_rb, buffer, wanted_size, el->input_wait_time);
-    } else {
-        ESP_LOGE(TAG, "[%s] Invalid read IO type", el->tag);
-        return ESP_FAIL;
-    }
-    if (in_len <= 0) {
-        switch (in_len) {
-            case AEL_IO_ABORT:
-                ESP_LOGW(TAG, "IN-[%s] AEL_IO_ABORT", el->tag);
-                break;
-            case AEL_IO_DONE:
-            case AEL_IO_OK:
-                ESP_LOGI(TAG, "IN-[%s] AEL_IO_DONE,%d", el->tag, in_len);
-                break;
-            case AEL_IO_FAIL:
-                ESP_LOGE(TAG, "IN-[%s] AEL_STATUS_ERROR_INPUT", el->tag);
-                audio_element_report_status(el, AEL_STATUS_ERROR_INPUT);
-                break;
-            case AEL_IO_TIMEOUT:
-                // ESP_LOGD(TAG, "IN-[%s] AEL_IO_TIMEOUT", el->tag);
-                break;
-            default:
-                ESP_LOGE(TAG, "IN-[%s] Input return not support,ret:%d", el->tag, in_len);
-                break;
-        }
-    }
-    return in_len;
-}
-
-audio_element_err_t audio_element_output(audio_element_handle_t el, char *buffer, int write_size)
-{
-    int output_len = 0;
-    if (el->write_type == IO_TYPE_CB) {
-        if (el->out.write_cb.cb && write_size) {
-            output_len = el->out.write_cb.cb(el, buffer, write_size, el->output_wait_time,
-                                             el->out.write_cb.ctx);
-        }
-    } else if (el->write_type == IO_TYPE_RB) {
-        if (el->out.output_rb && write_size) {
-            output_len = rb_write(el->out.output_rb, buffer, write_size, el->output_wait_time);
-            if ((rb_bytes_filled(el->out.output_rb) > el->out_buf_size_expect) || (output_len < 0)) {
-                xEventGroupSetBits(el->state_event, BUFFER_REACH_LEVEL_BIT);
-            }
-        }
-    }
-    if (output_len <= 0) {
-        switch (output_len) {
-            case AEL_IO_ABORT:
-                ESP_LOGW(TAG, "OUT-[%s] AEL_IO_ABORT", el->tag);
-                break;
-            case AEL_IO_DONE:
-            case AEL_IO_OK:
-                ESP_LOGI(TAG, "OUT-[%s] AEL_IO_DONE,%d", el->tag, output_len);
-                break;
-            case AEL_IO_FAIL:
-                ESP_LOGE(TAG, "OUT-[%s] AEL_STATUS_ERROR_OUTPUT", el->tag);
-                audio_element_report_status(el, AEL_STATUS_ERROR_OUTPUT);
-                break;
-            case AEL_IO_TIMEOUT:
-                ESP_LOGW(TAG, "OUT-[%s] AEL_IO_TIMEOUT", el->tag);
-                break;
-            default:
-                ESP_LOGE(TAG, "OUT-[%s] Output return not support,ret:%d", el->tag, output_len);
-                break;
-        }
-    }
-    return output_len;
-}
-void audio_element_task(void *pv)
-{
-    audio_element_handle_t el = (audio_element_handle_t)pv;
-    el->task_run = true;
-    xEventGroupSetBits(el->state_event, TASK_CREATED_BIT);
-    audio_element_force_set_state(el, AEL_STATE_INIT);
-    audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
-    if (el->buf_size > 0) {
-        el->buf = audio_calloc(1, el->buf_size);
-        AUDIO_MEM_CHECK(TAG, el->buf, {
-            el->task_run = false;
-            ESP_LOGE(TAG, "[%s] Error malloc element buffer", el->tag);
-        });
-    }
-    xEventGroupClearBits(el->state_event, STOPPED_BIT);
-    esp_err_t ret = ESP_OK;
-    while (el->task_run) {
-        if ((ret = audio_event_iface_waiting_cmd_msg(el->iface_event)) != ESP_OK) {
-            xEventGroupSetBits(el->state_event, STOPPED_BIT);
-            /*
-             * Do not exit task when audio_element_process_init failure to
-             * make call audio_element_deinit safety.
-            */
-            if (ret == AEL_IO_ABORT) {
-                break;
-            }
-        }
-        if (audio_element_process_running(el) != ESP_OK) {
-            // continue;
-        }
-    }
-
-    if (el->is_open && el->close) {
-        ESP_LOGD(TAG, "[%s-%p] el closed", el->tag, el);
-        el->close(el);
-        audio_element_force_set_state(el, AEL_STATE_STOPPED);
-    }
-    el->is_open = false;
-    audio_free(el->buf);
-    el->buf = NULL;
-    el->stopping = false;
-    el->task_run = false;
-    ESP_LOGD(TAG, "[%s-%p] el task deleted,%d", el->tag, el, uxTaskGetStackHighWaterMark(NULL));
-    xEventGroupSetBits(el->state_event, STOPPED_BIT);
-    xEventGroupSetBits(el->state_event, RESUMED_BIT);
-    xEventGroupSetBits(el->state_event, TASK_DESTROYED_BIT);
-    audio_thread_delete_task(&el->audio_thread);
-}
-
-esp_err_t audio_element_reset_state(audio_element_handle_t el)
-{
-    return audio_element_force_set_state(el, AEL_STATE_INIT);
-}
-
-audio_element_state_t audio_element_get_state(audio_element_handle_t el)
-{
-    if (el) {
-        return el->state;
-    }
-    return ESP_FAIL;
-}
-
-QueueHandle_t audio_element_get_event_queue(audio_element_handle_t el)
-{
-    if (!el) {
-        return NULL;
-    }
-    return audio_event_iface_get_queue_handle(el->iface_event);
-}
-
-esp_err_t audio_element_setdata(audio_element_handle_t el, void *data)
-{
-    el->data = data;
-    return ESP_OK;
-}
-
-void *audio_element_getdata(audio_element_handle_t el)
-{
-    return el->data;
-}
-
-esp_err_t audio_element_set_tag(audio_element_handle_t el, const char *tag)
-{
-    if (el->tag) {
-        audio_free(el->tag);
-        el->tag = NULL;
-    }
-
-    if (tag) {
-        el->tag = audio_strdup(tag);
-        AUDIO_MEM_CHECK(TAG, el->tag, {
-            return ESP_ERR_NO_MEM;
-        });
-    }
-    return ESP_OK;
-}
-
-char *audio_element_get_tag(audio_element_handle_t el)
-{
-    return el->tag;
-}
-
-esp_err_t audio_element_set_uri(audio_element_handle_t el, const char *uri)
-{
-    mutex_lock(el->lock);
-    if (el->info.uri) {
-        audio_free(el->info.uri);
-        el->info.uri = NULL;
-    }
-
-    if (uri) {
-        el->info.uri = audio_strdup(uri);
-        AUDIO_MEM_CHECK(TAG, el->info.uri, {
-            mutex_unlock(el->lock);
-            return ESP_ERR_NO_MEM;
-        });
-    }
-    mutex_unlock(el->lock);
-    return ESP_OK;
-}
-
-char *audio_element_get_uri(audio_element_handle_t el)
-{
-    mutex_lock(el->lock);
-    char *uri = el->info.uri;
-    mutex_unlock(el->lock);
-    return uri;
-}
-
-esp_err_t audio_element_set_event_callback(audio_element_handle_t el, event_cb_func cb_func, void *ctx)
-{
-    el->events_type = EVENTS_TYPE_CB;
-    el->callback_event.cb = cb_func;
-    el->callback_event.ctx = ctx;
-    return ESP_OK;
-}
-
-esp_err_t audio_element_msg_set_listener(audio_element_handle_t el, audio_event_iface_handle_t listener)
-{
-    return audio_event_iface_set_listener(el->iface_event, listener);
-}
-
-esp_err_t audio_element_msg_remove_listener(audio_element_handle_t el, audio_event_iface_handle_t listener)
-{
-    return audio_event_iface_remove_listener(listener, el->iface_event);
-}
-
-esp_err_t audio_element_setinfo(audio_element_handle_t el, audio_element_info_t *info)
-{
-    if (info && el) {
-        //FIXME: We will got reset if lock mutex here
-        mutex_lock(el->lock);
-        memcpy(&el->info, info, sizeof(audio_element_info_t));
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_getinfo(audio_element_handle_t el, audio_element_info_t *info)
-{
-    if (info && el) {
-        mutex_lock(el->lock);
-        memcpy(info, &el->info, sizeof(audio_element_info_t));
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_report_info(audio_element_handle_t el)
-{
-    if (el) {
-        audio_event_iface_msg_t msg = { 0 };
-        msg.cmd = AEL_MSG_CMD_REPORT_MUSIC_INFO;
-        msg.data = NULL;
-        ESP_LOGD(TAG, "REPORT_INFO,[%s]evt out cmd:%d,", el->tag, msg.cmd);
-        audio_element_msg_sendout(el, &msg);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_report_codec_fmt(audio_element_handle_t el)
-{
-    if (el) {
-        audio_event_iface_msg_t msg = { 0 };
-        msg.cmd = AEL_MSG_CMD_REPORT_CODEC_FMT;
-        msg.data = NULL;
-        ESP_LOGD(TAG, "REPORT_FMT,[%s]evt out cmd:%d,", el->tag, msg.cmd);
-        audio_element_msg_sendout(el, &msg);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_report_status(audio_element_handle_t el, audio_element_status_t status)
-{
-    if (el) {
-        audio_event_iface_msg_t msg = { 0 };
-        msg.cmd = AEL_MSG_CMD_REPORT_STATUS;
-        msg.data = (void *)status;
-        msg.data_len = sizeof(status);
-        ESP_LOGD(TAG, "REPORT_STATUS,[%s]evt out cmd = %d,status:%d", el->tag, msg.cmd, status);
-        return audio_element_msg_sendout(el, &msg);
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_report_pos(audio_element_handle_t el)
-{
-    if (el) {
-        audio_event_iface_msg_t msg = { 0 };
-        msg.cmd = AEL_MSG_CMD_REPORT_POSITION;
-        if (el->report_info == NULL) {
-            el->report_info = audio_calloc(1, sizeof(audio_element_info_t));
-            AUDIO_MEM_CHECK(TAG, el->report_info, return ESP_ERR_NO_MEM);
-        }
-
-        audio_element_getinfo(el, el->report_info);
-        msg.data = el->report_info;
-        msg.data_len = sizeof(audio_element_info_t);
-        ESP_LOGD(TAG, "REPORT_POS,[%s]evt out cmd:%d,", el->tag, msg.cmd);
-        audio_element_msg_sendout(el, &msg);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_finish_state(audio_element_handle_t el)
-{
-    if (el->task_stack <= 0) {
-        el->state = AEL_STATE_FINISHED;
-        audio_element_report_status(el, AEL_STATUS_STATE_FINISHED);
-        el->is_running = false;
-        xEventGroupSetBits(el->state_event, STOPPED_BIT);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_change_cmd(audio_element_handle_t el, audio_element_msg_cmd_t cmd)
-{
-    AUDIO_NULL_CHECK(TAG, el, return ESP_ERR_INVALID_ARG);
-    return audio_element_cmd_send(el, cmd);
-}
-
-esp_err_t audio_element_reset_input_ringbuf(audio_element_handle_t el)
-{
-    if (el->read_type != IO_TYPE_RB) {
-        return ESP_FAIL;
-    }
-    int ret = ESP_OK;
-    if (el->in.input_rb) {
-        ret |= rb_reset(el->in.input_rb);
-        for (int i = 0; i < el->multi_in.max_rb_num; ++i) {
-            if (el->multi_in.rb[i]) {
-                ret |= rb_reset(el->multi_in.rb[i]);
-            }
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_reset_output_ringbuf(audio_element_handle_t el)
-{
-    if (el->write_type != IO_TYPE_RB) {
-        return ESP_FAIL;
-    }
-    int ret = ESP_OK;
-    if (el->out.output_rb) {
-        ret |= rb_reset(el->out.output_rb);
-        for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
-            if (el->multi_out.rb[i]) {
-                ret |= rb_reset(el->multi_out.rb[i]);
-            }
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_abort_input_ringbuf(audio_element_handle_t el)
-{
-    if (el->read_type != IO_TYPE_RB) {
-        return ESP_FAIL;
-    }
-    int ret = ESP_OK;
-    if (el->in.input_rb) {
-        ret |= rb_abort(el->in.input_rb);
-        for (int i = 0; i < el->multi_in.max_rb_num; ++i) {
-            if (el->multi_in.rb[i]) {
-                ret |= rb_abort(el->multi_in.rb[i]);
-            }
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_abort_output_ringbuf(audio_element_handle_t el)
-{
-    if (el->write_type != IO_TYPE_RB) {
-        return ESP_FAIL;
-    }
-    int ret = ESP_OK;
-    if (el->out.output_rb) {
-        ret |= rb_abort(el->out.output_rb);
-        for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
-            if (el->multi_out.rb[i]) {
-                ret |= rb_abort(el->multi_out.rb[i]);
-            }
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_set_ringbuf_done(audio_element_handle_t el)
-{
-    if (NULL == el) {
-        return ESP_FAIL;
-    }
-    int ret = ESP_OK;
-    if (el->out.output_rb && el->write_type == IO_TYPE_RB) {
-        ret |= rb_done_write(el->out.output_rb);
-        for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
-            if (el->multi_out.rb[i]) {
-                ret |= rb_done_write(el->multi_out.rb[i]);
-            }
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_set_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb)
-{
-    if (rb) {
-        el->in.input_rb = rb;
-        rb_set_reader_holder(rb, (void*)el);
-        el->read_type = IO_TYPE_RB;
-    } else if (el->read_type == IO_TYPE_RB) {
-        el->in.input_rb = rb;
-        rb_set_reader_holder(rb, (void*)el);
-    }
-    return ESP_OK;
-}
-
-ringbuf_handle_t audio_element_get_input_ringbuf(audio_element_handle_t el)
-{
-    if (el->read_type == IO_TYPE_RB) {
-        return el->in.input_rb;
-    } else {
-        return NULL;
-    }
-}
-
-esp_err_t audio_element_set_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb)
-{
-    if (rb) {
-        el->out.output_rb = rb;
-        el->write_type = IO_TYPE_RB;
-        rb_set_writer_holder(rb, (void*)el);
-    } else if (el->write_type == IO_TYPE_RB) {
-        el->out.output_rb = rb;
-        rb_set_writer_holder(rb, (void*)el);
-    }
-    return ESP_OK;
-}
-
-ringbuf_handle_t audio_element_get_output_ringbuf(audio_element_handle_t el)
-{
-    if (el->write_type == IO_TYPE_RB) {
-        return el->out.output_rb;
-    } else {
-        return NULL;
-    }
-}
-
-esp_err_t audio_element_set_input_timeout(audio_element_handle_t el, TickType_t timeout)
-{
-    if (el) {
-        el->input_wait_time = timeout;
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_output_timeout(audio_element_handle_t el, TickType_t timeout)
-{
-    if (el) {
-        el->output_wait_time = timeout;
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-int audio_element_get_output_ringbuf_size(audio_element_handle_t el)
-{
-    if (el) {
-        return el->out_rb_size;
-    }
-    return 0;
-}
-
-esp_err_t audio_element_set_output_ringbuf_size(audio_element_handle_t el, int rb_size)
-{
-    if (el) {
-        el->out_rb_size = rb_size;
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_read_cb(audio_element_handle_t el, stream_func fn, void *context)
-{
-    if (el) {
-        el->in.read_cb.cb = fn;
-        el->in.read_cb.ctx = context;
-        el->read_type = IO_TYPE_CB;
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_write_cb(audio_element_handle_t el, stream_func fn, void *context)
-{
-    if (el) {
-        el->out.write_cb.cb = fn;
-        el->out.write_cb.ctx = context;
-        el->write_type = IO_TYPE_CB;
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-stream_func audio_element_get_write_cb(audio_element_handle_t el)
-{
-    if (el && el->write_type == IO_TYPE_CB) {
-        return el->out.write_cb.cb;
-    }
-    ESP_LOGE(TAG, "Fail to get write callback");
-    return NULL;
-}
-
-stream_func audio_element_get_read_cb(audio_element_handle_t el)
-{
-    if (el && el->read_type == IO_TYPE_CB) {
-        return el->in.read_cb.cb;
-    }
-    ESP_LOGE(TAG, "Fail to get read callback");
-    return NULL;
-}
-
-esp_err_t audio_element_wait_for_stop(audio_element_handle_t el)
-{
-    if (el->is_running == false) {
-        ESP_LOGD(TAG, "[%s] Element already stopped, return without waiting", el->tag);
-        return ESP_OK;
-    }
-    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, STOPPED_BIT, false, true, DEFAULT_MAX_WAIT_TIME);
-    esp_err_t ret = ESP_ERR_TIMEOUT;
-    if (uxBits & STOPPED_BIT) {
-        ret = ESP_OK;
-    }
-    return ret;
-}
-
-esp_err_t audio_element_wait_for_buffer(audio_element_handle_t el, int size_expect, TickType_t timeout)
-{
-    int ret = ESP_FAIL;
-    el->out_buf_size_expect = size_expect;
-    if (el->out.output_rb) {
-        xEventGroupClearBits(el->state_event, BUFFER_REACH_LEVEL_BIT);
-        EventBits_t uxBits = xEventGroupWaitBits(el->state_event, BUFFER_REACH_LEVEL_BIT, false, true, timeout);
-        if ((uxBits & BUFFER_REACH_LEVEL_BIT) != 0) {
-            ret = ESP_OK;
-        } else {
-            ret = ESP_FAIL;
-        }
-    }
-    return ret;
-}
-
-audio_element_handle_t audio_element_init(audio_element_cfg_t *config)
-{
-    audio_element_handle_t el = audio_calloc(1, sizeof(struct audio_element));
-
-    AUDIO_MEM_CHECK(TAG, el, {
-        return NULL;
-    });
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    evt_cfg.on_cmd = audio_element_on_cmd;
-    evt_cfg.context = el;
-    evt_cfg.queue_set_size = 0; // Element have no queue_set by default.
-    evt_cfg.external_queue_size = 5;
-    evt_cfg.internal_queue_size = 5;
-    bool _success =
-        (
-            ((config->tag ? audio_element_set_tag(el, config->tag) : audio_element_set_tag(el, "unknown")) == ESP_OK) &&
-            (el->lock           = mutex_create())                   &&
-            (el->iface_event    = audio_event_iface_init(&evt_cfg)) &&
-            (el->state_event    = xEventGroupCreate())
-        );
-
-    AUDIO_MEM_CHECK(TAG, _success, goto _element_init_failed);
-
-    el->open = config->open;
-    el->process = config->process;
-    el->close = config->close;
-    el->destroy = config->destroy;
-    el->seek = config->seek;
-    el->multi_in.max_rb_num = config->multi_in_rb_num;
-    el->multi_out.max_rb_num = config->multi_out_rb_num;
-    if (el->multi_in.max_rb_num > 0) {
-        el->multi_in.rb = (ringbuf_handle_t *)audio_calloc(el->multi_in.max_rb_num, sizeof(ringbuf_handle_t));
-        AUDIO_MEM_CHECK(TAG, el->multi_in.rb, goto _element_init_failed);
-    }
-    if (el->multi_out.max_rb_num > 0) {
-        el->multi_out.rb = (ringbuf_handle_t *)audio_calloc(el->multi_out.max_rb_num, sizeof(ringbuf_handle_t));
-        AUDIO_MEM_CHECK(TAG, el->multi_out.rb, goto _element_init_failed);
-    }
-
-    if (config->task_stack > 0) {
-        el->task_stack = config->task_stack;
-        el->stack_in_ext = config->stack_in_ext;
-    }
-    if (config->task_prio) {
-        el->task_prio = config->task_prio;
-    } else {
-        el->task_prio = DEFAULT_ELEMENT_TASK_PRIO;
-    }
-    if (config->task_core) {
-        el->task_core = config->task_core;
-    } else {
-        el->task_core = DEFAULT_ELEMENT_TASK_CORE;
-    }
-    if (config->out_rb_size > 0) {
-        el->out_rb_size = config->out_rb_size;
-    } else {
-        el->out_rb_size = DEFAULT_ELEMENT_RINGBUF_SIZE;
-    }
-    el->data = config ->data;
-
-    el->state = AEL_STATE_INIT;
-    el->buf_size = config->buffer_len;
-
-    audio_element_info_t info = AUDIO_ELEMENT_INFO_DEFAULT();
-    audio_element_setinfo(el, &info);
-    audio_element_set_input_timeout(el, portMAX_DELAY);
-    audio_element_set_output_timeout(el, portMAX_DELAY);
-
-    if (config->read != NULL) {
-        el->read_type = IO_TYPE_CB;
-        el->in.read_cb.cb = config->read;
-    } else {
-        el->read_type = IO_TYPE_RB;
-    }
-
-    if (config->write != NULL) {
-        el->write_type = IO_TYPE_CB;
-        el->out.write_cb.cb = config->write;
-    } else {
-        el->write_type = IO_TYPE_RB;
-    }
-
-    el->events_type = EVENTS_TYPE_Q;
-    return el;
-_element_init_failed:
-    audio_element_set_uri(el, NULL);
-    if (el->lock) {
-        mutex_destroy(el->lock);
-    }
-    if (el->state_event) {
-        vEventGroupDelete(el->state_event);
-    }
-    if (el->iface_event) {
-        audio_event_iface_destroy(el->iface_event);
-    }
-    if (el->tag) {
-        audio_element_set_tag(el, NULL);
-    }
-    if (el->multi_in.rb) {
-        audio_free(el->multi_in.rb);
-        el->multi_in.rb = NULL;
-    }
-    if (el->multi_out.rb) {
-        audio_free(el->multi_out.rb);
-        el->multi_out.rb = NULL;
-    }
-    audio_free(el);
-    return NULL;
-}
-
-esp_err_t audio_element_deinit(audio_element_handle_t el)
-{
-    audio_element_stop(el);
-    audio_element_wait_for_stop(el);
-    audio_element_terminate(el);
-    vEventGroupDelete(el->state_event);
-
-    audio_event_iface_destroy(el->iface_event);
-    if (el->destroy) {
-        el->destroy(el);
-    }
-    audio_element_set_tag(el, NULL);
-    audio_element_set_uri(el, NULL);
-    if (el->multi_in.rb) {
-        audio_free(el->multi_in.rb);
-        el->multi_in.rb = NULL;
-    }
-    if (el->multi_out.rb) {
-        audio_free(el->multi_out.rb);
-        el->multi_out.rb = NULL;
-    }
-    if (el->report_info) {
-        audio_free(el->report_info);
-    }
-    if (el->audio_thread) {
-        audio_thread_cleanup(&el->audio_thread);
-    }
-    mutex_destroy(el->lock);
-    el->lock = NULL;
-    audio_free(el);
-    return ESP_OK;
-}
-
-esp_err_t audio_element_run(audio_element_handle_t el)
-{
-    char task_name[32];
-    esp_err_t ret = ESP_FAIL;
-    if (el->task_run) {
-        ESP_LOGD(TAG, "[%s-%p] Element already created", el->tag, el);
-        return ESP_OK;
-    }
-    ESP_LOGV(TAG, "[%s] Element starting...", el->tag);
-    snprintf(task_name, 32, "el-%s", el->tag);
-    audio_event_iface_discard(el->iface_event);
-    xEventGroupClearBits(el->state_event, TASK_CREATED_BIT);
-    if (el->task_stack > 0) {
-        ret = audio_thread_create(&el->audio_thread, el->tag, audio_element_task, el, el->task_stack,
-                                  el->task_prio, el->stack_in_ext, el->task_core);
-        if (ret == ESP_FAIL) {
-            audio_element_force_set_state(el, AEL_STATE_ERROR);
-            audio_element_report_status(el, AEL_STATUS_ERROR_OPEN);
-            ESP_LOGE(TAG, "[%s] audio_thread_create failed", el->tag);
-            return ESP_FAIL;
-        }
-        EventBits_t uxBits = xEventGroupWaitBits(el->state_event, TASK_CREATED_BIT, false, true, DEFAULT_MAX_WAIT_TIME);
-
-        if (uxBits & TASK_CREATED_BIT) {
-            ret = ESP_OK;
-        }
-    } else {
-        el->task_run = true;
-        el->is_running = true;
-        audio_element_force_set_state(el, AEL_STATE_RUNNING);
-        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
-        ret = ESP_OK;
-    }
-    ESP_LOGI(TAG, "[%s-%p] Element task created", el->tag, el);
-    return ret;
-}
-
-static inline esp_err_t __audio_element_term(audio_element_handle_t el, TickType_t ticks_to_wait)
-{
-    xEventGroupClearBits(el->state_event, TASK_DESTROYED_BIT);
-    if (audio_element_cmd_send(el, AEL_MSG_CMD_DESTROY) != ESP_OK) {
-        ESP_LOGE(TAG, "[%s] Send destroy command failed", el->tag);
-        return ESP_FAIL;
-    }
-    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, TASK_DESTROYED_BIT, false, true, ticks_to_wait);
-    esp_err_t ret = ESP_FAIL;
-    if (uxBits & TASK_DESTROYED_BIT ) {
-        ESP_LOGD(TAG, "[%s-%p] Element task destroyed", el->tag, el);
-        ret = ESP_OK;
-    } else {
-        ESP_LOGW(TAG, "[%s-%p] Element task destroy timeout[%d]", el->tag, el, (int)ticks_to_wait);
-    }
-    return ret;
-}
-
-esp_err_t audio_element_terminate(audio_element_handle_t el)
-{
-    if (!el->task_run) {
-        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_TERMINATE", el->tag);
-        return ESP_OK;
-    }
-    if (el->task_stack <= 0) {
-        el->task_run = false;
-        el->is_running = false;
-        return ESP_OK;
-    }
-    return __audio_element_term(el, DEFAULT_MAX_WAIT_TIME);
-}
-
-esp_err_t audio_element_terminate_with_ticks(audio_element_handle_t el, TickType_t ticks_to_wait)
-{
-    if (!el->task_run) {
-        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_TERMINATE, tick:%d", el->tag, (int)ticks_to_wait);
-        return ESP_OK;
-    }
-    if (el->task_stack <= 0) {
-        el->task_run = false;
-        el->is_running = false;
-        return ESP_OK;
-    }
-    return __audio_element_term(el, ticks_to_wait);
-}
-
-esp_err_t audio_element_pause(audio_element_handle_t el)
-{
-    if (!el->task_run) {
-        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_PAUSE", el->tag);
-        return ESP_FAIL;
-    }
-    if ((el->state >= AEL_STATE_PAUSED)) {
-        audio_element_force_set_state(el, AEL_STATE_PAUSED);
-        ESP_LOGD(TAG, "[%s] Element already paused, state:%d", el->tag, el->state);
-        return ESP_OK;
-    }
-    xEventGroupClearBits(el->state_event, PAUSED_BIT);
-    if (el->task_stack <= 0) {
-        el->is_running = false;
-        audio_element_force_set_state(el, AEL_STATE_PAUSED);
-        return ESP_OK;
-    }
-    if (audio_element_cmd_send(el, AEL_MSG_CMD_PAUSE) != ESP_OK) {
-        ESP_LOGE(TAG, "[%s] Element send cmd error when AUDIO_ELEMENT_PAUSE", el->tag);
-        return ESP_FAIL;
-    }
-    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, PAUSED_BIT, false, true, DEFAULT_MAX_WAIT_TIME);
-    esp_err_t ret = ESP_FAIL;
-    if (uxBits & PAUSED_BIT) {
-        ret = ESP_OK;
-    }
-    return ret;
-}
-
-esp_err_t audio_element_resume(audio_element_handle_t el, float wait_for_rb_threshold, TickType_t timeout)
-{
-    if (!el->task_run) {
-        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_RESUME", el->tag);
-        return ESP_FAIL;
-    }
-    if (el->state == AEL_STATE_RUNNING) {
-        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
-        ESP_LOGD(TAG, "[%s] RESUME: Element is already running, state:%d, task_run:%d, is_running:%d",
-                 el->tag, el->state, el->task_run, el->is_running);
-        return ESP_OK;
-    }
-    if (el->task_stack <= 0) {
-        el->is_running = true;
-        audio_element_force_set_state(el, AEL_STATE_RUNNING);
-        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
-        return ESP_OK;
-    }
-    if (el->state == AEL_STATE_ERROR) {
-        ESP_LOGE(TAG, "[%s] RESUME: Element error, state:%d", el->tag, el->state);
-        return ESP_FAIL;
-    }
-    if (el->state == AEL_STATE_FINISHED) {
-        ESP_LOGI(TAG, "[%s] RESUME: Element has finished, state:%d", el->tag, el->state);
-        audio_element_report_status(el, AEL_STATUS_STATE_FINISHED);
-        return ESP_OK;
-    }
-    if (wait_for_rb_threshold > 1 || wait_for_rb_threshold < 0) {
-        return ESP_FAIL;
-    }
-    int ret =  ESP_OK;
-    xEventGroupClearBits(el->state_event, RESUMED_BIT);
-    if (audio_element_cmd_send(el, AEL_MSG_CMD_RESUME) == ESP_FAIL) {
-        ESP_LOGW(TAG, "[%s] Send resume command failed", el->tag);
-        return ESP_FAIL;
-    }
-    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, RESUMED_BIT, false, true, timeout);
-    if ((uxBits & RESUMED_BIT) != RESUMED_BIT) {
-        ESP_LOGW(TAG, "[%s-%p] RESUME timeout", el->tag, el);
-        ret = ESP_FAIL;
-    } else {
-        if (wait_for_rb_threshold != 0 && el->read_type == IO_TYPE_RB) {
-            ret = audio_element_wait_for_buffer(el, rb_get_size(el->in.input_rb) * wait_for_rb_threshold, timeout);
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_stop(audio_element_handle_t el)
-{
-    if (!el->task_run) {
-        ESP_LOGD(TAG, "[%s] Element has not create when AUDIO_ELEMENT_STOP", el->tag);
-        return ESP_FAIL;
-    }
-    if (el->state == AEL_STATE_PAUSED) {
-        audio_event_iface_set_cmd_waiting_timeout(el->iface_event, 0);
-        audio_element_set_byte_pos(el, 0);
-    }
-    if (el->is_running == false) {
-        xEventGroupSetBits(el->state_event, STOPPED_BIT);
-        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
-        ESP_LOGW(TAG, "[%s] Element already stopped", el->tag);
-        return ESP_OK;
-    }
-    audio_element_abort_output_ringbuf(el);
-    audio_element_abort_input_ringbuf(el);
-    if (el->state == AEL_STATE_RUNNING) {
-        xEventGroupClearBits(el->state_event, STOPPED_BIT);
-    }
-    if (el->task_stack <= 0) {
-        el->is_running = false;
-        audio_element_force_set_state(el, AEL_STATE_STOPPED);
-        xEventGroupSetBits(el->state_event, STOPPED_BIT);
-        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
-        return ESP_OK;
-    }
-    if (el->stopping) {
-        ESP_LOGD(TAG, "[%s] Stop command has already sent, %d", el->tag, el->stopping);
-        return ESP_OK;
-    }
-    el->stopping = true;
-    if (audio_element_cmd_send(el, AEL_MSG_CMD_STOP) != ESP_OK) {
-        el->stopping = false;
-        ESP_LOGW(TAG, "[%s-%p] Send stop command failed", el->tag, el);
-        return ESP_FAIL;
-    }
-    ESP_LOGD(TAG, "[%s-%p] Send stop command", el->tag, el);
-    return ESP_OK;
-}
-
-esp_err_t audio_element_wait_for_stop_ms(audio_element_handle_t el, TickType_t ticks_to_wait)
-{
-    if (el->is_running == false) {
-        ESP_LOGD(TAG, "[%s] Element already stopped, return without waiting", el->tag);
-        return ESP_OK;
-    }
-    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, STOPPED_BIT, false, true, ticks_to_wait);
-    esp_err_t ret = ESP_ERR_TIMEOUT;
-    if (uxBits & STOPPED_BIT) {
-        ret = ESP_OK;
-    }
-    return ret;
-}
-
-int audio_element_multi_input(audio_element_handle_t el, char *buffer, int wanted_size, int index, TickType_t ticks_to_wait)
-{
-    int ret = ESP_OK;
-    if (index >= el->multi_in.max_rb_num) {
-        ESP_LOGE(TAG, "The index of ringbuffer is gather than and equal to ringbuffer maximum (%d). line %d", el->multi_in.max_rb_num, __LINE__);
-        return ESP_ERR_INVALID_SIZE;
-    }
-    if (el->multi_in.rb[index]) {
-        ret = rb_read(el->multi_in.rb[index], buffer, wanted_size, ticks_to_wait);
-    }
-    return ret;
-}
-
-int audio_element_multi_output(audio_element_handle_t el, char *buffer, int wanted_size, TickType_t ticks_to_wait)
-{
-    int ret = ESP_OK;
-    for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
-        if (el->multi_out.rb[i]) {
-            ret |= rb_write(el->multi_out.rb[i], buffer, wanted_size, ticks_to_wait);
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_element_set_multi_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index)
-{
-    if ((index < el->multi_in.max_rb_num) && rb) {
-        el->multi_in.rb[index] = rb;
-        return ESP_OK;
-    }
-    return ESP_ERR_INVALID_ARG;
-}
-
-esp_err_t audio_element_set_multi_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index)
-{
-    if ((index < el->multi_out.max_rb_num) && rb) {
-        el->multi_out.rb[index] = rb;
-        return ESP_OK;
-    }
-    return ESP_ERR_INVALID_ARG;
-}
-
-ringbuf_handle_t audio_element_get_multi_input_ringbuf(audio_element_handle_t el, int index)
-{
-    if (index < el->multi_in.max_rb_num) {
-        return el->multi_in.rb[index];
-    }
-    return NULL;
-}
-
-ringbuf_handle_t audio_element_get_multi_output_ringbuf(audio_element_handle_t el, int index)
-{
-    if (index < el->multi_out.max_rb_num) {
-        return el->multi_out.rb[index];
-    }
-    return NULL;
-}
-
-esp_err_t audio_element_seek(audio_element_handle_t el, void *in_data, int in_size, void *out_data, int *out_size)
-{
-    esp_err_t ret = ESP_OK;
-    if (el && el->seek) {
-        ret = el->seek(el, in_data, in_size, out_data, out_size);
-    } else {
-        ret = ESP_ERR_NOT_SUPPORTED;
-    }
-    return ret;
-}
-
-bool audio_element_is_stopping(audio_element_handle_t el)
-{
-    if (el) {
-        return el->stopping;
-    }
-    return false;
-}
-
-esp_err_t audio_element_update_byte_pos(audio_element_handle_t el, int pos)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.byte_pos += pos;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_byte_pos(audio_element_handle_t el, int pos)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.byte_pos = pos;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_update_total_bytes(audio_element_handle_t el, int total_bytes)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.total_bytes += total_bytes;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_total_bytes(audio_element_handle_t el, int total_bytes)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.total_bytes = total_bytes;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_bps(audio_element_handle_t el, int bit_rate)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.bps = bit_rate;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_codec_fmt(audio_element_handle_t el, int format)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.codec_fmt = format;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_music_info(audio_element_handle_t el, int sample_rates, int channels, int bits)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.sample_rates = sample_rates;
-        el->info.channels = channels;
-        el->info.bits = bits;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_duration(audio_element_handle_t el, int duration)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.duration = duration;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_reserve_user0(audio_element_handle_t el, int user_data0)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.reserve_data.user_data_0 = user_data0;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_reserve_user1(audio_element_handle_t el, int user_data1)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.reserve_data.user_data_1 = user_data1;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_reserve_user2(audio_element_handle_t el, int user_data2)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.reserve_data.user_data_2 = user_data2;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-
-esp_err_t audio_element_set_reserve_user3(audio_element_handle_t el, int user_data3)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.reserve_data.user_data_3 = user_data3;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_element_set_reserve_user4(audio_element_handle_t el, int user_data4)
-{
-    if (el) {
-        mutex_lock(el->lock);
-        el->info.reserve_data.user_data_4 = user_data4;
-        mutex_unlock(el->lock);
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/event_groups.h"
+
+#include "esp_log.h"
+#include "audio_element.h"
+#include "audio_mem.h"
+#include "audio_mutex.h"
+#include "audio_error.h"
+#include "audio_thread.h"
+
+static const char *TAG = "AUDIO_ELEMENT";
+#define DEFAULT_MAX_WAIT_TIME       (2000/portTICK_PERIOD_MS)
+
+/**
+ *  I/O Element Abstract
+ */
+typedef struct io_callback {
+    stream_func                 cb;
+    void                        *ctx;
+} io_callback_t;
+
+/**
+ *  Audio Callback Abstract
+ */
+typedef struct audio_callback {
+    event_cb_func               cb;
+    void                        *ctx;
+} audio_callback_t;
+
+typedef struct audio_multi_rb {
+    ringbuf_handle_t            *rb;
+    int                         max_rb_num;
+} audio_multi_rb_t;
+
+typedef enum {
+    IO_TYPE_RB = 1, /* I/O through ringbuffer */
+    IO_TYPE_CB,     /* I/O through callback */
+} io_type_t;
+
+typedef enum {
+    EVENTS_TYPE_Q = 1,  /* Events through MessageQueue */
+    EVENTS_TYPE_CB,     /* Events through Callback function */
+} events_type_t;
+
+struct audio_element {
+    /* Functions/RingBuffers */
+    el_io_func                  open;
+    ctrl_func                   seek;
+    process_func                process;
+    el_io_func                  close;
+    el_io_func                  destroy;
+    io_type_t                   read_type;
+    union {
+        ringbuf_handle_t        input_rb;
+        io_callback_t           read_cb;
+    } in;
+    io_type_t                   write_type;
+    union {
+        ringbuf_handle_t        output_rb;
+        io_callback_t           write_cb;
+    } out;
+
+    audio_multi_rb_t            multi_in;
+    audio_multi_rb_t            multi_out;
+
+    /* Properties */
+    volatile bool               is_open;
+    audio_element_state_t       state;
+
+    events_type_t               events_type;
+    audio_event_iface_handle_t  iface_event;
+    audio_callback_t            callback_event;
+
+    int                         buf_size;
+    char                        *buf;
+
+    char                        *tag;
+    int                         task_stack;
+    int                         task_prio;
+    int                         task_core;
+    SemaphoreHandle_t            lock;
+    audio_element_info_t        info;
+    audio_element_info_t        *report_info;
+
+    bool                        stack_in_ext;
+    audio_thread_t              audio_thread;
+
+    /* PrivateData */
+    void                        *data;
+    EventGroupHandle_t          state_event;
+    int                         input_wait_time;
+    int                         output_wait_time;
+    int                         out_buf_size_expect;
+    int                         out_rb_size;
+    volatile bool               is_running;
+    volatile bool               task_run;
+    volatile bool               stopping;
+};
+
+const static int STOPPED_BIT = BIT0;
+const static int STARTED_BIT = BIT1;
+const static int BUFFER_REACH_LEVEL_BIT = BIT2;
+const static int TASK_CREATED_BIT = BIT3;
+const static int TASK_DESTROYED_BIT = BIT4;
+const static int PAUSED_BIT = BIT5;
+const static int RESUMED_BIT = BIT6;
+
+static esp_err_t audio_element_on_cmd_error(audio_element_handle_t el);
+static esp_err_t audio_element_on_cmd_stop(audio_element_handle_t el);
+
+static esp_err_t audio_element_force_set_state(audio_element_handle_t el, audio_element_state_t new_state)
+{
+    el->state = new_state;
+    return ESP_OK;
+}
+
+static esp_err_t audio_element_cmd_send(audio_element_handle_t el, audio_element_msg_cmd_t cmd)
+{
+    audio_event_iface_msg_t msg = {
+        .source = el,
+        .source_type = AUDIO_ELEMENT_TYPE_ELEMENT,
+        .cmd = cmd,
+    };
+    ESP_LOGV(TAG, "[%s]evt internal cmd = %d", el->tag, msg.cmd);
+    return audio_event_iface_cmd(el->iface_event, &msg);
+}
+
+static esp_err_t audio_element_msg_sendout(audio_element_handle_t el, audio_event_iface_msg_t *msg)
+{
+    msg->source = el;
+    msg->source_type = AUDIO_ELEMENT_TYPE_ELEMENT;
+    if (el->events_type == EVENTS_TYPE_CB && el->callback_event.cb) {
+        return el->callback_event.cb(el, msg, el->callback_event.ctx);
+    }
+    return audio_event_iface_sendout(el->iface_event, msg);
+}
+
+esp_err_t audio_element_process_init(audio_element_handle_t el)
+{
+    if (el->open == NULL) {
+        el->is_open = true;
+        xEventGroupSetBits(el->state_event, STARTED_BIT);
+        return ESP_OK;
+    }
+    el->is_open = true;
+    audio_element_force_set_state(el, AEL_STATE_INITIALIZING);
+    esp_err_t ret = el->open(el);
+    if (ret == ESP_OK) {
+        ESP_LOGD(TAG, "[%s] el opened", el->tag);
+        audio_element_force_set_state(el, AEL_STATE_RUNNING);
+        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
+        xEventGroupSetBits(el->state_event, STARTED_BIT);
+        return ESP_OK;
+    } else if (ret == AEL_IO_DONE) {
+        ESP_LOGW(TAG, "[%s] OPEN AEL_IO_DONE", el->tag);
+        audio_element_force_set_state(el, AEL_STATE_RUNNING);
+        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
+        return ESP_OK;
+    } else if (ret == AEL_IO_ABORT) {
+        ESP_LOGW(TAG, "[%s] AEL_IO_ABORT, %d", el->tag, ret);
+        audio_element_on_cmd_stop(el);
+    } else {
+        ESP_LOGE(TAG, "[%s] AEL_STATUS_ERROR_OPEN,%d", el->tag, ret);
+        audio_element_force_set_state(el, AEL_STATE_ERROR);
+        audio_element_report_status(el, AEL_STATUS_ERROR_OPEN);
+        audio_element_on_cmd_error(el);
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_process_deinit(audio_element_handle_t el)
+{
+    if (el->is_open && el->close) {
+        ESP_LOGV(TAG, "[%s] will be closed, line %d", el->tag, __LINE__);
+        el->close(el);
+    }
+    el->is_open = false;
+    return ESP_OK;
+}
+
+static esp_err_t audio_element_on_cmd_error(audio_element_handle_t el)
+{
+    if (el->state != AEL_STATE_STOPPED) {
+        ESP_LOGW(TAG, "[%s] audio_element_on_cmd_error,%d", el->tag, el->state);
+        audio_element_process_deinit(el);
+        el->state = AEL_STATE_ERROR;
+        audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
+        el->is_running = false;
+        xEventGroupSetBits(el->state_event, STOPPED_BIT);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t audio_element_on_cmd_stop(audio_element_handle_t el)
+{
+    if (el->state == AEL_STATE_INIT) {
+        ESP_LOGW(TAG, "[%p-%s] is already in the AEL_STATE_INIT state", el, el->tag);
+        return ESP_OK;
+    }
+    if ((el->state != AEL_STATE_FINISHED) && (el->state != AEL_STATE_STOPPED)) {
+        audio_element_process_deinit(el);
+        el->state = AEL_STATE_STOPPED;
+        audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
+        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
+        el->is_running = false;
+        el->stopping = false;
+        ESP_LOGD(TAG, "[%p-%s] audio_element_on_cmd_stop, line: %d, state: %d", el, el->tag, __LINE__, el->state);
+        xEventGroupSetBits(el->state_event, STOPPED_BIT);
+    } else {
+        // Change element state to AEL_STATE_STOPPED, even if AEL_STATE_ERROR or AEL_STATE_FINISHED
+        // Except AEL_STATE_STOPPED and is not running
+        ESP_LOGD(TAG, "[%p-%s] audio_element_on_cmd_stop, line: %d, state: %d", el, el->tag, __LINE__, el->state);
+        if ((el->is_running == false) && (el->state == AEL_STATE_STOPPED)) {
+            el->stopping = false;
+            return ESP_OK;
+        }
+        el->state = AEL_STATE_STOPPED;
+        el->is_running = false;
+        el->stopping = false;
+        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
+        xEventGroupSetBits(el->state_event, STOPPED_BIT);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t audio_element_on_cmd_finish(audio_element_handle_t el)
+{
+    if ((el->state == AEL_STATE_ERROR)
+        || (el->state == AEL_STATE_STOPPED)) {
+        ESP_LOGD(TAG, "[%s] audio_element_on_cmd_finish, state:%d", el->tag, el->state);
+        return ESP_OK;
+    }
+    audio_element_process_deinit(el);
+    el->state = AEL_STATE_FINISHED;
+    audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
+    audio_element_report_status(el, AEL_STATUS_STATE_FINISHED);
+    el->is_running = false;
+    xEventGroupSetBits(el->state_event, STOPPED_BIT);
+    ESP_LOGD(TAG, "[%s] audio_element_on_cmd_finish", el->tag);
+    return ESP_OK;
+}
+
+static esp_err_t audio_element_on_cmd_resume(audio_element_handle_t el)
+{
+    if (el->state == AEL_STATE_RUNNING) {
+        el->is_running = true;
+        xEventGroupSetBits(el->state_event, RESUMED_BIT);
+        return ESP_OK;
+    }
+    if (el->state != AEL_STATE_INIT && el->state != AEL_STATE_RUNNING && el->state != AEL_STATE_PAUSED) {
+        audio_element_reset_output_ringbuf(el);
+    }
+    el->is_running = true;
+    xEventGroupSetBits(el->state_event, RESUMED_BIT);
+    if (audio_element_process_init(el) != ESP_OK) {
+        audio_element_abort_output_ringbuf(el);
+        audio_element_abort_input_ringbuf(el);
+        el->is_running = false;
+        return ESP_FAIL;
+    }
+    audio_event_iface_set_cmd_waiting_timeout(el->iface_event, 0);
+    xEventGroupClearBits(el->state_event, STOPPED_BIT);
+    return ESP_OK;
+}
+
+static esp_err_t audio_element_on_cmd(audio_event_iface_msg_t *msg, void *context)
+{
+    audio_element_handle_t el = (audio_element_handle_t)context;
+
+    if (msg->source_type != AUDIO_ELEMENT_TYPE_ELEMENT) {
+        ESP_LOGE(TAG, "[%s] Invalid event type, this event should be ELEMENT type", el->tag);
+        return ESP_FAIL;
+    }
+    esp_err_t ret = ESP_OK;
+    //process an event
+    switch (msg->cmd) {
+        case AEL_MSG_CMD_FINISH:
+            ESP_LOGD(TAG, "[%s] AEL_MSG_CMD_FINISH, state:%d", el->tag, el->state);
+            ret = audio_element_on_cmd_finish(el);
+            break;
+        case AEL_MSG_CMD_STOP:
+            ESP_LOGD(TAG, "[%s] AEL_MSG_CMD_STOP, state:%d", el->tag, el->state);
+            ret = audio_element_on_cmd_stop(el);
+            break;
+        case AEL_MSG_CMD_PAUSE:
+            el->state = AEL_STATE_PAUSED;
+            audio_element_process_deinit(el);
+            audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
+            audio_element_report_status(el, AEL_STATUS_STATE_PAUSED);
+            el->is_running = false;
+            ESP_LOGI(TAG, "[%s] AEL_MSG_CMD_PAUSE", el->tag);
+            xEventGroupSetBits(el->state_event, PAUSED_BIT);
+            break;
+        case AEL_MSG_CMD_RESUME:
+            ESP_LOGI(TAG, "[%s] AEL_MSG_CMD_RESUME,state:%d", el->tag, el->state);
+            ret = audio_element_on_cmd_resume(el);
+            break;
+        case AEL_MSG_CMD_DESTROY:
+            el->is_running = false;
+            ESP_LOGD(TAG, "[%s] AEL_MSG_CMD_DESTROY", el->tag);
+            ret = AEL_IO_ABORT;
+    }
+    return ret;
+}
+
+static esp_err_t audio_element_process_running(audio_element_handle_t el)
+{
+    int process_len = -1;
+    if (el->state < AEL_STATE_RUNNING || !el->is_running) {
+        return ESP_ERR_INVALID_STATE;
+    }
+    process_len = el->process(el, el->buf, el->buf_size);
+    if (process_len <= 0) {
+        switch (process_len) {
+            case AEL_IO_ABORT:
+                ESP_LOGD(TAG, "[%s] ERROR_PROCESS, AEL_IO_ABORT", el->tag);
+                audio_element_on_cmd_stop(el);
+                break;
+            case AEL_IO_DONE:
+            case AEL_IO_OK:
+                // Re-open if reset_state function called
+                if (audio_element_get_state(el) == AEL_STATE_INIT) {
+                    return audio_element_on_cmd_resume(el);
+                }
+                audio_element_set_ringbuf_done(el);
+                audio_element_on_cmd_finish(el);
+                break;
+            case AEL_IO_FAIL:
+                ESP_LOGE(TAG, "[%s] ERROR_PROCESS, AEL_IO_FAIL", el->tag);
+                audio_element_report_status(el, AEL_STATUS_ERROR_PROCESS);
+                audio_element_on_cmd_error(el);
+                break;
+            case AEL_IO_TIMEOUT:
+                ESP_LOGD(TAG, "[%s] ERROR_PROCESS, AEL_IO_TIMEOUT", el->tag);
+                break;
+            case AEL_PROCESS_FAIL:
+                ESP_LOGE(TAG, "[%s] ERROR_PROCESS, AEL_PROCESS_FAIL", el->tag);
+                audio_element_report_status(el, AEL_STATUS_ERROR_PROCESS);
+                audio_element_on_cmd_error(el);
+                break;
+            default:
+                ESP_LOGW(TAG, "[%s] Process return error,ret:%d", el->tag, process_len);
+                break;
+        }
+    }
+    return ESP_OK;
+}
+
+audio_element_err_t audio_element_input(audio_element_handle_t el, char *buffer, int wanted_size)
+{
+    int in_len = 0;
+    if (el->read_type == IO_TYPE_CB) {
+        if (el->in.read_cb.cb == NULL) {
+            ESP_LOGE(TAG, "[%s] Read IO Type callback but callback not set", el->tag);
+            return ESP_FAIL;
+        }
+        in_len = el->in.read_cb.cb(el, buffer, wanted_size, el->input_wait_time,
+                                   el->in.read_cb.ctx);
+    } else if (el->read_type == IO_TYPE_RB) {
+        if (el->in.input_rb == NULL) {
+            ESP_LOGE(TAG, "[%s] Read IO type ringbuf but ringbuf not set", el->tag);
+            return ESP_FAIL;
+        }
+        in_len = rb_read(el->in.input_rb, buffer, wanted_size, el->input_wait_time);
+    } else {
+        ESP_LOGE(TAG, "[%s] Invalid read IO type", el->tag);
+        return ESP_FAIL;
+    }
+    if (in_len <= 0) {
+        switch (in_len) {
+            case AEL_IO_ABORT:
+                ESP_LOGW(TAG, "IN-[%s] AEL_IO_ABORT", el->tag);
+                break;
+            case AEL_IO_DONE:
+            case AEL_IO_OK:
+                ESP_LOGI(TAG, "IN-[%s] AEL_IO_DONE,%d", el->tag, in_len);
+                break;
+            case AEL_IO_FAIL:
+                ESP_LOGE(TAG, "IN-[%s] AEL_STATUS_ERROR_INPUT", el->tag);
+                audio_element_report_status(el, AEL_STATUS_ERROR_INPUT);
+                break;
+            case AEL_IO_TIMEOUT:
+                // ESP_LOGD(TAG, "IN-[%s] AEL_IO_TIMEOUT", el->tag);
+                break;
+            default:
+                ESP_LOGE(TAG, "IN-[%s] Input return not support,ret:%d", el->tag, in_len);
+                break;
+        }
+    }
+    return in_len;
+}
+
+audio_element_err_t audio_element_output(audio_element_handle_t el, char *buffer, int write_size)
+{
+    int output_len = 0;
+    if (el->write_type == IO_TYPE_CB) {
+        if (el->out.write_cb.cb && write_size) {
+            output_len = el->out.write_cb.cb(el, buffer, write_size, el->output_wait_time,
+                                             el->out.write_cb.ctx);
+        }
+    } else if (el->write_type == IO_TYPE_RB) {
+        if (el->out.output_rb && write_size) {
+            output_len = rb_write(el->out.output_rb, buffer, write_size, el->output_wait_time);
+            if ((rb_bytes_filled(el->out.output_rb) > el->out_buf_size_expect) || (output_len < 0)) {
+                xEventGroupSetBits(el->state_event, BUFFER_REACH_LEVEL_BIT);
+            }
+        }
+    }
+    if (output_len <= 0) {
+        switch (output_len) {
+            case AEL_IO_ABORT:
+                ESP_LOGW(TAG, "OUT-[%s] AEL_IO_ABORT", el->tag);
+                break;
+            case AEL_IO_DONE:
+            case AEL_IO_OK:
+                ESP_LOGI(TAG, "OUT-[%s] AEL_IO_DONE,%d", el->tag, output_len);
+                break;
+            case AEL_IO_FAIL:
+                ESP_LOGE(TAG, "OUT-[%s] AEL_STATUS_ERROR_OUTPUT", el->tag);
+                audio_element_report_status(el, AEL_STATUS_ERROR_OUTPUT);
+                break;
+            case AEL_IO_TIMEOUT:
+                ESP_LOGW(TAG, "OUT-[%s] AEL_IO_TIMEOUT", el->tag);
+                break;
+            default:
+                ESP_LOGE(TAG, "OUT-[%s] Output return not support,ret:%d", el->tag, output_len);
+                break;
+        }
+    }
+    return output_len;
+}
+void audio_element_task(void *pv)
+{
+    audio_element_handle_t el = (audio_element_handle_t)pv;
+    el->task_run = true;
+    xEventGroupSetBits(el->state_event, TASK_CREATED_BIT);
+    audio_element_force_set_state(el, AEL_STATE_INIT);
+    audio_event_iface_set_cmd_waiting_timeout(el->iface_event, portMAX_DELAY);
+    if (el->buf_size > 0) {
+        el->buf = audio_calloc(1, el->buf_size);
+        AUDIO_MEM_CHECK(TAG, el->buf, {
+            el->task_run = false;
+            ESP_LOGE(TAG, "[%s] Error malloc element buffer", el->tag);
+        });
+    }
+    xEventGroupClearBits(el->state_event, STOPPED_BIT);
+    esp_err_t ret = ESP_OK;
+    while (el->task_run) {
+        if ((ret = audio_event_iface_waiting_cmd_msg(el->iface_event)) != ESP_OK) {
+            xEventGroupSetBits(el->state_event, STOPPED_BIT);
+            /*
+             * Do not exit task when audio_element_process_init failure to
+             * make call audio_element_deinit safety.
+            */
+            if (ret == AEL_IO_ABORT) {
+                break;
+            }
+        }
+        if (audio_element_process_running(el) != ESP_OK) {
+            // continue;
+        }
+    }
+
+    if (el->is_open && el->close) {
+        ESP_LOGD(TAG, "[%s-%p] el closed", el->tag, el);
+        el->close(el);
+        audio_element_force_set_state(el, AEL_STATE_STOPPED);
+    }
+    el->is_open = false;
+    audio_free(el->buf);
+    el->buf = NULL;
+    el->stopping = false;
+    el->task_run = false;
+    ESP_LOGD(TAG, "[%s-%p] el task deleted,%d", el->tag, el, uxTaskGetStackHighWaterMark(NULL));
+    xEventGroupSetBits(el->state_event, STOPPED_BIT);
+    xEventGroupSetBits(el->state_event, RESUMED_BIT);
+    xEventGroupSetBits(el->state_event, TASK_DESTROYED_BIT);
+    audio_thread_delete_task(&el->audio_thread);
+}
+
+esp_err_t audio_element_reset_state(audio_element_handle_t el)
+{
+    return audio_element_force_set_state(el, AEL_STATE_INIT);
+}
+
+audio_element_state_t audio_element_get_state(audio_element_handle_t el)
+{
+    if (el) {
+        return el->state;
+    }
+    return ESP_FAIL;
+}
+
+QueueHandle_t audio_element_get_event_queue(audio_element_handle_t el)
+{
+    if (!el) {
+        return NULL;
+    }
+    return audio_event_iface_get_queue_handle(el->iface_event);
+}
+
+esp_err_t audio_element_setdata(audio_element_handle_t el, void *data)
+{
+    el->data = data;
+    return ESP_OK;
+}
+
+void *audio_element_getdata(audio_element_handle_t el)
+{
+    return el->data;
+}
+
+esp_err_t audio_element_set_tag(audio_element_handle_t el, const char *tag)
+{
+    if (el->tag) {
+        audio_free(el->tag);
+        el->tag = NULL;
+    }
+
+    if (tag) {
+        el->tag = audio_strdup(tag);
+        AUDIO_MEM_CHECK(TAG, el->tag, {
+            return ESP_ERR_NO_MEM;
+        });
+    }
+    return ESP_OK;
+}
+
+char *audio_element_get_tag(audio_element_handle_t el)
+{
+    return el->tag;
+}
+
+esp_err_t audio_element_set_uri(audio_element_handle_t el, const char *uri)
+{
+    mutex_lock(el->lock);
+    if (el->info.uri) {
+        audio_free(el->info.uri);
+        el->info.uri = NULL;
+    }
+
+    if (uri) {
+        el->info.uri = audio_strdup(uri);
+        AUDIO_MEM_CHECK(TAG, el->info.uri, {
+            mutex_unlock(el->lock);
+            return ESP_ERR_NO_MEM;
+        });
+    }
+    mutex_unlock(el->lock);
+    return ESP_OK;
+}
+
+char *audio_element_get_uri(audio_element_handle_t el)
+{
+    mutex_lock(el->lock);
+    char *uri = el->info.uri;
+    mutex_unlock(el->lock);
+    return uri;
+}
+
+esp_err_t audio_element_set_event_callback(audio_element_handle_t el, event_cb_func cb_func, void *ctx)
+{
+    el->events_type = EVENTS_TYPE_CB;
+    el->callback_event.cb = cb_func;
+    el->callback_event.ctx = ctx;
+    return ESP_OK;
+}
+
+esp_err_t audio_element_msg_set_listener(audio_element_handle_t el, audio_event_iface_handle_t listener)
+{
+    return audio_event_iface_set_listener(el->iface_event, listener);
+}
+
+esp_err_t audio_element_msg_remove_listener(audio_element_handle_t el, audio_event_iface_handle_t listener)
+{
+    return audio_event_iface_remove_listener(listener, el->iface_event);
+}
+
+esp_err_t audio_element_setinfo(audio_element_handle_t el, audio_element_info_t *info)
+{
+    if (info && el) {
+        //FIXME: We will got reset if lock mutex here
+        mutex_lock(el->lock);
+        memcpy(&el->info, info, sizeof(audio_element_info_t));
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_getinfo(audio_element_handle_t el, audio_element_info_t *info)
+{
+    if (info && el) {
+        mutex_lock(el->lock);
+        memcpy(info, &el->info, sizeof(audio_element_info_t));
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_report_info(audio_element_handle_t el)
+{
+    if (el) {
+        audio_event_iface_msg_t msg = { 0 };
+        msg.cmd = AEL_MSG_CMD_REPORT_MUSIC_INFO;
+        msg.data = NULL;
+        ESP_LOGD(TAG, "REPORT_INFO,[%s]evt out cmd:%d,", el->tag, msg.cmd);
+        audio_element_msg_sendout(el, &msg);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_report_codec_fmt(audio_element_handle_t el)
+{
+    if (el) {
+        audio_event_iface_msg_t msg = { 0 };
+        msg.cmd = AEL_MSG_CMD_REPORT_CODEC_FMT;
+        msg.data = NULL;
+        ESP_LOGD(TAG, "REPORT_FMT,[%s]evt out cmd:%d,", el->tag, msg.cmd);
+        audio_element_msg_sendout(el, &msg);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_report_status(audio_element_handle_t el, audio_element_status_t status)
+{
+    if (el) {
+        audio_event_iface_msg_t msg = { 0 };
+        msg.cmd = AEL_MSG_CMD_REPORT_STATUS;
+        msg.data = (void *)status;
+        msg.data_len = sizeof(status);
+        ESP_LOGD(TAG, "REPORT_STATUS,[%s]evt out cmd = %d,status:%d", el->tag, msg.cmd, status);
+        return audio_element_msg_sendout(el, &msg);
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_report_pos(audio_element_handle_t el)
+{
+    if (el) {
+        audio_event_iface_msg_t msg = { 0 };
+        msg.cmd = AEL_MSG_CMD_REPORT_POSITION;
+        if (el->report_info == NULL) {
+            el->report_info = audio_calloc(1, sizeof(audio_element_info_t));
+            AUDIO_MEM_CHECK(TAG, el->report_info, return ESP_ERR_NO_MEM);
+        }
+
+        audio_element_getinfo(el, el->report_info);
+        msg.data = el->report_info;
+        msg.data_len = sizeof(audio_element_info_t);
+        ESP_LOGD(TAG, "REPORT_POS,[%s]evt out cmd:%d,", el->tag, msg.cmd);
+        audio_element_msg_sendout(el, &msg);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_finish_state(audio_element_handle_t el)
+{
+    if (el->task_stack <= 0) {
+        el->state = AEL_STATE_FINISHED;
+        audio_element_report_status(el, AEL_STATUS_STATE_FINISHED);
+        el->is_running = false;
+        xEventGroupSetBits(el->state_event, STOPPED_BIT);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_change_cmd(audio_element_handle_t el, audio_element_msg_cmd_t cmd)
+{
+    AUDIO_NULL_CHECK(TAG, el, return ESP_ERR_INVALID_ARG);
+    return audio_element_cmd_send(el, cmd);
+}
+
+esp_err_t audio_element_reset_input_ringbuf(audio_element_handle_t el)
+{
+    if (el->read_type != IO_TYPE_RB) {
+        return ESP_FAIL;
+    }
+    int ret = ESP_OK;
+    if (el->in.input_rb) {
+        ret |= rb_reset(el->in.input_rb);
+        for (int i = 0; i < el->multi_in.max_rb_num; ++i) {
+            if (el->multi_in.rb[i]) {
+                ret |= rb_reset(el->multi_in.rb[i]);
+            }
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_reset_output_ringbuf(audio_element_handle_t el)
+{
+    if (el->write_type != IO_TYPE_RB) {
+        return ESP_FAIL;
+    }
+    int ret = ESP_OK;
+    if (el->out.output_rb) {
+        ret |= rb_reset(el->out.output_rb);
+        for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
+            if (el->multi_out.rb[i]) {
+                ret |= rb_reset(el->multi_out.rb[i]);
+            }
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_abort_input_ringbuf(audio_element_handle_t el)
+{
+    if (el->read_type != IO_TYPE_RB) {
+        return ESP_FAIL;
+    }
+    int ret = ESP_OK;
+    if (el->in.input_rb) {
+        ret |= rb_abort(el->in.input_rb);
+        for (int i = 0; i < el->multi_in.max_rb_num; ++i) {
+            if (el->multi_in.rb[i]) {
+                ret |= rb_abort(el->multi_in.rb[i]);
+            }
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_abort_output_ringbuf(audio_element_handle_t el)
+{
+    if (el->write_type != IO_TYPE_RB) {
+        return ESP_FAIL;
+    }
+    int ret = ESP_OK;
+    if (el->out.output_rb) {
+        ret |= rb_abort(el->out.output_rb);
+        for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
+            if (el->multi_out.rb[i]) {
+                ret |= rb_abort(el->multi_out.rb[i]);
+            }
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_set_ringbuf_done(audio_element_handle_t el)
+{
+    if (NULL == el) {
+        return ESP_FAIL;
+    }
+    int ret = ESP_OK;
+    if (el->out.output_rb && el->write_type == IO_TYPE_RB) {
+        ret |= rb_done_write(el->out.output_rb);
+        for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
+            if (el->multi_out.rb[i]) {
+                ret |= rb_done_write(el->multi_out.rb[i]);
+            }
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_set_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb)
+{
+    if (rb) {
+        el->in.input_rb = rb;
+        rb_set_reader_holder(rb, (void*)el);
+        el->read_type = IO_TYPE_RB;
+    } else if (el->read_type == IO_TYPE_RB) {
+        el->in.input_rb = rb;
+        rb_set_reader_holder(rb, (void*)el);
+    }
+    return ESP_OK;
+}
+
+ringbuf_handle_t audio_element_get_input_ringbuf(audio_element_handle_t el)
+{
+    if (el->read_type == IO_TYPE_RB) {
+        return el->in.input_rb;
+    } else {
+        return NULL;
+    }
+}
+
+esp_err_t audio_element_set_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb)
+{
+    if (rb) {
+        el->out.output_rb = rb;
+        el->write_type = IO_TYPE_RB;
+        rb_set_writer_holder(rb, (void*)el);
+    } else if (el->write_type == IO_TYPE_RB) {
+        el->out.output_rb = rb;
+        rb_set_writer_holder(rb, (void*)el);
+    }
+    return ESP_OK;
+}
+
+ringbuf_handle_t audio_element_get_output_ringbuf(audio_element_handle_t el)
+{
+    if (el->write_type == IO_TYPE_RB) {
+        return el->out.output_rb;
+    } else {
+        return NULL;
+    }
+}
+
+esp_err_t audio_element_set_input_timeout(audio_element_handle_t el, TickType_t timeout)
+{
+    if (el) {
+        el->input_wait_time = timeout;
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_output_timeout(audio_element_handle_t el, TickType_t timeout)
+{
+    if (el) {
+        el->output_wait_time = timeout;
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+int audio_element_get_output_ringbuf_size(audio_element_handle_t el)
+{
+    if (el) {
+        return el->out_rb_size;
+    }
+    return 0;
+}
+
+esp_err_t audio_element_set_output_ringbuf_size(audio_element_handle_t el, int rb_size)
+{
+    if (el) {
+        el->out_rb_size = rb_size;
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_read_cb(audio_element_handle_t el, stream_func fn, void *context)
+{
+    if (el) {
+        el->in.read_cb.cb = fn;
+        el->in.read_cb.ctx = context;
+        el->read_type = IO_TYPE_CB;
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_write_cb(audio_element_handle_t el, stream_func fn, void *context)
+{
+    if (el) {
+        el->out.write_cb.cb = fn;
+        el->out.write_cb.ctx = context;
+        el->write_type = IO_TYPE_CB;
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+stream_func audio_element_get_write_cb(audio_element_handle_t el)
+{
+    if (el && el->write_type == IO_TYPE_CB) {
+        return el->out.write_cb.cb;
+    }
+    ESP_LOGE(TAG, "Fail to get write callback");
+    return NULL;
+}
+
+stream_func audio_element_get_read_cb(audio_element_handle_t el)
+{
+    if (el && el->read_type == IO_TYPE_CB) {
+        return el->in.read_cb.cb;
+    }
+    ESP_LOGE(TAG, "Fail to get read callback");
+    return NULL;
+}
+
+esp_err_t audio_element_wait_for_stop(audio_element_handle_t el)
+{
+    if (el->is_running == false) {
+        ESP_LOGD(TAG, "[%s] Element already stopped, return without waiting", el->tag);
+        return ESP_OK;
+    }
+    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, STOPPED_BIT, false, true, DEFAULT_MAX_WAIT_TIME);
+    esp_err_t ret = ESP_ERR_TIMEOUT;
+    if (uxBits & STOPPED_BIT) {
+        ret = ESP_OK;
+    }
+    return ret;
+}
+
+esp_err_t audio_element_wait_for_buffer(audio_element_handle_t el, int size_expect, TickType_t timeout)
+{
+    int ret = ESP_FAIL;
+    el->out_buf_size_expect = size_expect;
+    if (el->out.output_rb) {
+        xEventGroupClearBits(el->state_event, BUFFER_REACH_LEVEL_BIT);
+        EventBits_t uxBits = xEventGroupWaitBits(el->state_event, BUFFER_REACH_LEVEL_BIT, false, true, timeout);
+        if ((uxBits & BUFFER_REACH_LEVEL_BIT) != 0) {
+            ret = ESP_OK;
+        } else {
+            ret = ESP_FAIL;
+        }
+    }
+    return ret;
+}
+
+audio_element_handle_t audio_element_init(audio_element_cfg_t *config)
+{
+    audio_element_handle_t el = audio_calloc(1, sizeof(struct audio_element));
+
+    AUDIO_MEM_CHECK(TAG, el, {
+        return NULL;
+    });
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    evt_cfg.on_cmd = audio_element_on_cmd;
+    evt_cfg.context = el;
+    evt_cfg.queue_set_size = 0; // Element have no queue_set by default.
+    evt_cfg.external_queue_size = 5;
+    evt_cfg.internal_queue_size = 5;
+    bool _success =
+        (
+            ((config->tag ? audio_element_set_tag(el, config->tag) : audio_element_set_tag(el, "unknown")) == ESP_OK) &&
+            (el->lock           = mutex_create())                   &&
+            (el->iface_event    = audio_event_iface_init(&evt_cfg)) &&
+            (el->state_event    = xEventGroupCreate())
+        );
+
+    AUDIO_MEM_CHECK(TAG, _success, goto _element_init_failed);
+
+    el->open = config->open;
+    el->process = config->process;
+    el->close = config->close;
+    el->destroy = config->destroy;
+    el->seek = config->seek;
+    el->multi_in.max_rb_num = config->multi_in_rb_num;
+    el->multi_out.max_rb_num = config->multi_out_rb_num;
+    if (el->multi_in.max_rb_num > 0) {
+        el->multi_in.rb = (ringbuf_handle_t *)audio_calloc(el->multi_in.max_rb_num, sizeof(ringbuf_handle_t));
+        AUDIO_MEM_CHECK(TAG, el->multi_in.rb, goto _element_init_failed);
+    }
+    if (el->multi_out.max_rb_num > 0) {
+        el->multi_out.rb = (ringbuf_handle_t *)audio_calloc(el->multi_out.max_rb_num, sizeof(ringbuf_handle_t));
+        AUDIO_MEM_CHECK(TAG, el->multi_out.rb, goto _element_init_failed);
+    }
+
+    if (config->task_stack > 0) {
+        el->task_stack = config->task_stack;
+        el->stack_in_ext = config->stack_in_ext;
+    }
+    if (config->task_prio) {
+        el->task_prio = config->task_prio;
+    } else {
+        el->task_prio = DEFAULT_ELEMENT_TASK_PRIO;
+    }
+    if (config->task_core) {
+        el->task_core = config->task_core;
+    } else {
+        el->task_core = DEFAULT_ELEMENT_TASK_CORE;
+    }
+    if (config->out_rb_size > 0) {
+        el->out_rb_size = config->out_rb_size;
+    } else {
+        el->out_rb_size = DEFAULT_ELEMENT_RINGBUF_SIZE;
+    }
+    el->data = config ->data;
+
+    el->state = AEL_STATE_INIT;
+    el->buf_size = config->buffer_len;
+
+    audio_element_info_t info = AUDIO_ELEMENT_INFO_DEFAULT();
+    audio_element_setinfo(el, &info);
+    audio_element_set_input_timeout(el, portMAX_DELAY);
+    audio_element_set_output_timeout(el, portMAX_DELAY);
+
+    if (config->read != NULL) {
+        el->read_type = IO_TYPE_CB;
+        el->in.read_cb.cb = config->read;
+    } else {
+        el->read_type = IO_TYPE_RB;
+    }
+
+    if (config->write != NULL) {
+        el->write_type = IO_TYPE_CB;
+        el->out.write_cb.cb = config->write;
+    } else {
+        el->write_type = IO_TYPE_RB;
+    }
+
+    el->events_type = EVENTS_TYPE_Q;
+    return el;
+_element_init_failed:
+    audio_element_set_uri(el, NULL);
+    if (el->lock) {
+        mutex_destroy(el->lock);
+    }
+    if (el->state_event) {
+        vEventGroupDelete(el->state_event);
+    }
+    if (el->iface_event) {
+        audio_event_iface_destroy(el->iface_event);
+    }
+    if (el->tag) {
+        audio_element_set_tag(el, NULL);
+    }
+    if (el->multi_in.rb) {
+        audio_free(el->multi_in.rb);
+        el->multi_in.rb = NULL;
+    }
+    if (el->multi_out.rb) {
+        audio_free(el->multi_out.rb);
+        el->multi_out.rb = NULL;
+    }
+    audio_free(el);
+    return NULL;
+}
+
+esp_err_t audio_element_deinit(audio_element_handle_t el)
+{
+    audio_element_stop(el);
+    audio_element_wait_for_stop(el);
+    audio_element_terminate(el);
+    vEventGroupDelete(el->state_event);
+
+    audio_event_iface_destroy(el->iface_event);
+    if (el->destroy) {
+        el->destroy(el);
+    }
+    audio_element_set_tag(el, NULL);
+    audio_element_set_uri(el, NULL);
+    if (el->multi_in.rb) {
+        audio_free(el->multi_in.rb);
+        el->multi_in.rb = NULL;
+    }
+    if (el->multi_out.rb) {
+        audio_free(el->multi_out.rb);
+        el->multi_out.rb = NULL;
+    }
+    if (el->report_info) {
+        audio_free(el->report_info);
+    }
+    if (el->audio_thread) {
+        audio_thread_cleanup(&el->audio_thread);
+    }
+    mutex_destroy(el->lock);
+    el->lock = NULL;
+    audio_free(el);
+    return ESP_OK;
+}
+
+esp_err_t audio_element_run(audio_element_handle_t el)
+{
+    char task_name[32];
+    esp_err_t ret = ESP_FAIL;
+    if (el->task_run) {
+        ESP_LOGD(TAG, "[%s-%p] Element already created", el->tag, el);
+        return ESP_OK;
+    }
+    ESP_LOGV(TAG, "[%s] Element starting...", el->tag);
+    snprintf(task_name, 32, "el-%s", el->tag);
+    audio_event_iface_discard(el->iface_event);
+    xEventGroupClearBits(el->state_event, TASK_CREATED_BIT);
+    if (el->task_stack > 0) {
+        ret = audio_thread_create(&el->audio_thread, el->tag, audio_element_task, el, el->task_stack,
+                                  el->task_prio, el->stack_in_ext, el->task_core);
+        if (ret == ESP_FAIL) {
+            audio_element_force_set_state(el, AEL_STATE_ERROR);
+            audio_element_report_status(el, AEL_STATUS_ERROR_OPEN);
+            ESP_LOGE(TAG, "[%s] audio_thread_create failed", el->tag);
+            return ESP_FAIL;
+        }
+        EventBits_t uxBits = xEventGroupWaitBits(el->state_event, TASK_CREATED_BIT, false, true, DEFAULT_MAX_WAIT_TIME);
+
+        if (uxBits & TASK_CREATED_BIT) {
+            ret = ESP_OK;
+        }
+    } else {
+        el->task_run = true;
+        el->is_running = true;
+        audio_element_force_set_state(el, AEL_STATE_RUNNING);
+        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
+        ret = ESP_OK;
+    }
+    ESP_LOGI(TAG, "[%s-%p] Element task created", el->tag, el);
+    return ret;
+}
+
+static inline esp_err_t __audio_element_term(audio_element_handle_t el, TickType_t ticks_to_wait)
+{
+    xEventGroupClearBits(el->state_event, TASK_DESTROYED_BIT);
+    if (audio_element_cmd_send(el, AEL_MSG_CMD_DESTROY) != ESP_OK) {
+        ESP_LOGE(TAG, "[%s] Send destroy command failed", el->tag);
+        return ESP_FAIL;
+    }
+    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, TASK_DESTROYED_BIT, false, true, ticks_to_wait);
+    esp_err_t ret = ESP_FAIL;
+    if (uxBits & TASK_DESTROYED_BIT ) {
+        ESP_LOGD(TAG, "[%s-%p] Element task destroyed", el->tag, el);
+        ret = ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "[%s-%p] Element task destroy timeout[%d]", el->tag, el, (int)ticks_to_wait);
+    }
+    return ret;
+}
+
+esp_err_t audio_element_terminate(audio_element_handle_t el)
+{
+    if (!el->task_run) {
+        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_TERMINATE", el->tag);
+        return ESP_OK;
+    }
+    if (el->task_stack <= 0) {
+        el->task_run = false;
+        el->is_running = false;
+        return ESP_OK;
+    }
+    return __audio_element_term(el, DEFAULT_MAX_WAIT_TIME);
+}
+
+esp_err_t audio_element_terminate_with_ticks(audio_element_handle_t el, TickType_t ticks_to_wait)
+{
+    if (!el->task_run) {
+        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_TERMINATE, tick:%d", el->tag, (int)ticks_to_wait);
+        return ESP_OK;
+    }
+    if (el->task_stack <= 0) {
+        el->task_run = false;
+        el->is_running = false;
+        return ESP_OK;
+    }
+    return __audio_element_term(el, ticks_to_wait);
+}
+
+esp_err_t audio_element_pause(audio_element_handle_t el)
+{
+    if (!el->task_run) {
+        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_PAUSE", el->tag);
+        return ESP_FAIL;
+    }
+    if ((el->state >= AEL_STATE_PAUSED)) {
+        audio_element_force_set_state(el, AEL_STATE_PAUSED);
+        ESP_LOGD(TAG, "[%s] Element already paused, state:%d", el->tag, el->state);
+        return ESP_OK;
+    }
+    xEventGroupClearBits(el->state_event, PAUSED_BIT);
+    if (el->task_stack <= 0) {
+        el->is_running = false;
+        audio_element_force_set_state(el, AEL_STATE_PAUSED);
+        return ESP_OK;
+    }
+    if (audio_element_cmd_send(el, AEL_MSG_CMD_PAUSE) != ESP_OK) {
+        ESP_LOGE(TAG, "[%s] Element send cmd error when AUDIO_ELEMENT_PAUSE", el->tag);
+        return ESP_FAIL;
+    }
+    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, PAUSED_BIT, false, true, DEFAULT_MAX_WAIT_TIME);
+    esp_err_t ret = ESP_FAIL;
+    if (uxBits & PAUSED_BIT) {
+        ret = ESP_OK;
+    }
+    return ret;
+}
+
+esp_err_t audio_element_resume(audio_element_handle_t el, float wait_for_rb_threshold, TickType_t timeout)
+{
+    if (!el->task_run) {
+        ESP_LOGW(TAG, "[%s] Element has not create when AUDIO_ELEMENT_RESUME", el->tag);
+        return ESP_FAIL;
+    }
+    if (el->state == AEL_STATE_RUNNING) {
+        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
+        ESP_LOGD(TAG, "[%s] RESUME: Element is already running, state:%d, task_run:%d, is_running:%d",
+                 el->tag, el->state, el->task_run, el->is_running);
+        return ESP_OK;
+    }
+    if (el->task_stack <= 0) {
+        el->is_running = true;
+        audio_element_force_set_state(el, AEL_STATE_RUNNING);
+        audio_element_report_status(el, AEL_STATUS_STATE_RUNNING);
+        return ESP_OK;
+    }
+    if (el->state == AEL_STATE_ERROR) {
+        ESP_LOGE(TAG, "[%s] RESUME: Element error, state:%d", el->tag, el->state);
+        return ESP_FAIL;
+    }
+    if (el->state == AEL_STATE_FINISHED) {
+        ESP_LOGI(TAG, "[%s] RESUME: Element has finished, state:%d", el->tag, el->state);
+        audio_element_report_status(el, AEL_STATUS_STATE_FINISHED);
+        return ESP_OK;
+    }
+    if (wait_for_rb_threshold > 1 || wait_for_rb_threshold < 0) {
+        return ESP_FAIL;
+    }
+    int ret =  ESP_OK;
+    xEventGroupClearBits(el->state_event, RESUMED_BIT);
+    if (audio_element_cmd_send(el, AEL_MSG_CMD_RESUME) == ESP_FAIL) {
+        ESP_LOGW(TAG, "[%s] Send resume command failed", el->tag);
+        return ESP_FAIL;
+    }
+    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, RESUMED_BIT, false, true, timeout);
+    if ((uxBits & RESUMED_BIT) != RESUMED_BIT) {
+        ESP_LOGW(TAG, "[%s-%p] RESUME timeout", el->tag, el);
+        ret = ESP_FAIL;
+    } else {
+        if (wait_for_rb_threshold != 0 && el->read_type == IO_TYPE_RB) {
+            ret = audio_element_wait_for_buffer(el, rb_get_size(el->in.input_rb) * wait_for_rb_threshold, timeout);
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_stop(audio_element_handle_t el)
+{
+    if (!el->task_run) {
+        ESP_LOGD(TAG, "[%s] Element has not create when AUDIO_ELEMENT_STOP", el->tag);
+        return ESP_FAIL;
+    }
+    if (el->state == AEL_STATE_PAUSED) {
+        audio_event_iface_set_cmd_waiting_timeout(el->iface_event, 0);
+        audio_element_set_byte_pos(el, 0);
+    }
+    if (el->is_running == false) {
+        xEventGroupSetBits(el->state_event, STOPPED_BIT);
+        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
+        ESP_LOGW(TAG, "[%s] Element already stopped", el->tag);
+        return ESP_OK;
+    }
+    audio_element_abort_output_ringbuf(el);
+    audio_element_abort_input_ringbuf(el);
+    if (el->state == AEL_STATE_RUNNING) {
+        xEventGroupClearBits(el->state_event, STOPPED_BIT);
+    }
+    if (el->task_stack <= 0) {
+        el->is_running = false;
+        audio_element_force_set_state(el, AEL_STATE_STOPPED);
+        xEventGroupSetBits(el->state_event, STOPPED_BIT);
+        audio_element_report_status(el, AEL_STATUS_STATE_STOPPED);
+        return ESP_OK;
+    }
+    if (el->stopping) {
+        ESP_LOGD(TAG, "[%s] Stop command has already sent, %d", el->tag, el->stopping);
+        return ESP_OK;
+    }
+    el->stopping = true;
+    if (audio_element_cmd_send(el, AEL_MSG_CMD_STOP) != ESP_OK) {
+        el->stopping = false;
+        ESP_LOGW(TAG, "[%s-%p] Send stop command failed", el->tag, el);
+        return ESP_FAIL;
+    }
+    ESP_LOGD(TAG, "[%s-%p] Send stop command", el->tag, el);
+    return ESP_OK;
+}
+
+esp_err_t audio_element_wait_for_stop_ms(audio_element_handle_t el, TickType_t ticks_to_wait)
+{
+    if (el->is_running == false) {
+        ESP_LOGD(TAG, "[%s] Element already stopped, return without waiting", el->tag);
+        return ESP_OK;
+    }
+    EventBits_t uxBits = xEventGroupWaitBits(el->state_event, STOPPED_BIT, false, true, ticks_to_wait);
+    esp_err_t ret = ESP_ERR_TIMEOUT;
+    if (uxBits & STOPPED_BIT) {
+        ret = ESP_OK;
+    }
+    return ret;
+}
+
+int audio_element_multi_input(audio_element_handle_t el, char *buffer, int wanted_size, int index, TickType_t ticks_to_wait)
+{
+    int ret = ESP_OK;
+    if (index >= el->multi_in.max_rb_num) {
+        ESP_LOGE(TAG, "The index of ringbuffer is gather than and equal to ringbuffer maximum (%d). line %d", el->multi_in.max_rb_num, __LINE__);
+        return ESP_ERR_INVALID_SIZE;
+    }
+    if (el->multi_in.rb[index]) {
+        ret = rb_read(el->multi_in.rb[index], buffer, wanted_size, ticks_to_wait);
+    }
+    return ret;
+}
+
+int audio_element_multi_output(audio_element_handle_t el, char *buffer, int wanted_size, TickType_t ticks_to_wait)
+{
+    int ret = ESP_OK;
+    for (int i = 0; i < el->multi_out.max_rb_num; ++i) {
+        if (el->multi_out.rb[i]) {
+            ret |= rb_write(el->multi_out.rb[i], buffer, wanted_size, ticks_to_wait);
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_element_set_multi_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index)
+{
+    if ((index < el->multi_in.max_rb_num) && rb) {
+        el->multi_in.rb[index] = rb;
+        return ESP_OK;
+    }
+    return ESP_ERR_INVALID_ARG;
+}
+
+esp_err_t audio_element_set_multi_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index)
+{
+    if ((index < el->multi_out.max_rb_num) && rb) {
+        el->multi_out.rb[index] = rb;
+        return ESP_OK;
+    }
+    return ESP_ERR_INVALID_ARG;
+}
+
+ringbuf_handle_t audio_element_get_multi_input_ringbuf(audio_element_handle_t el, int index)
+{
+    if (index < el->multi_in.max_rb_num) {
+        return el->multi_in.rb[index];
+    }
+    return NULL;
+}
+
+ringbuf_handle_t audio_element_get_multi_output_ringbuf(audio_element_handle_t el, int index)
+{
+    if (index < el->multi_out.max_rb_num) {
+        return el->multi_out.rb[index];
+    }
+    return NULL;
+}
+
+esp_err_t audio_element_seek(audio_element_handle_t el, void *in_data, int in_size, void *out_data, int *out_size)
+{
+    esp_err_t ret = ESP_OK;
+    if (el && el->seek) {
+        ret = el->seek(el, in_data, in_size, out_data, out_size);
+    } else {
+        ret = ESP_ERR_NOT_SUPPORTED;
+    }
+    return ret;
+}
+
+bool audio_element_is_stopping(audio_element_handle_t el)
+{
+    if (el) {
+        return el->stopping;
+    }
+    return false;
+}
+
+esp_err_t audio_element_update_byte_pos(audio_element_handle_t el, int pos)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.byte_pos += pos;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_byte_pos(audio_element_handle_t el, int pos)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.byte_pos = pos;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_update_total_bytes(audio_element_handle_t el, int total_bytes)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.total_bytes += total_bytes;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_total_bytes(audio_element_handle_t el, int total_bytes)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.total_bytes = total_bytes;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_bps(audio_element_handle_t el, int bit_rate)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.bps = bit_rate;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_codec_fmt(audio_element_handle_t el, int format)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.codec_fmt = format;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_music_info(audio_element_handle_t el, int sample_rates, int channels, int bits)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.sample_rates = sample_rates;
+        el->info.channels = channels;
+        el->info.bits = bits;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_duration(audio_element_handle_t el, int duration)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.duration = duration;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_reserve_user0(audio_element_handle_t el, int user_data0)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.reserve_data.user_data_0 = user_data0;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_reserve_user1(audio_element_handle_t el, int user_data1)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.reserve_data.user_data_1 = user_data1;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_reserve_user2(audio_element_handle_t el, int user_data2)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.reserve_data.user_data_2 = user_data2;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+
+esp_err_t audio_element_set_reserve_user3(audio_element_handle_t el, int user_data3)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.reserve_data.user_data_3 = user_data3;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_element_set_reserve_user4(audio_element_handle_t el, int user_data4)
+{
+    if (el) {
+        mutex_lock(el->lock);
+        el->info.reserve_data.user_data_4 = user_data4;
+        mutex_unlock(el->lock);
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
diff --git a/components/audio_pipeline/audio_event_iface.c b/components/audio_pipeline/audio_event_iface.c
index e936c25e..5f029b9c 100644
--- a/components/audio_pipeline/audio_event_iface.c
+++ b/components/audio_pipeline/audio_event_iface.c
@@ -1,320 +1,320 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-#include "freertos/FreeRTOSConfig.h"
-
-#include "sys/queue.h"
-#include "esp_log.h"
-#include "audio_event_iface.h"
-#include "audio_error.h"
-#include "audio_mem.h"
-
-static const char *TAG = "AUDIO_EVT";
-
-
-typedef struct audio_event_iface_item {
-    STAILQ_ENTRY(audio_event_iface_item)    next;
-    QueueHandle_t                           queue;
-    int                                     queue_size;
-    int                                     mark_to_remove;
-} audio_event_iface_item_t;
-
-typedef STAILQ_HEAD(audio_event_iface_list, audio_event_iface_item) audio_event_iface_list_t;
-
-/**
- * Audio event structure
- */
-struct audio_event_iface {
-    QueueHandle_t               internal_queue;
-    QueueHandle_t               external_queue;
-    QueueSetHandle_t            queue_set;
-    int                         internal_queue_size;
-    int                         external_queue_size;
-    int                         queue_set_size;
-    audio_event_iface_list_t    listening_queues;
-    void                        *context;
-    on_event_iface_func         on_cmd;
-    int                         wait_time;
-    int                         type;
-};
-
-audio_event_iface_handle_t audio_event_iface_init(audio_event_iface_cfg_t *config)
-{
-    audio_event_iface_handle_t evt = audio_calloc(1, sizeof(struct audio_event_iface));
-    AUDIO_MEM_CHECK(TAG, evt, return NULL);
-    evt->queue_set_size   = config->queue_set_size;
-    evt->internal_queue_size = config->internal_queue_size;
-    evt->external_queue_size = config->external_queue_size;
-    evt->context = config->context;
-    evt->on_cmd = config->on_cmd;
-    evt->type = config->type;
-    if (evt->queue_set_size) {
-        evt->queue_set = xQueueCreateSet(evt->queue_set_size);
-    }
-    if (evt->internal_queue_size) {
-        evt->internal_queue = xQueueCreate(evt->internal_queue_size, sizeof(audio_event_iface_msg_t));
-        AUDIO_MEM_CHECK(TAG, evt->internal_queue, goto _event_iface_init_failed);
-    }
-    if (evt->external_queue_size) {
-        evt->external_queue = xQueueCreate(evt->external_queue_size, sizeof(audio_event_iface_msg_t));
-        AUDIO_MEM_CHECK(TAG, evt->external_queue, goto _event_iface_init_failed);
-    } else {
-        ESP_LOGD(TAG, "This emiiter have no queue set,%p", evt);
-    }
-
-    STAILQ_INIT(&evt->listening_queues);
-    return evt;
-_event_iface_init_failed:
-    if (evt->internal_queue) {
-        vQueueDelete(evt->internal_queue);
-    }
-    if (evt->external_queue) {
-        vQueueDelete(evt->external_queue);
-    }
-    return NULL;
-}
-
-static esp_err_t audio_event_iface_cleanup_listener(audio_event_iface_handle_t listen)
-{
-    audio_event_iface_item_t *item, *tmp;
-    audio_event_iface_discard(listen);
-    STAILQ_FOREACH_SAFE(item, &listen->listening_queues, next, tmp) {
-        audio_event_iface_msg_t dummy;
-        while (audio_event_iface_read(listen, &dummy, 0) == ESP_OK);
-        while (listen->queue_set && (xQueueRemoveFromSet(item->queue, listen->queue_set) != pdPASS)) {
-            ESP_LOGW(TAG, "Error remove listener,%p", item->queue);
-            while (audio_event_iface_read(listen, &dummy, 0) == ESP_OK);
-        }
-    }
-    if (listen->queue_set) {
-        vQueueDelete(listen->queue_set);
-        listen->queue_set = NULL;
-    }
-    return ESP_OK;
-}
-
-static esp_err_t audio_event_iface_update_listener(audio_event_iface_handle_t listen)
-{
-    audio_event_iface_item_t *item;
-    int queue_size = 0;
-    STAILQ_FOREACH(item, &listen->listening_queues, next) {
-        queue_size += item->queue_size;
-    }
-    if (queue_size) {
-        listen->queue_set = xQueueCreateSet(queue_size);
-    }
-    STAILQ_FOREACH(item, &listen->listening_queues, next) {
-        if (item->queue) {
-            audio_event_iface_msg_t dummy;
-            while (xQueueReceive(item->queue, &dummy, 0) == pdTRUE);
-        }
-        if (listen->queue_set && item->queue && xQueueAddToSet(item->queue, listen->queue_set) != pdPASS) {
-            ESP_LOGE(TAG, "Error add queue items to queue set");
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_read(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time)
-{
-    if (evt->queue_set) {
-        QueueSetMemberHandle_t active_queue;
-        active_queue = xQueueSelectFromSet(evt->queue_set, wait_time);
-        if (active_queue) {
-            if (xQueueReceive(active_queue, msg, 0) == pdTRUE) {
-                return ESP_OK;
-            }
-        }
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_event_iface_destroy(audio_event_iface_handle_t evt)
-{
-    audio_event_iface_cleanup_listener(evt);
-    audio_event_iface_item_t *item, *tmp;
-    STAILQ_FOREACH_SAFE(item, &evt->listening_queues, next, tmp) {
-        STAILQ_REMOVE(&evt->listening_queues, item, audio_event_iface_item, next);
-        audio_free(item);
-    }
-    if (evt->internal_queue) {
-        audio_event_iface_set_cmd_waiting_timeout(evt, 0);
-        vQueueDelete(evt->internal_queue);
-    }
-    if (evt->external_queue) {
-        vQueueDelete(evt->external_queue);
-    }
-    if (evt->queue_set) {
-        vQueueDelete(evt->queue_set);
-    }
-    audio_free(evt);
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_set_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener)
-{
-    if ((NULL == evt->external_queue)
-        || (0 == evt->external_queue_size)) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    audio_event_iface_item_t *item = audio_calloc(1, sizeof(audio_event_iface_item_t));
-    AUDIO_MEM_CHECK(TAG, item, return ESP_ERR_NO_MEM);
-
-    if (audio_event_iface_cleanup_listener(listener) != ESP_OK) {
-        AUDIO_ERROR(TAG, "Error cleanup listener");
-        return ESP_FAIL;
-    }
-    item->queue = evt->external_queue;
-    item->queue_size = evt->external_queue_size;
-    STAILQ_INSERT_TAIL(&listener->listening_queues, item, next);
-    return audio_event_iface_update_listener(listener);
-}
-
-esp_err_t audio_event_iface_set_msg_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener)
-{
-    if ((NULL == evt->internal_queue)
-        || (0 == evt->internal_queue_size)) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    audio_event_iface_item_t *item = audio_calloc(1, sizeof(audio_event_iface_item_t));
-    AUDIO_MEM_CHECK(TAG, item, return ESP_ERR_NO_MEM);
-    if (audio_event_iface_cleanup_listener(listener) != ESP_OK) {
-        AUDIO_ERROR(TAG, "Error cleanup listener");
-        return ESP_FAIL;
-    }
-    item->queue = evt->internal_queue;
-    item->queue_size = evt->internal_queue_size;
-    STAILQ_INSERT_TAIL(&listener->listening_queues, item, next);
-    return audio_event_iface_update_listener(listener);
-}
-
-esp_err_t audio_event_iface_remove_listener(audio_event_iface_handle_t listen, audio_event_iface_handle_t evt)
-{
-    if ((NULL == evt->external_queue)
-        || (0 == evt->external_queue_size)) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    audio_event_iface_item_t *item, *tmp;
-    if (audio_event_iface_cleanup_listener(listen) != ESP_OK) {
-        return ESP_FAIL;
-    }
-    STAILQ_FOREACH_SAFE(item, &listen->listening_queues, next, tmp) {
-        if (evt->external_queue == item->queue) {
-            STAILQ_REMOVE(&listen->listening_queues, item, audio_event_iface_item, next);
-            audio_free(item);
-        }
-    }
-    return audio_event_iface_update_listener(listen);
-}
-
-esp_err_t audio_event_iface_set_cmd_waiting_timeout(audio_event_iface_handle_t evt, TickType_t wait_time)
-{
-    evt->wait_time = wait_time;
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_waiting_cmd_msg(audio_event_iface_handle_t evt)
-{
-    audio_event_iface_msg_t msg;
-    if (evt->internal_queue && (xQueueReceive(evt->internal_queue, (void *)&msg, evt->wait_time) == pdTRUE)) {
-        if (evt->on_cmd) {
-            return evt->on_cmd((void *)&msg, evt->context);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_cmd(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg)
-{
-    if (evt->internal_queue && (xQueueSend(evt->internal_queue, (void *)msg, 0) != pdPASS)) {
-        ESP_LOGW(TAG, "There are no space to dispatch queue");
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_cmd_from_isr(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg)
-{
-    if (evt->internal_queue && (xQueueSendFromISR(evt->internal_queue, (void *)msg, 0) != pdPASS)) {
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_sendout(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg)
-{
-    if (evt->external_queue) {
-        if (xQueueSend(evt->external_queue, (void *)msg, 0) != pdPASS) {
-            ESP_LOGW(TAG, "There is no space in external queue");
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_discard(audio_event_iface_handle_t evt)
-{
-    audio_event_iface_msg_t msg;
-    if (evt->external_queue && evt->external_queue_size) {
-        while (xQueueReceive(evt->external_queue, &msg, 0) == pdTRUE);
-    }
-    if (evt->internal_queue && evt->internal_queue_size) {
-        while (xQueueReceive(evt->internal_queue, &msg, 0) == pdTRUE);
-    }
-    if (evt->queue_set && evt->queue_set_size) {
-        while (audio_event_iface_read(evt, &msg, 0) == ESP_OK);
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_event_iface_listen(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time)
-{
-    if (!evt) {
-        return ESP_FAIL;
-    }
-    if (audio_event_iface_read(evt, msg, wait_time) != ESP_OK) {
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-QueueHandle_t audio_event_iface_get_queue_handle(audio_event_iface_handle_t evt)
-{
-    if (!evt) {
-        return NULL;
-    }
-    return evt->external_queue;
-}
-
-QueueHandle_t audio_event_iface_get_msg_queue_handle(audio_event_iface_handle_t evt)
-{
-    if (!evt) {
-        return NULL;
-    }
-    return evt->internal_queue;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+#include "freertos/FreeRTOSConfig.h"
+
+#include "sys/queue.h"
+#include "esp_log.h"
+#include "audio_event_iface.h"
+#include "audio_error.h"
+#include "audio_mem.h"
+
+static const char *TAG = "AUDIO_EVT";
+
+
+typedef struct audio_event_iface_item {
+    STAILQ_ENTRY(audio_event_iface_item)    next;
+    QueueHandle_t                           queue;
+    int                                     queue_size;
+    int                                     mark_to_remove;
+} audio_event_iface_item_t;
+
+typedef STAILQ_HEAD(audio_event_iface_list, audio_event_iface_item) audio_event_iface_list_t;
+
+/**
+ * Audio event structure
+ */
+struct audio_event_iface {
+    QueueHandle_t               internal_queue;
+    QueueHandle_t               external_queue;
+    QueueSetHandle_t            queue_set;
+    int                         internal_queue_size;
+    int                         external_queue_size;
+    int                         queue_set_size;
+    audio_event_iface_list_t    listening_queues;
+    void                        *context;
+    on_event_iface_func         on_cmd;
+    int                         wait_time;
+    int                         type;
+};
+
+audio_event_iface_handle_t audio_event_iface_init(audio_event_iface_cfg_t *config)
+{
+    audio_event_iface_handle_t evt = audio_calloc(1, sizeof(struct audio_event_iface));
+    AUDIO_MEM_CHECK(TAG, evt, return NULL);
+    evt->queue_set_size   = config->queue_set_size;
+    evt->internal_queue_size = config->internal_queue_size;
+    evt->external_queue_size = config->external_queue_size;
+    evt->context = config->context;
+    evt->on_cmd = config->on_cmd;
+    evt->type = config->type;
+    if (evt->queue_set_size) {
+        evt->queue_set = xQueueCreateSet(evt->queue_set_size);
+    }
+    if (evt->internal_queue_size) {
+        evt->internal_queue = xQueueCreate(evt->internal_queue_size, sizeof(audio_event_iface_msg_t));
+        AUDIO_MEM_CHECK(TAG, evt->internal_queue, goto _event_iface_init_failed);
+    }
+    if (evt->external_queue_size) {
+        evt->external_queue = xQueueCreate(evt->external_queue_size, sizeof(audio_event_iface_msg_t));
+        AUDIO_MEM_CHECK(TAG, evt->external_queue, goto _event_iface_init_failed);
+    } else {
+        ESP_LOGD(TAG, "This emiiter have no queue set,%p", evt);
+    }
+
+    STAILQ_INIT(&evt->listening_queues);
+    return evt;
+_event_iface_init_failed:
+    if (evt->internal_queue) {
+        vQueueDelete(evt->internal_queue);
+    }
+    if (evt->external_queue) {
+        vQueueDelete(evt->external_queue);
+    }
+    return NULL;
+}
+
+static esp_err_t audio_event_iface_cleanup_listener(audio_event_iface_handle_t listen)
+{
+    audio_event_iface_item_t *item, *tmp;
+    audio_event_iface_discard(listen);
+    STAILQ_FOREACH_SAFE(item, &listen->listening_queues, next, tmp) {
+        audio_event_iface_msg_t dummy;
+        while (audio_event_iface_read(listen, &dummy, 0) == ESP_OK);
+        while (listen->queue_set && (xQueueRemoveFromSet(item->queue, listen->queue_set) != pdPASS)) {
+            ESP_LOGW(TAG, "Error remove listener,%p", item->queue);
+            while (audio_event_iface_read(listen, &dummy, 0) == ESP_OK);
+        }
+    }
+    if (listen->queue_set) {
+        vQueueDelete(listen->queue_set);
+        listen->queue_set = NULL;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t audio_event_iface_update_listener(audio_event_iface_handle_t listen)
+{
+    audio_event_iface_item_t *item;
+    int queue_size = 0;
+    STAILQ_FOREACH(item, &listen->listening_queues, next) {
+        queue_size += item->queue_size;
+    }
+    if (queue_size) {
+        listen->queue_set = xQueueCreateSet(queue_size);
+    }
+    STAILQ_FOREACH(item, &listen->listening_queues, next) {
+        if (item->queue) {
+            audio_event_iface_msg_t dummy;
+            while (xQueueReceive(item->queue, &dummy, 0) == pdTRUE);
+        }
+        if (listen->queue_set && item->queue && xQueueAddToSet(item->queue, listen->queue_set) != pdPASS) {
+            ESP_LOGE(TAG, "Error add queue items to queue set");
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_read(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time)
+{
+    if (evt->queue_set) {
+        QueueSetMemberHandle_t active_queue;
+        active_queue = xQueueSelectFromSet(evt->queue_set, wait_time);
+        if (active_queue) {
+            if (xQueueReceive(active_queue, msg, 0) == pdTRUE) {
+                return ESP_OK;
+            }
+        }
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_event_iface_destroy(audio_event_iface_handle_t evt)
+{
+    audio_event_iface_cleanup_listener(evt);
+    audio_event_iface_item_t *item, *tmp;
+    STAILQ_FOREACH_SAFE(item, &evt->listening_queues, next, tmp) {
+        STAILQ_REMOVE(&evt->listening_queues, item, audio_event_iface_item, next);
+        audio_free(item);
+    }
+    if (evt->internal_queue) {
+        audio_event_iface_set_cmd_waiting_timeout(evt, 0);
+        vQueueDelete(evt->internal_queue);
+    }
+    if (evt->external_queue) {
+        vQueueDelete(evt->external_queue);
+    }
+    if (evt->queue_set) {
+        vQueueDelete(evt->queue_set);
+    }
+    audio_free(evt);
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_set_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener)
+{
+    if ((NULL == evt->external_queue)
+        || (0 == evt->external_queue_size)) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    audio_event_iface_item_t *item = audio_calloc(1, sizeof(audio_event_iface_item_t));
+    AUDIO_MEM_CHECK(TAG, item, return ESP_ERR_NO_MEM);
+
+    if (audio_event_iface_cleanup_listener(listener) != ESP_OK) {
+        AUDIO_ERROR(TAG, "Error cleanup listener");
+        return ESP_FAIL;
+    }
+    item->queue = evt->external_queue;
+    item->queue_size = evt->external_queue_size;
+    STAILQ_INSERT_TAIL(&listener->listening_queues, item, next);
+    return audio_event_iface_update_listener(listener);
+}
+
+esp_err_t audio_event_iface_set_msg_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener)
+{
+    if ((NULL == evt->internal_queue)
+        || (0 == evt->internal_queue_size)) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    audio_event_iface_item_t *item = audio_calloc(1, sizeof(audio_event_iface_item_t));
+    AUDIO_MEM_CHECK(TAG, item, return ESP_ERR_NO_MEM);
+    if (audio_event_iface_cleanup_listener(listener) != ESP_OK) {
+        AUDIO_ERROR(TAG, "Error cleanup listener");
+        return ESP_FAIL;
+    }
+    item->queue = evt->internal_queue;
+    item->queue_size = evt->internal_queue_size;
+    STAILQ_INSERT_TAIL(&listener->listening_queues, item, next);
+    return audio_event_iface_update_listener(listener);
+}
+
+esp_err_t audio_event_iface_remove_listener(audio_event_iface_handle_t listen, audio_event_iface_handle_t evt)
+{
+    if ((NULL == evt->external_queue)
+        || (0 == evt->external_queue_size)) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    audio_event_iface_item_t *item, *tmp;
+    if (audio_event_iface_cleanup_listener(listen) != ESP_OK) {
+        return ESP_FAIL;
+    }
+    STAILQ_FOREACH_SAFE(item, &listen->listening_queues, next, tmp) {
+        if (evt->external_queue == item->queue) {
+            STAILQ_REMOVE(&listen->listening_queues, item, audio_event_iface_item, next);
+            audio_free(item);
+        }
+    }
+    return audio_event_iface_update_listener(listen);
+}
+
+esp_err_t audio_event_iface_set_cmd_waiting_timeout(audio_event_iface_handle_t evt, TickType_t wait_time)
+{
+    evt->wait_time = wait_time;
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_waiting_cmd_msg(audio_event_iface_handle_t evt)
+{
+    audio_event_iface_msg_t msg;
+    if (evt->internal_queue && (xQueueReceive(evt->internal_queue, (void *)&msg, evt->wait_time) == pdTRUE)) {
+        if (evt->on_cmd) {
+            return evt->on_cmd((void *)&msg, evt->context);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_cmd(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg)
+{
+    if (evt->internal_queue && (xQueueSend(evt->internal_queue, (void *)msg, 0) != pdPASS)) {
+        ESP_LOGW(TAG, "There are no space to dispatch queue");
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_cmd_from_isr(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg)
+{
+    if (evt->internal_queue && (xQueueSendFromISR(evt->internal_queue, (void *)msg, 0) != pdPASS)) {
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_sendout(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg)
+{
+    if (evt->external_queue) {
+        if (xQueueSend(evt->external_queue, (void *)msg, 0) != pdPASS) {
+            ESP_LOGW(TAG, "There is no space in external queue");
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_discard(audio_event_iface_handle_t evt)
+{
+    audio_event_iface_msg_t msg;
+    if (evt->external_queue && evt->external_queue_size) {
+        while (xQueueReceive(evt->external_queue, &msg, 0) == pdTRUE);
+    }
+    if (evt->internal_queue && evt->internal_queue_size) {
+        while (xQueueReceive(evt->internal_queue, &msg, 0) == pdTRUE);
+    }
+    if (evt->queue_set && evt->queue_set_size) {
+        while (audio_event_iface_read(evt, &msg, 0) == ESP_OK);
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_event_iface_listen(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time)
+{
+    if (!evt) {
+        return ESP_FAIL;
+    }
+    if (audio_event_iface_read(evt, msg, wait_time) != ESP_OK) {
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+QueueHandle_t audio_event_iface_get_queue_handle(audio_event_iface_handle_t evt)
+{
+    if (!evt) {
+        return NULL;
+    }
+    return evt->external_queue;
+}
+
+QueueHandle_t audio_event_iface_get_msg_queue_handle(audio_event_iface_handle_t evt)
+{
+    if (!evt) {
+        return NULL;
+    }
+    return evt->internal_queue;
+}
diff --git a/components/audio_pipeline/audio_pipeline.c b/components/audio_pipeline/audio_pipeline.c
index 8be8365c..fad41c75 100644
--- a/components/audio_pipeline/audio_pipeline.c
+++ b/components/audio_pipeline/audio_pipeline.c
@@ -1,1022 +1,1031 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-#include "freertos/event_groups.h"
-
-#include "sys/queue.h"
-#include "esp_log.h"
-#include "audio_element.h"
-#include "audio_pipeline.h"
-#include "audio_event_iface.h"
-#include "audio_mem.h"
-#include "audio_mutex.h"
-#include "ringbuf.h"
-#include "audio_error.h"
-
-static const char *TAG = "AUDIO_PIPELINE";
-
-#define PIPELINE_DEBUG(x) debug_pipeline_lists(x, __LINE__, __func__)
-
-typedef struct ringbuf_item {
-    STAILQ_ENTRY(ringbuf_item)  next;
-    ringbuf_handle_t            rb;
-    audio_element_handle_t      host_el;
-    bool                        linked;
-    bool                        kept_ctx;
-} ringbuf_item_t;
-
-typedef STAILQ_HEAD(ringbuf_list, ringbuf_item) ringbuf_list_t;
-
-typedef struct audio_element_item {
-    STAILQ_ENTRY(audio_element_item) next;
-    audio_element_handle_t           el;
-    bool                             linked;
-    bool                             kept_ctx;
-    audio_element_status_t           el_state;
-} audio_element_item_t;
-
-typedef STAILQ_HEAD(audio_element_list, audio_element_item) audio_element_list_t;
-
-struct audio_pipeline {
-    audio_element_list_t        el_list;
-    ringbuf_list_t              rb_list;
-    audio_element_state_t       state;
-    xSemaphoreHandle            lock;
-    bool                        linked;
-    audio_event_iface_handle_t  listener;
-};
-
-static audio_element_item_t *audio_pipeline_get_el_item_by_tag(audio_pipeline_handle_t pipeline, const char *tag)
-{
-    audio_element_item_t *item;
-    STAILQ_FOREACH(item, &pipeline->el_list, next) {
-        char *el_tag = audio_element_get_tag(item->el);
-        if (el_tag && strcasecmp(el_tag, tag) == 0) {
-            return item;
-        }
-    }
-    return NULL;
-}
-
-static audio_element_item_t *audio_pipeline_get_el_item_by_handle(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
-{
-    audio_element_item_t *item;
-    STAILQ_FOREACH(item, &pipeline->el_list, next) {
-        if (item->el == el) {
-            return item;
-        }
-    }
-    return NULL;
-}
-
-esp_err_t audio_pipeline_change_state(audio_pipeline_handle_t pipeline, audio_element_state_t new_state)
-{
-    pipeline->state = new_state;
-    return ESP_OK;
-}
-
-static void audio_pipeline_register_element(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
-{
-    if (audio_pipeline_get_el_item_by_handle(pipeline, el) != NULL) {
-        ESP_LOGW(TAG, "%d, %s already exist in pipeline", __LINE__, audio_element_get_tag(el));
-        return;
-    }
-    audio_element_item_t *el_item = audio_calloc(1, sizeof(audio_element_item_t));
-    AUDIO_MEM_CHECK(TAG, el_item, return);
-    el_item->el = el;
-    el_item->linked = true;
-    STAILQ_INSERT_TAIL(&pipeline->el_list, el_item, next);
-}
-
-static void audio_pipeline_unregister_element(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
-{
-    audio_element_item_t *el_item, *tmp;
-    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, tmp) {
-        if (el_item->el == el) {
-            STAILQ_REMOVE(&pipeline->el_list, el_item, audio_element_item, next);
-            audio_free(el_item);
-        }
-    }
-}
-
-static void add_rb_to_audio_pipeline(audio_pipeline_handle_t pipeline, ringbuf_handle_t rb, audio_element_handle_t host_el)
-{
-    ringbuf_item_t *rb_item = (ringbuf_item_t *)audio_calloc(1, sizeof(ringbuf_item_t));
-    AUDIO_MEM_CHECK(TAG, rb_item, return);
-    rb_item->rb = rb;
-    rb_item->linked = true;
-    rb_item->kept_ctx = false;
-    rb_item->host_el = host_el;
-    STAILQ_INSERT_TAIL(&pipeline->rb_list, rb_item, next);
-}
-
-static void debug_pipeline_lists(audio_pipeline_handle_t pipeline, int line, const char *func)
-{
-    audio_element_item_t *el_item, *el_tmp;
-    ringbuf_item_t *rb_item, *tmp;
-    ESP_LOGD(TAG, "FUNC:%s, LINE:%d", func, line);
-    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
-        ESP_LOGD(TAG, "el-list: linked:%d, kept:%d, el:%p, %16s, in_rb:%p, out_rb:%p",
-                 el_item->linked, el_item->kept_ctx,
-                 el_item->el, audio_element_get_tag(el_item->el),
-                 audio_element_get_input_ringbuf(el_item->el),
-                 audio_element_get_output_ringbuf(el_item->el));
-    }
-    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
-        ESP_LOGD(TAG, "rb-list: linked:%d, kept:%d, rb:%p, host_el:%p, %16s", rb_item->linked, rb_item->kept_ctx,
-                 rb_item->rb, rb_item->host_el,
-                 rb_item->host_el != NULL ? audio_element_get_tag(rb_item->host_el) : "NULL");
-    }
-}
-
-audio_element_handle_t audio_pipeline_get_el_by_tag(audio_pipeline_handle_t pipeline, const char *tag)
-{
-    if (tag == NULL || pipeline == NULL) {
-        ESP_LOGE(TAG, "Invalid parameters, tag:%p, p:%p", tag, pipeline);
-        return NULL;
-    }
-    audio_element_item_t *item;
-    STAILQ_FOREACH(item, &pipeline->el_list, next) {
-        char *el_tag = audio_element_get_tag(item->el);
-        ESP_LOGD(TAG, "Get_el_by_tag, el:%p, kept:%d, linked:%d el-tag:%16s, in_tag:%s",
-                 item->el, item->kept_ctx, item->linked, item->el != NULL ? audio_element_get_tag(item->el) : "NULL", tag);
-        if (item->kept_ctx) {
-            continue;
-        }
-        if (el_tag && strcasecmp(el_tag, tag) == 0) {
-            return item->el;
-        }
-    }
-    return NULL;
-}
-
-audio_element_handle_t audio_pipeline_get_el_once(audio_pipeline_handle_t pipeline, const audio_element_handle_t start_el, const char *tag)
-{
-    if (tag == NULL || pipeline == NULL) {
-        ESP_LOGE(TAG, "Invalid parameters, tag:%p, p:%p", tag, pipeline);
-        return NULL;
-    }
-    audio_element_item_t *item;
-    bool start = false;
-    STAILQ_FOREACH(item, &pipeline->el_list, next) {
-        if (start == false) {
-            if (item->el == start_el) {
-                start = true;
-            }
-        } else {
-            char *el_tag = audio_element_get_tag(item->el);
-            ESP_LOGD(TAG, "Get_el_by_el, el:%p, kept:%d, linked:%d el-tag:%16s, in_tag:%s",
-                     item->el, item->kept_ctx, item->linked, item->el != NULL ? audio_element_get_tag(item->el) : "NULL", tag);
-            if (item->kept_ctx) {
-                continue;
-            }
-            if (el_tag && strcasecmp(el_tag, tag) == 0) {
-                return item->el;
-            }
-        }
-    }
-    return NULL;
-}
-
-
-esp_err_t audio_pipeline_set_listener(audio_pipeline_handle_t pipeline, audio_event_iface_handle_t listener)
-{
-    audio_element_item_t *el_item;
-    if (pipeline->listener) {
-        audio_pipeline_remove_listener(pipeline);
-    }
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked == false) {
-            continue;
-        }
-        if (audio_element_msg_set_listener(el_item->el, listener) != ESP_OK) {
-            ESP_LOGE(TAG, "Error register event with: %s", (char *)audio_element_get_tag(el_item->el));
-            return ESP_FAIL;
-        }
-    }
-    pipeline->listener = listener;
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_remove_listener(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    if (pipeline->listener == NULL) {
-        ESP_LOGW(TAG, "There are no listener registered");
-        return ESP_FAIL;
-    }
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked == false) {
-            continue;
-        }
-        if (audio_element_msg_remove_listener(el_item->el, pipeline->listener) != ESP_OK) {
-            ESP_LOGE(TAG, "Error unregister event with: %s", audio_element_get_tag(el_item->el));
-            return ESP_FAIL;
-        }
-    }
-    pipeline->listener = NULL;
-    return ESP_OK;
-}
-
-audio_pipeline_handle_t audio_pipeline_init(audio_pipeline_cfg_t *config)
-{
-    audio_pipeline_handle_t pipeline;
-    bool _success =
-        (
-            (pipeline       = audio_calloc(1, sizeof(struct audio_pipeline)))   &&
-            (pipeline->lock = mutex_create())
-        );
-
-    AUDIO_MEM_CHECK(TAG, _success, return NULL);
-    STAILQ_INIT(&pipeline->el_list);
-    STAILQ_INIT(&pipeline->rb_list);
-
-    pipeline->state = AEL_STATE_INIT;
-    return pipeline;
-}
-
-esp_err_t audio_pipeline_deinit(audio_pipeline_handle_t pipeline)
-{
-    audio_pipeline_terminate(pipeline);
-    audio_pipeline_unlink(pipeline);
-    audio_element_item_t *el_item, *tmp;
-    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, tmp) {
-        ESP_LOGD(TAG, "[%16s]-[%p]element instance has been deleted", audio_element_get_tag(el_item->el), el_item->el);
-        audio_element_deinit(el_item->el);
-        audio_pipeline_unregister(pipeline, el_item->el);
-    }
-    mutex_destroy(pipeline->lock);
-    audio_free(pipeline);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_register(audio_pipeline_handle_t pipeline, audio_element_handle_t el, const char *name)
-{
-    audio_pipeline_unregister(pipeline, el);
-    if (name) {
-        audio_element_set_tag(el, name);
-    }
-    audio_element_item_t *el_item = audio_calloc(1, sizeof(audio_element_item_t));
-
-    AUDIO_MEM_CHECK(TAG, el_item, return ESP_ERR_NO_MEM);
-    el_item->el = el;
-    el_item->linked = false;
-    STAILQ_INSERT_TAIL(&pipeline->el_list, el_item, next);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_unregister(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
-{
-    audio_element_item_t *el_item, *tmp;
-    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, tmp) {
-        if (el_item->el == el) {
-            STAILQ_REMOVE(&pipeline->el_list, el_item, audio_element_item, next);
-            audio_free(el_item);
-            return ESP_OK;
-        }
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_pipeline_resume(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    bool wait_first_el = true;
-    esp_err_t ret = ESP_OK;
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        ESP_LOGD(TAG, "resume,linked:%d, state:%d,[%s-%p]", el_item->linked,
-                 audio_element_get_state(el_item->el), audio_element_get_tag(el_item->el), el_item->el);
-        if (false == el_item->linked) {
-            continue;
-        }
-        if (wait_first_el) {
-            ret |= audio_element_resume(el_item->el, 0, 2000 / portTICK_RATE_MS);
-            wait_first_el = false;
-        } else {
-            ret |= audio_element_resume(el_item->el, 0, 2000 / portTICK_RATE_MS);
-        }
-    }
-    audio_pipeline_change_state(pipeline, AEL_STATE_RUNNING);
-    return ret;
-}
-
-esp_err_t audio_pipeline_pause(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (false == el_item->linked) {
-            continue;
-        }
-        ESP_LOGD(TAG, "pause [%s]  %p", audio_element_get_tag(el_item->el), el_item->el);
-        audio_element_pause(el_item->el);
-    }
-
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_run(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    if (pipeline->state != AEL_STATE_INIT) {
-        ESP_LOGW(TAG, "Pipeline already started, state:%d", pipeline->state);
-        return ESP_OK;
-    }
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        ESP_LOGD(TAG, "start el[%16s], linked:%d, state:%d,[%p], ", audio_element_get_tag(el_item->el), el_item->linked,  audio_element_get_state(el_item->el), el_item->el);
-        if (el_item->linked
-            && ((AEL_STATE_INIT == audio_element_get_state(el_item->el))
-                || (AEL_STATE_STOPPED == audio_element_get_state(el_item->el))
-                || (AEL_STATE_FINISHED == audio_element_get_state(el_item->el))
-                || (AEL_STATE_ERROR == audio_element_get_state(el_item->el)))) {
-            audio_element_run(el_item->el);
-        }
-    }
-    AUDIO_MEM_SHOW(TAG);
-
-    if (ESP_FAIL == audio_pipeline_resume(pipeline)) {
-        ESP_LOGE(TAG, "audio_pipeline_resume failed");
-        audio_pipeline_change_state(pipeline, AEL_STATE_ERROR);
-        audio_pipeline_terminate(pipeline);
-        return ESP_FAIL;
-    } else {
-        audio_pipeline_change_state(pipeline, AEL_STATE_RUNNING);
-    }
-
-    ESP_LOGI(TAG, "Pipeline started");
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_terminate(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    ESP_LOGD(TAG, "Destroy audio_pipeline elements");
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            audio_element_terminate(el_item->el);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_terminate_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait)
-{
-    audio_element_item_t *el_item;
-    esp_err_t ret = ESP_OK;
-    ESP_LOGD(TAG, "Destroy audio_pipeline elements with ticks[%d]", (int)ticks_to_wait);
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            ret |= audio_element_terminate_with_ticks(el_item->el, ticks_to_wait);
-        }
-    }
-    return ret;
-}
-
-esp_err_t audio_pipeline_stop(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    ESP_LOGD(TAG, "audio_element_stop");
-    if (pipeline->state != AEL_STATE_RUNNING) {
-        ESP_LOGW(TAG, "Without stop, st:%d", pipeline->state);
-        return ESP_FAIL;
-    }
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            audio_element_stop(el_item->el);
-        }
-    }
-    return ESP_OK;
-}
-
-static inline esp_err_t __audio_pipeline_wait_stop(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait)
-{
-    audio_element_item_t *el_item;
-    esp_err_t ret = ESP_OK;
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            esp_err_t res = audio_element_wait_for_stop_ms(el_item->el, ticks_to_wait);
-            if (res == ESP_ERR_TIMEOUT) {
-                ESP_LOGW(TAG, "Wait stop timeout, el:%p, tag:%s",
-                         el_item->el, audio_element_get_tag(el_item->el) == NULL ? "NULL" : audio_element_get_tag(el_item->el));
-            } else {
-                audio_element_reset_state(el_item->el);
-            }
-            ret |= res;
-        }
-    }
-    audio_pipeline_change_state(pipeline, AEL_STATE_INIT);
-    return ret;
-}
-
-esp_err_t audio_pipeline_wait_for_stop(audio_pipeline_handle_t pipeline)
-{
-    if (pipeline->state != AEL_STATE_RUNNING) {
-        ESP_LOGW(TAG, "Without wait stop, st:%d", pipeline->state);
-        return ESP_FAIL;
-    }
-
-    ESP_LOGD(TAG, "%s - IN", __func__);
-    esp_err_t ret = __audio_pipeline_wait_stop(pipeline, portMAX_DELAY);
-    ESP_LOGD(TAG, "%s - OUT", __func__);
-    return ret;
-}
-
-esp_err_t audio_pipeline_wait_for_stop_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait)
-{
-    if (pipeline->state != AEL_STATE_RUNNING) {
-        ESP_LOGW(TAG, "Without wait stop, st:%d", pipeline->state);
-        return ESP_FAIL;
-    }
-
-    ESP_LOGD(TAG, "%s - IN", __func__);
-    esp_err_t ret = __audio_pipeline_wait_stop(pipeline, ticks_to_wait);
-    ESP_LOGD(TAG, "%s - OUT", __func__);
-    return ret;
-}
-
-static esp_err_t _pipeline_rb_linked(audio_pipeline_handle_t pipeline, audio_element_handle_t el, bool first, bool last)
-{
-    static ringbuf_handle_t rb;
-    ringbuf_item_t *rb_item;
-    if (last) {
-        audio_element_set_input_ringbuf(el, rb);
-    } else {
-        if (!first) {
-            audio_element_set_input_ringbuf(el, rb);
-        }
-        bool _success = (
-                            (rb_item = audio_calloc(1, sizeof(ringbuf_item_t))) &&
-                            (rb = rb_create(audio_element_get_output_ringbuf_size(el), 1))
-                        );
-
-        AUDIO_MEM_CHECK(TAG, _success, {
-            audio_free(rb_item);
-            return ESP_ERR_NO_MEM;
-        });
-
-        rb_item->rb = rb;
-        rb_item->linked = true;
-        rb_item->kept_ctx = false;
-        rb_item->host_el = el;
-        STAILQ_INSERT_TAIL(&pipeline->rb_list, rb_item, next);
-        audio_element_set_output_ringbuf(el, rb);
-        ESP_LOGI(TAG, "link el->rb, el:%p, tag:%s, rb:%p", el, audio_element_get_tag(el) == NULL ? "NULL" : audio_element_get_tag(el), rb);
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_link(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num)
-{
-    esp_err_t ret = ESP_OK;
-    bool first = false, last = false;
-    if (pipeline->linked) {
-        audio_pipeline_unlink(pipeline);
-    }
-    for (int i = 0; i < link_num; i++) {
-        audio_element_item_t *item = audio_pipeline_get_el_item_by_tag(pipeline, link_tag[i]);
-        if (item == NULL) {
-            ESP_LOGE(TAG, "There is 1 link_tag invalid: %s", link_tag[i]);
-            return ESP_FAIL;
-        }
-        item->linked = true;
-        item->kept_ctx = false;
-        audio_element_handle_t el = item->el;
-        first = (i == 0);
-        last = (i == link_num - 1);
-        ret = _pipeline_rb_linked(pipeline, el, first, last);
-        if (ret != ESP_OK) {
-            return ret;
-        }
-    }
-    pipeline->linked = true;
-    PIPELINE_DEBUG(pipeline);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_unlink(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    ringbuf_item_t *rb_item, *tmp;
-    if (!pipeline->linked) {
-        return ESP_OK;
-    }
-    audio_pipeline_remove_listener(pipeline);
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            el_item->linked = false;
-            el_item->kept_ctx = false;
-            audio_element_set_output_ringbuf(el_item->el, NULL);
-            audio_element_set_input_ringbuf(el_item->el, NULL);
-            ESP_LOGD(TAG, "audio_pipeline_unlink, %p, %s", el_item->el, audio_element_get_tag(el_item->el));
-        }
-    }
-    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
-        ESP_LOGD(TAG, "audio_pipeline_unlink, RB:%p,host_el:%p", rb_item->rb, rb_item->host_el);
-        STAILQ_REMOVE(&pipeline->rb_list, rb_item, ringbuf_item, next);
-        if (rb_item->host_el) {
-            audio_element_set_output_ringbuf(rb_item->host_el, NULL);
-            audio_element_set_input_ringbuf(rb_item->host_el, NULL);
-        }
-        rb_destroy(rb_item->rb);
-        rb_item->linked = false;
-        rb_item->kept_ctx = false;
-        rb_item->host_el = NULL;
-        audio_free(rb_item);
-    }
-    ESP_LOGI(TAG, "audio_pipeline_unlinked");
-    STAILQ_INIT(&pipeline->rb_list);
-    pipeline->linked = false;
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_register_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
-{
-    va_list args;
-    va_start(args, element_1);
-    while (element_1) {
-        audio_pipeline_register_element(pipeline, element_1);
-        element_1 = va_arg(args, audio_element_handle_t);
-    }
-    va_end(args);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_unregister_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
-{
-    va_list args;
-    va_start(args, element_1);
-    while (element_1) {
-        audio_pipeline_unregister_element(pipeline, element_1);
-        element_1 = va_arg(args, audio_element_handle_t);
-    }
-    va_end(args);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_link_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
-{
-    va_list args;
-    esp_err_t ret = ESP_OK;
-    int idx = 0;
-    bool first = false;
-    bool last = false;
-    if (pipeline->linked) {
-        audio_pipeline_unlink(pipeline);
-    }
-    va_start(args, element_1);
-    while (element_1) {
-        audio_element_handle_t el = element_1;
-        audio_element_item_t *item = audio_pipeline_get_el_item_by_handle(pipeline, element_1);
-        if (item == NULL) {
-            ESP_LOGE(TAG, "Can't found element[%p-%s] item", element_1, audio_element_get_tag(element_1));
-            return ESP_FAIL;
-        }
-        item->linked = true;
-        item->kept_ctx = false;
-        idx ++;
-        first = (idx == 1);
-        element_1 = va_arg(args, audio_element_handle_t);
-        last = (NULL == element_1) ? true : false;
-        ret = _pipeline_rb_linked(pipeline, el, first, last);
-        if (ret != ESP_OK) {
-            return ret;
-        }
-    }
-    pipeline->linked = true;
-    va_end(args);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_link_insert(audio_pipeline_handle_t pipeline, bool first, audio_element_handle_t prev, ringbuf_handle_t conect_rb, audio_element_handle_t next)
-{
-    if (first) {
-        audio_pipeline_register_element(pipeline, prev);
-    }
-    ESP_LOGD(TAG, "element is prev:%p, rb:%p, next:%p", prev, conect_rb, next);
-    audio_pipeline_register_element(pipeline, next);
-    audio_element_set_output_ringbuf(prev, conect_rb);
-    audio_element_set_input_ringbuf(next, conect_rb);
-    add_rb_to_audio_pipeline(pipeline, conect_rb, prev);
-    pipeline->linked = true;
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_listen_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
-{
-    va_list args;
-    va_start(args, element_1);
-    while (element_1) {
-        audio_element_handle_t el = element_1;
-        element_1 = va_arg(args, audio_element_handle_t);
-        QueueHandle_t que = audio_element_get_event_queue(el);
-        audio_event_iface_msg_t dummy = {0};
-        while (1) {
-            if (xQueueReceive(que, &dummy, 0) == pdTRUE) {
-                ESP_LOGD(TAG, "Listen_more el:%p, que :%p, OK", el, que);
-            } else {
-                ESP_LOGD(TAG, "Listen_more el:%p, que :%p, FAIL", el, que);
-                break;
-            }
-        }
-    }
-    va_end(args);
-    PIPELINE_DEBUG(pipeline);
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_check_items_state(audio_pipeline_handle_t pipeline, audio_element_handle_t el, audio_element_status_t status)
-{
-    audio_element_item_t *item;
-    int el_cnt = 0;
-    int el_sta_cnt = 0;
-    audio_element_item_t *it = audio_pipeline_get_el_item_by_handle(pipeline, el);
-    it->el_state =  status;
-    STAILQ_FOREACH(item, &pipeline->el_list, next) {
-        if (false == item->linked) {
-            continue;
-        }
-        el_cnt ++;
-        ESP_LOGV(TAG, "pipeline state check, pl:%p, el:%p, tag:%16s, state:%d, status:%d", pipeline, item->el,
-                 audio_element_get_tag(item->el), item->el_state, status);
-        int st = audio_element_get_state(item->el);
-        if ((st == AEL_STATE_STOPPED)
-            || (st == AEL_STATE_FINISHED)
-            || (st == AEL_STATE_ERROR)) {
-            ESP_LOGV(TAG, "Element rewrite, tag:%16s, el-state:%d, it->el_state:%d, wanted:%d",
-                     audio_element_get_tag(item->el), st, it->el_state, status);
-            if (st == AEL_STATE_ERROR) {
-                item->el_state = AEL_STATUS_ERROR_PROCESS;
-            } else {
-                item->el_state = st + AEL_STATUS_INPUT_BUFFERING;
-            }
-        }
-        if (item->el_state == AEL_STATUS_NONE) {
-            continue;
-        }
-        if (status == item->el_state) {
-            el_sta_cnt++;
-        } else if ((status == AEL_STATUS_STATE_RUNNING)) {
-            if ((item->el_state == AEL_STATUS_STATE_FINISHED)
-                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
-                el_sta_cnt++;
-                ESP_LOGW(TAG, "Check AEL RUNNING, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
-                         audio_element_get_tag(item->el), item->el_state, status);
-            }
-        } else if (status == AEL_STATUS_STATE_PAUSED) {
-            if ((item->el_state == AEL_STATUS_STATE_FINISHED)
-                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
-                el_sta_cnt++;
-                ESP_LOGW(TAG, "Check AEL PAUSED, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
-                         audio_element_get_tag(item->el), item->el_state, status);
-            }
-        } else if (status == AEL_STATUS_STATE_STOPPED) {
-            if ((item->el_state == AEL_STATUS_STATE_FINISHED)
-                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
-                el_sta_cnt++;
-                ESP_LOGW(TAG, "Check AEL STOPPED, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
-                         audio_element_get_tag(item->el), item->el_state, status);
-            }
-        } else if (status == AEL_STATUS_STATE_FINISHED) {
-            if ((item->el_state == AEL_STATUS_STATE_STOPPED)
-                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
-                el_sta_cnt++;
-                ESP_LOGW(TAG, "Check AEL FINISHED, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
-                         audio_element_get_tag(item->el), item->el_state, status);
-            }
-        } else {
-            // TODO nothing
-        }
-    }
-    if (el_cnt && (el_sta_cnt == el_cnt)) {
-        return ESP_OK;
-    } else {
-        return ESP_FAIL;
-    }
-}
-
-esp_err_t audio_pipeline_reset_items_state(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    ESP_LOGD(TAG, "audio_pipeline_reset_items_state");
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            el_item->el_state = AEL_STATUS_NONE;
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_reset_ringbuffer(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            audio_element_reset_input_ringbuf(el_item->el);
-            audio_element_reset_output_ringbuf(el_item->el);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_reset_elements(audio_pipeline_handle_t pipeline)
-{
-    audio_element_item_t *el_item;
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->linked) {
-            audio_element_reset_state(el_item->el);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_reset_kept_state(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
-{
-    audio_element_item_t *el_item;
-    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
-        if (el_item->el == el) {
-            el_item->linked = false;
-            el_item->kept_ctx = false;
-            break;
-        }
-    }
-    ringbuf_handle_t rb = audio_element_get_output_ringbuf(el);
-    audio_element_set_output_ringbuf(el, NULL);
-    ringbuf_item_t *rb_item, *tmp;
-    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
-        if (rb_item->rb == rb) {
-            rb_item->linked = false;
-            rb_item->kept_ctx = false;
-            rb_item->host_el = NULL;
-            ESP_LOGW(TAG, "kept_reset, rb:%p", rb);
-            break;
-        }
-    }
-    pipeline->linked = false;
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_breakup_elements(audio_pipeline_handle_t pipeline, audio_element_handle_t kept_ctx_el)
-{
-    if (pipeline == NULL) {
-        ESP_LOGE(TAG, "%s have invalid args, %p", __func__, pipeline);
-        return ESP_ERR_INVALID_ARG;
-    }
-    audio_pipeline_remove_listener(pipeline);
-    audio_element_item_t *el_item, *el_tmp;
-    ringbuf_item_t *rb_item, *tmp;
-    bool kept = true;
-    ESP_LOGD(TAG, "audio_pipeline_breakup_elements IN,%p,%s", kept_ctx_el, kept_ctx_el != NULL ? audio_element_get_tag(kept_ctx_el) : "NULL");
-    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
-        ESP_LOGD(TAG, "%d, el:%08x, %s, in_rb:%08x, out_rb:%08x, linked:%d, el-kept:%d", __LINE__,
-                 (int)el_item->el, audio_element_get_tag(el_item->el),
-                 (int)audio_element_get_input_ringbuf(el_item->el),
-                 (int)audio_element_get_output_ringbuf(el_item->el),
-                 el_item->linked,
-                 el_item->kept_ctx);
-        if (!el_item->linked) {
-            continue;
-        }
-        if ((!kept) && el_item->el != kept_ctx_el) {
-            audio_element_reset_state(el_item->el);
-            STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
-                if (audio_element_get_output_ringbuf(el_item->el) == NULL) {
-                    el_item->linked = false;
-                    el_item->kept_ctx = false;
-                    audio_element_set_input_ringbuf(el_item->el, NULL);
-                    ESP_LOGD(TAG, "output ringbuf is null");
-                    break;
-                } else if (rb_item->rb == audio_element_get_output_ringbuf(el_item->el)) {
-                    el_item->linked = false;
-                    el_item->kept_ctx = false;
-                    rb_item->kept_ctx = false;
-                    rb_item->linked = false;
-                    rb_item->host_el = NULL;
-                    audio_element_set_output_ringbuf(el_item->el, NULL);
-                    audio_element_set_input_ringbuf(el_item->el, NULL);
-                    ESP_LOGD(TAG, "found output ringbuf, %p", el_item->el);
-                    break;
-                }
-                audio_element_set_output_ringbuf(el_item->el, NULL);
-                audio_element_set_input_ringbuf(el_item->el, NULL);
-            }
-        } else {
-            STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
-                if (rb_item->rb == audio_element_get_output_ringbuf(el_item->el)) {
-                    el_item->linked = false;
-                    if ((audio_element_get_state(el_item->el) == AEL_STATE_RUNNING)
-                        || (audio_element_get_state(el_item->el) == AEL_STATE_PAUSED)
-                        /*|| (audio_element_get_state(el_item->el) == AEL_STATE_FINISHED)*/) {
-                        el_item->kept_ctx = true;
-                        rb_item->kept_ctx = true;
-                        ESP_LOGD(TAG, "found kept_ctx_el:%p and ringbuf:%p", el_item->el, rb_item->rb);
-                    } else {
-                        ESP_LOGW(TAG, "found kept_ctx_el and ringbuf, but not set kept, el:%p, rb:%p", el_item->el, rb_item->rb);
-                        audio_element_set_output_ringbuf(el_item->el, NULL);
-                    }
-                    kept = false;
-                    audio_element_set_input_ringbuf(el_item->el, NULL);
-                    break;
-                } else {
-                    el_item->linked = false;
-                }
-            }
-        }
-
-    }
-    // For Debug
-    PIPELINE_DEBUG(pipeline);
-    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
-        if (rb_item->kept_ctx == false) {
-            rb_item->linked = false;
-            rb_reset(rb_item->rb);
-        }
-        ESP_LOGD(TAG, "%d, reset rb:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->kept_ctx, rb_item->linked );
-    }
-    pipeline->linked = false;
-    audio_pipeline_change_state(pipeline, AEL_STATE_INIT);
-    return ESP_OK;
-}
-
-static esp_err_t audio_pipeline_el_item_link(audio_pipeline_handle_t pipeline,
-        audio_element_item_t *src_el_item,
-        audio_element_handle_t el, bool first, bool last)
-{
-    ringbuf_item_t *cur_rb_item = NULL;
-    ringbuf_item_t *rb_item, *rb_tmp;
-    static ringbuf_handle_t rb;
-    // Found the kept ringbuffer if exist
-    if (src_el_item->kept_ctx) {
-        STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, rb_tmp) {
-            ESP_LOGD(TAG, "%d, rb:%p host_el:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->host_el, rb_item->kept_ctx, rb_item->linked);
-            if (rb_item->host_el == el) {
-                cur_rb_item = rb_item;
-                cur_rb_item->linked = true;
-                cur_rb_item->kept_ctx = false;
-                cur_rb_item->host_el = el;
-                src_el_item->kept_ctx = false;
-                ESP_LOGD(TAG, "found kept rb:%p kept:%d,linked:%d, el:%p, name:%s", rb_item->rb, rb_item->kept_ctx,
-                         rb_item->linked, src_el_item->el, audio_element_get_tag(src_el_item->el));
-                break;
-            }
-        }
-    } else {
-        STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, rb_tmp) {
-            ESP_LOGD(TAG, "%d, rb:%p host_el:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->host_el, rb_item->kept_ctx, rb_item->linked);
-            if ((rb_item->linked == false)
-                && (rb_item->kept_ctx == false)) {
-                if (rb_item->host_el == NULL) {
-                    cur_rb_item = rb_item;
-                    cur_rb_item->linked = true;
-                    cur_rb_item->kept_ctx = false;
-                    cur_rb_item->host_el = el;
-                    rb_reset(cur_rb_item->rb);
-                    ESP_LOGD(TAG, "%d, found not used rb:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->kept_ctx, rb_item->linked);
-                    break;
-                }
-                rb_item->host_el = NULL;
-            }
-        }
-    }
-    if ((last == false) && (cur_rb_item == NULL)) {
-        ringbuf_handle_t tmp_rb = NULL;
-        bool _success = (
-                            (cur_rb_item = audio_calloc(1, sizeof(ringbuf_item_t))) &&
-                            (tmp_rb = rb_create(audio_element_get_output_ringbuf_size(el), 1))
-                        );
-
-        AUDIO_MEM_CHECK(TAG, _success, {
-            audio_free(cur_rb_item);
-            return ESP_ERR_NO_MEM;
-        });
-        cur_rb_item->rb = tmp_rb;
-        cur_rb_item->linked = true;
-        cur_rb_item->kept_ctx = false;
-        cur_rb_item->host_el = el;
-        STAILQ_INSERT_TAIL(&pipeline->rb_list, cur_rb_item, next);
-        ESP_LOGI(TAG, "create new rb,rb:%p",  cur_rb_item->rb);
-    }
-    ESP_LOGD(TAG, "%d, el:%p, tag:%s, cur_rb_item:%p, rb:%p, first:%d, last:%d\r\n", __LINE__, el,
-             audio_element_get_tag(el), cur_rb_item, cur_rb_item != NULL ? cur_rb_item->rb : NULL, first, last);
-    if (last) {
-        audio_element_set_input_ringbuf(el, rb);
-    } else {
-        if (!first) {
-            audio_element_set_input_ringbuf(el, rb);
-        }
-        rb = cur_rb_item->rb;
-        audio_element_set_output_ringbuf(el, rb);
-    }
-    return ESP_OK;
-}
-
-esp_err_t audio_pipeline_relink(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num)
-{
-    if (pipeline == NULL
-        || link_tag == NULL) {
-        ESP_LOGE(TAG, "%s have invalid args, %p, %p", __func__, pipeline, link_tag);
-        return ESP_ERR_INVALID_ARG;
-    }
-    if (pipeline->linked) {
-        ESP_LOGE(TAG, "%s pipeline is already linked, can't relink", __func__);
-        return ESP_FAIL;
-    }
-    esp_err_t ret = ESP_OK;
-    audio_element_item_t *el_item, *el_tmp;
-    bool first = false, last = false;
-    for (int i = 0; i < link_num; i++) {
-        audio_element_item_t *src_el_item = audio_pipeline_get_el_item_by_tag(pipeline, link_tag[i]);
-        if (src_el_item == NULL) {
-            ESP_LOGE(TAG, "There is link_tag invalid: %s", link_tag[i]);
-            ret = ESP_FAIL;
-            goto relink_err;
-        }
-        audio_element_handle_t el = NULL;
-        STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
-            ESP_LOGD(TAG, "%d, linked:%d, kept:%d, el:%s, el:%p, tag:%s, target-el:%p", __LINE__, el_item->linked, el_item->kept_ctx,
-                     audio_element_get_tag(el_item->el), el_item->el, link_tag[i], src_el_item->el);
-            if (src_el_item->el == el_item->el) {
-                el = el_item->el;
-                break;
-            }
-        }
-        if (el == NULL) {
-            ESP_LOGE(TAG, "Can't find element, wanted_el:%s", link_tag[i]);
-            ret = ESP_FAIL;
-            goto relink_err;
-        }
-        src_el_item->linked = true;
-        first = (i == 0);
-        last = (i == link_num - 1);
-        audio_pipeline_el_item_link(pipeline, src_el_item, el, first, last);
-    }
-    pipeline->linked = true;
-    PIPELINE_DEBUG(pipeline);
-relink_err:
-    return ret;
-}
-
-esp_err_t audio_pipeline_relink_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
-{
-    AUDIO_NULL_CHECK(TAG, (pipeline || element_1), return ESP_ERR_INVALID_ARG);
-    if (pipeline->linked) {
-        ESP_LOGE(TAG, "%s pipeline is already linked, can't relink", __func__);
-        return ESP_FAIL;
-    }
-    va_list args;
-    audio_element_item_t *el_item, *el_tmp;
-    va_start(args, element_1);
-    bool first = false, last = false;
-    uint16_t idx = 0;
-    while (element_1) {
-        audio_element_item_t *src_el_item = audio_pipeline_get_el_item_by_handle(pipeline, element_1);
-        AUDIO_NULL_CHECK(TAG, src_el_item, return ESP_FAIL);
-
-        audio_element_handle_t el = NULL;
-        STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
-            ESP_LOGD(TAG, "%d, linked:%d, kept:%d, el:%s, el:%p, tag:%s, target-el:%p", __LINE__, el_item->linked, el_item->kept_ctx,
-                     audio_element_get_tag(el_item->el), el_item->el, audio_element_get_tag(src_el_item->el), src_el_item->el);
-            if (src_el_item->el == el_item->el) {
-                el = el_item->el;
-                break;
-            }
-        }
-        if (el == NULL) {
-            ESP_LOGE(TAG, "Can't find element, wanted_el:%s", audio_element_get_tag(src_el_item->el));
-            return ESP_FAIL;
-        }
-        src_el_item->linked = true;
-        idx ++;
-        first = (idx == 1);
-        element_1 = va_arg(args, audio_element_handle_t);
-        last = (NULL == element_1) ? true : false;
-        audio_pipeline_el_item_link(pipeline, src_el_item, el, first, last);
-    }
-    pipeline->linked = true;
-    PIPELINE_DEBUG(pipeline);
-    va_end(args);
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+#include "freertos/event_groups.h"
+
+#include "sys/queue.h"
+#include "esp_log.h"
+#include "audio_element.h"
+#include "audio_pipeline.h"
+#include "audio_event_iface.h"
+#include "audio_mem.h"
+#include "audio_mutex.h"
+#include "ringbuf.h"
+#include "audio_error.h"
+
+static const char *TAG = "AUDIO_PIPELINE";
+
+#define PIPELINE_DEBUG(x) debug_pipeline_lists(x, __LINE__, __func__)
+
+typedef struct ringbuf_item {
+    STAILQ_ENTRY(ringbuf_item)  next;
+    ringbuf_handle_t            rb;
+    audio_element_handle_t      host_el;
+    bool                        linked;
+    bool                        kept_ctx;
+} ringbuf_item_t;
+
+typedef STAILQ_HEAD(ringbuf_list, ringbuf_item) ringbuf_list_t;
+
+typedef struct audio_element_item {
+    STAILQ_ENTRY(audio_element_item) next;
+    audio_element_handle_t           el;
+    bool                             linked;
+    bool                             kept_ctx;
+    audio_element_status_t           el_state;
+} audio_element_item_t;
+
+typedef STAILQ_HEAD(audio_element_list, audio_element_item) audio_element_list_t;
+
+struct audio_pipeline {
+    audio_element_list_t        el_list;
+    ringbuf_list_t              rb_list;
+    audio_element_state_t       state;
+    SemaphoreHandle_t            lock;
+    bool                        linked;
+    audio_event_iface_handle_t  listener;
+};
+
+static audio_element_item_t *audio_pipeline_get_el_item_by_tag(audio_pipeline_handle_t pipeline, const char *tag)
+{
+    audio_element_item_t *item;
+    STAILQ_FOREACH(item, &pipeline->el_list, next) {
+        char *el_tag = audio_element_get_tag(item->el);
+        if (el_tag && strcasecmp(el_tag, tag) == 0) {
+            return item;
+        }
+    }
+    return NULL;
+}
+
+static audio_element_item_t *audio_pipeline_get_el_item_by_handle(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
+{
+    audio_element_item_t *item;
+    STAILQ_FOREACH(item, &pipeline->el_list, next) {
+        if (item->el == el) {
+            return item;
+        }
+    }
+    return NULL;
+}
+
+esp_err_t audio_pipeline_change_state(audio_pipeline_handle_t pipeline, audio_element_state_t new_state)
+{
+    pipeline->state = new_state;
+    return ESP_OK;
+}
+
+static void audio_pipeline_register_element(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
+{
+    if (audio_pipeline_get_el_item_by_handle(pipeline, el) != NULL) {
+        ESP_LOGW(TAG, "%d, %s already exist in pipeline", __LINE__, audio_element_get_tag(el));
+        return;
+    }
+    audio_element_item_t *el_item = audio_calloc(1, sizeof(audio_element_item_t));
+    AUDIO_MEM_CHECK(TAG, el_item, return);
+    el_item->el = el;
+    el_item->linked = true;
+    STAILQ_INSERT_TAIL(&pipeline->el_list, el_item, next);
+}
+
+static void audio_pipeline_unregister_element(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
+{
+    audio_element_item_t *el_item, *tmp;
+    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, tmp) {
+        if (el_item->el == el) {
+            STAILQ_REMOVE(&pipeline->el_list, el_item, audio_element_item, next);
+            audio_free(el_item);
+        }
+    }
+}
+
+static void add_rb_to_audio_pipeline(audio_pipeline_handle_t pipeline, ringbuf_handle_t rb, audio_element_handle_t host_el)
+{
+    ringbuf_item_t *rb_item = (ringbuf_item_t *)audio_calloc(1, sizeof(ringbuf_item_t));
+    AUDIO_MEM_CHECK(TAG, rb_item, return);
+    rb_item->rb = rb;
+    rb_item->linked = true;
+    rb_item->kept_ctx = false;
+    rb_item->host_el = host_el;
+    STAILQ_INSERT_TAIL(&pipeline->rb_list, rb_item, next);
+}
+
+static void debug_pipeline_lists(audio_pipeline_handle_t pipeline, int line, const char *func)
+{
+    audio_element_item_t *el_item, *el_tmp;
+    ringbuf_item_t *rb_item, *tmp;
+    ESP_LOGD(TAG, "FUNC:%s, LINE:%d", func, line);
+    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
+        ESP_LOGD(TAG, "el-list: linked:%d, kept:%d, el:%p, %16s, in_rb:%p, out_rb:%p",
+                 el_item->linked, el_item->kept_ctx,
+                 el_item->el, audio_element_get_tag(el_item->el),
+                 audio_element_get_input_ringbuf(el_item->el),
+                 audio_element_get_output_ringbuf(el_item->el));
+    }
+    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
+        ESP_LOGD(TAG, "rb-list: linked:%d, kept:%d, rb:%p, host_el:%p, %16s", rb_item->linked, rb_item->kept_ctx,
+                 rb_item->rb, rb_item->host_el,
+                 rb_item->host_el != NULL ? audio_element_get_tag(rb_item->host_el) : "NULL");
+    }
+}
+
+audio_element_handle_t audio_pipeline_get_el_by_tag(audio_pipeline_handle_t pipeline, const char *tag)
+{
+    if (tag == NULL || pipeline == NULL) {
+        ESP_LOGE(TAG, "Invalid parameters, tag:%p, p:%p", tag, pipeline);
+        return NULL;
+    }
+    audio_element_item_t *item;
+    STAILQ_FOREACH(item, &pipeline->el_list, next) {
+        char *el_tag = audio_element_get_tag(item->el);
+        ESP_LOGD(TAG, "Get_el_by_tag, el:%p, kept:%d, linked:%d el-tag:%16s, in_tag:%s",
+                 item->el, item->kept_ctx, item->linked, item->el != NULL ? audio_element_get_tag(item->el) : "NULL", tag);
+        if (item->kept_ctx) {
+            continue;
+        }
+        if (el_tag && strcasecmp(el_tag, tag) == 0) {
+            return item->el;
+        }
+    }
+    return NULL;
+}
+
+audio_event_iface_handle_t audio_pipeline_get_event_iface(audio_pipeline_handle_t pipeline) {
+    if (!pipeline) {
+        ESP_LOGE(TAG, "Pipeline is NULL");
+        return NULL;
+    }
+    return pipeline->listener; // Access the listener field in the pipeline structure
+}
+
+
+audio_element_handle_t audio_pipeline_get_el_once(audio_pipeline_handle_t pipeline, const audio_element_handle_t start_el, const char *tag)
+{
+    if (tag == NULL || pipeline == NULL) {
+        ESP_LOGE(TAG, "Invalid parameters, tag:%p, p:%p", tag, pipeline);
+        return NULL;
+    }
+    audio_element_item_t *item;
+    bool start = false;
+    STAILQ_FOREACH(item, &pipeline->el_list, next) {
+        if (start == false) {
+            if (item->el == start_el) {
+                start = true;
+            }
+        } else {
+            char *el_tag = audio_element_get_tag(item->el);
+            ESP_LOGD(TAG, "Get_el_by_el, el:%p, kept:%d, linked:%d el-tag:%16s, in_tag:%s",
+                     item->el, item->kept_ctx, item->linked, item->el != NULL ? audio_element_get_tag(item->el) : "NULL", tag);
+            if (item->kept_ctx) {
+                continue;
+            }
+            if (el_tag && strcasecmp(el_tag, tag) == 0) {
+                return item->el;
+            }
+        }
+    }
+    return NULL;
+}
+
+
+esp_err_t audio_pipeline_set_listener(audio_pipeline_handle_t pipeline, audio_event_iface_handle_t listener)
+{
+    audio_element_item_t *el_item;
+    if (pipeline->listener) {
+        audio_pipeline_remove_listener(pipeline);
+    }
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked == false) {
+            continue;
+        }
+        if (audio_element_msg_set_listener(el_item->el, listener) != ESP_OK) {
+            ESP_LOGE(TAG, "Error register event with: %s", (char *)audio_element_get_tag(el_item->el));
+            return ESP_FAIL;
+        }
+    }
+    pipeline->listener = listener;
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_remove_listener(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    if (pipeline->listener == NULL) {
+        ESP_LOGW(TAG, "There are no listener registered");
+        return ESP_FAIL;
+    }
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked == false) {
+            continue;
+        }
+        if (audio_element_msg_remove_listener(el_item->el, pipeline->listener) != ESP_OK) {
+            ESP_LOGE(TAG, "Error unregister event with: %s", audio_element_get_tag(el_item->el));
+            return ESP_FAIL;
+        }
+    }
+    pipeline->listener = NULL;
+    return ESP_OK;
+}
+
+audio_pipeline_handle_t audio_pipeline_init(audio_pipeline_cfg_t *config)
+{
+    audio_pipeline_handle_t pipeline;
+    bool _success =
+        (
+            (pipeline       = audio_calloc(1, sizeof(struct audio_pipeline)))   &&
+            (pipeline->lock = mutex_create())
+        );
+
+    AUDIO_MEM_CHECK(TAG, _success, return NULL);
+    STAILQ_INIT(&pipeline->el_list);
+    STAILQ_INIT(&pipeline->rb_list);
+
+    pipeline->state = AEL_STATE_INIT;
+    return pipeline;
+}
+
+esp_err_t audio_pipeline_deinit(audio_pipeline_handle_t pipeline)
+{
+    audio_pipeline_terminate(pipeline);
+    audio_pipeline_unlink(pipeline);
+    audio_element_item_t *el_item, *tmp;
+    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, tmp) {
+        ESP_LOGD(TAG, "[%16s]-[%p]element instance has been deleted", audio_element_get_tag(el_item->el), el_item->el);
+        audio_element_deinit(el_item->el);
+        audio_pipeline_unregister(pipeline, el_item->el);
+    }
+    mutex_destroy(pipeline->lock);
+    audio_free(pipeline);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_register(audio_pipeline_handle_t pipeline, audio_element_handle_t el, const char *name)
+{
+    audio_pipeline_unregister(pipeline, el);
+    if (name) {
+        audio_element_set_tag(el, name);
+    }
+    audio_element_item_t *el_item = audio_calloc(1, sizeof(audio_element_item_t));
+
+    AUDIO_MEM_CHECK(TAG, el_item, return ESP_ERR_NO_MEM);
+    el_item->el = el;
+    el_item->linked = false;
+    STAILQ_INSERT_TAIL(&pipeline->el_list, el_item, next);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_unregister(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
+{
+    audio_element_item_t *el_item, *tmp;
+    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, tmp) {
+        if (el_item->el == el) {
+            STAILQ_REMOVE(&pipeline->el_list, el_item, audio_element_item, next);
+            audio_free(el_item);
+            return ESP_OK;
+        }
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_pipeline_resume(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    bool wait_first_el = true;
+    esp_err_t ret = ESP_OK;
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        ESP_LOGD(TAG, "resume,linked:%d, state:%d,[%s-%p]", el_item->linked,
+                 audio_element_get_state(el_item->el), audio_element_get_tag(el_item->el), el_item->el);
+        if (false == el_item->linked) {
+            continue;
+        }
+        if (wait_first_el) {
+            ret |= audio_element_resume(el_item->el, 0, 2000 / portTICK_PERIOD_MS);
+            wait_first_el = false;
+        } else {
+            ret |= audio_element_resume(el_item->el, 0, 2000 / portTICK_PERIOD_MS);
+        }
+    }
+    audio_pipeline_change_state(pipeline, AEL_STATE_RUNNING);
+    return ret;
+}
+
+esp_err_t audio_pipeline_pause(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (false == el_item->linked) {
+            continue;
+        }
+        ESP_LOGD(TAG, "pause [%s]  %p", audio_element_get_tag(el_item->el), el_item->el);
+        audio_element_pause(el_item->el);
+    }
+
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_run(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    if (pipeline->state != AEL_STATE_INIT) {
+        ESP_LOGW(TAG, "Pipeline already started, state:%d", pipeline->state);
+        return ESP_OK;
+    }
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        ESP_LOGD(TAG, "start el[%16s], linked:%d, state:%d,[%p], ", audio_element_get_tag(el_item->el), el_item->linked,  audio_element_get_state(el_item->el), el_item->el);
+        if (el_item->linked
+            && ((AEL_STATE_INIT == audio_element_get_state(el_item->el))
+                || (AEL_STATE_STOPPED == audio_element_get_state(el_item->el))
+                || (AEL_STATE_FINISHED == audio_element_get_state(el_item->el))
+                || (AEL_STATE_ERROR == audio_element_get_state(el_item->el)))) {
+            audio_element_run(el_item->el);
+        }
+    }
+    AUDIO_MEM_SHOW(TAG);
+
+    if (ESP_FAIL == audio_pipeline_resume(pipeline)) {
+        ESP_LOGE(TAG, "audio_pipeline_resume failed");
+        audio_pipeline_change_state(pipeline, AEL_STATE_ERROR);
+        audio_pipeline_terminate(pipeline);
+        return ESP_FAIL;
+    } else {
+        audio_pipeline_change_state(pipeline, AEL_STATE_RUNNING);
+    }
+
+    ESP_LOGI(TAG, "Pipeline started");
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_terminate(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    ESP_LOGD(TAG, "Destroy audio_pipeline elements");
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            audio_element_terminate(el_item->el);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_terminate_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait)
+{
+    audio_element_item_t *el_item;
+    esp_err_t ret = ESP_OK;
+    ESP_LOGD(TAG, "Destroy audio_pipeline elements with ticks[%d]", (int)ticks_to_wait);
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            ret |= audio_element_terminate_with_ticks(el_item->el, ticks_to_wait);
+        }
+    }
+    return ret;
+}
+
+esp_err_t audio_pipeline_stop(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    ESP_LOGD(TAG, "audio_element_stop");
+    if (pipeline->state != AEL_STATE_RUNNING) {
+        ESP_LOGW(TAG, "Without stop, st:%d", pipeline->state);
+        return ESP_FAIL;
+    }
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            audio_element_stop(el_item->el);
+        }
+    }
+    return ESP_OK;
+}
+
+static inline esp_err_t __audio_pipeline_wait_stop(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait)
+{
+    audio_element_item_t *el_item;
+    esp_err_t ret = ESP_OK;
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            esp_err_t res = audio_element_wait_for_stop_ms(el_item->el, ticks_to_wait);
+            if (res == ESP_ERR_TIMEOUT) {
+                ESP_LOGW(TAG, "Wait stop timeout, el:%p, tag:%s",
+                         el_item->el, audio_element_get_tag(el_item->el) == NULL ? "NULL" : audio_element_get_tag(el_item->el));
+            } else {
+                audio_element_reset_state(el_item->el);
+            }
+            ret |= res;
+        }
+    }
+    audio_pipeline_change_state(pipeline, AEL_STATE_INIT);
+    return ret;
+}
+
+esp_err_t audio_pipeline_wait_for_stop(audio_pipeline_handle_t pipeline)
+{
+    if (pipeline->state != AEL_STATE_RUNNING) {
+        ESP_LOGW(TAG, "Without wait stop, st:%d", pipeline->state);
+        return ESP_FAIL;
+    }
+
+    ESP_LOGD(TAG, "%s - IN", __func__);
+    esp_err_t ret = __audio_pipeline_wait_stop(pipeline, portMAX_DELAY);
+    ESP_LOGD(TAG, "%s - OUT", __func__);
+    return ret;
+}
+
+esp_err_t audio_pipeline_wait_for_stop_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait)
+{
+    if (pipeline->state != AEL_STATE_RUNNING) {
+        ESP_LOGW(TAG, "Without wait stop, st:%d", pipeline->state);
+        return ESP_FAIL;
+    }
+
+    ESP_LOGD(TAG, "%s - IN", __func__);
+    esp_err_t ret = __audio_pipeline_wait_stop(pipeline, ticks_to_wait);
+    ESP_LOGD(TAG, "%s - OUT", __func__);
+    return ret;
+}
+
+static esp_err_t _pipeline_rb_linked(audio_pipeline_handle_t pipeline, audio_element_handle_t el, bool first, bool last)
+{
+    static ringbuf_handle_t rb;
+    ringbuf_item_t *rb_item;
+    if (last) {
+        audio_element_set_input_ringbuf(el, rb);
+    } else {
+        if (!first) {
+            audio_element_set_input_ringbuf(el, rb);
+        }
+        bool _success = (
+                            (rb_item = audio_calloc(1, sizeof(ringbuf_item_t))) &&
+                            (rb = rb_create(audio_element_get_output_ringbuf_size(el), 1))
+                        );
+
+        AUDIO_MEM_CHECK(TAG, _success, {
+            audio_free(rb_item);
+            return ESP_ERR_NO_MEM;
+        });
+
+        rb_item->rb = rb;
+        rb_item->linked = true;
+        rb_item->kept_ctx = false;
+        rb_item->host_el = el;
+        STAILQ_INSERT_TAIL(&pipeline->rb_list, rb_item, next);
+        audio_element_set_output_ringbuf(el, rb);
+        ESP_LOGI(TAG, "link el->rb, el:%p, tag:%s, rb:%p", el, audio_element_get_tag(el) == NULL ? "NULL" : audio_element_get_tag(el), rb);
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_link(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num)
+{
+    esp_err_t ret = ESP_OK;
+    bool first = false, last = false;
+    if (pipeline->linked) {
+        audio_pipeline_unlink(pipeline);
+    }
+    for (int i = 0; i < link_num; i++) {
+        audio_element_item_t *item = audio_pipeline_get_el_item_by_tag(pipeline, link_tag[i]);
+        if (item == NULL) {
+            ESP_LOGE(TAG, "There is 1 link_tag invalid: %s", link_tag[i]);
+            return ESP_FAIL;
+        }
+        item->linked = true;
+        item->kept_ctx = false;
+        audio_element_handle_t el = item->el;
+        first = (i == 0);
+        last = (i == link_num - 1);
+        ret = _pipeline_rb_linked(pipeline, el, first, last);
+        if (ret != ESP_OK) {
+            return ret;
+        }
+    }
+    pipeline->linked = true;
+    PIPELINE_DEBUG(pipeline);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_unlink(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    ringbuf_item_t *rb_item, *tmp;
+    if (!pipeline->linked) {
+        return ESP_OK;
+    }
+    audio_pipeline_remove_listener(pipeline);
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            el_item->linked = false;
+            el_item->kept_ctx = false;
+            audio_element_set_output_ringbuf(el_item->el, NULL);
+            audio_element_set_input_ringbuf(el_item->el, NULL);
+            ESP_LOGD(TAG, "audio_pipeline_unlink, %p, %s", el_item->el, audio_element_get_tag(el_item->el));
+        }
+    }
+    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
+        ESP_LOGD(TAG, "audio_pipeline_unlink, RB:%p,host_el:%p", rb_item->rb, rb_item->host_el);
+        STAILQ_REMOVE(&pipeline->rb_list, rb_item, ringbuf_item, next);
+        if (rb_item->host_el) {
+            audio_element_set_output_ringbuf(rb_item->host_el, NULL);
+            audio_element_set_input_ringbuf(rb_item->host_el, NULL);
+        }
+        rb_destroy(rb_item->rb);
+        rb_item->linked = false;
+        rb_item->kept_ctx = false;
+        rb_item->host_el = NULL;
+        audio_free(rb_item);
+    }
+    ESP_LOGI(TAG, "audio_pipeline_unlinked");
+    STAILQ_INIT(&pipeline->rb_list);
+    pipeline->linked = false;
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_register_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
+{
+    va_list args;
+    va_start(args, element_1);
+    while (element_1) {
+        audio_pipeline_register_element(pipeline, element_1);
+        element_1 = va_arg(args, audio_element_handle_t);
+    }
+    va_end(args);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_unregister_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
+{
+    va_list args;
+    va_start(args, element_1);
+    while (element_1) {
+        audio_pipeline_unregister_element(pipeline, element_1);
+        element_1 = va_arg(args, audio_element_handle_t);
+    }
+    va_end(args);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_link_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
+{
+    va_list args;
+    esp_err_t ret = ESP_OK;
+    int idx = 0;
+    bool first = false;
+    bool last = false;
+    if (pipeline->linked) {
+        audio_pipeline_unlink(pipeline);
+    }
+    va_start(args, element_1);
+    while (element_1) {
+        audio_element_handle_t el = element_1;
+        audio_element_item_t *item = audio_pipeline_get_el_item_by_handle(pipeline, element_1);
+        if (item == NULL) {
+            ESP_LOGE(TAG, "Can't found element[%p-%s] item", element_1, audio_element_get_tag(element_1));
+            return ESP_FAIL;
+        }
+        item->linked = true;
+        item->kept_ctx = false;
+        idx ++;
+        first = (idx == 1);
+        element_1 = va_arg(args, audio_element_handle_t);
+        last = (NULL == element_1) ? true : false;
+        ret = _pipeline_rb_linked(pipeline, el, first, last);
+        if (ret != ESP_OK) {
+            return ret;
+        }
+    }
+    pipeline->linked = true;
+    va_end(args);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_link_insert(audio_pipeline_handle_t pipeline, bool first, audio_element_handle_t prev, ringbuf_handle_t conect_rb, audio_element_handle_t next)
+{
+    if (first) {
+        audio_pipeline_register_element(pipeline, prev);
+    }
+    ESP_LOGD(TAG, "element is prev:%p, rb:%p, next:%p", prev, conect_rb, next);
+    audio_pipeline_register_element(pipeline, next);
+    audio_element_set_output_ringbuf(prev, conect_rb);
+    audio_element_set_input_ringbuf(next, conect_rb);
+    add_rb_to_audio_pipeline(pipeline, conect_rb, prev);
+    pipeline->linked = true;
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_listen_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
+{
+    va_list args;
+    va_start(args, element_1);
+    while (element_1) {
+        audio_element_handle_t el = element_1;
+        element_1 = va_arg(args, audio_element_handle_t);
+        QueueHandle_t que = audio_element_get_event_queue(el);
+        audio_event_iface_msg_t dummy = {0};
+        while (1) {
+            if (xQueueReceive(que, &dummy, 0) == pdTRUE) {
+                ESP_LOGD(TAG, "Listen_more el:%p, que :%p, OK", el, que);
+            } else {
+                ESP_LOGD(TAG, "Listen_more el:%p, que :%p, FAIL", el, que);
+                break;
+            }
+        }
+    }
+    va_end(args);
+    PIPELINE_DEBUG(pipeline);
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_check_items_state(audio_pipeline_handle_t pipeline, audio_element_handle_t el, audio_element_status_t status)
+{
+    audio_element_item_t *item;
+    int el_cnt = 0;
+    int el_sta_cnt = 0;
+    audio_element_item_t *it = audio_pipeline_get_el_item_by_handle(pipeline, el);
+    it->el_state =  status;
+    STAILQ_FOREACH(item, &pipeline->el_list, next) {
+        if (false == item->linked) {
+            continue;
+        }
+        el_cnt ++;
+        ESP_LOGV(TAG, "pipeline state check, pl:%p, el:%p, tag:%16s, state:%d, status:%d", pipeline, item->el,
+                 audio_element_get_tag(item->el), item->el_state, status);
+        int st = audio_element_get_state(item->el);
+        if ((st == AEL_STATE_STOPPED)
+            || (st == AEL_STATE_FINISHED)
+            || (st == AEL_STATE_ERROR)) {
+            ESP_LOGV(TAG, "Element rewrite, tag:%16s, el-state:%d, it->el_state:%d, wanted:%d",
+                     audio_element_get_tag(item->el), st, it->el_state, status);
+            if (st == AEL_STATE_ERROR) {
+                item->el_state = AEL_STATUS_ERROR_PROCESS;
+            } else {
+                item->el_state = st + AEL_STATUS_INPUT_BUFFERING;
+            }
+        }
+        if (item->el_state == AEL_STATUS_NONE) {
+            continue;
+        }
+        if (status == item->el_state) {
+            el_sta_cnt++;
+        } else if ((status == AEL_STATUS_STATE_RUNNING)) {
+            if ((item->el_state == AEL_STATUS_STATE_FINISHED)
+                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
+                el_sta_cnt++;
+                ESP_LOGW(TAG, "Check AEL RUNNING, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
+                         audio_element_get_tag(item->el), item->el_state, status);
+            }
+        } else if (status == AEL_STATUS_STATE_PAUSED) {
+            if ((item->el_state == AEL_STATUS_STATE_FINISHED)
+                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
+                el_sta_cnt++;
+                ESP_LOGW(TAG, "Check AEL PAUSED, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
+                         audio_element_get_tag(item->el), item->el_state, status);
+            }
+        } else if (status == AEL_STATUS_STATE_STOPPED) {
+            if ((item->el_state == AEL_STATUS_STATE_FINISHED)
+                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
+                el_sta_cnt++;
+                ESP_LOGW(TAG, "Check AEL STOPPED, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
+                         audio_element_get_tag(item->el), item->el_state, status);
+            }
+        } else if (status == AEL_STATUS_STATE_FINISHED) {
+            if ((item->el_state == AEL_STATUS_STATE_STOPPED)
+                || ((item->el_state > AEL_STATUS_NONE) && (item->el_state < AEL_STATUS_INPUT_DONE))) {
+                el_sta_cnt++;
+                ESP_LOGW(TAG, "Check AEL FINISHED, pl:%p, el:%p, tag:%16s, state:%d, wanted:%d", pipeline, item->el,
+                         audio_element_get_tag(item->el), item->el_state, status);
+            }
+        } else {
+            // TODO nothing
+        }
+    }
+    if (el_cnt && (el_sta_cnt == el_cnt)) {
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
+
+esp_err_t audio_pipeline_reset_items_state(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    ESP_LOGD(TAG, "audio_pipeline_reset_items_state");
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            el_item->el_state = AEL_STATUS_NONE;
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_reset_ringbuffer(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            audio_element_reset_input_ringbuf(el_item->el);
+            audio_element_reset_output_ringbuf(el_item->el);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_reset_elements(audio_pipeline_handle_t pipeline)
+{
+    audio_element_item_t *el_item;
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->linked) {
+            audio_element_reset_state(el_item->el);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_reset_kept_state(audio_pipeline_handle_t pipeline, audio_element_handle_t el)
+{
+    audio_element_item_t *el_item;
+    STAILQ_FOREACH(el_item, &pipeline->el_list, next) {
+        if (el_item->el == el) {
+            el_item->linked = false;
+            el_item->kept_ctx = false;
+            break;
+        }
+    }
+    ringbuf_handle_t rb = audio_element_get_output_ringbuf(el);
+    audio_element_set_output_ringbuf(el, NULL);
+    ringbuf_item_t *rb_item, *tmp;
+    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
+        if (rb_item->rb == rb) {
+            rb_item->linked = false;
+            rb_item->kept_ctx = false;
+            rb_item->host_el = NULL;
+            ESP_LOGW(TAG, "kept_reset, rb:%p", rb);
+            break;
+        }
+    }
+    pipeline->linked = false;
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_breakup_elements(audio_pipeline_handle_t pipeline, audio_element_handle_t kept_ctx_el)
+{
+    if (pipeline == NULL) {
+        ESP_LOGE(TAG, "%s have invalid args, %p", __func__, pipeline);
+        return ESP_ERR_INVALID_ARG;
+    }
+    audio_pipeline_remove_listener(pipeline);
+    audio_element_item_t *el_item, *el_tmp;
+    ringbuf_item_t *rb_item, *tmp;
+    bool kept = true;
+    ESP_LOGD(TAG, "audio_pipeline_breakup_elements IN,%p,%s", kept_ctx_el, kept_ctx_el != NULL ? audio_element_get_tag(kept_ctx_el) : "NULL");
+    STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
+        ESP_LOGD(TAG, "%d, el:%08x, %s, in_rb:%08x, out_rb:%08x, linked:%d, el-kept:%d", __LINE__,
+                 (int)el_item->el, audio_element_get_tag(el_item->el),
+                 (int)audio_element_get_input_ringbuf(el_item->el),
+                 (int)audio_element_get_output_ringbuf(el_item->el),
+                 el_item->linked,
+                 el_item->kept_ctx);
+        if (!el_item->linked) {
+            continue;
+        }
+        if ((!kept) && el_item->el != kept_ctx_el) {
+            audio_element_reset_state(el_item->el);
+            STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
+                if (audio_element_get_output_ringbuf(el_item->el) == NULL) {
+                    el_item->linked = false;
+                    el_item->kept_ctx = false;
+                    audio_element_set_input_ringbuf(el_item->el, NULL);
+                    ESP_LOGD(TAG, "output ringbuf is null");
+                    break;
+                } else if (rb_item->rb == audio_element_get_output_ringbuf(el_item->el)) {
+                    el_item->linked = false;
+                    el_item->kept_ctx = false;
+                    rb_item->kept_ctx = false;
+                    rb_item->linked = false;
+                    rb_item->host_el = NULL;
+                    audio_element_set_output_ringbuf(el_item->el, NULL);
+                    audio_element_set_input_ringbuf(el_item->el, NULL);
+                    ESP_LOGD(TAG, "found output ringbuf, %p", el_item->el);
+                    break;
+                }
+                audio_element_set_output_ringbuf(el_item->el, NULL);
+                audio_element_set_input_ringbuf(el_item->el, NULL);
+            }
+        } else {
+            STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
+                if (rb_item->rb == audio_element_get_output_ringbuf(el_item->el)) {
+                    el_item->linked = false;
+                    if ((audio_element_get_state(el_item->el) == AEL_STATE_RUNNING)
+                        || (audio_element_get_state(el_item->el) == AEL_STATE_PAUSED)
+                        /*|| (audio_element_get_state(el_item->el) == AEL_STATE_FINISHED)*/) {
+                        el_item->kept_ctx = true;
+                        rb_item->kept_ctx = true;
+                        ESP_LOGD(TAG, "found kept_ctx_el:%p and ringbuf:%p", el_item->el, rb_item->rb);
+                    } else {
+                        ESP_LOGW(TAG, "found kept_ctx_el and ringbuf, but not set kept, el:%p, rb:%p", el_item->el, rb_item->rb);
+                        audio_element_set_output_ringbuf(el_item->el, NULL);
+                    }
+                    kept = false;
+                    audio_element_set_input_ringbuf(el_item->el, NULL);
+                    break;
+                } else {
+                    el_item->linked = false;
+                }
+            }
+        }
+
+    }
+    // For Debug
+    PIPELINE_DEBUG(pipeline);
+    STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, tmp) {
+        if (rb_item->kept_ctx == false) {
+            rb_item->linked = false;
+            rb_reset(rb_item->rb);
+        }
+        ESP_LOGD(TAG, "%d, reset rb:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->kept_ctx, rb_item->linked );
+    }
+    pipeline->linked = false;
+    audio_pipeline_change_state(pipeline, AEL_STATE_INIT);
+    return ESP_OK;
+}
+
+static esp_err_t audio_pipeline_el_item_link(audio_pipeline_handle_t pipeline,
+        audio_element_item_t *src_el_item,
+        audio_element_handle_t el, bool first, bool last)
+{
+    ringbuf_item_t *cur_rb_item = NULL;
+    ringbuf_item_t *rb_item, *rb_tmp;
+    static ringbuf_handle_t rb;
+    // Found the kept ringbuffer if exist
+    if (src_el_item->kept_ctx) {
+        STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, rb_tmp) {
+            ESP_LOGD(TAG, "%d, rb:%p host_el:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->host_el, rb_item->kept_ctx, rb_item->linked);
+            if (rb_item->host_el == el) {
+                cur_rb_item = rb_item;
+                cur_rb_item->linked = true;
+                cur_rb_item->kept_ctx = false;
+                cur_rb_item->host_el = el;
+                src_el_item->kept_ctx = false;
+                ESP_LOGD(TAG, "found kept rb:%p kept:%d,linked:%d, el:%p, name:%s", rb_item->rb, rb_item->kept_ctx,
+                         rb_item->linked, src_el_item->el, audio_element_get_tag(src_el_item->el));
+                break;
+            }
+        }
+    } else {
+        STAILQ_FOREACH_SAFE(rb_item, &pipeline->rb_list, next, rb_tmp) {
+            ESP_LOGD(TAG, "%d, rb:%p host_el:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->host_el, rb_item->kept_ctx, rb_item->linked);
+            if ((rb_item->linked == false)
+                && (rb_item->kept_ctx == false)) {
+                if (rb_item->host_el == NULL) {
+                    cur_rb_item = rb_item;
+                    cur_rb_item->linked = true;
+                    cur_rb_item->kept_ctx = false;
+                    cur_rb_item->host_el = el;
+                    rb_reset(cur_rb_item->rb);
+                    ESP_LOGD(TAG, "%d, found not used rb:%p kept:%d,linked:%d", __LINE__, rb_item->rb, rb_item->kept_ctx, rb_item->linked);
+                    break;
+                }
+                rb_item->host_el = NULL;
+            }
+        }
+    }
+    if ((last == false) && (cur_rb_item == NULL)) {
+        ringbuf_handle_t tmp_rb = NULL;
+        bool _success = (
+                            (cur_rb_item = audio_calloc(1, sizeof(ringbuf_item_t))) &&
+                            (tmp_rb = rb_create(audio_element_get_output_ringbuf_size(el), 1))
+                        );
+
+        AUDIO_MEM_CHECK(TAG, _success, {
+            audio_free(cur_rb_item);
+            return ESP_ERR_NO_MEM;
+        });
+        cur_rb_item->rb = tmp_rb;
+        cur_rb_item->linked = true;
+        cur_rb_item->kept_ctx = false;
+        cur_rb_item->host_el = el;
+        STAILQ_INSERT_TAIL(&pipeline->rb_list, cur_rb_item, next);
+        ESP_LOGI(TAG, "create new rb,rb:%p",  cur_rb_item->rb);
+    }
+    ESP_LOGD(TAG, "%d, el:%p, tag:%s, cur_rb_item:%p, rb:%p, first:%d, last:%d\r\n", __LINE__, el,
+             audio_element_get_tag(el), cur_rb_item, cur_rb_item != NULL ? cur_rb_item->rb : NULL, first, last);
+    if (last) {
+        audio_element_set_input_ringbuf(el, rb);
+    } else {
+        if (!first) {
+            audio_element_set_input_ringbuf(el, rb);
+        }
+        rb = cur_rb_item->rb;
+        audio_element_set_output_ringbuf(el, rb);
+    }
+    return ESP_OK;
+}
+
+esp_err_t audio_pipeline_relink(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num)
+{
+    if (pipeline == NULL
+        || link_tag == NULL) {
+        ESP_LOGE(TAG, "%s have invalid args, %p, %p", __func__, pipeline, link_tag);
+        return ESP_ERR_INVALID_ARG;
+    }
+    if (pipeline->linked) {
+        ESP_LOGE(TAG, "%s pipeline is already linked, can't relink", __func__);
+        return ESP_FAIL;
+    }
+    esp_err_t ret = ESP_OK;
+    audio_element_item_t *el_item, *el_tmp;
+    bool first = false, last = false;
+    for (int i = 0; i < link_num; i++) {
+        audio_element_item_t *src_el_item = audio_pipeline_get_el_item_by_tag(pipeline, link_tag[i]);
+        if (src_el_item == NULL) {
+            ESP_LOGE(TAG, "There is link_tag invalid: %s", link_tag[i]);
+            ret = ESP_FAIL;
+            goto relink_err;
+        }
+        audio_element_handle_t el = NULL;
+        STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
+            ESP_LOGD(TAG, "%d, linked:%d, kept:%d, el:%s, el:%p, tag:%s, target-el:%p", __LINE__, el_item->linked, el_item->kept_ctx,
+                     audio_element_get_tag(el_item->el), el_item->el, link_tag[i], src_el_item->el);
+            if (src_el_item->el == el_item->el) {
+                el = el_item->el;
+                break;
+            }
+        }
+        if (el == NULL) {
+            ESP_LOGE(TAG, "Can't find element, wanted_el:%s", link_tag[i]);
+            ret = ESP_FAIL;
+            goto relink_err;
+        }
+        src_el_item->linked = true;
+        first = (i == 0);
+        last = (i == link_num - 1);
+        audio_pipeline_el_item_link(pipeline, src_el_item, el, first, last);
+    }
+    pipeline->linked = true;
+    PIPELINE_DEBUG(pipeline);
+relink_err:
+    return ret;
+}
+
+esp_err_t audio_pipeline_relink_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...)
+{
+    AUDIO_NULL_CHECK(TAG, (pipeline || element_1), return ESP_ERR_INVALID_ARG);
+    if (pipeline->linked) {
+        ESP_LOGE(TAG, "%s pipeline is already linked, can't relink", __func__);
+        return ESP_FAIL;
+    }
+    va_list args;
+    audio_element_item_t *el_item, *el_tmp;
+    va_start(args, element_1);
+    bool first = false, last = false;
+    uint16_t idx = 0;
+    while (element_1) {
+        audio_element_item_t *src_el_item = audio_pipeline_get_el_item_by_handle(pipeline, element_1);
+        AUDIO_NULL_CHECK(TAG, src_el_item, return ESP_FAIL);
+
+        audio_element_handle_t el = NULL;
+        STAILQ_FOREACH_SAFE(el_item, &pipeline->el_list, next, el_tmp) {
+            ESP_LOGD(TAG, "%d, linked:%d, kept:%d, el:%s, el:%p, tag:%s, target-el:%p", __LINE__, el_item->linked, el_item->kept_ctx,
+                     audio_element_get_tag(el_item->el), el_item->el, audio_element_get_tag(src_el_item->el), src_el_item->el);
+            if (src_el_item->el == el_item->el) {
+                el = el_item->el;
+                break;
+            }
+        }
+        if (el == NULL) {
+            ESP_LOGE(TAG, "Can't find element, wanted_el:%s", audio_element_get_tag(src_el_item->el));
+            return ESP_FAIL;
+        }
+        src_el_item->linked = true;
+        idx ++;
+        first = (idx == 1);
+        element_1 = va_arg(args, audio_element_handle_t);
+        last = (NULL == element_1) ? true : false;
+        audio_pipeline_el_item_link(pipeline, src_el_item, el, first, last);
+    }
+    pipeline->linked = true;
+    PIPELINE_DEBUG(pipeline);
+    va_end(args);
+    return ESP_OK;
+}
diff --git a/components/audio_pipeline/component.mk b/components/audio_pipeline/component.mk
index a98f634e..d1eb1e57 100644
--- a/components/audio_pipeline/component.mk
+++ b/components/audio_pipeline/component.mk
@@ -1,4 +1,4 @@
-#
-# "main" pseudo-component makefile.
-#
-# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
diff --git a/components/audio_pipeline/i2s_debug.c b/components/audio_pipeline/i2s_debug.c
new file mode 100644
index 00000000..6c90486b
--- /dev/null
+++ b/components/audio_pipeline/i2s_debug.c
@@ -0,0 +1,34 @@
+#include "driver/i2s_std.h"
+#include "esp_log.h"
+#include <string.h>
+#include "i2s_debug.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+
+#define TAG "I2S_FLOW_DEBUG"
+
+void debug_i2s_data_flow() {
+    ESP_LOGI(TAG, "Debugging I2S data flow");
+
+    // Declare and initialize the I2S channel
+    i2s_chan_handle_t tx_handle = NULL;
+    i2s_chan_config_t chan_config = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
+    ESP_ERROR_CHECK(i2s_new_channel(&chan_config, &tx_handle, NULL));
+    ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));
+
+    // Prepare test data
+    uint8_t test_data[] = {0x55, 0xAA, 0x55, 0xAA}; // Sample test pattern
+    size_t bytes_written;
+
+    // Write data to the I2S channel
+    esp_err_t ret = i2s_channel_write(tx_handle, test_data, sizeof(test_data), &bytes_written, pdMS_TO_TICKS(1000));
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "I2S write failed: %s", esp_err_to_name(ret));
+    } else {
+        ESP_LOGI(TAG, "I2S write successful, bytes written: %zu", bytes_written);
+    }
+
+    // Disable and delete the I2S channel
+    ESP_ERROR_CHECK(i2s_channel_disable(tx_handle));
+    ESP_ERROR_CHECK(i2s_del_channel(tx_handle));
+}
\ No newline at end of file
diff --git a/components/audio_pipeline/include/audio_common.h b/components/audio_pipeline/include/audio_common.h
index d7028393..4a30abe8 100644
--- a/components/audio_pipeline/include/audio_common.h
+++ b/components/audio_pipeline/include/audio_common.h
@@ -1,63 +1,63 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_COMMON_H_
-#define _AUDIO_COMMON_H_
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "audio_type_def.h"
-
-#define ELEMENT_SUB_TYPE_OFFSET 16
-
-typedef enum {
-    AUDIO_ELEMENT_TYPE_UNKNOW = 0x01<<ELEMENT_SUB_TYPE_OFFSET,
-    AUDIO_ELEMENT_TYPE_ELEMENT= 0x01<<(ELEMENT_SUB_TYPE_OFFSET+1),
-    AUDIO_ELEMENT_TYPE_PLAYER = 0x01<<(ELEMENT_SUB_TYPE_OFFSET+2),
-    AUDIO_ELEMENT_TYPE_SERVICE = 0x01<<(ELEMENT_SUB_TYPE_OFFSET+3),
-    AUDIO_ELEMENT_TYPE_PERIPH = 0x01<<(ELEMENT_SUB_TYPE_OFFSET+4),
-} audio_element_type_t;
-
-typedef enum {
-    AUDIO_STREAM_NONE = 0,
-    AUDIO_STREAM_READER,
-    AUDIO_STREAM_WRITER
-} audio_stream_type_t;
-
-typedef enum {
-    AUDIO_CODEC_TYPE_NONE = 0,
-    AUDIO_CODEC_TYPE_DECODER,
-    AUDIO_CODEC_TYPE_ENCODER
-} audio_codec_type_t;
-
-#define mem_assert(x)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_COMMON_H_
+#define _AUDIO_COMMON_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "audio_type_def.h"
+
+#define ELEMENT_SUB_TYPE_OFFSET 16
+
+typedef enum {
+    AUDIO_ELEMENT_TYPE_UNKNOW = 0x01<<ELEMENT_SUB_TYPE_OFFSET,
+    AUDIO_ELEMENT_TYPE_ELEMENT= 0x01<<(ELEMENT_SUB_TYPE_OFFSET+1),
+    AUDIO_ELEMENT_TYPE_PLAYER = 0x01<<(ELEMENT_SUB_TYPE_OFFSET+2),
+    AUDIO_ELEMENT_TYPE_SERVICE = 0x01<<(ELEMENT_SUB_TYPE_OFFSET+3),
+    AUDIO_ELEMENT_TYPE_PERIPH = 0x01<<(ELEMENT_SUB_TYPE_OFFSET+4),
+} audio_element_type_t;
+
+typedef enum {
+    AUDIO_STREAM_NONE = 0,
+    AUDIO_STREAM_READER,
+    AUDIO_STREAM_WRITER
+} audio_stream_type_t;
+
+typedef enum {
+    AUDIO_CODEC_TYPE_NONE = 0,
+    AUDIO_CODEC_TYPE_DECODER,
+    AUDIO_CODEC_TYPE_ENCODER
+} audio_codec_type_t;
+
+#define mem_assert(x)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_pipeline/include/audio_element.h b/components/audio_pipeline/include/audio_element.h
old mode 100755
new mode 100644
index 9bf4db22..2f7236f9
--- a/components/audio_pipeline/include/audio_element.h
+++ b/components/audio_pipeline/include/audio_element.h
@@ -1,1082 +1,1082 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_ELEMENT_H_
-#define _AUDIO_ELEMENT_H_
-
-#include "esp_err.h"
-#include "audio_event_iface.h"
-#include "ringbuf.h"
-#include "audio_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum {
-    AEL_IO_OK           = ESP_OK,
-    AEL_IO_FAIL         = ESP_FAIL,
-    AEL_IO_DONE         = -2,
-    AEL_IO_ABORT        = -3,
-    AEL_IO_TIMEOUT      = -4,
-    AEL_PROCESS_FAIL    = -5,
-} audio_element_err_t;
-
-/**
- * @brief Audio element state
- */
-typedef enum {
-    AEL_STATE_NONE          = 0,
-    AEL_STATE_INIT          = 1,
-    AEL_STATE_INITIALIZING  = 2,
-    AEL_STATE_RUNNING       = 3,
-    AEL_STATE_PAUSED        = 4,
-    AEL_STATE_STOPPED       = 5,
-    AEL_STATE_FINISHED      = 6,
-    AEL_STATE_ERROR         = 7
-} audio_element_state_t;
-
-/**
- * Audio element action command, process on dispatcher
- */
-typedef enum {
-    AEL_MSG_CMD_NONE                = 0,
-    // AEL_MSG_CMD_ERROR               = 1,
-    AEL_MSG_CMD_FINISH              = 2,
-    AEL_MSG_CMD_STOP                = 3,
-    AEL_MSG_CMD_PAUSE               = 4,
-    AEL_MSG_CMD_RESUME              = 5,
-    AEL_MSG_CMD_DESTROY             = 6,
-    // AEL_MSG_CMD_CHANGE_STATE        = 7,
-    AEL_MSG_CMD_REPORT_STATUS       = 8,
-    AEL_MSG_CMD_REPORT_MUSIC_INFO   = 9,
-    AEL_MSG_CMD_REPORT_CODEC_FMT    = 10,
-    AEL_MSG_CMD_REPORT_POSITION     = 11,
-} audio_element_msg_cmd_t;
-
-/**
- * Audio element status report
- */
-typedef enum {
-    AEL_STATUS_NONE                     = 0,
-    AEL_STATUS_ERROR_OPEN               = 1,
-    AEL_STATUS_ERROR_INPUT              = 2,
-    AEL_STATUS_ERROR_PROCESS            = 3,
-    AEL_STATUS_ERROR_OUTPUT             = 4,
-    AEL_STATUS_ERROR_CLOSE              = 5,
-    AEL_STATUS_ERROR_TIMEOUT            = 6,
-    AEL_STATUS_ERROR_UNKNOWN            = 7,
-    AEL_STATUS_INPUT_DONE               = 8,
-    AEL_STATUS_INPUT_BUFFERING          = 9,
-    AEL_STATUS_OUTPUT_DONE              = 10,
-    AEL_STATUS_OUTPUT_BUFFERING         = 11,
-    AEL_STATUS_STATE_RUNNING            = 12,
-    AEL_STATUS_STATE_PAUSED             = 13,
-    AEL_STATUS_STATE_STOPPED            = 14,
-    AEL_STATUS_STATE_FINISHED           = 15,
-    AEL_STATUS_MOUNTED                  = 16,
-    AEL_STATUS_UNMOUNTED                = 17,
-} audio_element_status_t;
-
-typedef struct audio_element *audio_element_handle_t;
-
-/**
- * @brief Audio Element user reserved data
- */
-typedef struct {
-    int user_data_0;     /*!< user data 0 */
-    int user_data_1;     /*!< user data 1 */
-    int user_data_2;     /*!< user data 2 */
-    int user_data_3;     /*!< user data 3 */
-    int user_data_4;     /*!< user data 4 */
-} audio_element_reserve_data_t;
-
-/**
- * @brief Audio Element informations
- */
-typedef struct {
-    int sample_rates;                           /*!< Sample rates in Hz */
-    int channels;                               /*!< Number of audio channel, mono is 1, stereo is 2 */
-    int bits;                                   /*!< Bit wide (8, 16, 24, 32 bits) */
-    int bps;                                    /*!< Bit per second */
-    int64_t byte_pos;                           /*!< The current position (in bytes) being processed for an element */
-    int64_t total_bytes;                        /*!< The total bytes for an element */
-    int duration;                               /*!< The duration for an element (optional) */
-    char *uri;                                  /*!< URI (optional) */
-    esp_codec_type_t codec_fmt;                 /*!< Music format (optional) */
-    audio_element_reserve_data_t reserve_data;  /*!< This value is reserved for user use (optional) */
-} audio_element_info_t;
-
-#define AUDIO_ELEMENT_INFO_DEFAULT()    { \
-    .sample_rates = 44100,                \
-    .channels = 2,                        \
-    .bits = 16,                           \
-    .bps = 0,                             \
-    .byte_pos = 0,                        \
-    .total_bytes = 0,                     \
-    .duration = 0,                        \
-    .uri = NULL,                          \
-    .codec_fmt = ESP_CODEC_TYPE_UNKNOW    \
-}
-
-typedef esp_err_t (*el_io_func)(audio_element_handle_t self);
-typedef audio_element_err_t (*process_func)(audio_element_handle_t self, char *el_buffer, int el_buf_len);
-typedef int (*stream_func)(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait,
-        void *context);
-typedef esp_err_t (*event_cb_func)(audio_element_handle_t el, audio_event_iface_msg_t *event, void *ctx);
-typedef esp_err_t (*ctrl_func)(audio_element_handle_t self, void *in_data, int in_size, void *out_data, int *out_size);
-
-/**
- * @brief Audio Element configurations.
- *        Each Element at startup will be a self-running task.
- *        These tasks will execute the callback open -> [loop: read -> process -> write] -> close.
- *        These callback functions are provided by the user corresponding to this configuration.
- *
- */
-typedef struct {
-    el_io_func          open;             /*!< Open callback function */
-    ctrl_func           seek;             /*!< Seek callback function */
-    process_func        process;          /*!< Process callback function */
-    el_io_func          close;            /*!< Close callback function */
-    el_io_func          destroy;          /*!< Destroy callback function */
-    stream_func         read;             /*!< Read callback function */
-    stream_func         write;            /*!< Write callback function */
-    int                 buffer_len;       /*!< Buffer length use for an Element */
-    int                 task_stack;       /*!< Element task stack */
-    int                 task_prio;        /*!< Element task priority (based on freeRTOS priority) */
-    int                 task_core;        /*!< Element task running in core (0 or 1) */
-    int                 out_rb_size;      /*!< Output ringbuffer size */
-    void                *data;            /*!< User context */
-    const char          *tag;             /*!< Element tag */
-    bool                stack_in_ext;     /*!< Try to allocate stack in external memory */
-    int                 multi_in_rb_num;  /*!< The number of multiple input ringbuffer */
-    int                 multi_out_rb_num; /*!< The number of multiple output ringbuffer */
-} audio_element_cfg_t;
-
-#define DEFAULT_ELEMENT_RINGBUF_SIZE    (8*1024)
-#define DEFAULT_ELEMENT_BUFFER_LENGTH   (4*1024)
-#define DEFAULT_ELEMENT_STACK_SIZE      (2*1024)
-#define DEFAULT_ELEMENT_TASK_PRIO       (5)
-#define DEFAULT_ELEMENT_TASK_CORE       (0)
-
-#define DEFAULT_AUDIO_ELEMENT_CONFIG() {                \
-    .buffer_len         = DEFAULT_ELEMENT_BUFFER_LENGTH,\
-    .task_stack         = DEFAULT_ELEMENT_STACK_SIZE,   \
-    .task_prio          = DEFAULT_ELEMENT_TASK_PRIO,    \
-    .task_core          = DEFAULT_ELEMENT_TASK_CORE,    \
-    .multi_in_rb_num    = 0,                            \
-    .multi_out_rb_num   = 0,                            \
-}
-
-/**
- * @brief      Initialize audio element with config.
- *
- * @param      config  The configuration
- *
- * @return
- *     - audio_elemenent handle object
- *     - NULL
- */
-audio_element_handle_t audio_element_init(audio_element_cfg_t *config);
-
-/**
- * @brief      Destroy audio element handle object, stop, clear, deletel all.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_deinit(audio_element_handle_t el);
-
-/**
- * @brief      Set context data to element handle object.
- *             It can be retrieved by calling `audio_element_getdata`.
- *
- * @param[in]  el    The audio element handle
- * @param      data  The data pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_setdata(audio_element_handle_t el, void *data);
-
-/**
- * @brief      Get context data from element handle object.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     data pointer
- */
-void *audio_element_getdata(audio_element_handle_t el);
-
-/**
- * @brief      Set elemenet tag name, or clear if tag = NULL.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  tag   The tag name pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_tag(audio_element_handle_t el, const char *tag);
-
-/**
- * @brief      Get element tag name.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     Element tag name pointer
- */
-char *audio_element_get_tag(audio_element_handle_t el);
-
-/**
- * @brief      Set audio element infomation.
- *
- * @param[in]  el    The audio element handle
- * @param      info  The information pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_setinfo(audio_element_handle_t el, audio_element_info_t *info);
-
-/**
- * @brief      Get audio element infomation.
- *
- * @param[in]  el    The audio element handle
- * @param      info  The information pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_getinfo(audio_element_handle_t el, audio_element_info_t *info);
-
-/**
- * @brief      Set audio element URI.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  uri   The uri pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_uri(audio_element_handle_t el, const char *uri);
-
-/**
- * @brief      Get audio element URI.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     URI pointer
- */
-char *audio_element_get_uri(audio_element_handle_t el);
-
-/**
- * @brief      Start Audio Element.
- *             With this function, audio_element will start as freeRTOS task,
- *             and put the task into 'PAUSED' state.
- *             Note: Element does not actually start when this function returns
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_run(audio_element_handle_t el);
-
-/**
- * @brief      Terminate Audio Element.
- *             With this function, audio_element will exit the task function.
- *             Note: this API only sends request. It does not actually terminate immediately when this function returns.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_terminate(audio_element_handle_t el);
-
-/**
- * @brief      Terminate Audio Element with specific ticks for timeout.
- *             With this function, audio_element will exit the task function.
- *             Note: this API only sends request. It does not actually terminate immediately when this function returns.
- *
- * @param[in]  el               The audio element handle
- * @param[in]  ticks_to_wait    The maximum amount of time to blocking
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_terminate_with_ticks(audio_element_handle_t el, TickType_t ticks_to_wait);
-
-/**
- * @brief      Request stop of the Audio Element.
- *             After receiving the stop request, the element will ignore the actions being performed
- *             (read/write, wait for the ringbuffer ...) and close the task, reset the state variables.
- *             Note: this API only sends requests, Element does not actually stop when this function returns
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_stop(audio_element_handle_t el);
-
-/**
- * @brief      After the `audio_element_stop` function is called, the Element task will perform some abort procedures.
- *             This function will be blocked (Time is DEFAULT_MAX_WAIT_TIME) until Element Task has done and exit.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK, Success
- *     - ESP_FAIL, The state is not AEL_STATE_RUNNING
- *     - ESP_ERR_TIMEOUT, Timeout
- */
-esp_err_t audio_element_wait_for_stop(audio_element_handle_t el);
-
-/**
- * @brief      After the `audio_element_stop` function is called, the Element task will perform some abort procedures.
- *             The maximum amount of time should block waiting for Element task has stopped.
- *
- * @param[in]  el               The audio element handle
- * @param[in]  ticks_to_wait    The maximum amount of time to wait for stop
- *
- * @return
- *     - ESP_OK, Success
- *     - ESP_FAIL, The state is not AEL_STATE_RUNNING
- *     - ESP_ERR_TIMEOUT, Timeout
- */
-esp_err_t audio_element_wait_for_stop_ms(audio_element_handle_t el, TickType_t ticks_to_wait);
-
-/**
- * @brief      Request audio Element enter 'PAUSE' state.
- *             In this state, the task will wait for any event
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_pause(audio_element_handle_t el);
-
-/**
- * @brief      Request audio Element enter 'RUNNING' state.
- *             In this state, the task listens to events and invokes the callback functions.
- *             At the same time it will wait until the size/total_size of the output ringbuffer is greater than or equal to `wait_for_rb_threshold`.
- *             If the timeout period has been exceeded and ringbuffer output has not yet reached `wait_for_rb_threshold` then the function will return.
- *
- * @param[in]  el                     The audio element handle
- * @param[in]  wait_for_rb_threshold  The wait for rb threshold (0 .. 1)
- * @param[in]  timeout                The timeout
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_resume(audio_element_handle_t el, float wait_for_rb_threshold, TickType_t timeout);
-
-/**
- * @brief      This function will add a `listener` to listen to all events from audio element `el`.
- *             Any event from el->external_event will be send to the `listener`.
- *
- * @param      el           The audio element handle
- * @param      listener     The event will be listen to
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_msg_set_listener(audio_element_handle_t el, audio_event_iface_handle_t listener);
-
-/**
- * @brief      This function will add a `callback` to be called from audio element `el`.
- *             Any event to caller will cause to call callback function.
- *
- * @param      el           The audio element handle
- * @param      cb_func      The callback function
- * @param      ctx          Caller context
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_event_callback(audio_element_handle_t el, event_cb_func cb_func, void *ctx);
-
-/**
- * @brief      Remove listener out of el.
- *             No new events will be sent to the listener.
- *
- * @param[in]  el        The audio element handle
- * @param      listener  The listener
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_msg_remove_listener(audio_element_handle_t el, audio_event_iface_handle_t listener);
-
-/**
- * @brief      Set Element input ringbuffer
- *
- * @param[in]  el    The audio element handle
- * @param[in]  rb    The ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb);
-
-/**
- * @brief      Get Element input ringbuffer.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     ringbuf_handle_t
- */
-ringbuf_handle_t audio_element_get_input_ringbuf(audio_element_handle_t el);
-
-/**
- * @brief      Set Element output ringbuffer.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  rb    The ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb);
-
-/**
- * @brief      Get Element output ringbuffer.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     ringbuf_handle_t
- */
-ringbuf_handle_t audio_element_get_output_ringbuf(audio_element_handle_t el);
-
-/**
- * @brief      Get current Element state.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     audio_element_state_t
- */
-audio_element_state_t audio_element_get_state(audio_element_handle_t el);
-
-/**
- * @brief      If the element is requesting data from the input ringbuffer, this function forces it to abort.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_abort_input_ringbuf(audio_element_handle_t el);
-
-/**
- * @brief      If the element is waiting to write data to the ringbuffer output, this function forces it to abort.
- *
- * @param[in]  el   The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_abort_output_ringbuf(audio_element_handle_t el);
-
-/**
- * @brief      This function will wait until the sizeof the output ringbuffer is greater than or equal to `size_expect`.
- *             If the timeout period has been exceeded and ringbuffer output has not yet reached `size_expect`
- *             then the function will return `ESP_FAIL`
- *
- * @param[in]  el           The audio element handle
- * @param[in]  size_expect  The size expect
- * @param[in]  timeout      The timeout
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_wait_for_buffer(audio_element_handle_t el, int size_expect, TickType_t timeout);
-
-/**
- * @brief      Element will sendout event (status) to event by this function.
- *
- * @param[in]  el      The audio element handle
- * @param[in]  status  The status
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_report_status(audio_element_handle_t el, audio_element_status_t status);
-
-/**
- * @brief      Element will sendout event (information) to event by this function.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_report_info(audio_element_handle_t el);
-
-/**
- * @brief      Element will sendout event (codec format) to event by this function.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_report_codec_fmt(audio_element_handle_t el);
-
-/**
- * @brief      Element will sendout event with a duplicate information by this function.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- *     - ESP_ERR_NO_MEM
- */
-esp_err_t audio_element_report_pos(audio_element_handle_t el);
-
-/**
- * @brief      Set input read timeout (default is `portMAX_DELAY`).
- *
- * @param[in]  el       The audio element handle
- * @param[in]  timeout  The timeout
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_input_timeout(audio_element_handle_t el, TickType_t timeout);
-
-/**
- * @brief      Set output read timeout (default is `portMAX_DELAY`).
- *
- * @param[in]  el       The audio element handle
- * @param[in]  timeout  The timeout
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_output_timeout(audio_element_handle_t el, TickType_t timeout);
-
-/**
- * @brief      Reset inputbuffer.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_reset_input_ringbuf(audio_element_handle_t el);
-
-/**
- * @brief      Set element finish state
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_finish_state(audio_element_handle_t el);
-
-/**
- * @brief      Change element running state with specific command.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  cmd   Specific command from audio_element_msg_cmd_t
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- *     - ESP_ERR_INVALID_ARG Element handle is null
- */
-esp_err_t audio_element_change_cmd(audio_element_handle_t el, audio_element_msg_cmd_t cmd);
-
-/**
- * @brief      Reset outputbuffer.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_reset_output_ringbuf(audio_element_handle_t el);
-
-/**
- * @brief      Call this function to provide Element input data.
- *             Depending on setup using ringbuffer or function callback, Element invokes read ringbuffer, or calls read callback funtion.
- *
- * @param[in]  el            The audio element handle
- * @param      buffer        The buffer pointer
- * @param[in]  wanted_size   The wanted size
- *
- * @return
- *        - > 0 number of bytes produced
- *        - <=0 audio_element_err_t
- */
-audio_element_err_t audio_element_input(audio_element_handle_t el, char *buffer, int wanted_size);
-
-/**
- * @brief      Call this function to sendout Element output data.
- *             Depending on setup using ringbuffer or function callback, Element will invoke write to ringbuffer, or call write callback funtion.
- *
- * @param[in]  el          The audio element handle
- * @param      buffer      The buffer pointer
- * @param[in]  write_size  The write size
- *
- * @return
- *        - > 0 number of bytes written
- *        - <=0 audio_element_err_t
- */
-audio_element_err_t audio_element_output(audio_element_handle_t el, char *buffer, int write_size);
-
-/**
- * @brief     This API allows the application to set a read callback for the first audio_element in the pipeline for
- *            allowing the pipeline to interface with other systems. The callback is invoked every time the audio
- *            element requires data to be processed.
- *
- * @param[in]  el        The audio element handle
- * @param[in]  fn        Callback read function. The callback function should return number of bytes read or -1
- *                       in case of error in reading. Note that the callback function may decide to block and
- *                       that may block the entire pipeline.
- * @param[in]  context   An optional context which will be passed to callback function on every invocation
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_read_cb(audio_element_handle_t el, stream_func fn, void *context);
-
-/**
- * @brief     This API allows the application to set a write callback for the last audio_element in the pipeline for
- *            allowing the pipeline to interface with other systems.
- *            The callback is invoked every time the audio element has a processed data that needs to be passed forward.
- *
- * @param[in]  el        The audio element
- * @param[in]  fn        Callback write function
- *                       The callback function should return number of bytes written or -1 in case of error in writing.
- *                       Note that the callback function may decide to block and that may block the entire pipeline.
- * @param[in]  context   An optional context which will be passed to callback function on every invocation
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_write_cb(audio_element_handle_t el, stream_func fn, void *context);
-
-/**
- * @brief     Get callback write function that register to the element
- *
- * @param[in]  el        The audio element
- *
- * @return
- *     - Callback write function pointer
- *     - NULL     Failed
- */
-stream_func audio_element_get_write_cb(audio_element_handle_t el);
-
-/**
- * @brief     Get callback read function that register to the element
- *
- * @param[in]  el        The audio element
- *
- * @return
- *     - Callback read function pointer
- *     - NULL     Failed
- */
-stream_func audio_element_get_read_cb(audio_element_handle_t el);
-
-/**
- * @brief      Get External queue of Emitter.
- *             We can read any event that has been send out of Element from this `QueueHandle_t`.
- *
- * @param[in]  el    The audio element handle
- *
- * @return     QueueHandle_t
- */
-QueueHandle_t audio_element_get_event_queue(audio_element_handle_t el);
-
-/**
- * @brief      Set inputbuffer and outputbuffer have finished.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_ringbuf_done(audio_element_handle_t el);
-
-/**
- * @brief      Enforce 'AEL_STATE_INIT' state.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_reset_state(audio_element_handle_t el);
-
-/**
- * @brief      Get Element output ringbuffer size.
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - =0: Parameter NULL
- *     - >0: Size of ringbuffer
- */
-int audio_element_get_output_ringbuf_size(audio_element_handle_t el);
-
-/**
- * @brief      Set Element output ringbuffer size.
- *
- * @param[in]  el       The audio element handle
- * @param[in]  rb_size  Size of the ringbuffer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_output_ringbuf_size(audio_element_handle_t el, int rb_size);
-
-/**
- * @brief      Call this function to read data from multi input ringbuffer by given index.
- *
- * @param      el            The audio element handle
- * @param      buffer        The buffer pointer
- * @param      wanted_size   The wanted size
- * @param      index         The index of multi input ringbuffer, start from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
- * @param      ticks_to_wait Timeout of ringbuffer
- *
- * @return
- *     - ESP_ERR_INVALID_SIZE
- *     - Others are same as the `rb_read`
- */
-int audio_element_multi_input(audio_element_handle_t el, char *buffer, int wanted_size, int index, TickType_t ticks_to_wait);
-
-/**
- * @brief      Call this function write data by multi output ringbuffer.
- *
- * @param[in]  el            The audio element handle
- * @param      buffer        The buffer pointer
- * @param[in]  wanted_size   The wanted size
- * @param      ticks_to_wait Timeout of ringbuffer
- *
- * @return
- *     - The return value is same as the `rb_write`
- */
-int audio_element_multi_output(audio_element_handle_t el, char *buffer, int wanted_size, TickType_t ticks_to_wait);
-
-/**
- * @brief      Set multi input ringbuffer Element.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  rb    The ringbuffer handle
- * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_multi_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index);
-
-/**
- * @brief      Set multi output ringbuffer Element.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  rb    The ringbuffer handle
- * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
- *
- * @return
- *     - ESP_OK
- *     - ESP_ERR_INVALID_ARG
- */
-esp_err_t audio_element_set_multi_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index);
-
-/**
- * @brief      Get handle of multi input ringbuffer Element by index.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
- *
- * @return
- *     - NULL   Error
- *     - Others ringbuf_handle_t
- */
-ringbuf_handle_t audio_element_get_multi_input_ringbuf(audio_element_handle_t el, int index);
-
-/**
- * @brief      Get handle of multi output ringbuffer Element by index.
- *
- * @param[in]  el    The audio element handle
- * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
- *
- * @return
- *     - NULL   Error
- *     - Others ringbuf_handle_t
- */
-ringbuf_handle_t audio_element_get_multi_output_ringbuf(audio_element_handle_t el, int index);
-
-/**
- * @brief      Provides a way to call element's `open`
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_process_init(audio_element_handle_t el);
-
-/**
- * @brief      Provides a way to call element's `close`
- *
- * @param[in]  el    The audio element handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_process_deinit(audio_element_handle_t el);
-
-/**
- * @brief      Call element's `seek`
- *
- * @param[in]  el           The audio element handle
- * @param[in]  in_data      A pointer to in data
- * @param[in]  in_size      The size of the `in_data`
- * @param[out] out_data     A pointer to the out data
- * @param[out] out_size     The size of the `out_data`
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- *     - ESP_ERR_NOT_SUPPORTED
- */
-esp_err_t audio_element_seek(audio_element_handle_t el, void *in_data, int in_size, void *out_data, int *out_size);
-
-/**
- * @brief      Get Element stopping flag
- *
- * @param[in]  el    The audio element handle
- *
- * @return     element's stopping flag
- */
-bool audio_element_is_stopping(audio_element_handle_t el);
-
-/**
- * @brief      Update the byte position of element information
- *
- * @param[in]  el    The audio element handle
- * @param[in]  pos   The byte_pos accumulated by this value
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_update_byte_pos(audio_element_handle_t el, int pos);
-
-/**
- * @brief      Set the byte position of element information
- *
- * @param[in]  el    The audio element handle
- * @param[in]  pos   This value is assigned to byte_pos
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_byte_pos(audio_element_handle_t el, int pos);
-
-/**
- * @brief      Update the total bytes of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  total_bytes      The total_bytes accumulated by this value
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_update_total_bytes(audio_element_handle_t el, int total_bytes);
-
-/**
- * @brief      Set the total bytes of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  total_bytes      This value is assigned to total_bytes
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_total_bytes(audio_element_handle_t el, int total_bytes);
-
-/**
- * @brief      Set the bps of element information
- *
- * @param[in]  el           The audio element handle
- * @param[in]  bit_rate     This value is assigned to bps
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_bps(audio_element_handle_t el, int bit_rate);
-
-/**
- * @brief      Set the codec format of element information
- *
- * @param[in]  el       The audio element handle
- * @param[in]  format   This value is assigned to codec_fmt
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_codec_fmt(audio_element_handle_t el, int format);
-
-/**
- * @brief      Set the sample_rate, channels, bits of element information
- *
- * @param[in]  el             The audio element handle
- * @param[in]  sample_rates   Sample_rates of music information
- * @param[in]  channels       Channels of music information
- * @param[in]  bits           Bits of music information
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_music_info(audio_element_handle_t el, int sample_rates, int channels, int bits);
-
-/**
- * @brief      Set the duration of element information
- *
- * @param[in]  el           The audio element handle
- * @param[in]  duration     This value is assigned to duration
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_duration(audio_element_handle_t el, int duration);
-
-/**
- * @brief      Set the user_data_0 of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  user_data0       This value is assigned to user_data_0
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_reserve_user0(audio_element_handle_t el, int user_data0);
-
-/**
- * @brief      Set the user_data_1 of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  user_data1       This value is assigned to user_data_1
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_reserve_user1(audio_element_handle_t el, int user_data1);
-
-/**
- * @brief      Set the user_data_2 of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  user_data2       This value is assigned to user_data_2
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_reserve_user2(audio_element_handle_t el, int user_data2);
-
-/**
- * @brief      Set the user_data_3 of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  user_data3       This value is assigned to user_data_3
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_reserve_user3(audio_element_handle_t el, int user_data3);
-
-/**
- * @brief      Set the user_data_4 of element information
- *
- * @param[in]  el               The audio element handle
- * @param[in]  user_data4       This value is assigned to user_data_4
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_element_set_reserve_user4(audio_element_handle_t el, int user_data4);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_ELEMENT_H_
+#define _AUDIO_ELEMENT_H_
+
+#include "esp_err.h"
+#include "audio_event_iface.h"
+#include "ringbuf.h"
+#include "audio_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    AEL_IO_OK           = ESP_OK,
+    AEL_IO_FAIL         = ESP_FAIL,
+    AEL_IO_DONE         = -2,
+    AEL_IO_ABORT        = -3,
+    AEL_IO_TIMEOUT      = -4,
+    AEL_PROCESS_FAIL    = -5,
+} audio_element_err_t;
+
+/**
+ * @brief Audio element state
+ */
+typedef enum {
+    AEL_STATE_NONE          = 0,
+    AEL_STATE_INIT          = 1,
+    AEL_STATE_INITIALIZING  = 2,
+    AEL_STATE_RUNNING       = 3,
+    AEL_STATE_PAUSED        = 4,
+    AEL_STATE_STOPPED       = 5,
+    AEL_STATE_FINISHED      = 6,
+    AEL_STATE_ERROR         = 7
+} audio_element_state_t;
+
+/**
+ * Audio element action command, process on dispatcher
+ */
+typedef enum {
+    AEL_MSG_CMD_NONE                = 0,
+    // AEL_MSG_CMD_ERROR               = 1,
+    AEL_MSG_CMD_FINISH              = 2,
+    AEL_MSG_CMD_STOP                = 3,
+    AEL_MSG_CMD_PAUSE               = 4,
+    AEL_MSG_CMD_RESUME              = 5,
+    AEL_MSG_CMD_DESTROY             = 6,
+    // AEL_MSG_CMD_CHANGE_STATE        = 7,
+    AEL_MSG_CMD_REPORT_STATUS       = 8,
+    AEL_MSG_CMD_REPORT_MUSIC_INFO   = 9,
+    AEL_MSG_CMD_REPORT_CODEC_FMT    = 10,
+    AEL_MSG_CMD_REPORT_POSITION     = 11,
+} audio_element_msg_cmd_t;
+
+/**
+ * Audio element status report
+ */
+typedef enum {
+    AEL_STATUS_NONE                     = 0,
+    AEL_STATUS_ERROR_OPEN               = 1,
+    AEL_STATUS_ERROR_INPUT              = 2,
+    AEL_STATUS_ERROR_PROCESS            = 3,
+    AEL_STATUS_ERROR_OUTPUT             = 4,
+    AEL_STATUS_ERROR_CLOSE              = 5,
+    AEL_STATUS_ERROR_TIMEOUT            = 6,
+    AEL_STATUS_ERROR_UNKNOWN            = 7,
+    AEL_STATUS_INPUT_DONE               = 8,
+    AEL_STATUS_INPUT_BUFFERING          = 9,
+    AEL_STATUS_OUTPUT_DONE              = 10,
+    AEL_STATUS_OUTPUT_BUFFERING         = 11,
+    AEL_STATUS_STATE_RUNNING            = 12,
+    AEL_STATUS_STATE_PAUSED             = 13,
+    AEL_STATUS_STATE_STOPPED            = 14,
+    AEL_STATUS_STATE_FINISHED           = 15,
+    AEL_STATUS_MOUNTED                  = 16,
+    AEL_STATUS_UNMOUNTED                = 17,
+} audio_element_status_t;
+
+typedef struct audio_element *audio_element_handle_t;
+
+/**
+ * @brief Audio Element user reserved data
+ */
+typedef struct {
+    int user_data_0;     /*!< user data 0 */
+    int user_data_1;     /*!< user data 1 */
+    int user_data_2;     /*!< user data 2 */
+    int user_data_3;     /*!< user data 3 */
+    int user_data_4;     /*!< user data 4 */
+} audio_element_reserve_data_t;
+
+/**
+ * @brief Audio Element informations
+ */
+typedef struct {
+    int sample_rates;                           /*!< Sample rates in Hz */
+    int channels;                               /*!< Number of audio channel, mono is 1, stereo is 2 */
+    int bits;                                   /*!< Bit wide (8, 16, 24, 32 bits) */
+    int bps;                                    /*!< Bit per second */
+    int64_t byte_pos;                           /*!< The current position (in bytes) being processed for an element */
+    int64_t total_bytes;                        /*!< The total bytes for an element */
+    int duration;                               /*!< The duration for an element (optional) */
+    char *uri;                                  /*!< URI (optional) */
+    esp_codec_type_t codec_fmt;                 /*!< Music format (optional) */
+    audio_element_reserve_data_t reserve_data;  /*!< This value is reserved for user use (optional) */
+} audio_element_info_t;
+
+#define AUDIO_ELEMENT_INFO_DEFAULT()    { \
+    .sample_rates = 44100,                \
+    .channels = 2,                        \
+    .bits = 16,                           \
+    .bps = 0,                             \
+    .byte_pos = 0,                        \
+    .total_bytes = 0,                     \
+    .duration = 0,                        \
+    .uri = NULL,                          \
+    .codec_fmt = ESP_CODEC_TYPE_UNKNOW    \
+}
+
+typedef esp_err_t (*el_io_func)(audio_element_handle_t self);
+typedef audio_element_err_t (*process_func)(audio_element_handle_t self, char *el_buffer, int el_buf_len);
+typedef int (*stream_func)(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait,
+        void *context);
+typedef esp_err_t (*event_cb_func)(audio_element_handle_t el, audio_event_iface_msg_t *event, void *ctx);
+typedef esp_err_t (*ctrl_func)(audio_element_handle_t self, void *in_data, int in_size, void *out_data, int *out_size);
+
+/**
+ * @brief Audio Element configurations.
+ *        Each Element at startup will be a self-running task.
+ *        These tasks will execute the callback open -> [loop: read -> process -> write] -> close.
+ *        These callback functions are provided by the user corresponding to this configuration.
+ *
+ */
+typedef struct {
+    el_io_func          open;             /*!< Open callback function */
+    ctrl_func           seek;             /*!< Seek callback function */
+    process_func        process;          /*!< Process callback function */
+    el_io_func          close;            /*!< Close callback function */
+    el_io_func          destroy;          /*!< Destroy callback function */
+    stream_func         read;             /*!< Read callback function */
+    stream_func         write;            /*!< Write callback function */
+    int                 buffer_len;       /*!< Buffer length use for an Element */
+    int                 task_stack;       /*!< Element task stack */
+    int                 task_prio;        /*!< Element task priority (based on freeRTOS priority) */
+    int                 task_core;        /*!< Element task running in core (0 or 1) */
+    int                 out_rb_size;      /*!< Output ringbuffer size */
+    void                *data;            /*!< User context */
+    const char          *tag;             /*!< Element tag */
+    bool                stack_in_ext;     /*!< Try to allocate stack in external memory */
+    int                 multi_in_rb_num;  /*!< The number of multiple input ringbuffer */
+    int                 multi_out_rb_num; /*!< The number of multiple output ringbuffer */
+} audio_element_cfg_t;
+
+#define DEFAULT_ELEMENT_RINGBUF_SIZE    (8*1024)
+#define DEFAULT_ELEMENT_BUFFER_LENGTH   (4*1024)
+#define DEFAULT_ELEMENT_STACK_SIZE      (2*1024)
+#define DEFAULT_ELEMENT_TASK_PRIO       (5)
+#define DEFAULT_ELEMENT_TASK_CORE       (0)
+
+#define DEFAULT_AUDIO_ELEMENT_CONFIG() {                \
+    .buffer_len         = DEFAULT_ELEMENT_BUFFER_LENGTH,\
+    .task_stack         = DEFAULT_ELEMENT_STACK_SIZE,   \
+    .task_prio          = DEFAULT_ELEMENT_TASK_PRIO,    \
+    .task_core          = DEFAULT_ELEMENT_TASK_CORE,    \
+    .multi_in_rb_num    = 0,                            \
+    .multi_out_rb_num   = 0,                            \
+}
+
+/**
+ * @brief      Initialize audio element with config.
+ *
+ * @param      config  The configuration
+ *
+ * @return
+ *     - audio_elemenent handle object
+ *     - NULL
+ */
+audio_element_handle_t audio_element_init(audio_element_cfg_t *config);
+
+/**
+ * @brief      Destroy audio element handle object, stop, clear, deletel all.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_deinit(audio_element_handle_t el);
+
+/**
+ * @brief      Set context data to element handle object.
+ *             It can be retrieved by calling `audio_element_getdata`.
+ *
+ * @param[in]  el    The audio element handle
+ * @param      data  The data pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_setdata(audio_element_handle_t el, void *data);
+
+/**
+ * @brief      Get context data from element handle object.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     data pointer
+ */
+void *audio_element_getdata(audio_element_handle_t el);
+
+/**
+ * @brief      Set elemenet tag name, or clear if tag = NULL.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  tag   The tag name pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_tag(audio_element_handle_t el, const char *tag);
+
+/**
+ * @brief      Get element tag name.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     Element tag name pointer
+ */
+char *audio_element_get_tag(audio_element_handle_t el);
+
+/**
+ * @brief      Set audio element infomation.
+ *
+ * @param[in]  el    The audio element handle
+ * @param      info  The information pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_setinfo(audio_element_handle_t el, audio_element_info_t *info);
+
+/**
+ * @brief      Get audio element infomation.
+ *
+ * @param[in]  el    The audio element handle
+ * @param      info  The information pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_getinfo(audio_element_handle_t el, audio_element_info_t *info);
+
+/**
+ * @brief      Set audio element URI.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  uri   The uri pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_uri(audio_element_handle_t el, const char *uri);
+
+/**
+ * @brief      Get audio element URI.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     URI pointer
+ */
+char *audio_element_get_uri(audio_element_handle_t el);
+
+/**
+ * @brief      Start Audio Element.
+ *             With this function, audio_element will start as freeRTOS task,
+ *             and put the task into 'PAUSED' state.
+ *             Note: Element does not actually start when this function returns
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_run(audio_element_handle_t el);
+
+/**
+ * @brief      Terminate Audio Element.
+ *             With this function, audio_element will exit the task function.
+ *             Note: this API only sends request. It does not actually terminate immediately when this function returns.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_terminate(audio_element_handle_t el);
+
+/**
+ * @brief      Terminate Audio Element with specific ticks for timeout.
+ *             With this function, audio_element will exit the task function.
+ *             Note: this API only sends request. It does not actually terminate immediately when this function returns.
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  ticks_to_wait    The maximum amount of time to blocking
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_terminate_with_ticks(audio_element_handle_t el, TickType_t ticks_to_wait);
+
+/**
+ * @brief      Request stop of the Audio Element.
+ *             After receiving the stop request, the element will ignore the actions being performed
+ *             (read/write, wait for the ringbuffer ...) and close the task, reset the state variables.
+ *             Note: this API only sends requests, Element does not actually stop when this function returns
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_stop(audio_element_handle_t el);
+
+/**
+ * @brief      After the `audio_element_stop` function is called, the Element task will perform some abort procedures.
+ *             This function will be blocked (Time is DEFAULT_MAX_WAIT_TIME) until Element Task has done and exit.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK, Success
+ *     - ESP_FAIL, The state is not AEL_STATE_RUNNING
+ *     - ESP_ERR_TIMEOUT, Timeout
+ */
+esp_err_t audio_element_wait_for_stop(audio_element_handle_t el);
+
+/**
+ * @brief      After the `audio_element_stop` function is called, the Element task will perform some abort procedures.
+ *             The maximum amount of time should block waiting for Element task has stopped.
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  ticks_to_wait    The maximum amount of time to wait for stop
+ *
+ * @return
+ *     - ESP_OK, Success
+ *     - ESP_FAIL, The state is not AEL_STATE_RUNNING
+ *     - ESP_ERR_TIMEOUT, Timeout
+ */
+esp_err_t audio_element_wait_for_stop_ms(audio_element_handle_t el, TickType_t ticks_to_wait);
+
+/**
+ * @brief      Request audio Element enter 'PAUSE' state.
+ *             In this state, the task will wait for any event
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_pause(audio_element_handle_t el);
+
+/**
+ * @brief      Request audio Element enter 'RUNNING' state.
+ *             In this state, the task listens to events and invokes the callback functions.
+ *             At the same time it will wait until the size/total_size of the output ringbuffer is greater than or equal to `wait_for_rb_threshold`.
+ *             If the timeout period has been exceeded and ringbuffer output has not yet reached `wait_for_rb_threshold` then the function will return.
+ *
+ * @param[in]  el                     The audio element handle
+ * @param[in]  wait_for_rb_threshold  The wait for rb threshold (0 .. 1)
+ * @param[in]  timeout                The timeout
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_resume(audio_element_handle_t el, float wait_for_rb_threshold, TickType_t timeout);
+
+/**
+ * @brief      This function will add a `listener` to listen to all events from audio element `el`.
+ *             Any event from el->external_event will be send to the `listener`.
+ *
+ * @param      el           The audio element handle
+ * @param      listener     The event will be listen to
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_msg_set_listener(audio_element_handle_t el, audio_event_iface_handle_t listener);
+
+/**
+ * @brief      This function will add a `callback` to be called from audio element `el`.
+ *             Any event to caller will cause to call callback function.
+ *
+ * @param      el           The audio element handle
+ * @param      cb_func      The callback function
+ * @param      ctx          Caller context
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_event_callback(audio_element_handle_t el, event_cb_func cb_func, void *ctx);
+
+/**
+ * @brief      Remove listener out of el.
+ *             No new events will be sent to the listener.
+ *
+ * @param[in]  el        The audio element handle
+ * @param      listener  The listener
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_msg_remove_listener(audio_element_handle_t el, audio_event_iface_handle_t listener);
+
+/**
+ * @brief      Set Element input ringbuffer
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  rb    The ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb);
+
+/**
+ * @brief      Get Element input ringbuffer.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     ringbuf_handle_t
+ */
+ringbuf_handle_t audio_element_get_input_ringbuf(audio_element_handle_t el);
+
+/**
+ * @brief      Set Element output ringbuffer.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  rb    The ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb);
+
+/**
+ * @brief      Get Element output ringbuffer.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     ringbuf_handle_t
+ */
+ringbuf_handle_t audio_element_get_output_ringbuf(audio_element_handle_t el);
+
+/**
+ * @brief      Get current Element state.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     audio_element_state_t
+ */
+audio_element_state_t audio_element_get_state(audio_element_handle_t el);
+
+/**
+ * @brief      If the element is requesting data from the input ringbuffer, this function forces it to abort.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_abort_input_ringbuf(audio_element_handle_t el);
+
+/**
+ * @brief      If the element is waiting to write data to the ringbuffer output, this function forces it to abort.
+ *
+ * @param[in]  el   The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_abort_output_ringbuf(audio_element_handle_t el);
+
+/**
+ * @brief      This function will wait until the sizeof the output ringbuffer is greater than or equal to `size_expect`.
+ *             If the timeout period has been exceeded and ringbuffer output has not yet reached `size_expect`
+ *             then the function will return `ESP_FAIL`
+ *
+ * @param[in]  el           The audio element handle
+ * @param[in]  size_expect  The size expect
+ * @param[in]  timeout      The timeout
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_wait_for_buffer(audio_element_handle_t el, int size_expect, TickType_t timeout);
+
+/**
+ * @brief      Element will sendout event (status) to event by this function.
+ *
+ * @param[in]  el      The audio element handle
+ * @param[in]  status  The status
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_report_status(audio_element_handle_t el, audio_element_status_t status);
+
+/**
+ * @brief      Element will sendout event (information) to event by this function.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_report_info(audio_element_handle_t el);
+
+/**
+ * @brief      Element will sendout event (codec format) to event by this function.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_report_codec_fmt(audio_element_handle_t el);
+
+/**
+ * @brief      Element will sendout event with a duplicate information by this function.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ *     - ESP_ERR_NO_MEM
+ */
+esp_err_t audio_element_report_pos(audio_element_handle_t el);
+
+/**
+ * @brief      Set input read timeout (default is `portMAX_DELAY`).
+ *
+ * @param[in]  el       The audio element handle
+ * @param[in]  timeout  The timeout
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_input_timeout(audio_element_handle_t el, TickType_t timeout);
+
+/**
+ * @brief      Set output read timeout (default is `portMAX_DELAY`).
+ *
+ * @param[in]  el       The audio element handle
+ * @param[in]  timeout  The timeout
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_output_timeout(audio_element_handle_t el, TickType_t timeout);
+
+/**
+ * @brief      Reset inputbuffer.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_reset_input_ringbuf(audio_element_handle_t el);
+
+/**
+ * @brief      Set element finish state
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_finish_state(audio_element_handle_t el);
+
+/**
+ * @brief      Change element running state with specific command.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  cmd   Specific command from audio_element_msg_cmd_t
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ *     - ESP_ERR_INVALID_ARG Element handle is null
+ */
+esp_err_t audio_element_change_cmd(audio_element_handle_t el, audio_element_msg_cmd_t cmd);
+
+/**
+ * @brief      Reset outputbuffer.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_reset_output_ringbuf(audio_element_handle_t el);
+
+/**
+ * @brief      Call this function to provide Element input data.
+ *             Depending on setup using ringbuffer or function callback, Element invokes read ringbuffer, or calls read callback funtion.
+ *
+ * @param[in]  el            The audio element handle
+ * @param      buffer        The buffer pointer
+ * @param[in]  wanted_size   The wanted size
+ *
+ * @return
+ *        - > 0 number of bytes produced
+ *        - <=0 audio_element_err_t
+ */
+audio_element_err_t audio_element_input(audio_element_handle_t el, char *buffer, int wanted_size);
+
+/**
+ * @brief      Call this function to sendout Element output data.
+ *             Depending on setup using ringbuffer or function callback, Element will invoke write to ringbuffer, or call write callback funtion.
+ *
+ * @param[in]  el          The audio element handle
+ * @param      buffer      The buffer pointer
+ * @param[in]  write_size  The write size
+ *
+ * @return
+ *        - > 0 number of bytes written
+ *        - <=0 audio_element_err_t
+ */
+audio_element_err_t audio_element_output(audio_element_handle_t el, char *buffer, int write_size);
+
+/**
+ * @brief     This API allows the application to set a read callback for the first audio_element in the pipeline for
+ *            allowing the pipeline to interface with other systems. The callback is invoked every time the audio
+ *            element requires data to be processed.
+ *
+ * @param[in]  el        The audio element handle
+ * @param[in]  fn        Callback read function. The callback function should return number of bytes read or -1
+ *                       in case of error in reading. Note that the callback function may decide to block and
+ *                       that may block the entire pipeline.
+ * @param[in]  context   An optional context which will be passed to callback function on every invocation
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_read_cb(audio_element_handle_t el, stream_func fn, void *context);
+
+/**
+ * @brief     This API allows the application to set a write callback for the last audio_element in the pipeline for
+ *            allowing the pipeline to interface with other systems.
+ *            The callback is invoked every time the audio element has a processed data that needs to be passed forward.
+ *
+ * @param[in]  el        The audio element
+ * @param[in]  fn        Callback write function
+ *                       The callback function should return number of bytes written or -1 in case of error in writing.
+ *                       Note that the callback function may decide to block and that may block the entire pipeline.
+ * @param[in]  context   An optional context which will be passed to callback function on every invocation
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_write_cb(audio_element_handle_t el, stream_func fn, void *context);
+
+/**
+ * @brief     Get callback write function that register to the element
+ *
+ * @param[in]  el        The audio element
+ *
+ * @return
+ *     - Callback write function pointer
+ *     - NULL     Failed
+ */
+stream_func audio_element_get_write_cb(audio_element_handle_t el);
+
+/**
+ * @brief     Get callback read function that register to the element
+ *
+ * @param[in]  el        The audio element
+ *
+ * @return
+ *     - Callback read function pointer
+ *     - NULL     Failed
+ */
+stream_func audio_element_get_read_cb(audio_element_handle_t el);
+
+/**
+ * @brief      Get External queue of Emitter.
+ *             We can read any event that has been send out of Element from this `QueueHandle_t`.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     QueueHandle_t
+ */
+QueueHandle_t audio_element_get_event_queue(audio_element_handle_t el);
+
+/**
+ * @brief      Set inputbuffer and outputbuffer have finished.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_ringbuf_done(audio_element_handle_t el);
+
+/**
+ * @brief      Enforce 'AEL_STATE_INIT' state.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_reset_state(audio_element_handle_t el);
+
+/**
+ * @brief      Get Element output ringbuffer size.
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - =0: Parameter NULL
+ *     - >0: Size of ringbuffer
+ */
+int audio_element_get_output_ringbuf_size(audio_element_handle_t el);
+
+/**
+ * @brief      Set Element output ringbuffer size.
+ *
+ * @param[in]  el       The audio element handle
+ * @param[in]  rb_size  Size of the ringbuffer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_output_ringbuf_size(audio_element_handle_t el, int rb_size);
+
+/**
+ * @brief      Call this function to read data from multi input ringbuffer by given index.
+ *
+ * @param      el            The audio element handle
+ * @param      buffer        The buffer pointer
+ * @param      wanted_size   The wanted size
+ * @param      index         The index of multi input ringbuffer, start from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
+ * @param      ticks_to_wait Timeout of ringbuffer
+ *
+ * @return
+ *     - ESP_ERR_INVALID_SIZE
+ *     - Others are same as the `rb_read`
+ */
+int audio_element_multi_input(audio_element_handle_t el, char *buffer, int wanted_size, int index, TickType_t ticks_to_wait);
+
+/**
+ * @brief      Call this function write data by multi output ringbuffer.
+ *
+ * @param[in]  el            The audio element handle
+ * @param      buffer        The buffer pointer
+ * @param[in]  wanted_size   The wanted size
+ * @param      ticks_to_wait Timeout of ringbuffer
+ *
+ * @return
+ *     - The return value is same as the `rb_write`
+ */
+int audio_element_multi_output(audio_element_handle_t el, char *buffer, int wanted_size, TickType_t ticks_to_wait);
+
+/**
+ * @brief      Set multi input ringbuffer Element.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  rb    The ringbuffer handle
+ * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_multi_input_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index);
+
+/**
+ * @brief      Set multi output ringbuffer Element.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  rb    The ringbuffer handle
+ * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_ERR_INVALID_ARG
+ */
+esp_err_t audio_element_set_multi_output_ringbuf(audio_element_handle_t el, ringbuf_handle_t rb, int index);
+
+/**
+ * @brief      Get handle of multi input ringbuffer Element by index.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
+ *
+ * @return
+ *     - NULL   Error
+ *     - Others ringbuf_handle_t
+ */
+ringbuf_handle_t audio_element_get_multi_input_ringbuf(audio_element_handle_t el, int index);
+
+/**
+ * @brief      Get handle of multi output ringbuffer Element by index.
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  index Index of multi ringbuffer, starts from `0`, should be less than `NUMBER_OF_MULTI_RINGBUF`
+ *
+ * @return
+ *     - NULL   Error
+ *     - Others ringbuf_handle_t
+ */
+ringbuf_handle_t audio_element_get_multi_output_ringbuf(audio_element_handle_t el, int index);
+
+/**
+ * @brief      Provides a way to call element's `open`
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_process_init(audio_element_handle_t el);
+
+/**
+ * @brief      Provides a way to call element's `close`
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_process_deinit(audio_element_handle_t el);
+
+/**
+ * @brief      Call element's `seek`
+ *
+ * @param[in]  el           The audio element handle
+ * @param[in]  in_data      A pointer to in data
+ * @param[in]  in_size      The size of the `in_data`
+ * @param[out] out_data     A pointer to the out data
+ * @param[out] out_size     The size of the `out_data`
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ *     - ESP_ERR_NOT_SUPPORTED
+ */
+esp_err_t audio_element_seek(audio_element_handle_t el, void *in_data, int in_size, void *out_data, int *out_size);
+
+/**
+ * @brief      Get Element stopping flag
+ *
+ * @param[in]  el    The audio element handle
+ *
+ * @return     element's stopping flag
+ */
+bool audio_element_is_stopping(audio_element_handle_t el);
+
+/**
+ * @brief      Update the byte position of element information
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  pos   The byte_pos accumulated by this value
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_update_byte_pos(audio_element_handle_t el, int pos);
+
+/**
+ * @brief      Set the byte position of element information
+ *
+ * @param[in]  el    The audio element handle
+ * @param[in]  pos   This value is assigned to byte_pos
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_byte_pos(audio_element_handle_t el, int pos);
+
+/**
+ * @brief      Update the total bytes of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  total_bytes      The total_bytes accumulated by this value
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_update_total_bytes(audio_element_handle_t el, int total_bytes);
+
+/**
+ * @brief      Set the total bytes of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  total_bytes      This value is assigned to total_bytes
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_total_bytes(audio_element_handle_t el, int total_bytes);
+
+/**
+ * @brief      Set the bps of element information
+ *
+ * @param[in]  el           The audio element handle
+ * @param[in]  bit_rate     This value is assigned to bps
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_bps(audio_element_handle_t el, int bit_rate);
+
+/**
+ * @brief      Set the codec format of element information
+ *
+ * @param[in]  el       The audio element handle
+ * @param[in]  format   This value is assigned to codec_fmt
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_codec_fmt(audio_element_handle_t el, int format);
+
+/**
+ * @brief      Set the sample_rate, channels, bits of element information
+ *
+ * @param[in]  el             The audio element handle
+ * @param[in]  sample_rates   Sample_rates of music information
+ * @param[in]  channels       Channels of music information
+ * @param[in]  bits           Bits of music information
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_music_info(audio_element_handle_t el, int sample_rates, int channels, int bits);
+
+/**
+ * @brief      Set the duration of element information
+ *
+ * @param[in]  el           The audio element handle
+ * @param[in]  duration     This value is assigned to duration
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_duration(audio_element_handle_t el, int duration);
+
+/**
+ * @brief      Set the user_data_0 of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  user_data0       This value is assigned to user_data_0
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_reserve_user0(audio_element_handle_t el, int user_data0);
+
+/**
+ * @brief      Set the user_data_1 of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  user_data1       This value is assigned to user_data_1
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_reserve_user1(audio_element_handle_t el, int user_data1);
+
+/**
+ * @brief      Set the user_data_2 of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  user_data2       This value is assigned to user_data_2
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_reserve_user2(audio_element_handle_t el, int user_data2);
+
+/**
+ * @brief      Set the user_data_3 of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  user_data3       This value is assigned to user_data_3
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_reserve_user3(audio_element_handle_t el, int user_data3);
+
+/**
+ * @brief      Set the user_data_4 of element information
+ *
+ * @param[in]  el               The audio element handle
+ * @param[in]  user_data4       This value is assigned to user_data_4
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_element_set_reserve_user4(audio_element_handle_t el, int user_data4);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_pipeline/include/audio_event_iface.h b/components/audio_pipeline/include/audio_event_iface.h
index 7aab3c02..23bd2e55 100644
--- a/components/audio_pipeline/include/audio_event_iface.h
+++ b/components/audio_pipeline/include/audio_event_iface.h
@@ -1,252 +1,252 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_EVENT_IFACE_H_
-#define _AUDIO_EVENT_IFACE_H_
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/queue.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * Event message
- */
-typedef struct {
-    int cmd;                /*!< Command id */
-    void *data;             /*!< Data pointer */
-    int data_len;           /*!< Data length */
-    void *source;           /*!< Source event */
-    int source_type;        /*!< Source type (To know where it came from) */
-    bool need_free_data;    /*!< Need to free data pointer after the event has been processed */
-} audio_event_iface_msg_t;
-
-typedef esp_err_t (*on_event_iface_func)(audio_event_iface_msg_t *, void *);
-
-typedef struct audio_event_iface *audio_event_iface_handle_t;
-
-/**
- * Event interface configurations
- */
-typedef struct {
-    int                 internal_queue_size;        /*!< It's optional, Queue size for event `internal_queue` */
-    int                 external_queue_size;        /*!< It's optional, Queue size for event `external_queue` */
-    int                 queue_set_size;             /*!< It's optional, QueueSet size for event `queue_set`*/
-    on_event_iface_func on_cmd;                     /*!< Function callback for listener when any event arrived */
-    void                *context;                   /*!< Context will pass to callback function */
-    TickType_t          wait_time;                  /*!< Timeout to check for event queue */
-    int                 type;                       /*!< it will pass to audio_event_iface_msg_t source_type (To know where it came from) */
-} audio_event_iface_cfg_t;
-
-
-#define DEFAULT_AUDIO_EVENT_IFACE_SIZE  (5)
-
-#define AUDIO_EVENT_IFACE_DEFAULT_CFG() {                   \
-    .internal_queue_size = DEFAULT_AUDIO_EVENT_IFACE_SIZE,  \
-    .external_queue_size = DEFAULT_AUDIO_EVENT_IFACE_SIZE,  \
-    .queue_set_size = DEFAULT_AUDIO_EVENT_IFACE_SIZE,       \
-    .on_cmd = NULL,                                         \
-    .context = NULL,                                        \
-    .wait_time = portMAX_DELAY,                             \
-    .type = 0,                                              \
-}
-
-/**
- * @brief      Initialize audio event
- *
- * @param      config  The configurations
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-audio_event_iface_handle_t audio_event_iface_init(audio_event_iface_cfg_t *config);
-
-/**
- * @brief      Cleanup event, it doesn't free evt pointer
- *
- * @param      evt   The event
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_destroy(audio_event_iface_handle_t evt);
-
-/**
- * @brief      Add audio event `evt` to the listener, then we can listen `evt` event from `listen`
- *
- * @param      listener     The event can listen another event
- * @param      evt          The event to be added to
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_set_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener);
-
-/**
- * @brief      Remove audio event `evt` from the listener
- *
- * @param      listener     The event listener
- * @param      evt          The event to be removed from
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_remove_listener(audio_event_iface_handle_t listener, audio_event_iface_handle_t evt);
-
-/**
- * @brief      Set current queue wait time for the event
- *
- * @param      evt        The event
- * @param[in]  wait_time  The wait time
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_set_cmd_waiting_timeout(audio_event_iface_handle_t evt, TickType_t wait_time);
-
-/**
- * @brief      Waiting internal queue message
- *
- * @param      evt        The event
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_waiting_cmd_msg(audio_event_iface_handle_t evt);
-
-/**
- * @brief      Trigger an event for internal queue with a message
- *
- * @param      evt   The event
- * @param      msg   The message
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_cmd(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg);
-
-/**
- * @brief      It's same with `audio_event_iface_cmd`, but can send a message from ISR
- *
- * @param[in]  evt   The event
- * @param      msg   The message
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_cmd_from_isr(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg);
-
-/**
- * @brief      Trigger and event out with a message
- *
- * @param      evt   The event
- * @param      msg   The message
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_sendout(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg);
-
-/**
- * @brief      Discard all ongoing event message
- *
- * @param      evt   The event
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_discard(audio_event_iface_handle_t evt);
-
-/**
- * @brief      Listening and invoke callback function if there are any event are comming
- *
- * @param      evt          The event
- * @param      msg          The message
- * @param      wait_time    The wait time
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_listen(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time);
-
-/**
- * @brief      Get External queue handle of Emmitter
- *
- * @param[in]  evt   The external queue
- *
- * @return     External QueueHandle_t
- */
-QueueHandle_t audio_event_iface_get_queue_handle(audio_event_iface_handle_t evt);
-
-/**
- * @brief      Read the event from all the registered event emitters in the queue set of the interface
- *
- * @param[in]  evt  The event interface
- * @param[out] msg  The pointer to structure in which event is to be received
- * @param[in]  wait_time Timeout for receiving event
- *
- * @return
- *     - ESP_OK     On successful receiving of event
- *     - ESP_FAIL   In case of a timeout or invalid parameter passed
- */
-esp_err_t audio_event_iface_read(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time);
-
-/**
- * @brief      Get Internal queue handle of Emmitter
- *
- * @param[in]  evt   The Internal queue
- *
- * @return     Internal QueueHandle_t
- */
-QueueHandle_t audio_event_iface_get_msg_queue_handle(audio_event_iface_handle_t evt);
-
-/**
- * @brief      Add audio internal event `evt` to the listener, then we can listen `evt` event from `listen`
- *
- * @param      listener     The event can listen another event
- * @param      evt          The event to be added to
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_event_iface_set_msg_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener);
-#ifdef __cplusplus
-}
-#endif
-
-#endif //end of file _AUDIO_EVENT_IFACE_H_
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_EVENT_IFACE_H_
+#define _AUDIO_EVENT_IFACE_H_
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/queue.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Event message
+ */
+typedef struct {
+    int cmd;                /*!< Command id */
+    void *data;             /*!< Data pointer */
+    int data_len;           /*!< Data length */
+    void *source;           /*!< Source event */
+    int source_type;        /*!< Source type (To know where it came from) */
+    bool need_free_data;    /*!< Need to free data pointer after the event has been processed */
+} audio_event_iface_msg_t;
+
+typedef esp_err_t (*on_event_iface_func)(audio_event_iface_msg_t *, void *);
+
+typedef struct audio_event_iface *audio_event_iface_handle_t;
+
+/**
+ * Event interface configurations
+ */
+typedef struct {
+    int                 internal_queue_size;        /*!< It's optional, Queue size for event `internal_queue` */
+    int                 external_queue_size;        /*!< It's optional, Queue size for event `external_queue` */
+    int                 queue_set_size;             /*!< It's optional, QueueSet size for event `queue_set`*/
+    on_event_iface_func on_cmd;                     /*!< Function callback for listener when any event arrived */
+    void                *context;                   /*!< Context will pass to callback function */
+    TickType_t          wait_time;                  /*!< Timeout to check for event queue */
+    int                 type;                       /*!< it will pass to audio_event_iface_msg_t source_type (To know where it came from) */
+} audio_event_iface_cfg_t;
+
+
+#define DEFAULT_AUDIO_EVENT_IFACE_SIZE  (5)
+
+#define AUDIO_EVENT_IFACE_DEFAULT_CFG() {                   \
+    .internal_queue_size = DEFAULT_AUDIO_EVENT_IFACE_SIZE,  \
+    .external_queue_size = DEFAULT_AUDIO_EVENT_IFACE_SIZE,  \
+    .queue_set_size = DEFAULT_AUDIO_EVENT_IFACE_SIZE,       \
+    .on_cmd = NULL,                                         \
+    .context = NULL,                                        \
+    .wait_time = portMAX_DELAY,                             \
+    .type = 0,                                              \
+}
+
+/**
+ * @brief      Initialize audio event
+ *
+ * @param      config  The configurations
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+audio_event_iface_handle_t audio_event_iface_init(audio_event_iface_cfg_t *config);
+
+/**
+ * @brief      Cleanup event, it doesn't free evt pointer
+ *
+ * @param      evt   The event
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_destroy(audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Add audio event `evt` to the listener, then we can listen `evt` event from `listen`
+ *
+ * @param      listener     The event can listen another event
+ * @param      evt          The event to be added to
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_set_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener);
+
+/**
+ * @brief      Remove audio event `evt` from the listener
+ *
+ * @param      listener     The event listener
+ * @param      evt          The event to be removed from
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_remove_listener(audio_event_iface_handle_t listener, audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Set current queue wait time for the event
+ *
+ * @param      evt        The event
+ * @param[in]  wait_time  The wait time
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_set_cmd_waiting_timeout(audio_event_iface_handle_t evt, TickType_t wait_time);
+
+/**
+ * @brief      Waiting internal queue message
+ *
+ * @param      evt        The event
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_waiting_cmd_msg(audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Trigger an event for internal queue with a message
+ *
+ * @param      evt   The event
+ * @param      msg   The message
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_cmd(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg);
+
+/**
+ * @brief      It's same with `audio_event_iface_cmd`, but can send a message from ISR
+ *
+ * @param[in]  evt   The event
+ * @param      msg   The message
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_cmd_from_isr(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg);
+
+/**
+ * @brief      Trigger and event out with a message
+ *
+ * @param      evt   The event
+ * @param      msg   The message
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_sendout(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg);
+
+/**
+ * @brief      Discard all ongoing event message
+ *
+ * @param      evt   The event
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_discard(audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Listening and invoke callback function if there are any event are comming
+ *
+ * @param      evt          The event
+ * @param      msg          The message
+ * @param      wait_time    The wait time
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_listen(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time);
+
+/**
+ * @brief      Get External queue handle of Emmitter
+ *
+ * @param[in]  evt   The external queue
+ *
+ * @return     External QueueHandle_t
+ */
+QueueHandle_t audio_event_iface_get_queue_handle(audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Read the event from all the registered event emitters in the queue set of the interface
+ *
+ * @param[in]  evt  The event interface
+ * @param[out] msg  The pointer to structure in which event is to be received
+ * @param[in]  wait_time Timeout for receiving event
+ *
+ * @return
+ *     - ESP_OK     On successful receiving of event
+ *     - ESP_FAIL   In case of a timeout or invalid parameter passed
+ */
+esp_err_t audio_event_iface_read(audio_event_iface_handle_t evt, audio_event_iface_msg_t *msg, TickType_t wait_time);
+
+/**
+ * @brief      Get Internal queue handle of Emmitter
+ *
+ * @param[in]  evt   The Internal queue
+ *
+ * @return     Internal QueueHandle_t
+ */
+QueueHandle_t audio_event_iface_get_msg_queue_handle(audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Add audio internal event `evt` to the listener, then we can listen `evt` event from `listen`
+ *
+ * @param      listener     The event can listen another event
+ * @param      evt          The event to be added to
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_event_iface_set_msg_listener(audio_event_iface_handle_t evt, audio_event_iface_handle_t listener);
+#ifdef __cplusplus
+}
+#endif
+
+#endif //end of file _AUDIO_EVENT_IFACE_H_
diff --git a/components/audio_pipeline/include/audio_pipeline.h b/components/audio_pipeline/include/audio_pipeline.h
index 1957c9a0..cc9b925a 100644
--- a/components/audio_pipeline/include/audio_pipeline.h
+++ b/components/audio_pipeline/include/audio_pipeline.h
@@ -1,488 +1,488 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AUDIO_PIPELINE_H_
-#define _AUDIO_PIPELINE_H_
-
-#include "audio_element.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct audio_pipeline *audio_pipeline_handle_t;
-
-/**
- * @brief Audio Pipeline configurations
- */
-typedef struct audio_pipeline_cfg {
-    int rb_size;        /*!< Audio Pipeline ringbuffer size */
-} audio_pipeline_cfg_t;
-
-#define DEFAULT_PIPELINE_RINGBUF_SIZE    (8*1024)
-
-#define DEFAULT_AUDIO_PIPELINE_CONFIG() {\
-    .rb_size            = DEFAULT_PIPELINE_RINGBUF_SIZE,\
-}
-
-/**
- * @brief      Initialize audio_pipeline_handle_t object
- *             audio_pipeline is responsible for controlling the audio data stream and connecting the audio elements with the ringbuffer
- *             It will connect and start the audio element in order, responsible for retrieving the data from the previous element
- *             and passing it to the element after it. Also get events from each element, process events or pass it to a higher layer
- *
- * @param      config  The configuration - audio_pipeline_cfg_t
- *
- * @return
- *     - audio_pipeline_handle_t on success
- *     - NULL when any errors
- */
-audio_pipeline_handle_t audio_pipeline_init(audio_pipeline_cfg_t *config);
-
-/**
- * @brief      This function removes all of the element's links in audio_pipeline,
- *             cancels the registration of all events, invokes the destroy functions of the registered elements,
- *             and frees the memory allocated by the init function.
- *             Briefly, frees all memory
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return     ESP_OK
- */
-esp_err_t audio_pipeline_deinit(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Registering an element for audio_pipeline, each element can be registered multiple times,
- *             but `name` (as String) must be unique in audio_pipeline,
- *             which is used to identify the element for link creation mentioned in the `audio_pipeline_link`
- *
- * @note       Because of stop pipeline or pause pipeline depend much on register order.
- *             Please register element strictly in the following order: input element first, process middle, output element last.
- *
- * @param[in]  pipeline The Audio Pipeline Handle
- * @param[in]  el       The Audio Element Handle
- * @param[in]  name     The name identifier of the audio_element in this audio_pipeline
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_register(audio_pipeline_handle_t pipeline, audio_element_handle_t el, const char *name);
-
-/**
- * @brief      Unregister the audio_element in audio_pipeline, remove it from the list
- *
- * @param[in]  pipeline The Audio Pipeline Handle
- * @param[in]  el       The Audio Element Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_unregister(audio_pipeline_handle_t pipeline, audio_element_handle_t el);
-
-/**
- * @brief    Start Audio Pipeline.
- *
- *           With this function audio_pipeline will create tasks for all elements,
- *           that have been linked using the linking functions.
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_run(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief    Stop Audio Pipeline.
- *
- *           With this function audio_pipeline will destroy tasks of all elements,
- *           that have been linked using the linking functions.
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_terminate(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief    Stop Audio Pipeline with specific ticks for timeout
- *
- *           With this function audio_pipeline will destroy tasks of all elements,
- *           that have been linked using the linking functions.
- *
- * @param[in]  pipeline         The Audio Pipeline Handle
- * @param[in]  ticks_to_wait    The maximum amount of time to block wait for element destroy
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_pipeline_terminate_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait);
-
-/**
- * @brief      This function will set all the elements to the `RUNNING` state and process the audio data as an inherent feature of audio_pipeline.
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_resume(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      This function will set all the elements to the `PAUSED` state. Everything remains the same except the data processing is stopped
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_pause(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief     Stop all of the linked elements. Used with `audio_pipeline_wait_for_stop` to keep in sync.
- *            The link state of the elements in the pipeline is kept, events are still registered.
- *            The stopped audio_pipeline restart by `audio_pipeline_resume`.
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_stop(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      The `audio_pipeline_stop` function sends requests to the elements and exits.
- *             But they need time to get rid of time-blocking tasks.
- *             This function will wait `portMAX_DELAY` until all the Elements in the pipeline actually stop
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_wait_for_stop(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      The `audio_pipeline_stop` function sends requests to the elements and exits.
- *             But they need time to get rid of time-blocking tasks.
- *             This function will wait `ticks_to_wait` until all the Elements in the pipeline actually stop
- *
- * @param[in]  pipeline         The Audio Pipeline Handle
- * @param[in]  ticks_to_wait    The maximum amount of time to block wait for stop
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_wait_for_stop_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait);
-
-/**
- * @brief      The audio_element added to audio_pipeline will be unconnected before it is called by this function.
- *             Based on element's `name` already registered by `audio_pipeline_register`, the path of the data will be linked in the order of the link_tag.
- *             Element at index 0 is first, and index `link_num -1` is final.
- *             As well as audio_pipeline will subscribe all element's events
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- * @param      link_tag   Array of element `name` was registered by `audio_pipeline_register`
- * @param[in]  link_num   Total number of elements of the `link_tag` array
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_link(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num);
-
-/**
- * @brief      Removes the connection of the elements, as well as unsubscribe events
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_unlink(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Find un-kept element from registered pipeline by tag
- *
- * @param[in]  pipeline     The Audio Pipeline Handle
- * @param[in]  tag          A char pointer
- *
- * @return
- *     - NULL when any errors
- *     - Others on success
- */
-audio_element_handle_t audio_pipeline_get_el_by_tag(audio_pipeline_handle_t pipeline, const char *tag);
-
-/**
- * @brief      Based on beginning element to find un-kept element from registered pipeline by tag
- *
- * @param[in]  pipeline     The Audio Pipeline Handle
- * @param[in]  start_el     Specific beginning element
- * @param[in]  tag          A char pointer
- *
- * @return
- *     - NULL when any errors
- *     - Others on success
- */
-audio_element_handle_t audio_pipeline_get_el_once(audio_pipeline_handle_t pipeline, const audio_element_handle_t start_el, const char *tag);
-
-/**
- * @brief      Remove event listener from this audio_pipeline
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_remove_listener(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Set event listner for this audio_pipeline, any event from this pipeline can be listen to by `evt`
- *
- * @param[in]  pipeline     The Audio Pipeline Handle
- * @param[in]  evt          The Event Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_set_listener(audio_pipeline_handle_t pipeline, audio_event_iface_handle_t evt);
-
-/**
- * @brief      Get the event iface using by this pipeline
- *
- * @param[in]  pipeline  The pipeline
- *
- * @return     The  Event Handle
- */
-audio_event_iface_handle_t audio_pipeline_get_event_iface(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Insert the specific audio_element to audio_pipeline, previous element connect to the next element by ring buffer.
- *
- * @param[in]  pipeline     The audio pipeline handle
- * @param[in]  first        Previous element is first input element, need to set `true`
- * @param[in]  prev         Previous element
- * @param[in]  conect_rb    Connect ring buffer
- * @param[in]  next         Next element
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_pipeline_link_insert(audio_pipeline_handle_t pipeline, bool first, audio_element_handle_t prev,
-                                     ringbuf_handle_t conect_rb, audio_element_handle_t next);
-
-/**
- * @brief      Register a NULL-terminated list of elements to audio_pipeline.
- *
- * @param[in]  pipeline     The audio pipeline handle
- * @param[in]  element_1    The element to add to the audio_pipeline.
- * @param[in]  ...          Additional elements to add to the audio_pipeline.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_pipeline_register_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
-
-/**
- * @brief      Unregister a NULL-terminated list of elements to audio_pipeline.
- *
- * @param[in]  pipeline     The audio pipeline handle
- * @param[in]  element_1    The element to add to the audio_pipeline.
- * @param[in]  ...          Additional elements to add to the audio_pipeline.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_pipeline_unregister_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
-
-/**
- * @brief      Adds a NULL-terminated list of elements to audio_pipeline.
- *
- * @param[in]  pipeline     The audio pipeline handle
- * @param[in]  element_1    The element to add to the audio_pipeline.
- * @param[in]  ...          Additional elements to add to the audio_pipeline.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_pipeline_link_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
-
-/**
- * @brief      Subscribe a NULL-terminated list of element's events to audio_pipeline.
- *
- * @param[in]  pipeline     The audio pipeline handle
- * @param[in]  element_1    The element event to subscribe to the audio_pipeline.
- * @param[in]  ...          Additional elements event to subscribe to the audio_pipeline.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t audio_pipeline_listen_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
-
-/**
- * @brief      Update the destination element state and check the all of linked elements state are same.
- *
- * @param[in]  pipeline     The audio pipeline handle
- * @param[in]  dest_el      Destination element
- * @param[in]  status       The new status
- *
- * @return
- *     - ESP_OK             All linked elements state are same.
- *     - ESP_FAIL           All linked elements state are not same.
- */
-esp_err_t audio_pipeline_check_items_state(audio_pipeline_handle_t pipeline, audio_element_handle_t dest_el, audio_element_status_t status);
-
-/**
- * @brief      Reset pipeline element items state to `AEL_STATUS_NONE`
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_reset_items_state(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Reset pipeline element ringbuffer
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_reset_ringbuffer(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Reset Pipeline linked elements state
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_reset_elements(audio_pipeline_handle_t pipeline);
-
-/**
- * @brief      Reset the specific element kept state
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- * @param[in]  el         The Audio element Handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t audio_pipeline_reset_kept_state(audio_pipeline_handle_t pipeline, audio_element_handle_t el);
-
-/**
- * @brief      Break up all the linked elements of specific `pipeline`.
- *             The include and before `kept_ctx_el` working (AEL_STATE_RUNNING or AEL_STATE_PAUSED) elements
- *             and connected ringbuffer will be reserved.
- *
- * @note       There is no element reserved when `kept_ctx_el` is NULL.
- *             This function will unsubscribe all element's events.
- *
- * @param[in]  pipeline         The audio pipeline handle
- * @param[in]  kept_ctx_el      Destination keep elements
- *
- * @return
- *     - ESP_OK                 All linked elements state are same.
- *     - ESP_ERR_INVALID_ARG    Invalid parameters.
- */
-esp_err_t audio_pipeline_breakup_elements(audio_pipeline_handle_t pipeline, audio_element_handle_t kept_ctx_el);
-
-/**
- * @brief      Basing on element's `name` already registered by `audio_pipeline_register`,
- *             relink the pipeline following the order of `names` in the `link_tag.
- *
- * @note       If the ringbuffer is not enough to connect the new pipeline will create new ringbuffer.
- *
- * @param[in]  pipeline   The Audio Pipeline Handle
- * @param      link_tag   Array of elements `name` that was registered by `audio_pipeline_register`
- * @param[in]  link_num   Total number of elements of the `link_tag` array
- *
- * @return
- *     - ESP_OK                 All linked elements state are same.
- *     - ESP_FAIL               Error.
- *     - ESP_ERR_INVALID_ARG    Invalid parameters.
- */
-esp_err_t audio_pipeline_relink(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num);
-
-/**
- * @brief      Adds a NULL-terminated list of elements to audio_pipeline.
- *
- * @note       If the ringbuffer is not enough to connect the new pipeline will create new ringbuffer.
- *
- * @param[in]  pipeline     The Audio Pipeline Handle
- * @param[in]  element_1    The element to add to the audio_pipeline.
- * @param[in]  ...          Additional elements to add to the audio_pipeline.
- *
- * @return
- *     - ESP_OK                 All linked elements state are same.
- *     - ESP_FAIL               Error.
- *     - ESP_ERR_INVALID_ARG    Invalid parameters.
- */
-esp_err_t audio_pipeline_relink_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
-
-/**
- * @brief      Set the pipeline state.
- *
- * @param[in]  pipeline     The Audio Pipeline Handle
- * @param[in]  new_state    The new state will be set
- *
- * @return
- *     - ESP_OK                 All linked elements state are same.
- *     - ESP_FAIL               Error.
- */
-esp_err_t audio_pipeline_change_state(audio_pipeline_handle_t pipeline, audio_element_state_t new_state);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _AUDIO_PIPELINE_H_ */
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AUDIO_PIPELINE_H_
+#define _AUDIO_PIPELINE_H_
+
+#include "audio_element.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct audio_pipeline *audio_pipeline_handle_t;
+
+/**
+ * @brief Audio Pipeline configurations
+ */
+typedef struct audio_pipeline_cfg {
+    int rb_size;        /*!< Audio Pipeline ringbuffer size */
+} audio_pipeline_cfg_t;
+
+#define DEFAULT_PIPELINE_RINGBUF_SIZE    (8*1024)
+
+#define DEFAULT_AUDIO_PIPELINE_CONFIG() {\
+    .rb_size            = DEFAULT_PIPELINE_RINGBUF_SIZE,\
+}
+
+/**
+ * @brief      Initialize audio_pipeline_handle_t object
+ *             audio_pipeline is responsible for controlling the audio data stream and connecting the audio elements with the ringbuffer
+ *             It will connect and start the audio element in order, responsible for retrieving the data from the previous element
+ *             and passing it to the element after it. Also get events from each element, process events or pass it to a higher layer
+ *
+ * @param      config  The configuration - audio_pipeline_cfg_t
+ *
+ * @return
+ *     - audio_pipeline_handle_t on success
+ *     - NULL when any errors
+ */
+audio_pipeline_handle_t audio_pipeline_init(audio_pipeline_cfg_t *config);
+
+/**
+ * @brief      This function removes all of the element's links in audio_pipeline,
+ *             cancels the registration of all events, invokes the destroy functions of the registered elements,
+ *             and frees the memory allocated by the init function.
+ *             Briefly, frees all memory
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return     ESP_OK
+ */
+esp_err_t audio_pipeline_deinit(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Registering an element for audio_pipeline, each element can be registered multiple times,
+ *             but `name` (as String) must be unique in audio_pipeline,
+ *             which is used to identify the element for link creation mentioned in the `audio_pipeline_link`
+ *
+ * @note       Because of stop pipeline or pause pipeline depend much on register order.
+ *             Please register element strictly in the following order: input element first, process middle, output element last.
+ *
+ * @param[in]  pipeline The Audio Pipeline Handle
+ * @param[in]  el       The Audio Element Handle
+ * @param[in]  name     The name identifier of the audio_element in this audio_pipeline
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_register(audio_pipeline_handle_t pipeline, audio_element_handle_t el, const char *name);
+
+/**
+ * @brief      Unregister the audio_element in audio_pipeline, remove it from the list
+ *
+ * @param[in]  pipeline The Audio Pipeline Handle
+ * @param[in]  el       The Audio Element Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_unregister(audio_pipeline_handle_t pipeline, audio_element_handle_t el);
+
+/**
+ * @brief    Start Audio Pipeline.
+ *
+ *           With this function audio_pipeline will create tasks for all elements,
+ *           that have been linked using the linking functions.
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_run(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief    Stop Audio Pipeline.
+ *
+ *           With this function audio_pipeline will destroy tasks of all elements,
+ *           that have been linked using the linking functions.
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_terminate(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief    Stop Audio Pipeline with specific ticks for timeout
+ *
+ *           With this function audio_pipeline will destroy tasks of all elements,
+ *           that have been linked using the linking functions.
+ *
+ * @param[in]  pipeline         The Audio Pipeline Handle
+ * @param[in]  ticks_to_wait    The maximum amount of time to block wait for element destroy
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_pipeline_terminate_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait);
+
+/**
+ * @brief      This function will set all the elements to the `RUNNING` state and process the audio data as an inherent feature of audio_pipeline.
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_resume(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      This function will set all the elements to the `PAUSED` state. Everything remains the same except the data processing is stopped
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_pause(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief     Stop all of the linked elements. Used with `audio_pipeline_wait_for_stop` to keep in sync.
+ *            The link state of the elements in the pipeline is kept, events are still registered.
+ *            The stopped audio_pipeline restart by `audio_pipeline_resume`.
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_stop(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      The `audio_pipeline_stop` function sends requests to the elements and exits.
+ *             But they need time to get rid of time-blocking tasks.
+ *             This function will wait `portMAX_DELAY` until all the Elements in the pipeline actually stop
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_wait_for_stop(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      The `audio_pipeline_stop` function sends requests to the elements and exits.
+ *             But they need time to get rid of time-blocking tasks.
+ *             This function will wait `ticks_to_wait` until all the Elements in the pipeline actually stop
+ *
+ * @param[in]  pipeline         The Audio Pipeline Handle
+ * @param[in]  ticks_to_wait    The maximum amount of time to block wait for stop
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_wait_for_stop_with_ticks(audio_pipeline_handle_t pipeline, TickType_t ticks_to_wait);
+
+/**
+ * @brief      The audio_element added to audio_pipeline will be unconnected before it is called by this function.
+ *             Based on element's `name` already registered by `audio_pipeline_register`, the path of the data will be linked in the order of the link_tag.
+ *             Element at index 0 is first, and index `link_num -1` is final.
+ *             As well as audio_pipeline will subscribe all element's events
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ * @param      link_tag   Array of element `name` was registered by `audio_pipeline_register`
+ * @param[in]  link_num   Total number of elements of the `link_tag` array
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_link(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num);
+
+/**
+ * @brief      Removes the connection of the elements, as well as unsubscribe events
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_unlink(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Find un-kept element from registered pipeline by tag
+ *
+ * @param[in]  pipeline     The Audio Pipeline Handle
+ * @param[in]  tag          A char pointer
+ *
+ * @return
+ *     - NULL when any errors
+ *     - Others on success
+ */
+audio_element_handle_t audio_pipeline_get_el_by_tag(audio_pipeline_handle_t pipeline, const char *tag);
+
+/**
+ * @brief      Based on beginning element to find un-kept element from registered pipeline by tag
+ *
+ * @param[in]  pipeline     The Audio Pipeline Handle
+ * @param[in]  start_el     Specific beginning element
+ * @param[in]  tag          A char pointer
+ *
+ * @return
+ *     - NULL when any errors
+ *     - Others on success
+ */
+audio_element_handle_t audio_pipeline_get_el_once(audio_pipeline_handle_t pipeline, const audio_element_handle_t start_el, const char *tag);
+
+/**
+ * @brief      Remove event listener from this audio_pipeline
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_remove_listener(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Set event listner for this audio_pipeline, any event from this pipeline can be listen to by `evt`
+ *
+ * @param[in]  pipeline     The Audio Pipeline Handle
+ * @param[in]  evt          The Event Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_set_listener(audio_pipeline_handle_t pipeline, audio_event_iface_handle_t evt);
+
+/**
+ * @brief      Get the event iface using by this pipeline
+ *
+ * @param[in]  pipeline  The pipeline
+ *
+ * @return     The  Event Handle
+ */
+audio_event_iface_handle_t audio_pipeline_get_event_iface(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Insert the specific audio_element to audio_pipeline, previous element connect to the next element by ring buffer.
+ *
+ * @param[in]  pipeline     The audio pipeline handle
+ * @param[in]  first        Previous element is first input element, need to set `true`
+ * @param[in]  prev         Previous element
+ * @param[in]  conect_rb    Connect ring buffer
+ * @param[in]  next         Next element
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_pipeline_link_insert(audio_pipeline_handle_t pipeline, bool first, audio_element_handle_t prev,
+                                     ringbuf_handle_t conect_rb, audio_element_handle_t next);
+
+/**
+ * @brief      Register a NULL-terminated list of elements to audio_pipeline.
+ *
+ * @param[in]  pipeline     The audio pipeline handle
+ * @param[in]  element_1    The element to add to the audio_pipeline.
+ * @param[in]  ...          Additional elements to add to the audio_pipeline.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_pipeline_register_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
+
+/**
+ * @brief      Unregister a NULL-terminated list of elements to audio_pipeline.
+ *
+ * @param[in]  pipeline     The audio pipeline handle
+ * @param[in]  element_1    The element to add to the audio_pipeline.
+ * @param[in]  ...          Additional elements to add to the audio_pipeline.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_pipeline_unregister_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
+
+/**
+ * @brief      Adds a NULL-terminated list of elements to audio_pipeline.
+ *
+ * @param[in]  pipeline     The audio pipeline handle
+ * @param[in]  element_1    The element to add to the audio_pipeline.
+ * @param[in]  ...          Additional elements to add to the audio_pipeline.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_pipeline_link_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
+
+/**
+ * @brief      Subscribe a NULL-terminated list of element's events to audio_pipeline.
+ *
+ * @param[in]  pipeline     The audio pipeline handle
+ * @param[in]  element_1    The element event to subscribe to the audio_pipeline.
+ * @param[in]  ...          Additional elements event to subscribe to the audio_pipeline.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t audio_pipeline_listen_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
+
+/**
+ * @brief      Update the destination element state and check the all of linked elements state are same.
+ *
+ * @param[in]  pipeline     The audio pipeline handle
+ * @param[in]  dest_el      Destination element
+ * @param[in]  status       The new status
+ *
+ * @return
+ *     - ESP_OK             All linked elements state are same.
+ *     - ESP_FAIL           All linked elements state are not same.
+ */
+esp_err_t audio_pipeline_check_items_state(audio_pipeline_handle_t pipeline, audio_element_handle_t dest_el, audio_element_status_t status);
+
+/**
+ * @brief      Reset pipeline element items state to `AEL_STATUS_NONE`
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_reset_items_state(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Reset pipeline element ringbuffer
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_reset_ringbuffer(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Reset Pipeline linked elements state
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_reset_elements(audio_pipeline_handle_t pipeline);
+
+/**
+ * @brief      Reset the specific element kept state
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ * @param[in]  el         The Audio element Handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t audio_pipeline_reset_kept_state(audio_pipeline_handle_t pipeline, audio_element_handle_t el);
+
+/**
+ * @brief      Break up all the linked elements of specific `pipeline`.
+ *             The include and before `kept_ctx_el` working (AEL_STATE_RUNNING or AEL_STATE_PAUSED) elements
+ *             and connected ringbuffer will be reserved.
+ *
+ * @note       There is no element reserved when `kept_ctx_el` is NULL.
+ *             This function will unsubscribe all element's events.
+ *
+ * @param[in]  pipeline         The audio pipeline handle
+ * @param[in]  kept_ctx_el      Destination keep elements
+ *
+ * @return
+ *     - ESP_OK                 All linked elements state are same.
+ *     - ESP_ERR_INVALID_ARG    Invalid parameters.
+ */
+esp_err_t audio_pipeline_breakup_elements(audio_pipeline_handle_t pipeline, audio_element_handle_t kept_ctx_el);
+
+/**
+ * @brief      Basing on element's `name` already registered by `audio_pipeline_register`,
+ *             relink the pipeline following the order of `names` in the `link_tag.
+ *
+ * @note       If the ringbuffer is not enough to connect the new pipeline will create new ringbuffer.
+ *
+ * @param[in]  pipeline   The Audio Pipeline Handle
+ * @param      link_tag   Array of elements `name` that was registered by `audio_pipeline_register`
+ * @param[in]  link_num   Total number of elements of the `link_tag` array
+ *
+ * @return
+ *     - ESP_OK                 All linked elements state are same.
+ *     - ESP_FAIL               Error.
+ *     - ESP_ERR_INVALID_ARG    Invalid parameters.
+ */
+esp_err_t audio_pipeline_relink(audio_pipeline_handle_t pipeline, const char *link_tag[], int link_num);
+
+/**
+ * @brief      Adds a NULL-terminated list of elements to audio_pipeline.
+ *
+ * @note       If the ringbuffer is not enough to connect the new pipeline will create new ringbuffer.
+ *
+ * @param[in]  pipeline     The Audio Pipeline Handle
+ * @param[in]  element_1    The element to add to the audio_pipeline.
+ * @param[in]  ...          Additional elements to add to the audio_pipeline.
+ *
+ * @return
+ *     - ESP_OK                 All linked elements state are same.
+ *     - ESP_FAIL               Error.
+ *     - ESP_ERR_INVALID_ARG    Invalid parameters.
+ */
+esp_err_t audio_pipeline_relink_more(audio_pipeline_handle_t pipeline, audio_element_handle_t element_1, ...);
+
+/**
+ * @brief      Set the pipeline state.
+ *
+ * @param[in]  pipeline     The Audio Pipeline Handle
+ * @param[in]  new_state    The new state will be set
+ *
+ * @return
+ *     - ESP_OK                 All linked elements state are same.
+ *     - ESP_FAIL               Error.
+ */
+esp_err_t audio_pipeline_change_state(audio_pipeline_handle_t pipeline, audio_element_state_t new_state);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _AUDIO_PIPELINE_H_ */
+
diff --git a/components/audio_pipeline/include/i2s_debug.h b/components/audio_pipeline/include/i2s_debug.h
new file mode 100644
index 00000000..fb84477a
--- /dev/null
+++ b/components/audio_pipeline/include/i2s_debug.h
@@ -0,0 +1,18 @@
+#ifndef _I2S_DEBUG_H_
+#define _I2S_DEBUG_H_
+
+#include "esp_err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Debug functions for I2S
+void debug_i2s_data_flow(void);
+i2s_chan_handle_t tx_handle = NULL;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _I2S_DEBUG_H_
diff --git a/components/audio_pipeline/include/ringbuf.h b/components/audio_pipeline/include/ringbuf.h
index 3592944f..8d967bd6 100644
--- a/components/audio_pipeline/include/ringbuf.h
+++ b/components/audio_pipeline/include/ringbuf.h
@@ -1,228 +1,228 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _RINGBUF_H__
-#define _RINGBUF_H__
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/semphr.h"
-#include "freertos/queue.h"
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define RB_OK           (ESP_OK)
-#define RB_FAIL         (ESP_FAIL)
-#define RB_DONE         (-2)
-#define RB_ABORT        (-3)
-#define RB_TIMEOUT      (-4)
-
-typedef struct ringbuf *ringbuf_handle_t;
-
-/**
- * @brief      Create ringbuffer with total size = block_size * n_blocks
- *
- * @param[in]  block_size   Size of each block
- * @param[in]  n_blocks     Number of blocks
- *
- * @return     ringbuf_handle_t
- */
-ringbuf_handle_t rb_create(int block_size, int n_blocks);
-
-/**
- * @brief      Cleanup and free all memory created by ringbuf_handle_t
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_destroy(ringbuf_handle_t rb);
-
-/**
- * @brief      Abort waiting until there is space for reading or writing of the ringbuffer
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_abort(ringbuf_handle_t rb);
-
-/**
- * @brief      Reset ringbuffer, clear all values as initial state
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_reset(ringbuf_handle_t rb);
-
-/**
- * @brief      Reset is_done_write flag
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_reset_is_done_write(ringbuf_handle_t rb);
-
-/**
- * @brief      Get total bytes available of Ringbuffer
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return     total bytes available
- */
-int rb_bytes_available(ringbuf_handle_t rb);
-
-/**
- * @brief      Get the number of bytes that have filled the ringbuffer
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return     The number of bytes that have filled the ringbuffer
- */
-int rb_bytes_filled(ringbuf_handle_t rb);
-
-/**
- * @brief      Get total size of Ringbuffer (in bytes)
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return     total size of Ringbuffer
- */
-int rb_get_size(ringbuf_handle_t rb);
-
-/**
- * @brief      Read from Ringbuffer to `buf` with len and wait `tick_to_wait` ticks until enough bytes to read
- *             if the ringbuffer bytes available is less than `len`.
- *             If `buf` argument provided is `NULL`, then ringbuffer do pseudo reads by simply advancing pointers.
- *
- * @param[in]  rb             The Ringbuffer handle
- * @param      buf            The buffer pointer to read out data
- * @param[in]  len            The length request
- * @param[in]  ticks_to_wait  The ticks to wait
- *
- * @return     Number of bytes read
- */
-int rb_read(ringbuf_handle_t rb, char *buf, int len, TickType_t ticks_to_wait);
-
-/**
- * @brief      Write to Ringbuffer from `buf` with `len` and wait `tick_to_wait` ticks until enough space to write
- *             if the ringbuffer space available is less than `len`
- *
- * @param[in]  rb             The Ringbuffer handle
- * @param      buf            The buffer
- * @param[in]  len            The length
- * @param[in]  ticks_to_wait  The ticks to wait
- *
- * @return     Number of bytes written
- */
-int rb_write(ringbuf_handle_t rb, char *buf, int len, TickType_t ticks_to_wait);
-
-/**
- * @brief      Set status of writing to ringbuffer is done
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_done_write(ringbuf_handle_t rb);
-
-/**
- * @brief      Unblock from rb_read
- *
- * @param[in]  rb    The Ringbuffer handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_unblock_reader(ringbuf_handle_t rb);
-
-/**
- * @brief      Set the owner of the 'rb_read'.
- *
- * @param[in]  rb     The Ringbuffer handle
- * @param[in]  holder The owner of the 'rb_read'
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_set_reader_holder(ringbuf_handle_t rb, void *holder);
-
-/**
- * @brief      Get the owner of the 'rb_read'.
- *
- * @param[in]   rb     The Ringbuffer handle
- * @param[out]  holder The owner of the 'rb_read'
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_get_reader_holder(ringbuf_handle_t rb, void **holder);
-
-/**
- * @brief      Set the owner of the 'rb_write'.
- *
- * @param[in]  rb     The Ringbuffer handle
- * @param[in]  holder The owner of the 'rb_write'
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_set_writer_holder(ringbuf_handle_t rb, void *holder);
-
-/**
- * @brief      Get the owner of the 'rb_write'.
- *
- * @param[in]   rb     The Ringbuffer handle
- * @param[out]  holder The owner of the 'rb_write'
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t rb_get_writer_holder(ringbuf_handle_t rb, void **holder);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _RINGBUF_H__
+#define _RINGBUF_H__
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/semphr.h"
+#include "freertos/queue.h"
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RB_OK           (ESP_OK)
+#define RB_FAIL         (ESP_FAIL)
+#define RB_DONE         (-2)
+#define RB_ABORT        (-3)
+#define RB_TIMEOUT      (-4)
+
+typedef struct ringbuf *ringbuf_handle_t;
+
+/**
+ * @brief      Create ringbuffer with total size = block_size * n_blocks
+ *
+ * @param[in]  block_size   Size of each block
+ * @param[in]  n_blocks     Number of blocks
+ *
+ * @return     ringbuf_handle_t
+ */
+ringbuf_handle_t rb_create(int block_size, int n_blocks);
+
+/**
+ * @brief      Cleanup and free all memory created by ringbuf_handle_t
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_destroy(ringbuf_handle_t rb);
+
+/**
+ * @brief      Abort waiting until there is space for reading or writing of the ringbuffer
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_abort(ringbuf_handle_t rb);
+
+/**
+ * @brief      Reset ringbuffer, clear all values as initial state
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_reset(ringbuf_handle_t rb);
+
+/**
+ * @brief      Reset is_done_write flag
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_reset_is_done_write(ringbuf_handle_t rb);
+
+/**
+ * @brief      Get total bytes available of Ringbuffer
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return     total bytes available
+ */
+int rb_bytes_available(ringbuf_handle_t rb);
+
+/**
+ * @brief      Get the number of bytes that have filled the ringbuffer
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return     The number of bytes that have filled the ringbuffer
+ */
+int rb_bytes_filled(ringbuf_handle_t rb);
+
+/**
+ * @brief      Get total size of Ringbuffer (in bytes)
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return     total size of Ringbuffer
+ */
+int rb_get_size(ringbuf_handle_t rb);
+
+/**
+ * @brief      Read from Ringbuffer to `buf` with len and wait `tick_to_wait` ticks until enough bytes to read
+ *             if the ringbuffer bytes available is less than `len`.
+ *             If `buf` argument provided is `NULL`, then ringbuffer do pseudo reads by simply advancing pointers.
+ *
+ * @param[in]  rb             The Ringbuffer handle
+ * @param      buf            The buffer pointer to read out data
+ * @param[in]  len            The length request
+ * @param[in]  ticks_to_wait  The ticks to wait
+ *
+ * @return     Number of bytes read
+ */
+int rb_read(ringbuf_handle_t rb, char *buf, int len, TickType_t ticks_to_wait);
+
+/**
+ * @brief      Write to Ringbuffer from `buf` with `len` and wait `tick_to_wait` ticks until enough space to write
+ *             if the ringbuffer space available is less than `len`
+ *
+ * @param[in]  rb             The Ringbuffer handle
+ * @param      buf            The buffer
+ * @param[in]  len            The length
+ * @param[in]  ticks_to_wait  The ticks to wait
+ *
+ * @return     Number of bytes written
+ */
+int rb_write(ringbuf_handle_t rb, char *buf, int len, TickType_t ticks_to_wait);
+
+/**
+ * @brief      Set status of writing to ringbuffer is done
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_done_write(ringbuf_handle_t rb);
+
+/**
+ * @brief      Unblock from rb_read
+ *
+ * @param[in]  rb    The Ringbuffer handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_unblock_reader(ringbuf_handle_t rb);
+
+/**
+ * @brief      Set the owner of the 'rb_read'.
+ *
+ * @param[in]  rb     The Ringbuffer handle
+ * @param[in]  holder The owner of the 'rb_read'
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_set_reader_holder(ringbuf_handle_t rb, void *holder);
+
+/**
+ * @brief      Get the owner of the 'rb_read'.
+ *
+ * @param[in]   rb     The Ringbuffer handle
+ * @param[out]  holder The owner of the 'rb_read'
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_get_reader_holder(ringbuf_handle_t rb, void **holder);
+
+/**
+ * @brief      Set the owner of the 'rb_write'.
+ *
+ * @param[in]  rb     The Ringbuffer handle
+ * @param[in]  holder The owner of the 'rb_write'
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_set_writer_holder(ringbuf_handle_t rb, void *holder);
+
+/**
+ * @brief      Get the owner of the 'rb_write'.
+ *
+ * @param[in]   rb     The Ringbuffer handle
+ * @param[out]  holder The owner of the 'rb_write'
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t rb_get_writer_holder(ringbuf_handle_t rb, void **holder);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_pipeline/ringbuf.c b/components/audio_pipeline/ringbuf.c
index fa92b4e1..be56b5c1 100644
--- a/components/audio_pipeline/ringbuf.c
+++ b/components/audio_pipeline/ringbuf.c
@@ -1,443 +1,443 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/semphr.h"
-#include "ringbuf.h"
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "audio_error.h"
-
-static const char *TAG = "RINGBUF";
-
-struct ringbuf {
-    char *p_o;                   /**< Original pointer */
-    char *volatile p_r;          /**< Read pointer */
-    char *volatile p_w;          /**< Write pointer */
-    volatile uint32_t fill_cnt;  /**< Number of filled slots */
-    uint32_t size;               /**< Buffer size */
-    SemaphoreHandle_t can_read;
-    SemaphoreHandle_t can_write;
-    SemaphoreHandle_t lock;
-    bool abort_read;
-    bool abort_write;
-    bool is_done_write;         /**< To signal that we are done writing */
-    bool unblock_reader_flag;   /**< To unblock instantly from rb_read */
-    void *reader_holder;
-    void *writer_holder;
-};
-
-static esp_err_t rb_abort_read(ringbuf_handle_t rb);
-static esp_err_t rb_abort_write(ringbuf_handle_t rb);
-static void rb_release(SemaphoreHandle_t handle);
-
-ringbuf_handle_t rb_create(int block_size, int n_blocks)
-{
-    if (block_size < 2) {
-        ESP_LOGE(TAG, "Invalid size");
-        return NULL;
-    }
-
-    ringbuf_handle_t rb;
-    char *buf = NULL;
-    bool _success =
-        (
-            (rb             = audio_calloc(1, sizeof(struct ringbuf))) &&
-            (buf            = audio_calloc(n_blocks, block_size))   &&
-            (rb->can_read   = xSemaphoreCreateBinary())             &&
-            (rb->lock       = xSemaphoreCreateMutex())              &&
-            (rb->can_write  = xSemaphoreCreateBinary())
-        );
-
-    AUDIO_MEM_CHECK(TAG, _success, goto _rb_init_failed);
-
-    rb->p_o = rb->p_r = rb->p_w = buf;
-    rb->fill_cnt = 0;
-    rb->size = block_size * n_blocks;
-    rb->is_done_write = false;
-    rb->unblock_reader_flag = false;
-    rb->abort_read = false;
-    rb->abort_write = false;
-    return rb;
-_rb_init_failed:
-    rb_destroy(rb);
-    return NULL;
-}
-
-esp_err_t rb_destroy(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    if (rb->p_o) {
-        audio_free(rb->p_o);
-        rb->p_o = NULL;
-    }
-    if (rb->can_read) {
-        vSemaphoreDelete(rb->can_read);
-        rb->can_read = NULL;
-    }
-    if (rb->can_write) {
-        vSemaphoreDelete(rb->can_write);
-        rb->can_write = NULL;
-    }
-    if (rb->lock) {
-        vSemaphoreDelete(rb->lock);
-        rb->lock = NULL;
-    }
-    audio_free(rb);
-    rb = NULL;
-    return ESP_OK;
-}
-
-esp_err_t rb_reset(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_FAIL;
-    }
-    rb->p_r = rb->p_w = rb->p_o;
-    rb->fill_cnt = 0;
-    rb->is_done_write = false;
-
-    rb->unblock_reader_flag = false;
-    rb->abort_read = false;
-    rb->abort_write = false;
-    return ESP_OK;
-}
-
-esp_err_t rb_reset_is_done_write(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_FAIL;
-    }
-    rb->is_done_write = false;
-    return ESP_OK;
-}
-
-int rb_bytes_available(ringbuf_handle_t rb)
-{
-    return (rb->size - rb->fill_cnt);
-}
-
-int rb_bytes_filled(ringbuf_handle_t rb)
-{
-    if (rb) {
-        return rb->fill_cnt;
-    }
-    return ESP_FAIL;
-}
-
-static void rb_release(SemaphoreHandle_t handle)
-{
-    xSemaphoreGive(handle);
-}
-
-#define rb_block(handle, time) xSemaphoreTake(handle, time)
-
-int rb_read(ringbuf_handle_t rb, char *buf, int buf_len, TickType_t ticks_to_wait)
-{
-    int read_size = 0;
-    int total_read_size = 0;
-    int ret_val = 0;
-
-    if (rb == NULL) {
-        return RB_FAIL;
-    }
-
-    while (buf_len) {
-        //take buffer lock
-        if (rb_block(rb->lock, portMAX_DELAY) != pdTRUE) {
-            ret_val = RB_TIMEOUT;
-            goto read_err;
-        }
-
-        if (rb->fill_cnt < buf_len) {
-            read_size = rb->fill_cnt;
-            /**
-             * When non-multiple of 4(word size) bytes are written to I2S, there is noise.
-             * Below is the kind of workaround to read only in multiple of 4. Avoids noise when rb is read in small chunks.
-             * Note that, when we have buf_len bytes available in rb, we still read those irrespective of if it's multiple of 4.
-             */
-            read_size = read_size & 0xfffffffc;
-            if ((read_size == 0) && rb->is_done_write) {
-                read_size = rb->fill_cnt;
-            }
-        } else {
-            read_size = buf_len;
-        }
-
-        if (read_size == 0) {
-            //no data to read, release thread block to allow other threads to write data
-
-            if (rb->is_done_write) {
-                ret_val = RB_DONE;
-                rb_release(rb->lock);
-                goto read_err;
-            }
-            if (rb->abort_read) {
-                ret_val = RB_ABORT;
-                rb_release(rb->lock);
-                goto read_err;
-            }
-            if (rb->unblock_reader_flag) {
-                //reader_unblock is nothing but forced timeout
-                ret_val = RB_TIMEOUT;
-                rb_release(rb->lock);
-                goto read_err;
-            }
-
-            rb_release(rb->lock);
-            rb_release(rb->can_write);
-            //wait till some data available to read
-            if (rb_block(rb->can_read, ticks_to_wait) != pdTRUE) {
-                ret_val = RB_TIMEOUT;
-                goto read_err;
-            }
-            continue;
-        }
-
-        if ((rb->p_r + read_size) > (rb->p_o + rb->size)) {
-            int rlen1 = rb->p_o + rb->size - rb->p_r;
-            int rlen2 = read_size - rlen1;
-            if (buf) {
-                memcpy(buf, rb->p_r, rlen1);
-                memcpy(buf + rlen1, rb->p_o, rlen2);
-            }
-            rb->p_r = rb->p_o + rlen2;
-        } else {
-            if (buf) {
-                memcpy(buf, rb->p_r, read_size);
-            }
-            rb->p_r = rb->p_r + read_size;
-        }
-
-        buf_len -= read_size;
-        rb->fill_cnt -= read_size;
-        total_read_size += read_size;
-        buf += read_size;
-        rb_release(rb->lock);
-        if (buf_len == 0) {
-            break;
-        }
-    }
-read_err:
-    if (total_read_size > 0) {
-        rb_release(rb->can_write);
-    }
-    if ((ret_val == RB_FAIL) ||
-        (ret_val == RB_ABORT)) {
-        total_read_size = ret_val;
-    }
-    rb->unblock_reader_flag = false; /* We are anyway unblocking the reader */
-    return total_read_size > 0 ? total_read_size : ret_val;
-}
-
-int rb_write(ringbuf_handle_t rb, char *buf, int buf_len, TickType_t ticks_to_wait)
-{
-    int write_size;
-    int total_write_size = 0;
-    int ret_val = 0;
-
-    if (rb == NULL || buf == NULL) {
-        return RB_FAIL;
-    }
-
-    while (buf_len) {
-        //take buffer lock
-        if (rb_block(rb->lock, portMAX_DELAY) != pdTRUE) {
-            ret_val =  RB_TIMEOUT;
-            goto write_err;
-        }
-        write_size = rb_bytes_available(rb);
-
-        if (buf_len < write_size) {
-            write_size = buf_len;
-        }
-
-        if (write_size == 0) {
-            //no space to write, release thread block to allow other to read data
-            if (rb->is_done_write) {
-                ret_val = RB_DONE;
-                rb_release(rb->lock);
-                goto write_err;
-            }
-            if (rb->abort_write) {
-                ret_val = RB_ABORT;
-                rb_release(rb->lock);
-                goto write_err;
-            }
-
-            rb_release(rb->lock);
-            rb_release(rb->can_read);
-            //wait till we have some empty space to write
-            if (rb_block(rb->can_write, ticks_to_wait) != pdTRUE) {
-                ret_val = RB_TIMEOUT;
-                goto write_err;
-            }
-            continue;
-        }
-
-        if ((rb->p_w + write_size) > (rb->p_o + rb->size)) {
-            int wlen1 = rb->p_o + rb->size - rb->p_w;
-            int wlen2 = write_size - wlen1;
-            memcpy(rb->p_w, buf, wlen1);
-            memcpy(rb->p_o, buf + wlen1, wlen2);
-            rb->p_w = rb->p_o + wlen2;
-        } else {
-            memcpy(rb->p_w, buf, write_size);
-            rb->p_w = rb->p_w + write_size;
-        }
-
-        buf_len -= write_size;
-        rb->fill_cnt += write_size;
-        total_write_size += write_size;
-        buf += write_size;
-        rb_release(rb->lock);
-        if (buf_len == 0) {
-            break;
-        }
-    }
-write_err:
-    if (total_write_size > 0) {
-        rb_release(rb->can_read);
-    }
-    if ((ret_val == RB_FAIL) ||
-        (ret_val == RB_ABORT)) {
-        total_write_size = ret_val;
-    }
-    return total_write_size > 0 ? total_write_size : ret_val;
-}
-
-static esp_err_t rb_abort_read(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    rb->abort_read = true;
-    xSemaphoreGive(rb->can_read);
-    return ESP_OK;
-}
-
-static esp_err_t rb_abort_write(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    rb->abort_write = true;
-    xSemaphoreGive(rb->can_write);
-    return ESP_OK;
-}
-
-esp_err_t rb_abort(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    esp_err_t err = rb_abort_read(rb);
-    err |= rb_abort_write(rb);
-    return err;
-}
-
-bool rb_is_full(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return false;
-    }
-    return (rb->size == rb->fill_cnt);
-}
-
-esp_err_t rb_done_write(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    rb->is_done_write = true;
-    rb_release(rb->can_read);
-    return ESP_OK;
-}
-
-esp_err_t rb_unblock_reader(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    rb->unblock_reader_flag = true;
-    rb_release(rb->can_read);
-    return ESP_OK;
-}
-
-bool rb_is_done_write(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return false;
-    }
-    return (rb->is_done_write);
-}
-
-int rb_get_size(ringbuf_handle_t rb)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    return rb->size;
-}
-
-esp_err_t rb_set_reader_holder(ringbuf_handle_t rb, void *holder)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    rb->reader_holder = holder;
-    return ESP_OK;
-}
-
-esp_err_t rb_get_reader_holder(ringbuf_handle_t rb, void **holder)
-{
-    if ((rb==NULL) || (holder == NULL)) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    *holder = rb->reader_holder;
-    return ESP_OK;
-}
-
-esp_err_t rb_set_writer_holder(ringbuf_handle_t rb, void *holder)
-{
-    if (rb == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    rb->writer_holder = holder;
-    return ESP_OK;
-}
-
-esp_err_t rb_get_writer_holder(ringbuf_handle_t rb, void **holder)
-{
-    if ((rb==NULL) || (holder == NULL)) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    *holder = rb->writer_holder;
-    return ESP_OK;
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/semphr.h"
+#include "ringbuf.h"
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "audio_error.h"
+
+static const char *TAG = "RINGBUF";
+
+struct ringbuf {
+    char *p_o;                   /**< Original pointer */
+    char *volatile p_r;          /**< Read pointer */
+    char *volatile p_w;          /**< Write pointer */
+    volatile uint32_t fill_cnt;  /**< Number of filled slots */
+    uint32_t size;               /**< Buffer size */
+    SemaphoreHandle_t can_read;
+    SemaphoreHandle_t can_write;
+    SemaphoreHandle_t lock;
+    bool abort_read;
+    bool abort_write;
+    bool is_done_write;         /**< To signal that we are done writing */
+    bool unblock_reader_flag;   /**< To unblock instantly from rb_read */
+    void *reader_holder;
+    void *writer_holder;
+};
+
+static esp_err_t rb_abort_read(ringbuf_handle_t rb);
+static esp_err_t rb_abort_write(ringbuf_handle_t rb);
+static void rb_release(SemaphoreHandle_t handle);
+
+ringbuf_handle_t rb_create(int block_size, int n_blocks)
+{
+    if (block_size < 2) {
+        ESP_LOGE(TAG, "Invalid size");
+        return NULL;
+    }
+
+    ringbuf_handle_t rb;
+    char *buf = NULL;
+    bool _success =
+        (
+            (rb             = audio_calloc(1, sizeof(struct ringbuf))) &&
+            (buf            = audio_calloc(n_blocks, block_size))   &&
+            (rb->can_read   = xSemaphoreCreateBinary())             &&
+            (rb->lock       = xSemaphoreCreateMutex())              &&
+            (rb->can_write  = xSemaphoreCreateBinary())
+        );
+
+    AUDIO_MEM_CHECK(TAG, _success, goto _rb_init_failed);
+
+    rb->p_o = rb->p_r = rb->p_w = buf;
+    rb->fill_cnt = 0;
+    rb->size = block_size * n_blocks;
+    rb->is_done_write = false;
+    rb->unblock_reader_flag = false;
+    rb->abort_read = false;
+    rb->abort_write = false;
+    return rb;
+_rb_init_failed:
+    rb_destroy(rb);
+    return NULL;
+}
+
+esp_err_t rb_destroy(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    if (rb->p_o) {
+        audio_free(rb->p_o);
+        rb->p_o = NULL;
+    }
+    if (rb->can_read) {
+        vSemaphoreDelete(rb->can_read);
+        rb->can_read = NULL;
+    }
+    if (rb->can_write) {
+        vSemaphoreDelete(rb->can_write);
+        rb->can_write = NULL;
+    }
+    if (rb->lock) {
+        vSemaphoreDelete(rb->lock);
+        rb->lock = NULL;
+    }
+    audio_free(rb);
+    rb = NULL;
+    return ESP_OK;
+}
+
+esp_err_t rb_reset(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_FAIL;
+    }
+    rb->p_r = rb->p_w = rb->p_o;
+    rb->fill_cnt = 0;
+    rb->is_done_write = false;
+
+    rb->unblock_reader_flag = false;
+    rb->abort_read = false;
+    rb->abort_write = false;
+    return ESP_OK;
+}
+
+esp_err_t rb_reset_is_done_write(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_FAIL;
+    }
+    rb->is_done_write = false;
+    return ESP_OK;
+}
+
+int rb_bytes_available(ringbuf_handle_t rb)
+{
+    return (rb->size - rb->fill_cnt);
+}
+
+int rb_bytes_filled(ringbuf_handle_t rb)
+{
+    if (rb) {
+        return rb->fill_cnt;
+    }
+    return ESP_FAIL;
+}
+
+static void rb_release(SemaphoreHandle_t handle)
+{
+    xSemaphoreGive(handle);
+}
+
+#define rb_block(handle, time) xSemaphoreTake(handle, time)
+
+int rb_read(ringbuf_handle_t rb, char *buf, int buf_len, TickType_t ticks_to_wait)
+{
+    int read_size = 0;
+    int total_read_size = 0;
+    int ret_val = 0;
+
+    if (rb == NULL) {
+        return RB_FAIL;
+    }
+
+    while (buf_len) {
+        //take buffer lock
+        if (rb_block(rb->lock, portMAX_DELAY) != pdTRUE) {
+            ret_val = RB_TIMEOUT;
+            goto read_err;
+        }
+
+        if (rb->fill_cnt < buf_len) {
+            read_size = rb->fill_cnt;
+            /**
+             * When non-multiple of 4(word size) bytes are written to I2S, there is noise.
+             * Below is the kind of workaround to read only in multiple of 4. Avoids noise when rb is read in small chunks.
+             * Note that, when we have buf_len bytes available in rb, we still read those irrespective of if it's multiple of 4.
+             */
+            read_size = read_size & 0xfffffffc;
+            if ((read_size == 0) && rb->is_done_write) {
+                read_size = rb->fill_cnt;
+            }
+        } else {
+            read_size = buf_len;
+        }
+
+        if (read_size == 0) {
+            //no data to read, release thread block to allow other threads to write data
+
+            if (rb->is_done_write) {
+                ret_val = RB_DONE;
+                rb_release(rb->lock);
+                goto read_err;
+            }
+            if (rb->abort_read) {
+                ret_val = RB_ABORT;
+                rb_release(rb->lock);
+                goto read_err;
+            }
+            if (rb->unblock_reader_flag) {
+                //reader_unblock is nothing but forced timeout
+                ret_val = RB_TIMEOUT;
+                rb_release(rb->lock);
+                goto read_err;
+            }
+
+            rb_release(rb->lock);
+            rb_release(rb->can_write);
+            //wait till some data available to read
+            if (rb_block(rb->can_read, ticks_to_wait) != pdTRUE) {
+                ret_val = RB_TIMEOUT;
+                goto read_err;
+            }
+            continue;
+        }
+
+        if ((rb->p_r + read_size) > (rb->p_o + rb->size)) {
+            int rlen1 = rb->p_o + rb->size - rb->p_r;
+            int rlen2 = read_size - rlen1;
+            if (buf) {
+                memcpy(buf, rb->p_r, rlen1);
+                memcpy(buf + rlen1, rb->p_o, rlen2);
+            }
+            rb->p_r = rb->p_o + rlen2;
+        } else {
+            if (buf) {
+                memcpy(buf, rb->p_r, read_size);
+            }
+            rb->p_r = rb->p_r + read_size;
+        }
+
+        buf_len -= read_size;
+        rb->fill_cnt -= read_size;
+        total_read_size += read_size;
+        buf += read_size;
+        rb_release(rb->lock);
+        if (buf_len == 0) {
+            break;
+        }
+    }
+read_err:
+    if (total_read_size > 0) {
+        rb_release(rb->can_write);
+    }
+    if ((ret_val == RB_FAIL) ||
+        (ret_val == RB_ABORT)) {
+        total_read_size = ret_val;
+    }
+    rb->unblock_reader_flag = false; /* We are anyway unblocking the reader */
+    return total_read_size > 0 ? total_read_size : ret_val;
+}
+
+int rb_write(ringbuf_handle_t rb, char *buf, int buf_len, TickType_t ticks_to_wait)
+{
+    int write_size;
+    int total_write_size = 0;
+    int ret_val = 0;
+
+    if (rb == NULL || buf == NULL) {
+        return RB_FAIL;
+    }
+
+    while (buf_len) {
+        //take buffer lock
+        if (rb_block(rb->lock, portMAX_DELAY) != pdTRUE) {
+            ret_val =  RB_TIMEOUT;
+            goto write_err;
+        }
+        write_size = rb_bytes_available(rb);
+
+        if (buf_len < write_size) {
+            write_size = buf_len;
+        }
+
+        if (write_size == 0) {
+            //no space to write, release thread block to allow other to read data
+            if (rb->is_done_write) {
+                ret_val = RB_DONE;
+                rb_release(rb->lock);
+                goto write_err;
+            }
+            if (rb->abort_write) {
+                ret_val = RB_ABORT;
+                rb_release(rb->lock);
+                goto write_err;
+            }
+
+            rb_release(rb->lock);
+            rb_release(rb->can_read);
+            //wait till we have some empty space to write
+            if (rb_block(rb->can_write, ticks_to_wait) != pdTRUE) {
+                ret_val = RB_TIMEOUT;
+                goto write_err;
+            }
+            continue;
+        }
+
+        if ((rb->p_w + write_size) > (rb->p_o + rb->size)) {
+            int wlen1 = rb->p_o + rb->size - rb->p_w;
+            int wlen2 = write_size - wlen1;
+            memcpy(rb->p_w, buf, wlen1);
+            memcpy(rb->p_o, buf + wlen1, wlen2);
+            rb->p_w = rb->p_o + wlen2;
+        } else {
+            memcpy(rb->p_w, buf, write_size);
+            rb->p_w = rb->p_w + write_size;
+        }
+
+        buf_len -= write_size;
+        rb->fill_cnt += write_size;
+        total_write_size += write_size;
+        buf += write_size;
+        rb_release(rb->lock);
+        if (buf_len == 0) {
+            break;
+        }
+    }
+write_err:
+    if (total_write_size > 0) {
+        rb_release(rb->can_read);
+    }
+    if ((ret_val == RB_FAIL) ||
+        (ret_val == RB_ABORT)) {
+        total_write_size = ret_val;
+    }
+    return total_write_size > 0 ? total_write_size : ret_val;
+}
+
+static esp_err_t rb_abort_read(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    rb->abort_read = true;
+    xSemaphoreGive(rb->can_read);
+    return ESP_OK;
+}
+
+static esp_err_t rb_abort_write(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    rb->abort_write = true;
+    xSemaphoreGive(rb->can_write);
+    return ESP_OK;
+}
+
+esp_err_t rb_abort(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    esp_err_t err = rb_abort_read(rb);
+    err |= rb_abort_write(rb);
+    return err;
+}
+
+bool rb_is_full(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return false;
+    }
+    return (rb->size == rb->fill_cnt);
+}
+
+esp_err_t rb_done_write(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    rb->is_done_write = true;
+    rb_release(rb->can_read);
+    return ESP_OK;
+}
+
+esp_err_t rb_unblock_reader(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    rb->unblock_reader_flag = true;
+    rb_release(rb->can_read);
+    return ESP_OK;
+}
+
+bool rb_is_done_write(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return false;
+    }
+    return (rb->is_done_write);
+}
+
+int rb_get_size(ringbuf_handle_t rb)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    return rb->size;
+}
+
+esp_err_t rb_set_reader_holder(ringbuf_handle_t rb, void *holder)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    rb->reader_holder = holder;
+    return ESP_OK;
+}
+
+esp_err_t rb_get_reader_holder(ringbuf_handle_t rb, void **holder)
+{
+    if ((rb==NULL) || (holder == NULL)) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    *holder = rb->reader_holder;
+    return ESP_OK;
+}
+
+esp_err_t rb_set_writer_holder(ringbuf_handle_t rb, void *holder)
+{
+    if (rb == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    rb->writer_holder = holder;
+    return ESP_OK;
+}
+
+esp_err_t rb_get_writer_holder(ringbuf_handle_t rb, void **holder)
+{
+    if ((rb==NULL) || (holder == NULL)) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    *holder = rb->writer_holder;
+    return ESP_OK;
 }
\ No newline at end of file
diff --git a/components/audio_pipeline/test/audio_element_test.c b/components/audio_pipeline/test/audio_element_test.c
index 5856272b..82a9662e 100644
--- a/components/audio_pipeline/test/audio_element_test.c
+++ b/components/audio_pipeline/test/audio_element_test.c
@@ -1,197 +1,197 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <pthread.h>
-#include "unity.h"
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "audio_element.h"
-#include "esp_log.h"
-#include "esp_err.h"
-
-static const char *TAG = "AUDIO_ELEMENT_TEST";
-
-static esp_err_t _el_open(audio_element_handle_t self)
-{
-    ESP_LOGI(TAG, "_el_open");
-    return ESP_OK;
-}
-
-static int _el_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
-{
-    ESP_LOGI(TAG, "_el_read");
-    return len;
-}
-
-static int _el_process(audio_element_handle_t self, char *in_buffer, int in_len, char *out_buffer, int out_len)
-{
-    ESP_LOGI(TAG, "_el_process");
-    vTaskDelay(100/portTICK_RATE_MS);
-    return in_len;
-}
-
-static int _el_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
-{
-    ESP_LOGI(TAG, "_el_write");
-    return len;
-}
-
-static esp_err_t _el_close(audio_element_handle_t self)
-{
-    ESP_LOGI(TAG, "_el_close");
-    return ESP_OK;
-}
-
-TEST_CASE("audio_element", "esp-adf")
-{
-    esp_log_level_set("*", ESP_LOG_INFO);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
-
-    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
-    audio_element_handle_t el;
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-
-    cfg.open = _el_open;
-    cfg.read = _el_read;
-    cfg.process = _el_process;
-    cfg.write = _el_write;
-    cfg.close = _el_close;
-    el = audio_element_init(&cfg);
-
-
-    TEST_ASSERT_NOT_NULL(el);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
-}
-
-TEST_CASE("audio_element_input_rb", "esp-adf")
-{
-    esp_log_level_set("*", ESP_LOG_INFO);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
-
-    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
-    RingbufHandle_t input_rb;
-    audio_element_handle_t el;
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-
-    cfg.open = _el_open;
-    // cfg.read = _el_read;
-    cfg.process = _el_process;
-    cfg.write = _el_write;
-    cfg.close = _el_close;
-    el = audio_element_init(&cfg);
-    input_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
-    audio_element_set_input_ringbuf(el, input_rb);
-
-    TEST_ASSERT_NOT_NULL(el);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
-    vRingbufferDelete(input_rb);
-}
-
-TEST_CASE("audio_element_output_rb", "esp-adf")
-{
-    esp_log_level_set("*", ESP_LOG_INFO);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
-
-    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
-    RingbufHandle_t output_rb;
-    audio_element_handle_t el;
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-
-    cfg.open = _el_open;
-    cfg.read = _el_read;
-    cfg.process = _el_process;
-    // cfg.write = _el_write;
-    cfg.close = _el_close;
-    el = audio_element_init(&cfg);
-    output_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
-    audio_element_set_output_ringbuf(el, output_rb);
-
-    TEST_ASSERT_NOT_NULL(el);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
-    vRingbufferDelete(output_rb);
-}
-
-
-TEST_CASE("audio_element_input_output_rb", "esp-adf")
-{
-    esp_log_level_set("*", ESP_LOG_INFO);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
-
-    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
-    RingbufHandle_t input_rb, output_rb;
-    audio_element_handle_t el;
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-
-    cfg.open = _el_open;
-    // cfg.read = _el_read;
-    cfg.process = _el_process;
-    // cfg.write = _el_write;
-    cfg.close = _el_close;
-    el = audio_element_init(&cfg);
-    output_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
-    input_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
-    audio_element_set_input_ringbuf(el, input_rb);
-    audio_element_set_output_ringbuf(el, output_rb);
-
-    TEST_ASSERT_NOT_NULL(el);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
-    vTaskDelay(2000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
-    vTaskDelay(2000/portTICK_RATE_MS);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
-    vRingbufferDelete(input_rb);
-    vRingbufferDelete(output_rb);
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <pthread.h>
+#include "unity.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "audio_element.h"
+#include "esp_log.h"
+#include "esp_err.h"
+
+static const char *TAG = "AUDIO_ELEMENT_TEST";
+
+static esp_err_t _el_open(audio_element_handle_t self)
+{
+    ESP_LOGI(TAG, "_el_open");
+    return ESP_OK;
+}
+
+static int _el_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
+{
+    ESP_LOGI(TAG, "_el_read");
+    return len;
+}
+
+static int _el_process(audio_element_handle_t self, char *in_buffer, int in_len, char *out_buffer, int out_len)
+{
+    ESP_LOGI(TAG, "_el_process");
+    vTaskDelay(100/portTICK_RATE_MS);
+    return in_len;
+}
+
+static int _el_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
+{
+    ESP_LOGI(TAG, "_el_write");
+    return len;
+}
+
+static esp_err_t _el_close(audio_element_handle_t self)
+{
+    ESP_LOGI(TAG, "_el_close");
+    return ESP_OK;
+}
+
+TEST_CASE("audio_element", "esp-adf")
+{
+    esp_log_level_set("*", ESP_LOG_INFO);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
+
+    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
+    audio_element_handle_t el;
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+
+    cfg.open = _el_open;
+    cfg.read = _el_read;
+    cfg.process = _el_process;
+    cfg.write = _el_write;
+    cfg.close = _el_close;
+    el = audio_element_init(&cfg);
+
+
+    TEST_ASSERT_NOT_NULL(el);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
+}
+
+TEST_CASE("audio_element_input_rb", "esp-adf")
+{
+    esp_log_level_set("*", ESP_LOG_INFO);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
+
+    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
+    RingbufHandle_t input_rb;
+    audio_element_handle_t el;
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+
+    cfg.open = _el_open;
+    // cfg.read = _el_read;
+    cfg.process = _el_process;
+    cfg.write = _el_write;
+    cfg.close = _el_close;
+    el = audio_element_init(&cfg);
+    input_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
+    audio_element_set_input_ringbuf(el, input_rb);
+
+    TEST_ASSERT_NOT_NULL(el);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
+    vRingbufferDelete(input_rb);
+}
+
+TEST_CASE("audio_element_output_rb", "esp-adf")
+{
+    esp_log_level_set("*", ESP_LOG_INFO);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
+
+    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
+    RingbufHandle_t output_rb;
+    audio_element_handle_t el;
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+
+    cfg.open = _el_open;
+    cfg.read = _el_read;
+    cfg.process = _el_process;
+    // cfg.write = _el_write;
+    cfg.close = _el_close;
+    el = audio_element_init(&cfg);
+    output_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
+    audio_element_set_output_ringbuf(el, output_rb);
+
+    TEST_ASSERT_NOT_NULL(el);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
+    vRingbufferDelete(output_rb);
+}
+
+
+TEST_CASE("audio_element_input_output_rb", "esp-adf")
+{
+    esp_log_level_set("*", ESP_LOG_INFO);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
+
+    ESP_LOGI(TAG, "[Γ£ô] audio_element_init element");
+    RingbufHandle_t input_rb, output_rb;
+    audio_element_handle_t el;
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+
+    cfg.open = _el_open;
+    // cfg.read = _el_read;
+    cfg.process = _el_process;
+    // cfg.write = _el_write;
+    cfg.close = _el_close;
+    el = audio_element_init(&cfg);
+    output_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
+    input_rb = xRingbufferCreate(4096, RINGBUF_TYPE_NOSPLIT);
+    audio_element_set_input_ringbuf(el, input_rb);
+    audio_element_set_output_ringbuf(el, output_rb);
+
+    TEST_ASSERT_NOT_NULL(el);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_run(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_pause(el));
+    vTaskDelay(2000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_resume(el, 0, 0));
+    vTaskDelay(2000/portTICK_RATE_MS);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_stop(el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(el));
+    vRingbufferDelete(input_rb);
+    vRingbufferDelete(output_rb);
+}
diff --git a/components/audio_pipeline/test/audio_event_iface_test.c b/components/audio_pipeline/test/audio_event_iface_test.c
index dfb55f3e..9f0aa754 100644
--- a/components/audio_pipeline/test/audio_event_iface_test.c
+++ b/components/audio_pipeline/test/audio_event_iface_test.c
@@ -1,139 +1,139 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <pthread.h>
-#include "unity.h"
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "audio_event_iface.h"
-#include "esp_log.h"
-#include "esp_err.h"
-#include "audio_common.h"
-
-static const char *TAG = "ESP_EMITTER_TEST";
-
-static esp_err_t event_on_cmd(audio_event_iface_msg_t *msg, void *context)
-{
-    ESP_LOGI(TAG, "receive evt msg cmd = %d, source addr = %x, type = %d", msg->cmd, (int)msg->source, msg->source_type);
-    if (msg->cmd == 9) {
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-TEST_CASE("audio_event_iface", "esp-adf")
-{
-    ESP_LOGI(TAG, "[Γ£ô] audio_event_iface_init evt1");
-    audio_event_iface_handle_t evt1;
-    audio_event_iface_cfg_t cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    cfg.on_cmd = event_on_cmd;
-    cfg.queue_size = 10;
-    cfg.context = &evt1;
-    evt1 = audio_event_iface_init(&cfg);
-    TEST_ASSERT_NOT_NULL(evt1);
-
-    audio_event_iface_msg_t msg;
-    int i;
-    ESP_LOGI(TAG, "[Γ£ô] dispatch 10 msg to evt1");
-    for (i = 0; i < 10; i++) {
-        msg.cmd = i;
-        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_cmd(evt1, &msg));
-    }
-    msg.cmd = 10;
-    TEST_ASSERT_EQUAL(ESP_FAIL, audio_event_iface_cmd(evt1, &msg));
-
-    ESP_LOGI(TAG, "[Γ£ô] listening 10 event have dispatched fron evt1");
-    while (audio_event_iface_waiting_cmd_msg(evt1) == ESP_OK);
-
-    ESP_LOGI(TAG, "[Γ£ô] audio_event_iface_init evt2");
-    audio_event_iface_handle_t evt2;
-    cfg.context = &evt2;
-    cfg.type = AUDIO_ELEMENT_TYPE_PIPELINE;
-    evt2 = audio_event_iface_init(&cfg);
-    TEST_ASSERT_NOT_NULL(evt2);
-
-    ESP_LOGI(TAG, "[Γ£ô] audio_event_iface_init evt3");
-    audio_event_iface_handle_t evt3;
-    cfg.context = &evt3;
-    cfg.type = AUDIO_ELEMENT_TYPE_PLAYER;
-    evt3 = audio_event_iface_init(&cfg);
-    TEST_ASSERT_NOT_NULL(evt3);
-
-    ESP_LOGI(TAG, "[Γ£ô] listen evt2 from evt1");
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(evt2, evt1));
-
-    ESP_LOGI(TAG, "[Γ£ô] listen evt3 from evt1");
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(evt3, evt1));
-
-    ESP_LOGI(TAG, "[Γ£ô] dispatch 2 msg to evt1");
-    for (i = 0; i < 2; i++) {
-        msg.source = evt1;
-        msg.cmd = i;
-        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_cmd(evt1, &msg));
-    }
-
-    ESP_LOGI(TAG, "[Γ£ô] sendout 3 msg from evt2 to evt1");
-    for (i = 2; i < 5; i++) {
-        msg.source = evt2;
-        msg.cmd = i;
-        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_sendout(evt2, &msg));
-    }
-
-    ESP_LOGI(TAG, "[Γ£ô] sendout 5 msg from evt3 to evt1");
-    for (i = 5; i < 10; i++) {
-        msg.source = evt3;
-        msg.cmd = i;
-        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_sendout(evt3, &msg));
-    }
-
-    ESP_LOGI(TAG, "[Γ£ô] listening 10 event have dispatched from evt1, evt2 and evt3");
-    while (audio_event_iface_waiting_cmd_msg(evt1) == ESP_OK);
-
-    ESP_LOGI(TAG, "[Γ£ô] remove listener from evt2");
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(evt2, evt1));
-
-    ESP_LOGI(TAG, "[Γ£ô] remove listener from evt3");
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(evt3, evt1));
-
-    ESP_LOGI(TAG, "[Γ£ô] sendout 5 msg from evt2 to evt1");
-    for (i = 1; i < 5; i++) {
-        msg.source = evt2;
-        msg.cmd = i;
-        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_sendout(evt2, &msg));
-    }
-
-    ESP_LOGI(TAG, "[Γ£ô] dispatch 5 msg to evt1");
-    for (i = 5; i < 10; i++) {
-        msg.source = evt1;
-        msg.cmd = i;
-        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_cmd(evt1, &msg));
-    }
-
-    ESP_LOGI(TAG, "[Γ£ô] listening 10 event have dispatched from evt1 and evt2");
-    while (audio_event_iface_listen(evt1) == ESP_OK);
-
-    audio_event_iface_destroy(evt1);
-    audio_event_iface_destroy(evt2);
-    audio_event_iface_destroy(evt3);
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <pthread.h>
+#include "unity.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "audio_event_iface.h"
+#include "esp_log.h"
+#include "esp_err.h"
+#include "audio_common.h"
+
+static const char *TAG = "ESP_EMITTER_TEST";
+
+static esp_err_t event_on_cmd(audio_event_iface_msg_t *msg, void *context)
+{
+    ESP_LOGI(TAG, "receive evt msg cmd = %d, source addr = %x, type = %d", msg->cmd, (int)msg->source, msg->source_type);
+    if (msg->cmd == 9) {
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+TEST_CASE("audio_event_iface", "esp-adf")
+{
+    ESP_LOGI(TAG, "[Γ£ô] audio_event_iface_init evt1");
+    audio_event_iface_handle_t evt1;
+    audio_event_iface_cfg_t cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    cfg.on_cmd = event_on_cmd;
+    cfg.queue_size = 10;
+    cfg.context = &evt1;
+    evt1 = audio_event_iface_init(&cfg);
+    TEST_ASSERT_NOT_NULL(evt1);
+
+    audio_event_iface_msg_t msg;
+    int i;
+    ESP_LOGI(TAG, "[Γ£ô] dispatch 10 msg to evt1");
+    for (i = 0; i < 10; i++) {
+        msg.cmd = i;
+        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_cmd(evt1, &msg));
+    }
+    msg.cmd = 10;
+    TEST_ASSERT_EQUAL(ESP_FAIL, audio_event_iface_cmd(evt1, &msg));
+
+    ESP_LOGI(TAG, "[Γ£ô] listening 10 event have dispatched fron evt1");
+    while (audio_event_iface_waiting_cmd_msg(evt1) == ESP_OK);
+
+    ESP_LOGI(TAG, "[Γ£ô] audio_event_iface_init evt2");
+    audio_event_iface_handle_t evt2;
+    cfg.context = &evt2;
+    cfg.type = AUDIO_ELEMENT_TYPE_PIPELINE;
+    evt2 = audio_event_iface_init(&cfg);
+    TEST_ASSERT_NOT_NULL(evt2);
+
+    ESP_LOGI(TAG, "[Γ£ô] audio_event_iface_init evt3");
+    audio_event_iface_handle_t evt3;
+    cfg.context = &evt3;
+    cfg.type = AUDIO_ELEMENT_TYPE_PLAYER;
+    evt3 = audio_event_iface_init(&cfg);
+    TEST_ASSERT_NOT_NULL(evt3);
+
+    ESP_LOGI(TAG, "[Γ£ô] listen evt2 from evt1");
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(evt2, evt1));
+
+    ESP_LOGI(TAG, "[Γ£ô] listen evt3 from evt1");
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(evt3, evt1));
+
+    ESP_LOGI(TAG, "[Γ£ô] dispatch 2 msg to evt1");
+    for (i = 0; i < 2; i++) {
+        msg.source = evt1;
+        msg.cmd = i;
+        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_cmd(evt1, &msg));
+    }
+
+    ESP_LOGI(TAG, "[Γ£ô] sendout 3 msg from evt2 to evt1");
+    for (i = 2; i < 5; i++) {
+        msg.source = evt2;
+        msg.cmd = i;
+        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_sendout(evt2, &msg));
+    }
+
+    ESP_LOGI(TAG, "[Γ£ô] sendout 5 msg from evt3 to evt1");
+    for (i = 5; i < 10; i++) {
+        msg.source = evt3;
+        msg.cmd = i;
+        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_sendout(evt3, &msg));
+    }
+
+    ESP_LOGI(TAG, "[Γ£ô] listening 10 event have dispatched from evt1, evt2 and evt3");
+    while (audio_event_iface_waiting_cmd_msg(evt1) == ESP_OK);
+
+    ESP_LOGI(TAG, "[Γ£ô] remove listener from evt2");
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(evt2, evt1));
+
+    ESP_LOGI(TAG, "[Γ£ô] remove listener from evt3");
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(evt3, evt1));
+
+    ESP_LOGI(TAG, "[Γ£ô] sendout 5 msg from evt2 to evt1");
+    for (i = 1; i < 5; i++) {
+        msg.source = evt2;
+        msg.cmd = i;
+        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_sendout(evt2, &msg));
+    }
+
+    ESP_LOGI(TAG, "[Γ£ô] dispatch 5 msg to evt1");
+    for (i = 5; i < 10; i++) {
+        msg.source = evt1;
+        msg.cmd = i;
+        TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_cmd(evt1, &msg));
+    }
+
+    ESP_LOGI(TAG, "[Γ£ô] listening 10 event have dispatched from evt1 and evt2");
+    while (audio_event_iface_listen(evt1) == ESP_OK);
+
+    audio_event_iface_destroy(evt1);
+    audio_event_iface_destroy(evt2);
+    audio_event_iface_destroy(evt3);
+}
diff --git a/components/audio_pipeline/test/audio_pipeline_test.c b/components/audio_pipeline/test/audio_pipeline_test.c
index 3b94d099..0d72f1b1 100644
--- a/components/audio_pipeline/test/audio_pipeline_test.c
+++ b/components/audio_pipeline/test/audio_pipeline_test.c
@@ -1,119 +1,119 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <pthread.h>
-#include "unity.h"
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "audio_pipeline.h"
-#include "esp_log.h"
-#include "esp_err.h"
-
-static const char *TAG = "AUDIO_ELEMENT_TEST";
-
-static esp_err_t _el_open(audio_element_handle_t self)
-{
-    ESP_LOGI(TAG, "[%s] _el_open", audio_element_get_tag(self));
-    return ESP_OK;
-}
-
-static int _el_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
-{
-    ESP_LOGI(TAG, "[%s] _el_read", audio_element_get_tag(self));
-    return len;
-}
-
-static int _el_process(audio_element_handle_t self, char *in_buffer, int in_len, char *out_buffer, int out_len)
-{
-    ESP_LOGI(TAG, "[%s] _el_process, in_len=%d, outlen=%d", audio_element_get_tag(self), in_len, out_len);
-    vTaskDelay(100/portTICK_RATE_MS);
-    return in_len;
-}
-
-static int _el_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
-{
-    ESP_LOGI(TAG, "[%s] _el_write", audio_element_get_tag(self));
-    return len;
-}
-
-static esp_err_t _el_close(audio_element_handle_t self)
-{
-    ESP_LOGI(TAG, "[%s] _el_close", audio_element_get_tag(self));
-    return ESP_OK;
-}
-
-TEST_CASE("audio_pipeline", "esp-adf")
-{
-    esp_log_level_set("*", ESP_LOG_INFO);
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_VERBOSE);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
-    esp_log_level_set("AUDIO_EVENT", ESP_LOG_VERBOSE);
-
-    ESP_LOGI(TAG, "[Γ£ô] init audio_pipeline and audio_element");
-    audio_element_handle_t first_el, mid_el, last_el;
-    audio_element_cfg_t el_cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-
-    el_cfg.open = _el_open;
-    el_cfg.read = _el_read;
-    el_cfg.process = _el_process;
-    el_cfg.close = _el_close;
-    first_el = audio_element_init(&el_cfg);
-    TEST_ASSERT_NOT_NULL(first_el);
-
-    el_cfg.read = NULL;
-    el_cfg.write = NULL;
-    mid_el = audio_element_init(&el_cfg);
-    TEST_ASSERT_NOT_NULL(mid_el);
-
-    el_cfg.write = _el_write;
-    last_el = audio_element_init(&el_cfg);
-    TEST_ASSERT_NOT_NULL(last_el);
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    audio_pipeline_handle_t pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, first_el, "first"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, mid_el, "mid"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, last_el, "last"));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]){"first", "mid", "last"}, 3));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    vTaskDelay(10000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unlink(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-    vTaskDelay(5000/portTICK_RATE_MS);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(first_el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(mid_el));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(last_el));
-
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <pthread.h>
+#include "unity.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "audio_pipeline.h"
+#include "esp_log.h"
+#include "esp_err.h"
+
+static const char *TAG = "AUDIO_ELEMENT_TEST";
+
+static esp_err_t _el_open(audio_element_handle_t self)
+{
+    ESP_LOGI(TAG, "[%s] _el_open", audio_element_get_tag(self));
+    return ESP_OK;
+}
+
+static int _el_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
+{
+    ESP_LOGI(TAG, "[%s] _el_read", audio_element_get_tag(self));
+    return len;
+}
+
+static int _el_process(audio_element_handle_t self, char *in_buffer, int in_len, char *out_buffer, int out_len)
+{
+    ESP_LOGI(TAG, "[%s] _el_process, in_len=%d, outlen=%d", audio_element_get_tag(self), in_len, out_len);
+    vTaskDelay(100/portTICK_RATE_MS);
+    return in_len;
+}
+
+static int _el_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait)
+{
+    ESP_LOGI(TAG, "[%s] _el_write", audio_element_get_tag(self));
+    return len;
+}
+
+static esp_err_t _el_close(audio_element_handle_t self)
+{
+    ESP_LOGI(TAG, "[%s] _el_close", audio_element_get_tag(self));
+    return ESP_OK;
+}
+
+TEST_CASE("audio_pipeline", "esp-adf")
+{
+    esp_log_level_set("*", ESP_LOG_INFO);
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_VERBOSE);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_VERBOSE);
+    esp_log_level_set("AUDIO_EVENT", ESP_LOG_VERBOSE);
+
+    ESP_LOGI(TAG, "[Γ£ô] init audio_pipeline and audio_element");
+    audio_element_handle_t first_el, mid_el, last_el;
+    audio_element_cfg_t el_cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+
+    el_cfg.open = _el_open;
+    el_cfg.read = _el_read;
+    el_cfg.process = _el_process;
+    el_cfg.close = _el_close;
+    first_el = audio_element_init(&el_cfg);
+    TEST_ASSERT_NOT_NULL(first_el);
+
+    el_cfg.read = NULL;
+    el_cfg.write = NULL;
+    mid_el = audio_element_init(&el_cfg);
+    TEST_ASSERT_NOT_NULL(mid_el);
+
+    el_cfg.write = _el_write;
+    last_el = audio_element_init(&el_cfg);
+    TEST_ASSERT_NOT_NULL(last_el);
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    audio_pipeline_handle_t pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, first_el, "first"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, mid_el, "mid"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, last_el, "last"));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]){"first", "mid", "last"}, 3));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    vTaskDelay(10000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unlink(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+    vTaskDelay(5000/portTICK_RATE_MS);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(first_el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(mid_el));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(last_el));
+
+}
diff --git a/components/audio_pipeline/test/component.mk b/components/audio_pipeline/test/component.mk
index 5dd172bd..5f441ada 100644
--- a/components/audio_pipeline/test/component.mk
+++ b/components/audio_pipeline/test/component.mk
@@ -1,5 +1,5 @@
-#
-#Component Makefile
-#
-
-COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
+#
+#Component Makefile
+#
+
+COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
diff --git a/components/audio_stream/CMakeLists.txt b/components/audio_stream/CMakeLists.txt
index a65eaa89..5106dfdf 100644
--- a/components/audio_stream/CMakeLists.txt
+++ b/components/audio_stream/CMakeLists.txt
@@ -1,34 +1,34 @@
-set(COMPONENT_SRCS "fatfs_stream.c"
-                    "http_stream.c"
-                    "http_playlist.c"
-                    "raw_stream.c"
-                    "spiffs_stream.c"
-                    "tone_stream.c"
-                    "tcp_client_stream.c"
-                    "embed_flash_stream.c"
-                    "pwm_stream.c")
-set(COMPONENT_ADD_INCLUDEDIRS "include")
-
-set(COMPONENT_PRIV_INCLUDEDIRS "lib/hls/include" "lib/gzip/include")
-list(APPEND COMPONENT_SRCS  "lib/hls/hls_parse.c"
-                            "lib/hls/hls_playlist.c"
-                            "lib/hls/line_reader.c"
-                            "lib/hls/join_path.c")
-
-if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_LESS "5.0")
-    list(APPEND COMPONENT_SRCS  "i2s_stream.c")
-else()
-    list(APPEND COMPONENT_SRCS  "i2s_stream_idf5.c")
-endif()
-
-
-list(APPEND COMPONENT_SRCS  "lib/gzip/gzip_miniz.c")
-
-set(COMPONENT_REQUIRES audio_pipeline driver audio_sal esp_http_client tcp_transport spiffs audio_board esp-adf-libs bootloader_support esp_dispatcher esp_actions tone_partition mbedtls)
-
-if((${IDF_TARGET} STREQUAL "esp32") OR (${IDF_TARGET} STREQUAL "esp32s3") OR (${IDF_TARGET} STREQUAL "esp32p4"))
-    list(APPEND COMPONENT_SRCS "algorithm_stream.c" "tts_stream.c")
-    list(APPEND COMPONENT_REQUIRES esp-sr)
-endif()
-
-register_component()
+set(COMPONENT_SRCS "fatfs_stream.c"
+                    "http_stream.c"
+                    "http_playlist.c"
+                    "raw_stream.c"
+                    "spiffs_stream.c"
+                    "tone_stream.c"
+                    "tcp_client_stream.c"
+                    "embed_flash_stream.c"
+                    "pwm_stream.c")
+set(COMPONENT_ADD_INCLUDEDIRS "include")
+
+set(COMPONENT_PRIV_INCLUDEDIRS "lib/hls/include" "lib/gzip/include")
+list(APPEND COMPONENT_SRCS  "lib/hls/hls_parse.c"
+                            "lib/hls/hls_playlist.c"
+                            "lib/hls/line_reader.c"
+                            "lib/hls/join_path.c")
+
+if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_LESS "5.0")
+    list(APPEND COMPONENT_SRCS  "i2s_stream.c")
+else()
+    list(APPEND COMPONENT_SRCS  "i2s_stream_idf5.c")
+endif()
+
+
+list(APPEND COMPONENT_SRCS  "lib/gzip/gzip_miniz.c")
+
+set(COMPONENT_REQUIRES audio_pipeline driver audio_sal esp_http_client tcp_transport spiffs audio_board esp-adf-libs bootloader_support esp_dispatcher esp_actions tone_partition mbedtls)
+
+if((${IDF_TARGET} STREQUAL "esp32") OR (${IDF_TARGET} STREQUAL "esp32s3") OR (${IDF_TARGET} STREQUAL "esp32p4"))
+    list(APPEND COMPONENT_SRCS "algorithm_stream.c" "tts_stream.c")
+    list(APPEND COMPONENT_REQUIRES esp-sr)
+endif()
+
+register_component()
diff --git a/components/audio_stream/algorithm_stream.c b/components/audio_stream/algorithm_stream.c
index 8caef6fc..f1936786 100644
--- a/components/audio_stream/algorithm_stream.c
+++ b/components/audio_stream/algorithm_stream.c
@@ -1,418 +1,418 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/event_groups.h"
-
-#include "audio_element.h"
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "audio_thread.h"
-#include "esp_log.h"
-
-#include "algorithm_stream.h"
-#include "esp_afe_sr_iface.h"
-#include "esp_afe_sr_models.h"
-
-#ifdef CONFIG_USE_NSNET
-#include "esp_nsn_models.h"
-#include "model_path.h"
-#endif  /* CONFIG_USE_NSNET */
-
-#define ALGORITHM_CHUNK_MAX_SIZE            (1024)
-#define ALGORITHM_FETCH_TASK_STACK_SIZE     (3 * 1024)
-#define ALGORITHM_GET_REFERENCE_TIMEOUT     (32 / portTICK_PERIOD_MS)
-
-static const char *TAG = "ALGORITHM_STREAM";
-
-const int FETCH_STOPPED_BIT = BIT0;
-
-typedef struct {
-    int16_t                      *record;
-    int16_t                      *reference;
-    int16_t                      *aec_buff;
-    int8_t                        algo_mask;
-    int8_t                        mic_ch;
-    bool                          afe_fetch_run;
-    int                           sample_rate;
-    int                           rec_linear_factor;
-    int                           ref_linear_factor;
-    algorithm_stream_input_type_t input_type;
-    const esp_afe_sr_iface_t     *afe_handle;
-    esp_afe_sr_data_t            *afe_data;
-    EventGroupHandle_t            state;
-    bool                          debug_input;
-    bool                          swap_ch;
-    bool                          aec_low_cost;
-    int                           agc_gain;
-#ifdef CONFIG_USE_NSNET
-    srmodel_list_t               *models;
-#endif  /* CONFIG_USE_NSNET */
-} algo_stream_t;
-
-esp_err_t algorithm_mono_fix(uint8_t *sbuff, uint32_t len)
-{
-    int16_t *temp_buf = (int16_t *)sbuff;
-    int16_t temp_box;
-    int k = len >> 1;
-    for (int i = 0; i < k; i += 2) {
-        temp_box = temp_buf[i];
-        temp_buf[i] = temp_buf[i + 1];
-        temp_buf[i + 1] = temp_box;
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _algo_close(audio_element_handle_t self)
-{
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-
-    algo->afe_fetch_run = false;
-
-    /* Feed some data to prevent afe->fetch getting stuck */
-    while (xEventGroupWaitBits(algo->state, FETCH_STOPPED_BIT, false, true, 10 / portTICK_PERIOD_MS) != FETCH_STOPPED_BIT) {
-        algo->afe_handle->feed(algo->afe_data, algo->aec_buff);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _algo_destroy(audio_element_handle_t self)
-{
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-    if (algo->afe_data) {
-        algo->afe_handle->destroy(algo->afe_data);
-        algo->afe_data = NULL;
-    }
-
-    if (algo->aec_buff) {
-        audio_free(algo->aec_buff);
-        algo->aec_buff = NULL;
-    }
-
-    if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE2) {
-        if (algo->record) {
-            audio_free(algo->record);
-            algo->record = NULL;
-        }
-
-        if (algo->reference) {
-            audio_free(algo->reference);
-            algo->reference = NULL;
-        }
-    }
-
-    if (algo->state) {
-        vEventGroupDelete(algo->state);
-    }
-
-#ifdef CONFIG_USE_NSNET
-    if (algo->models) {
-        esp_srmodel_deinit(algo->models);
-    }
-#endif  /* CONFIG_USE_NSNET */
-
-    if (algo) {
-        audio_free(algo);
-        algo = NULL;
-    }
-
-    return ESP_OK;
-}
-
-void _algo_fetch_task(void *pv)
-{
-    audio_element_handle_t self = pv;
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-
-    int afe_chunksize = algo->afe_handle->get_fetch_chunksize(algo->afe_data);
-
-    while (algo->afe_fetch_run && algo->afe_data) {
-        afe_fetch_result_t* res = algo->afe_handle->fetch(algo->afe_data);
-        if (res && res->ret_value != ESP_FAIL) {
-            audio_element_output(self, (char *)res->data, afe_chunksize * sizeof(int16_t));
-            switch (res->vad_state) {
-                case AFE_VAD_SILENCE:
-                    ESP_LOGD(TAG, "VAD state : SILENCE");
-                    break;
-                case AFE_VAD_SPEECH:
-                    ESP_LOGD(TAG, "VAD state : SPEECH");
-                    break;
-            }
-        }
-    }
-
-    ESP_LOGI(TAG, "_algo_fetch_task is stopped");
-    xEventGroupSetBits(algo->state, FETCH_STOPPED_BIT);
-    vTaskDelete(NULL);
-}
-
-static esp_err_t _algo_open(audio_element_handle_t self)
-{
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-    AUDIO_NULL_CHECK(TAG, algo, return ESP_FAIL);
-
-    afe_config_t afe_config = AFE_CONFIG_DEFAULT();
-    afe_config.vad_init = false;
-    afe_config.wakenet_init = false;
-    afe_config.afe_perferred_core = 1;
-    afe_config.afe_perferred_priority = 21;
-    afe_config.memory_alloc_mode = AFE_MEMORY_ALLOC_MORE_PSRAM;
-    afe_config.pcm_config.mic_num = algo->mic_ch;
-    afe_config.pcm_config.ref_num = 1;
-    afe_config.pcm_config.total_ch_num = algo->mic_ch + 1;
-#ifdef CONFIG_USE_NSNET
-    char *model_name = esp_srmodel_filter(algo->models, ESP_NSNET_PREFIX, NULL);
-    afe_config.afe_ns_mode = NS_MODE_NET;
-    afe_config.afe_ns_model_name = model_name;
-#endif  /* CONFIG_USE_NSNET */
-
-    if (!algo->aec_low_cost) {
-        afe_config.pcm_config.sample_rate = algo->sample_rate;
-        afe_config.voice_communication_init = true;
-        algo->afe_handle = &ESP_AFE_VC_HANDLE;
-    } else {
-        algo->afe_handle = &ESP_AFE_SR_HANDLE;
-    }
-
-    if (!(algo->algo_mask & ALGORITHM_STREAM_USE_AEC)) {
-        afe_config.aec_init = false;
-    }
-
-    if (!(algo->algo_mask & ALGORITHM_STREAM_USE_NS)) {
-        afe_config.se_init = false;
-    }
-
-    if (algo->algo_mask & ALGORITHM_STREAM_USE_VAD) {
-        afe_config.vad_init = true;
-    }
-
-    if (algo->algo_mask & ALGORITHM_STREAM_USE_AGC) {
-        afe_config.voice_communication_agc_init = true;
-        afe_config.voice_communication_agc_gain = algo->agc_gain;
-    }
-
-    algo->afe_data = algo->afe_handle->create_from_config(&afe_config);
-    algo->afe_fetch_run = true;
-
-    xEventGroupClearBits(algo->state, FETCH_STOPPED_BIT);
-
-    if (algo->debug_input) {
-        xEventGroupSetBits(algo->state, FETCH_STOPPED_BIT);
-    } else {
-        audio_thread_create(NULL, "algo_fetch", _algo_fetch_task, (void *)self, ALGORITHM_FETCH_TASK_STACK_SIZE,
-                            ALGORITHM_STREAM_TASK_PERIOD, true, ALGORITHM_STREAM_PINNED_TO_CORE);
-    }
-
-    AUDIO_NULL_CHECK(TAG, algo->afe_data, {
-        _algo_close(self);
-        return ESP_FAIL;
-    });
-    return ESP_OK;
-}
-
-static esp_err_t algorithm_data_gain(int16_t *raw_buff, int len, int linear_lfac, int linear_rfac)
-{
-    for (int i = 0; i < len / 4; i++) {
-        raw_buff[i << 1] = raw_buff[i << 1] * linear_lfac;
-        raw_buff[(i << 1) + 1] = raw_buff[(i << 1) + 1] * linear_rfac;
-    }
-    return ESP_OK;
-}
-
-// Swap left and right channels
-static esp_err_t algorithm_data_swap(int16_t *raw_buff, int len)
-{
-    int16_t tmp;
-    for (int i = 0; i < len / 4; i++) {
-        tmp = raw_buff[i << 1];
-        raw_buff[i << 1]         = raw_buff[(i << 1) + 1];
-        raw_buff[(i << 1) + 1]   = tmp;
-    }
-    return ESP_OK;
-}
-
-static int algorithm_data_process_for_type1(audio_element_handle_t self)
-{
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-    int bytes_read = 0;
-
-    int audio_chunksize = algo->afe_handle->get_feed_chunksize(algo->afe_data);
-    int size = audio_chunksize * 2 * sizeof(int16_t);
-
-    bytes_read = audio_element_input(self, (char *)algo->aec_buff, size);
-    if (bytes_read > 0) {
-        if (algo->swap_ch) {
-            algorithm_data_swap((int16_t *)algo->aec_buff, bytes_read);
-        }
-        if (algo->debug_input) {
-            audio_element_output(self, (char *)algo->aec_buff, size);
-        } else {
-            algorithm_data_gain(algo->aec_buff, size, algo->rec_linear_factor, algo->ref_linear_factor);
-            algo->afe_handle->feed(algo->afe_data, algo->aec_buff);
-        }
-    }
-    return bytes_read;
-}
-
-static int algorithm_data_process_for_type2(audio_element_handle_t self)
-{
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-    int bytes_read = 0;
-
-    int audio_chunksize = algo->afe_handle->get_feed_chunksize(algo->afe_data);
-    int size = audio_chunksize * sizeof(int16_t);
-
-    memset(algo->reference, 0, size);
-    bytes_read = audio_element_multi_input(self, (char *)algo->reference, size, 0, ALGORITHM_GET_REFERENCE_TIMEOUT);
-    if (bytes_read == AEL_IO_TIMEOUT) {
-        bytes_read = size;
-    } else if (bytes_read < 0) {
-        return bytes_read;
-    }
-
-    bytes_read = audio_element_input(self, (char *)algo->record, size);
-    if (bytes_read > 0) {
-        int16_t *temp = algo->aec_buff;
-        for (int i = 0; i < (size / 2); i++) {
-            temp[i << 1] = algo->record[i];
-            temp[(i << 1) + 1] = algo->reference[i];
-        }
-
-        if (algo->debug_input) {
-            audio_element_output(self, (char *)algo->aec_buff, 2 * size);
-        } else {
-            algo->afe_handle->feed(algo->afe_data, algo->aec_buff);
-        }
-    }
-    return bytes_read;
-}
-
-static audio_element_err_t _algo_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int ret = ESP_OK;
-    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
-
-    if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE1) {
-        ret = algorithm_data_process_for_type1(self);
-    } else if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE2) {
-        ret = algorithm_data_process_for_type2(self);
-    } else {
-        ESP_LOGE(TAG, "Type %d is not supported", algo->input_type);
-        return AEL_IO_FAIL;
-    }
-    return ret;
-}
-
-audio_element_handle_t algo_stream_init(algorithm_stream_cfg_t *config)
-{
-    AUDIO_NULL_CHECK(TAG, config, return NULL);
-    if ((config->rec_linear_factor <= 0) || (config->ref_linear_factor <= 0)) {
-        ESP_LOGE(TAG, "The linear amplication factor should be greater than 0");
-        return NULL;
-    }
-
-    algo_stream_t *algo = (algo_stream_t *)audio_calloc(1, sizeof(algo_stream_t));
-    AUDIO_NULL_CHECK(TAG, algo, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _algo_open;
-    cfg.close = _algo_close;
-    cfg.process = _algo_process;
-    cfg.destroy = _algo_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.multi_in_rb_num = config->input_type;
-    cfg.stack_in_ext = config->stack_in_ext;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.tag = "algorithm";
-
-    algo->swap_ch = config->swap_ch;
-    algo->agc_gain = config->agc_gain;
-    algo->mic_ch = config->mic_ch;
-    algo->sample_rate = config->sample_rate;
-    algo->input_type = config->input_type;
-    algo->algo_mask = config->algo_mask;
-    algo->aec_low_cost = config->aec_low_cost;
-    algo->rec_linear_factor = config->rec_linear_factor;
-    algo->ref_linear_factor = config->ref_linear_factor;
-    algo->state = xEventGroupCreate();
-    algo->debug_input = config->debug_input;
-    audio_element_handle_t el = audio_element_init(&cfg);
-    AUDIO_NULL_CHECK(TAG, el, {
-        audio_free(algo);
-        return NULL;
-    });
-
-    bool _success = true;
-    _success &= ((algo->aec_buff = audio_calloc(1, 2 * ALGORITHM_CHUNK_MAX_SIZE)) != NULL);
-    if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE2) {
-        _success &= ((algo->record = audio_calloc(1, ALGORITHM_CHUNK_MAX_SIZE)) != NULL);
-        _success &= ((algo->reference = audio_calloc(1, ALGORITHM_CHUNK_MAX_SIZE)) != NULL);
-    }
-
-#ifdef CONFIG_USE_NSNET
-    algo->models = esp_srmodel_init(config->partition_label);
-    if (algo->models != NULL) {
-        for (int i = 0; i < algo->models->num; i++) {
-            ESP_LOGI(TAG, "Load: %s", algo->models->model_name[i]);
-        }
-    } else {
-        ESP_LOGE(TAG, "Failed to load models");
-        _success = false;
-    }
-#endif  /* CONFIG_USE_NSNET */
-
-    AUDIO_NULL_CHECK(TAG, _success, {
-        ESP_LOGE(TAG, "Error occured");
-        _algo_close(el);
-        audio_free(algo);
-        return NULL;
-    });
-
-    audio_element_setdata(el, algo);
-    return el;
-}
-
-audio_element_err_t algo_stream_set_delay(audio_element_handle_t el, ringbuf_handle_t ringbuf, int delay_ms)
-{
-    AUDIO_NULL_CHECK(TAG, el, return ESP_ERR_INVALID_ARG);
-    AUDIO_NULL_CHECK(TAG, ringbuf, return ESP_ERR_INVALID_ARG);
-
-    if (delay_ms > 0) {
-        audio_element_info_t info;
-        audio_element_getinfo(el, &info);
-
-        uint32_t delay_size = delay_ms * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
-        char *in_buffer = (char *)audio_calloc(1, delay_size);
-        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
-        if (rb_write(ringbuf, in_buffer, delay_size, 0) <= 0) {
-            ESP_LOGW(TAG, "Can't set ringbuf delay, please make sure element ringbuf size is enough!");
-        }
-        audio_free(in_buffer);
-    }
-
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/event_groups.h"
+
+#include "audio_element.h"
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "audio_thread.h"
+#include "esp_log.h"
+
+#include "algorithm_stream.h"
+#include "esp_afe_sr_iface.h"
+#include "esp_afe_sr_models.h"
+
+#ifdef CONFIG_USE_NSNET
+#include "esp_nsn_models.h"
+#include "model_path.h"
+#endif  /* CONFIG_USE_NSNET */
+
+#define ALGORITHM_CHUNK_MAX_SIZE            (1024)
+#define ALGORITHM_FETCH_TASK_STACK_SIZE     (3 * 1024)
+#define ALGORITHM_GET_REFERENCE_TIMEOUT     (32 / portTICK_PERIOD_MS)
+
+static const char *TAG = "ALGORITHM_STREAM";
+
+const int FETCH_STOPPED_BIT = BIT0;
+
+typedef struct {
+    int16_t                      *record;
+    int16_t                      *reference;
+    int16_t                      *aec_buff;
+    int8_t                        algo_mask;
+    int8_t                        mic_ch;
+    bool                          afe_fetch_run;
+    int                           sample_rate;
+    int                           rec_linear_factor;
+    int                           ref_linear_factor;
+    algorithm_stream_input_type_t input_type;
+    const esp_afe_sr_iface_t     *afe_handle;
+    esp_afe_sr_data_t            *afe_data;
+    EventGroupHandle_t            state;
+    bool                          debug_input;
+    bool                          swap_ch;
+    bool                          aec_low_cost;
+    int                           agc_gain;
+#ifdef CONFIG_USE_NSNET
+    srmodel_list_t               *models;
+#endif  /* CONFIG_USE_NSNET */
+} algo_stream_t;
+
+esp_err_t algorithm_mono_fix(uint8_t *sbuff, uint32_t len)
+{
+    int16_t *temp_buf = (int16_t *)sbuff;
+    int16_t temp_box;
+    int k = len >> 1;
+    for (int i = 0; i < k; i += 2) {
+        temp_box = temp_buf[i];
+        temp_buf[i] = temp_buf[i + 1];
+        temp_buf[i + 1] = temp_box;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _algo_close(audio_element_handle_t self)
+{
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+
+    algo->afe_fetch_run = false;
+
+    /* Feed some data to prevent afe->fetch getting stuck */
+    while (xEventGroupWaitBits(algo->state, FETCH_STOPPED_BIT, false, true, 10 / portTICK_PERIOD_MS) != FETCH_STOPPED_BIT) {
+        algo->afe_handle->feed(algo->afe_data, algo->aec_buff);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _algo_destroy(audio_element_handle_t self)
+{
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+    if (algo->afe_data) {
+        algo->afe_handle->destroy(algo->afe_data);
+        algo->afe_data = NULL;
+    }
+
+    if (algo->aec_buff) {
+        audio_free(algo->aec_buff);
+        algo->aec_buff = NULL;
+    }
+
+    if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE2) {
+        if (algo->record) {
+            audio_free(algo->record);
+            algo->record = NULL;
+        }
+
+        if (algo->reference) {
+            audio_free(algo->reference);
+            algo->reference = NULL;
+        }
+    }
+
+    if (algo->state) {
+        vEventGroupDelete(algo->state);
+    }
+
+#ifdef CONFIG_USE_NSNET
+    if (algo->models) {
+        esp_srmodel_deinit(algo->models);
+    }
+#endif  /* CONFIG_USE_NSNET */
+
+    if (algo) {
+        audio_free(algo);
+        algo = NULL;
+    }
+
+    return ESP_OK;
+}
+
+void _algo_fetch_task(void *pv)
+{
+    audio_element_handle_t self = pv;
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+
+    int afe_chunksize = algo->afe_handle->get_fetch_chunksize(algo->afe_data);
+
+    while (algo->afe_fetch_run && algo->afe_data) {
+        afe_fetch_result_t* res = algo->afe_handle->fetch(algo->afe_data);
+        if (res && res->ret_value != ESP_FAIL) {
+            audio_element_output(self, (char *)res->data, afe_chunksize * sizeof(int16_t));
+            switch (res->vad_state) {
+                case AFE_VAD_SILENCE:
+                    ESP_LOGD(TAG, "VAD state : SILENCE");
+                    break;
+                case AFE_VAD_SPEECH:
+                    ESP_LOGD(TAG, "VAD state : SPEECH");
+                    break;
+            }
+        }
+    }
+
+    ESP_LOGI(TAG, "_algo_fetch_task is stopped");
+    xEventGroupSetBits(algo->state, FETCH_STOPPED_BIT);
+    vTaskDelete(NULL);
+}
+
+static esp_err_t _algo_open(audio_element_handle_t self)
+{
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+    AUDIO_NULL_CHECK(TAG, algo, return ESP_FAIL);
+
+    afe_config_t afe_config = AFE_CONFIG_DEFAULT();
+    afe_config.vad_init = false;
+    afe_config.wakenet_init = false;
+    afe_config.afe_perferred_core = 1;
+    afe_config.afe_perferred_priority = 21;
+    afe_config.memory_alloc_mode = AFE_MEMORY_ALLOC_MORE_PSRAM;
+    afe_config.pcm_config.mic_num = algo->mic_ch;
+    afe_config.pcm_config.ref_num = 1;
+    afe_config.pcm_config.total_ch_num = algo->mic_ch + 1;
+#ifdef CONFIG_USE_NSNET
+    char *model_name = esp_srmodel_filter(algo->models, ESP_NSNET_PREFIX, NULL);
+    afe_config.afe_ns_mode = NS_MODE_NET;
+    afe_config.afe_ns_model_name = model_name;
+#endif  /* CONFIG_USE_NSNET */
+
+    if (!algo->aec_low_cost) {
+        afe_config.pcm_config.sample_rate = algo->sample_rate;
+        afe_config.voice_communication_init = true;
+        algo->afe_handle = &ESP_AFE_VC_HANDLE;
+    } else {
+        algo->afe_handle = &ESP_AFE_SR_HANDLE;
+    }
+
+    if (!(algo->algo_mask & ALGORITHM_STREAM_USE_AEC)) {
+        afe_config.aec_init = false;
+    }
+
+    if (!(algo->algo_mask & ALGORITHM_STREAM_USE_NS)) {
+        afe_config.se_init = false;
+    }
+
+    if (algo->algo_mask & ALGORITHM_STREAM_USE_VAD) {
+        afe_config.vad_init = true;
+    }
+
+    if (algo->algo_mask & ALGORITHM_STREAM_USE_AGC) {
+        afe_config.voice_communication_agc_init = true;
+        afe_config.voice_communication_agc_gain = algo->agc_gain;
+    }
+
+    algo->afe_data = algo->afe_handle->create_from_config(&afe_config);
+    algo->afe_fetch_run = true;
+
+    xEventGroupClearBits(algo->state, FETCH_STOPPED_BIT);
+
+    if (algo->debug_input) {
+        xEventGroupSetBits(algo->state, FETCH_STOPPED_BIT);
+    } else {
+        audio_thread_create(NULL, "algo_fetch", _algo_fetch_task, (void *)self, ALGORITHM_FETCH_TASK_STACK_SIZE,
+                            ALGORITHM_STREAM_TASK_PERIOD, true, ALGORITHM_STREAM_PINNED_TO_CORE);
+    }
+
+    AUDIO_NULL_CHECK(TAG, algo->afe_data, {
+        _algo_close(self);
+        return ESP_FAIL;
+    });
+    return ESP_OK;
+}
+
+static esp_err_t algorithm_data_gain(int16_t *raw_buff, int len, int linear_lfac, int linear_rfac)
+{
+    for (int i = 0; i < len / 4; i++) {
+        raw_buff[i << 1] = raw_buff[i << 1] * linear_lfac;
+        raw_buff[(i << 1) + 1] = raw_buff[(i << 1) + 1] * linear_rfac;
+    }
+    return ESP_OK;
+}
+
+// Swap left and right channels
+static esp_err_t algorithm_data_swap(int16_t *raw_buff, int len)
+{
+    int16_t tmp;
+    for (int i = 0; i < len / 4; i++) {
+        tmp = raw_buff[i << 1];
+        raw_buff[i << 1]         = raw_buff[(i << 1) + 1];
+        raw_buff[(i << 1) + 1]   = tmp;
+    }
+    return ESP_OK;
+}
+
+static int algorithm_data_process_for_type1(audio_element_handle_t self)
+{
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+    int bytes_read = 0;
+
+    int audio_chunksize = algo->afe_handle->get_feed_chunksize(algo->afe_data);
+    int size = audio_chunksize * 2 * sizeof(int16_t);
+
+    bytes_read = audio_element_input(self, (char *)algo->aec_buff, size);
+    if (bytes_read > 0) {
+        if (algo->swap_ch) {
+            algorithm_data_swap((int16_t *)algo->aec_buff, bytes_read);
+        }
+        if (algo->debug_input) {
+            audio_element_output(self, (char *)algo->aec_buff, size);
+        } else {
+            algorithm_data_gain(algo->aec_buff, size, algo->rec_linear_factor, algo->ref_linear_factor);
+            algo->afe_handle->feed(algo->afe_data, algo->aec_buff);
+        }
+    }
+    return bytes_read;
+}
+
+static int algorithm_data_process_for_type2(audio_element_handle_t self)
+{
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+    int bytes_read = 0;
+
+    int audio_chunksize = algo->afe_handle->get_feed_chunksize(algo->afe_data);
+    int size = audio_chunksize * sizeof(int16_t);
+
+    memset(algo->reference, 0, size);
+    bytes_read = audio_element_multi_input(self, (char *)algo->reference, size, 0, ALGORITHM_GET_REFERENCE_TIMEOUT);
+    if (bytes_read == AEL_IO_TIMEOUT) {
+        bytes_read = size;
+    } else if (bytes_read < 0) {
+        return bytes_read;
+    }
+
+    bytes_read = audio_element_input(self, (char *)algo->record, size);
+    if (bytes_read > 0) {
+        int16_t *temp = algo->aec_buff;
+        for (int i = 0; i < (size / 2); i++) {
+            temp[i << 1] = algo->record[i];
+            temp[(i << 1) + 1] = algo->reference[i];
+        }
+
+        if (algo->debug_input) {
+            audio_element_output(self, (char *)algo->aec_buff, 2 * size);
+        } else {
+            algo->afe_handle->feed(algo->afe_data, algo->aec_buff);
+        }
+    }
+    return bytes_read;
+}
+
+static audio_element_err_t _algo_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int ret = ESP_OK;
+    algo_stream_t *algo = (algo_stream_t *)audio_element_getdata(self);
+
+    if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE1) {
+        ret = algorithm_data_process_for_type1(self);
+    } else if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE2) {
+        ret = algorithm_data_process_for_type2(self);
+    } else {
+        ESP_LOGE(TAG, "Type %d is not supported", algo->input_type);
+        return AEL_IO_FAIL;
+    }
+    return ret;
+}
+
+audio_element_handle_t algo_stream_init(algorithm_stream_cfg_t *config)
+{
+    AUDIO_NULL_CHECK(TAG, config, return NULL);
+    if ((config->rec_linear_factor <= 0) || (config->ref_linear_factor <= 0)) {
+        ESP_LOGE(TAG, "The linear amplication factor should be greater than 0");
+        return NULL;
+    }
+
+    algo_stream_t *algo = (algo_stream_t *)audio_calloc(1, sizeof(algo_stream_t));
+    AUDIO_NULL_CHECK(TAG, algo, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _algo_open;
+    cfg.close = _algo_close;
+    cfg.process = _algo_process;
+    cfg.destroy = _algo_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.multi_in_rb_num = config->input_type;
+    cfg.stack_in_ext = config->stack_in_ext;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.tag = "algorithm";
+
+    algo->swap_ch = config->swap_ch;
+    algo->agc_gain = config->agc_gain;
+    algo->mic_ch = config->mic_ch;
+    algo->sample_rate = config->sample_rate;
+    algo->input_type = config->input_type;
+    algo->algo_mask = config->algo_mask;
+    algo->aec_low_cost = config->aec_low_cost;
+    algo->rec_linear_factor = config->rec_linear_factor;
+    algo->ref_linear_factor = config->ref_linear_factor;
+    algo->state = xEventGroupCreate();
+    algo->debug_input = config->debug_input;
+    audio_element_handle_t el = audio_element_init(&cfg);
+    AUDIO_NULL_CHECK(TAG, el, {
+        audio_free(algo);
+        return NULL;
+    });
+
+    bool _success = true;
+    _success &= ((algo->aec_buff = audio_calloc(1, 2 * ALGORITHM_CHUNK_MAX_SIZE)) != NULL);
+    if (algo->input_type == ALGORITHM_STREAM_INPUT_TYPE2) {
+        _success &= ((algo->record = audio_calloc(1, ALGORITHM_CHUNK_MAX_SIZE)) != NULL);
+        _success &= ((algo->reference = audio_calloc(1, ALGORITHM_CHUNK_MAX_SIZE)) != NULL);
+    }
+
+#ifdef CONFIG_USE_NSNET
+    algo->models = esp_srmodel_init(config->partition_label);
+    if (algo->models != NULL) {
+        for (int i = 0; i < algo->models->num; i++) {
+            ESP_LOGI(TAG, "Load: %s", algo->models->model_name[i]);
+        }
+    } else {
+        ESP_LOGE(TAG, "Failed to load models");
+        _success = false;
+    }
+#endif  /* CONFIG_USE_NSNET */
+
+    AUDIO_NULL_CHECK(TAG, _success, {
+        ESP_LOGE(TAG, "Error occured");
+        _algo_close(el);
+        audio_free(algo);
+        return NULL;
+    });
+
+    audio_element_setdata(el, algo);
+    return el;
+}
+
+audio_element_err_t algo_stream_set_delay(audio_element_handle_t el, ringbuf_handle_t ringbuf, int delay_ms)
+{
+    AUDIO_NULL_CHECK(TAG, el, return ESP_ERR_INVALID_ARG);
+    AUDIO_NULL_CHECK(TAG, ringbuf, return ESP_ERR_INVALID_ARG);
+
+    if (delay_ms > 0) {
+        audio_element_info_t info;
+        audio_element_getinfo(el, &info);
+
+        uint32_t delay_size = delay_ms * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
+        char *in_buffer = (char *)audio_calloc(1, delay_size);
+        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
+        if (rb_write(ringbuf, in_buffer, delay_size, 0) <= 0) {
+            ESP_LOGW(TAG, "Can't set ringbuf delay, please make sure element ringbuf size is enough!");
+        }
+        audio_free(in_buffer);
+    }
+
+    return ESP_OK;
+}
diff --git a/components/audio_stream/component.mk b/components/audio_stream/component.mk
index d3600606..d6d843f5 100644
--- a/components/audio_stream/component.mk
+++ b/components/audio_stream/component.mk
@@ -1,6 +1,6 @@
-#
-# "main" pseudo-component makefile.
-#
-COMPONENT_ADD_INCLUDEDIRS := ./include
-COMPONENT_SRCDIRS := . ./lib/hls ./lib/gzip
-COMPONENT_PRIV_INCLUDEDIRS := ./lib/hls/include ./lib/gzip/include
+#
+# "main" pseudo-component makefile.
+#
+COMPONENT_ADD_INCLUDEDIRS := ./include
+COMPONENT_SRCDIRS := . ./lib/hls ./lib/gzip
+COMPONENT_PRIV_INCLUDEDIRS := ./lib/hls/include ./lib/gzip/include
diff --git a/components/audio_stream/embed_flash_stream.c b/components/audio_stream/embed_flash_stream.c
index 346fbd18..3740f78e 100644
--- a/components/audio_stream/embed_flash_stream.c
+++ b/components/audio_stream/embed_flash_stream.c
@@ -1,193 +1,193 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "embed_flash_stream.h"
-
-static const char * const TAG = "EMBED_FLASH_STREAM";
-
-#define EMBED_MAX_FILES   (2)   // 2 bytes, which means 100 files can be saved(10 * 10)
-#define EMBED_PREFIX_STR  "embed://tone/"
-
-/**
- * @brief   Embed status information
- */
-typedef struct embed_flash_s {
-    audio_stream_type_t    type;
-    bool                   is_open;
-    int                    cur_index;
-    embed_item_info_t      *info;
-} embed_flash_stream_t;
-
-static esp_err_t _embed_open(audio_element_handle_t self)
-{
-    embed_flash_stream_t *stream = (embed_flash_stream_t *)audio_element_getdata(self);
-    if (stream->is_open) {
-        ESP_LOGE(TAG, "already opened");
-        return ESP_FAIL;
-    }
-    if (stream->info == NULL) {
-        ESP_LOGE(TAG, "please call embed_flash_stream_set_context function first");
-        return ESP_FAIL;
-    }
-    char *url = audio_element_get_uri(self);
-    url += strlen(EMBED_PREFIX_STR);
-    char *temp = strchr(url, '_');
-    char find_num[EMBED_MAX_FILES] = { 0 };
-    int file_index = 0;
-    if (temp != NULL) {
-        strncpy(find_num, url, temp - url);
-        file_index = strtoul(find_num, 0, 10);
-        ESP_LOGD(TAG, "Wanted read flash tone index is %d", file_index);
-    } else {
-        ESP_LOGE(TAG, "Embed flash file name is not correct!");
-        return ESP_FAIL;
-    }
-    stream->cur_index = file_index;
-    audio_element_info_t info = { 0 };
-    info.total_bytes = stream->info[stream->cur_index].size;
-    audio_element_setdata(self, stream);
-    audio_element_set_total_bytes(self, info.total_bytes);
-
-    stream->is_open = true;
-    return ESP_OK;
-}
-
-static int _embed_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    audio_element_info_t info = { 0 };
-    embed_flash_stream_t *stream = NULL;
-
-    stream = (embed_flash_stream_t *)audio_element_getdata(self);
-    audio_element_getinfo(self, &info);
-    if (info.byte_pos + len > info.total_bytes) {
-        len = info.total_bytes - info.byte_pos;
-    }
-    if (len <= 0) {
-        ESP_LOGW(TAG, "No more data,ret:%d ,info.byte_pos:%llu", len, info.byte_pos);
-        return ESP_OK;
-    }
-    memcpy(buffer, stream->info[stream->cur_index].address + info.byte_pos, len);
-
-    audio_element_update_byte_pos(self, len);
-    ESP_LOGD(TAG, "req lengh=%d, pos=%d/%d", len, (int)info.byte_pos, (int)info.total_bytes);
-
-    return len;
-}
-
-static int _embed_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _embed_close(audio_element_handle_t self)
-{
-    embed_flash_stream_t *stream = (embed_flash_stream_t *)audio_element_getdata(self);
-    if (stream->is_open) {
-       stream->is_open = false;
-    }
-    audio_element_set_byte_pos(self, 0);
-    return ESP_OK;
-}
-
-static esp_err_t _embed_destroy(audio_element_handle_t self)
-{
-    embed_flash_stream_t *stream = (embed_flash_stream_t *)audio_element_getdata(self);
-    if (stream->info) {
-        audio_free(stream->info);
-    }
-    audio_free(stream);
-    return ESP_OK;
-}
-
-audio_element_handle_t embed_flash_stream_init(embed_flash_stream_cfg_t *config)
-{
-    audio_element_handle_t el;
-    embed_flash_stream_t *stream = audio_calloc(1, sizeof(embed_flash_stream_t));
-    AUDIO_MEM_CHECK(TAG, stream, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _embed_open;
-    cfg.close = _embed_close;
-    cfg.process = _embed_process;
-    cfg.destroy = _embed_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.buffer_len = config->buf_sz;
-    if (config->extern_stack == true) {
-        ESP_LOGW(TAG, "Just support %s task stack on internal memory\n \
-        will remove task on internal memory", "embed flash task");
-        config->extern_stack = false;
-    }
-    cfg.tag = "embed";
-
-    cfg.read = _embed_read;
-    el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, goto __exit);
-    audio_element_setdata(el, stream);
-    return el;
-
-__exit:
-    audio_free(stream);
-    stream = NULL;
-    return NULL;
-}
-
-esp_err_t  embed_flash_stream_set_context(audio_element_handle_t embed_stream, const embed_item_info_t *context, int max_num)
-{
-    AUDIO_MEM_CHECK(TAG, context, return ESP_FAIL);
-    embed_flash_stream_t *stream = NULL;
-    int max_can_saved_num = 1;
-    stream = (embed_flash_stream_t *)audio_element_getdata(embed_stream);
-
-    for (size_t i = 0; i < EMBED_MAX_FILES; i++) {
-        max_can_saved_num *= 10;
-    }
-
-    if (max_num > max_can_saved_num) {
-        ESP_LOGW(TAG, "The maximum storage quantity is exceeded. It is recommended to modify the `EMBED_MAX_FILES` value");
-        return ESP_FAIL;
-    }
-
-    if (stream->info) {
-        audio_free(stream->info);
-    }
-    stream->info = audio_calloc(max_num, sizeof(embed_item_info_t));
-    AUDIO_MEM_CHECK(TAG, stream->info, return ESP_FAIL);
-    memcpy(stream->info, context, sizeof(embed_item_info_t) * max_num);
-
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "embed_flash_stream.h"
+
+static const char * const TAG = "EMBED_FLASH_STREAM";
+
+#define EMBED_MAX_FILES   (2)   // 2 bytes, which means 100 files can be saved(10 * 10)
+#define EMBED_PREFIX_STR  "embed://tone/"
+
+/**
+ * @brief   Embed status information
+ */
+typedef struct embed_flash_s {
+    audio_stream_type_t    type;
+    bool                   is_open;
+    int                    cur_index;
+    embed_item_info_t      *info;
+} embed_flash_stream_t;
+
+static esp_err_t _embed_open(audio_element_handle_t self)
+{
+    embed_flash_stream_t *stream = (embed_flash_stream_t *)audio_element_getdata(self);
+    if (stream->is_open) {
+        ESP_LOGE(TAG, "already opened");
+        return ESP_FAIL;
+    }
+    if (stream->info == NULL) {
+        ESP_LOGE(TAG, "please call embed_flash_stream_set_context function first");
+        return ESP_FAIL;
+    }
+    char *url = audio_element_get_uri(self);
+    url += strlen(EMBED_PREFIX_STR);
+    char *temp = strchr(url, '_');
+    char find_num[EMBED_MAX_FILES] = { 0 };
+    int file_index = 0;
+    if (temp != NULL) {
+        strncpy(find_num, url, temp - url);
+        file_index = strtoul(find_num, 0, 10);
+        ESP_LOGD(TAG, "Wanted read flash tone index is %d", file_index);
+    } else {
+        ESP_LOGE(TAG, "Embed flash file name is not correct!");
+        return ESP_FAIL;
+    }
+    stream->cur_index = file_index;
+    audio_element_info_t info = { 0 };
+    info.total_bytes = stream->info[stream->cur_index].size;
+    audio_element_setdata(self, stream);
+    audio_element_set_total_bytes(self, info.total_bytes);
+
+    stream->is_open = true;
+    return ESP_OK;
+}
+
+static int _embed_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    audio_element_info_t info = { 0 };
+    embed_flash_stream_t *stream = NULL;
+
+    stream = (embed_flash_stream_t *)audio_element_getdata(self);
+    audio_element_getinfo(self, &info);
+    if (info.byte_pos + len > info.total_bytes) {
+        len = info.total_bytes - info.byte_pos;
+    }
+    if (len <= 0) {
+        ESP_LOGW(TAG, "No more data,ret:%d ,info.byte_pos:%llu", len, info.byte_pos);
+        return ESP_OK;
+    }
+    memcpy(buffer, stream->info[stream->cur_index].address + info.byte_pos, len);
+
+    audio_element_update_byte_pos(self, len);
+    ESP_LOGD(TAG, "req lengh=%d, pos=%d/%d", len, (int)info.byte_pos, (int)info.total_bytes);
+
+    return len;
+}
+
+static int _embed_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _embed_close(audio_element_handle_t self)
+{
+    embed_flash_stream_t *stream = (embed_flash_stream_t *)audio_element_getdata(self);
+    if (stream->is_open) {
+       stream->is_open = false;
+    }
+    audio_element_set_byte_pos(self, 0);
+    return ESP_OK;
+}
+
+static esp_err_t _embed_destroy(audio_element_handle_t self)
+{
+    embed_flash_stream_t *stream = (embed_flash_stream_t *)audio_element_getdata(self);
+    if (stream->info) {
+        audio_free(stream->info);
+    }
+    audio_free(stream);
+    return ESP_OK;
+}
+
+audio_element_handle_t embed_flash_stream_init(embed_flash_stream_cfg_t *config)
+{
+    audio_element_handle_t el;
+    embed_flash_stream_t *stream = audio_calloc(1, sizeof(embed_flash_stream_t));
+    AUDIO_MEM_CHECK(TAG, stream, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _embed_open;
+    cfg.close = _embed_close;
+    cfg.process = _embed_process;
+    cfg.destroy = _embed_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.buffer_len = config->buf_sz;
+    if (config->extern_stack == true) {
+        ESP_LOGW(TAG, "Just support %s task stack on internal memory\n \
+        will remove task on internal memory", "embed flash task");
+        config->extern_stack = false;
+    }
+    cfg.tag = "embed";
+
+    cfg.read = _embed_read;
+    el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, goto __exit);
+    audio_element_setdata(el, stream);
+    return el;
+
+__exit:
+    audio_free(stream);
+    stream = NULL;
+    return NULL;
+}
+
+esp_err_t  embed_flash_stream_set_context(audio_element_handle_t embed_stream, const embed_item_info_t *context, int max_num)
+{
+    AUDIO_MEM_CHECK(TAG, context, return ESP_FAIL);
+    embed_flash_stream_t *stream = NULL;
+    int max_can_saved_num = 1;
+    stream = (embed_flash_stream_t *)audio_element_getdata(embed_stream);
+
+    for (size_t i = 0; i < EMBED_MAX_FILES; i++) {
+        max_can_saved_num *= 10;
+    }
+
+    if (max_num > max_can_saved_num) {
+        ESP_LOGW(TAG, "The maximum storage quantity is exceeded. It is recommended to modify the `EMBED_MAX_FILES` value");
+        return ESP_FAIL;
+    }
+
+    if (stream->info) {
+        audio_free(stream->info);
+    }
+    stream->info = audio_calloc(max_num, sizeof(embed_item_info_t));
+    AUDIO_MEM_CHECK(TAG, stream->info, return ESP_FAIL);
+    memcpy(stream->info, context, sizeof(embed_item_info_t) * max_num);
+
+    return ESP_OK;
+}
diff --git a/components/audio_stream/fatfs_stream.c b/components/audio_stream/fatfs_stream.c
index 4afe8f4f..07a7be78 100644
--- a/components/audio_stream/fatfs_stream.c
+++ b/components/audio_stream/fatfs_stream.c
@@ -1,303 +1,303 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <sys/unistd.h>
-#include <sys/stat.h>
-#include <stdio.h>
-#include <string.h>
-#include "errno.h"
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-
-#include "fatfs_stream.h"
-#include "audio_common.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "wav_head.h"
-#include "esp_log.h"
-#include "unistd.h"
-#include "fcntl.h"
-
-#define FILE_WAV_SUFFIX_TYPE  "wav"
-#define FILE_OPUS_SUFFIX_TYPE "opus"
-#define FILE_AMR_SUFFIX_TYPE "amr"
-#define FILE_AMRWB_SUFFIX_TYPE "Wamr"
-
-static const char *TAG = "FATFS_STREAM";
-
-typedef enum {
-    STREAM_TYPE_UNKNOW,
-    STREAM_TYPE_WAV,
-    STREAM_TYPE_OPUS,
-    STREAM_TYPE_AMR,
-    STREAM_TYPE_AMRWB,
-} wr_stream_type_t;
-
-typedef struct fatfs_stream {
-    audio_stream_type_t type;
-    int block_size;
-    bool is_open;
-    int file;
-    wr_stream_type_t w_type;
-    bool write_header;
-} fatfs_stream_t;
-
-
-static wr_stream_type_t get_type(const char *str)
-{
-    char *relt = strrchr(str, '.');
-    if (relt != NULL) {
-        relt ++;
-        ESP_LOGD(TAG, "result = %s", relt);
-        if (strncasecmp(relt, FILE_WAV_SUFFIX_TYPE, 3) == 0) {
-            return STREAM_TYPE_WAV;
-        } else if (strncasecmp(relt, FILE_OPUS_SUFFIX_TYPE, 4) == 0) {
-            return STREAM_TYPE_OPUS;
-        } else if (strncasecmp(relt, FILE_AMR_SUFFIX_TYPE, 3) == 0) {
-            return STREAM_TYPE_AMR;
-        } else if (strncasecmp(relt, FILE_AMRWB_SUFFIX_TYPE, 4) == 0) {
-            return STREAM_TYPE_AMRWB;
-        } else {
-            return STREAM_TYPE_UNKNOW;
-        }
-    } else {
-        return STREAM_TYPE_UNKNOW;
-    }
-}
-
-static char* get_mount_path(char* uri) 
-{
-    /* support format: /sdcard, /spiffs, /storage etc ... */
-    if (uri[0] == '/') return uri;
-
-    /* support format: scheme://basepath... */
-    char *skip_scheme = strstr(uri, "://");
-    if (skip_scheme == NULL) return NULL;
-    skip_scheme += 2;
-
-    /* support format: scheme:///basepath... */
-    if (skip_scheme[1] == '/') skip_scheme++;
-
-    return skip_scheme;
-}
-
-static esp_err_t _fatfs_open(audio_element_handle_t self)
-{
-    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
-
-    if (fatfs->is_open) {
-        ESP_LOGE(TAG, "already opened");
-        return ESP_FAIL;
-    }
-
-    audio_element_info_t info;
-    char *uri = audio_element_get_uri(self);
-    if (uri == NULL) {
-        ESP_LOGE(TAG, "Error, uri is not set");
-        return ESP_FAIL;
-    }
-    ESP_LOGD(TAG, "_fatfs_open, uri:%s", uri);
-    char *path = get_mount_path(uri);
-    if (path == NULL) {
-        ESP_LOGE(TAG, "Error, Invalid file format (%s).", uri);
-        return ESP_FAIL;
-    }
-
-    audio_element_getinfo(self, &info);
-
-    if (fatfs->type == AUDIO_STREAM_READER) {
-        fatfs->file = open(path, O_RDONLY);
-        if (fatfs->file == -1) {
-            ESP_LOGE(TAG, "Failed to open. File name: %s, error message: %s, line: %d", path, strerror(errno), __LINE__);
-            return ESP_FAIL;
-        }
-        struct stat siz =  { 0 };
-        stat(path, &siz);
-        info.total_bytes = siz.st_size;
-        ESP_LOGI(TAG, "File size: %d byte, file position: %d", (int)siz.st_size, (int)info.byte_pos);
-        if (info.byte_pos > 0) {
-            if (lseek(fatfs->file, info.byte_pos, SEEK_SET) < 0) {
-                ESP_LOGE(TAG, "Error seek file. Error message: %s, line: %d", strerror(errno), __LINE__);
-                return ESP_FAIL;
-            }
-        }
-    } else if (fatfs->type == AUDIO_STREAM_WRITER) {
-        fatfs->file = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
-        if (fatfs->file == -1) {
-            ESP_LOGE(TAG, "Failed to open. File name: %s, error message: %s, line: %d", path, strerror(errno), __LINE__);
-            return ESP_FAIL;
-        }
-        fatfs->w_type =  get_type(path);
-        if ((STREAM_TYPE_WAV == fatfs->w_type) && (fatfs->write_header == true)) {
-            wav_header_t info = {0};
-            write(fatfs->file, &info, sizeof(wav_header_t));
-            fsync(fatfs->file);
-        } else if ((STREAM_TYPE_AMR == fatfs->w_type) && (fatfs->write_header == true)) {
-            write(fatfs->file, "#!AMR\n", 6);
-            fsync(fatfs->file);
-        } else if ((STREAM_TYPE_AMRWB == fatfs->w_type) && (fatfs->write_header == true)) {
-            write(fatfs->file, "#!AMR-WB\n", 9);
-            fsync(fatfs->file);
-        }
-    } else {
-        ESP_LOGE(TAG, "FATFS must be Reader or Writer");
-        return ESP_FAIL;
-    }
-    fatfs->is_open = true;
-    int ret = audio_element_set_total_bytes(self, info.total_bytes);
-    return ret;
-}
-
-static int _fatfs_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-
-    ESP_LOGD(TAG, "read len=%d, pos=%d/%d", len, (int)info.byte_pos, (int)info.total_bytes);
-    /* use file descriptors to access files */
-    int rlen = read(fatfs->file, buffer, len);
-    if (rlen == 0) {
-        ESP_LOGW(TAG, "No more data, ret:%d", rlen);
-    } else if (rlen == -1) {
-        ESP_LOGE(TAG, "The error is happened in reading data. Error message: %s", strerror(errno));
-    } else {
-        audio_element_update_byte_pos(self, rlen);
-    }
-    return rlen;
-}
-
-static int _fatfs_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-    int wlen =  write(fatfs->file, buffer, len);
-    fsync(fatfs->file);
-    if (wlen > 0) {
-        audio_element_update_byte_pos(self, wlen);
-    } if (wlen == -1) {
-        ESP_LOGE(TAG, "The error is happened in writing data. Error message: %s", strerror(errno));
-    }
-
-    return wlen;
-}
-
-static int _fatfs_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _fatfs_close(audio_element_handle_t self)
-{
-    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
-
-    if (AUDIO_STREAM_WRITER == fatfs->type
-        && (-1 != fatfs->file)
-        && (true == fatfs->write_header)
-        && STREAM_TYPE_WAV == fatfs->w_type) {
-        wav_header_t *wav_info = (wav_header_t *) audio_malloc(sizeof(wav_header_t));
-
-        AUDIO_MEM_CHECK(TAG, wav_info, return ESP_ERR_NO_MEM);
-
-        if (lseek(fatfs->file, 0, SEEK_SET) < 0) {
-            ESP_LOGE(TAG, "Error seek file. Error message: %s, line: %d", strerror(errno), __LINE__);
-        }
-        audio_element_info_t info;
-        audio_element_getinfo(self, &info);
-        wav_head_init(wav_info, info.sample_rates, info.bits, info.channels);
-        wav_head_size(wav_info, (uint32_t)info.byte_pos);
-        write(fatfs->file, wav_info, sizeof(wav_header_t));
-        fsync(fatfs->file);
-        audio_free(wav_info);
-    }
-
-    if (fatfs->is_open) {
-        close(fatfs->file);
-        fatfs->is_open = false;
-    }
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_report_info(self);
-        audio_element_set_byte_pos(self, 0);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _fatfs_destroy(audio_element_handle_t self)
-{
-    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
-    audio_free(fatfs);
-    return ESP_OK;
-}
-
-// Example of using an audio element - START
-audio_element_handle_t fatfs_stream_init(fatfs_stream_cfg_t *config)
-{
-    audio_element_handle_t el;
-    fatfs_stream_t *fatfs = audio_calloc(1, sizeof(fatfs_stream_t));
-    AUDIO_MEM_CHECK(TAG, fatfs, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _fatfs_open;
-    cfg.close = _fatfs_close;
-    cfg.process = _fatfs_process;
-    cfg.destroy = _fatfs_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.buffer_len = config->buf_sz;
-    cfg.stack_in_ext = config->ext_stack;
-    if (cfg.buffer_len == 0) {
-        cfg.buffer_len = FATFS_STREAM_BUF_SIZE;
-    }
-
-    cfg.tag = "file";
-    fatfs->type = config->type;
-    fatfs->write_header = config->write_header;
-
-    if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _fatfs_write;
-    } else {
-        cfg.read = _fatfs_read;
-    }
-    el = audio_element_init(&cfg);
-
-    AUDIO_MEM_CHECK(TAG, el, goto _fatfs_init_exit);
-    audio_element_setdata(el, fatfs);
-    return el;
-_fatfs_init_exit:
-    audio_free(fatfs);
-    return NULL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <sys/unistd.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include "errno.h"
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+
+#include "fatfs_stream.h"
+#include "audio_common.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "wav_head.h"
+#include "esp_log.h"
+#include "unistd.h"
+#include "fcntl.h"
+
+#define FILE_WAV_SUFFIX_TYPE  "wav"
+#define FILE_OPUS_SUFFIX_TYPE "opus"
+#define FILE_AMR_SUFFIX_TYPE "amr"
+#define FILE_AMRWB_SUFFIX_TYPE "Wamr"
+
+static const char *TAG = "FATFS_STREAM";
+
+typedef enum {
+    STREAM_TYPE_UNKNOW,
+    STREAM_TYPE_WAV,
+    STREAM_TYPE_OPUS,
+    STREAM_TYPE_AMR,
+    STREAM_TYPE_AMRWB,
+} wr_stream_type_t;
+
+typedef struct fatfs_stream {
+    audio_stream_type_t type;
+    int block_size;
+    bool is_open;
+    int file;
+    wr_stream_type_t w_type;
+    bool write_header;
+} fatfs_stream_t;
+
+
+static wr_stream_type_t get_type(const char *str)
+{
+    char *relt = strrchr(str, '.');
+    if (relt != NULL) {
+        relt ++;
+        ESP_LOGD(TAG, "result = %s", relt);
+        if (strncasecmp(relt, FILE_WAV_SUFFIX_TYPE, 3) == 0) {
+            return STREAM_TYPE_WAV;
+        } else if (strncasecmp(relt, FILE_OPUS_SUFFIX_TYPE, 4) == 0) {
+            return STREAM_TYPE_OPUS;
+        } else if (strncasecmp(relt, FILE_AMR_SUFFIX_TYPE, 3) == 0) {
+            return STREAM_TYPE_AMR;
+        } else if (strncasecmp(relt, FILE_AMRWB_SUFFIX_TYPE, 4) == 0) {
+            return STREAM_TYPE_AMRWB;
+        } else {
+            return STREAM_TYPE_UNKNOW;
+        }
+    } else {
+        return STREAM_TYPE_UNKNOW;
+    }
+}
+
+static char* get_mount_path(char* uri) 
+{
+    /* support format: /sdcard, /spiffs, /storage etc ... */
+    if (uri[0] == '/') return uri;
+
+    /* support format: scheme://basepath... */
+    char *skip_scheme = strstr(uri, "://");
+    if (skip_scheme == NULL) return NULL;
+    skip_scheme += 2;
+
+    /* support format: scheme:///basepath... */
+    if (skip_scheme[1] == '/') skip_scheme++;
+
+    return skip_scheme;
+}
+
+static esp_err_t _fatfs_open(audio_element_handle_t self)
+{
+    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
+
+    if (fatfs->is_open) {
+        ESP_LOGE(TAG, "already opened");
+        return ESP_FAIL;
+    }
+
+    audio_element_info_t info;
+    char *uri = audio_element_get_uri(self);
+    if (uri == NULL) {
+        ESP_LOGE(TAG, "Error, uri is not set");
+        return ESP_FAIL;
+    }
+    ESP_LOGD(TAG, "_fatfs_open, uri:%s", uri);
+    char *path = get_mount_path(uri);
+    if (path == NULL) {
+        ESP_LOGE(TAG, "Error, Invalid file format (%s).", uri);
+        return ESP_FAIL;
+    }
+
+    audio_element_getinfo(self, &info);
+
+    if (fatfs->type == AUDIO_STREAM_READER) {
+        fatfs->file = open(path, O_RDONLY);
+        if (fatfs->file == -1) {
+            ESP_LOGE(TAG, "Failed to open. File name: %s, error message: %s, line: %d", path, strerror(errno), __LINE__);
+            return ESP_FAIL;
+        }
+        struct stat siz =  { 0 };
+        stat(path, &siz);
+        info.total_bytes = siz.st_size;
+        ESP_LOGI(TAG, "File size: %d byte, file position: %d", (int)siz.st_size, (int)info.byte_pos);
+        if (info.byte_pos > 0) {
+            if (lseek(fatfs->file, info.byte_pos, SEEK_SET) < 0) {
+                ESP_LOGE(TAG, "Error seek file. Error message: %s, line: %d", strerror(errno), __LINE__);
+                return ESP_FAIL;
+            }
+        }
+    } else if (fatfs->type == AUDIO_STREAM_WRITER) {
+        fatfs->file = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
+        if (fatfs->file == -1) {
+            ESP_LOGE(TAG, "Failed to open. File name: %s, error message: %s, line: %d", path, strerror(errno), __LINE__);
+            return ESP_FAIL;
+        }
+        fatfs->w_type =  get_type(path);
+        if ((STREAM_TYPE_WAV == fatfs->w_type) && (fatfs->write_header == true)) {
+            wav_header_t info = {0};
+            write(fatfs->file, &info, sizeof(wav_header_t));
+            fsync(fatfs->file);
+        } else if ((STREAM_TYPE_AMR == fatfs->w_type) && (fatfs->write_header == true)) {
+            write(fatfs->file, "#!AMR\n", 6);
+            fsync(fatfs->file);
+        } else if ((STREAM_TYPE_AMRWB == fatfs->w_type) && (fatfs->write_header == true)) {
+            write(fatfs->file, "#!AMR-WB\n", 9);
+            fsync(fatfs->file);
+        }
+    } else {
+        ESP_LOGE(TAG, "FATFS must be Reader or Writer");
+        return ESP_FAIL;
+    }
+    fatfs->is_open = true;
+    int ret = audio_element_set_total_bytes(self, info.total_bytes);
+    return ret;
+}
+
+static int _fatfs_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+
+    ESP_LOGD(TAG, "read len=%d, pos=%d/%d", len, (int)info.byte_pos, (int)info.total_bytes);
+    /* use file descriptors to access files */
+    int rlen = read(fatfs->file, buffer, len);
+    if (rlen == 0) {
+        ESP_LOGW(TAG, "No more data, ret:%d", rlen);
+    } else if (rlen == -1) {
+        ESP_LOGE(TAG, "The error is happened in reading data. Error message: %s", strerror(errno));
+    } else {
+        audio_element_update_byte_pos(self, rlen);
+    }
+    return rlen;
+}
+
+static int _fatfs_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+    int wlen =  write(fatfs->file, buffer, len);
+    fsync(fatfs->file);
+    if (wlen > 0) {
+        audio_element_update_byte_pos(self, wlen);
+    } if (wlen == -1) {
+        ESP_LOGE(TAG, "The error is happened in writing data. Error message: %s", strerror(errno));
+    }
+
+    return wlen;
+}
+
+static int _fatfs_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _fatfs_close(audio_element_handle_t self)
+{
+    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
+
+    if (AUDIO_STREAM_WRITER == fatfs->type
+        && (-1 != fatfs->file)
+        && (true == fatfs->write_header)
+        && STREAM_TYPE_WAV == fatfs->w_type) {
+        wav_header_t *wav_info = (wav_header_t *) audio_malloc(sizeof(wav_header_t));
+
+        AUDIO_MEM_CHECK(TAG, wav_info, return ESP_ERR_NO_MEM);
+
+        if (lseek(fatfs->file, 0, SEEK_SET) < 0) {
+            ESP_LOGE(TAG, "Error seek file. Error message: %s, line: %d", strerror(errno), __LINE__);
+        }
+        audio_element_info_t info;
+        audio_element_getinfo(self, &info);
+        wav_head_init(wav_info, info.sample_rates, info.bits, info.channels);
+        wav_head_size(wav_info, (uint32_t)info.byte_pos);
+        write(fatfs->file, wav_info, sizeof(wav_header_t));
+        fsync(fatfs->file);
+        audio_free(wav_info);
+    }
+
+    if (fatfs->is_open) {
+        close(fatfs->file);
+        fatfs->is_open = false;
+    }
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_report_info(self);
+        audio_element_set_byte_pos(self, 0);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _fatfs_destroy(audio_element_handle_t self)
+{
+    fatfs_stream_t *fatfs = (fatfs_stream_t *)audio_element_getdata(self);
+    audio_free(fatfs);
+    return ESP_OK;
+}
+
+// Example of using an audio element - START
+audio_element_handle_t fatfs_stream_init(fatfs_stream_cfg_t *config)
+{
+    audio_element_handle_t el;
+    fatfs_stream_t *fatfs = audio_calloc(1, sizeof(fatfs_stream_t));
+    AUDIO_MEM_CHECK(TAG, fatfs, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _fatfs_open;
+    cfg.close = _fatfs_close;
+    cfg.process = _fatfs_process;
+    cfg.destroy = _fatfs_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.buffer_len = config->buf_sz;
+    cfg.stack_in_ext = config->ext_stack;
+    if (cfg.buffer_len == 0) {
+        cfg.buffer_len = FATFS_STREAM_BUF_SIZE;
+    }
+
+    cfg.tag = "file";
+    fatfs->type = config->type;
+    fatfs->write_header = config->write_header;
+
+    if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _fatfs_write;
+    } else {
+        cfg.read = _fatfs_read;
+    }
+    el = audio_element_init(&cfg);
+
+    AUDIO_MEM_CHECK(TAG, el, goto _fatfs_init_exit);
+    audio_element_setdata(el, fatfs);
+    return el;
+_fatfs_init_exit:
+    audio_free(fatfs);
+    return NULL;
+}
 // Example of using an audio element - END
\ No newline at end of file
diff --git a/components/audio_stream/http_playlist.c b/components/audio_stream/http_playlist.c
index 70d3c2e8..75c4181a 100644
--- a/components/audio_stream/http_playlist.c
+++ b/components/audio_stream/http_playlist.c
@@ -1,151 +1,151 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <sys/unistd.h>
-#include <sys/stat.h>
-#include <string.h>
-#include "join_path.h"
-#include "audio_mem.h"
-
-#include "http_playlist.h"
-#include "esp_log.h"
-#include "errno.h"
-
-static const char *TAG = "HLS_PLAYLIST";
-
-#define MAX_PLAYLIST_TRACKS (128)
-#define MAX_PLAYLIST_KEEP_TRACKS (18)
-
-typedef struct track_ {
-    char *uri;
-    bool is_played;
-    STAILQ_ENTRY(track_) next;
-} track_t;
-
-static void hls_remove_played_entry(http_playlist_t *playlist)
-{
-    track_t *track;
-    /* Remove head entry if total_entries are > MAX_PLAYLIST_KEEP_TRACKS */
-    if (playlist->total_tracks > MAX_PLAYLIST_KEEP_TRACKS) {
-        track = STAILQ_FIRST(&playlist->tracks);
-        if (track->is_played) {
-            STAILQ_REMOVE_HEAD(&playlist->tracks, next);
-            audio_free(track->uri);
-            audio_free(track);
-            playlist->total_tracks--;
-        }
-    }
-}
-
-void http_playlist_insert(http_playlist_t *playlist, char *track_uri)
-{
-    track_t *track;
-    const char *host_uri = (const char *) playlist->host_uri;
-    ESP_LOGD(TAG, "Insert url %s\n", track_uri);
-    while (playlist->total_tracks > MAX_PLAYLIST_TRACKS) {
-        track = STAILQ_FIRST(&playlist->tracks);
-        if (track == NULL) {
-            break;
-        }
-        STAILQ_REMOVE(&playlist->tracks, track, track_, next);
-        ESP_LOGD(TAG, "Remove %s", track->uri);
-        audio_free(track->uri);
-        audio_free(track);
-        playlist->total_tracks --;
-    }
-    track = audio_calloc(1, sizeof(track_t));
-    if (track == NULL) {
-        return;
-    }
-    if (strstr(track_uri, "http") == track_uri) { // Full URI
-        track->uri = audio_strdup(track_uri);
-    } else {
-        track->uri = join_url((char*)host_uri, track_uri);
-    }
-    if (track->uri == NULL) {
-        ESP_LOGE(TAG, "Error insert URI to playlist");
-        audio_free(track);
-        return;
-    }
-
-    track_t *find = NULL;
-    STAILQ_FOREACH(find, &playlist->tracks, next) {
-        if (strcmp(find->uri, track->uri) == 0) {
-            ESP_LOGD(TAG, "URI exist");
-            audio_free(track->uri);
-            audio_free(track);
-            return;
-        }
-    }
-
-    ESP_LOGD(TAG, "INSERT %s", track->uri);
-    STAILQ_INSERT_TAIL(&playlist->tracks, track, next);
-    playlist->total_tracks++;
-    hls_remove_played_entry(playlist);
-}
-
-char* http_playlist_get_next_track(http_playlist_t *playlist)
-{
-    track_t *track;
-    hls_remove_played_entry(playlist);
-    /* Find not played entry. */
-    STAILQ_FOREACH(track, &playlist->tracks, next) {
-        if (!track->is_played) {
-            track->is_played = true;
-            return track->uri;
-        }
-    }
-    return NULL;
-}
-
-char* http_playlist_get_last_track(http_playlist_t *playlist)
-{
-    track_t *track;
-    char* uri = NULL;
-    STAILQ_FOREACH(track, &playlist->tracks, next) {
-        if (!track->is_played) {
-            break;
-        } else {
-            uri = track->uri;
-        }
-    }
-    return uri;
-}
-
-void http_playlist_clear(http_playlist_t *playlist)
-{
-    track_t *track, *tmp;
-    STAILQ_FOREACH_SAFE(track, &playlist->tracks, next, tmp) {
-        STAILQ_REMOVE(&playlist->tracks, track, track_, next);
-        audio_free(track->uri);
-        audio_free(track);
-    }
-
-    if (playlist->host_uri) {
-        audio_free(playlist->host_uri);
-        playlist->host_uri = NULL;
-    }
-    playlist->is_incomplete = false;
-    playlist->total_tracks = 0;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <sys/unistd.h>
+#include <sys/stat.h>
+#include <string.h>
+#include "join_path.h"
+#include "audio_mem.h"
+
+#include "http_playlist.h"
+#include "esp_log.h"
+#include "errno.h"
+
+static const char *TAG = "HLS_PLAYLIST";
+
+#define MAX_PLAYLIST_TRACKS (128)
+#define MAX_PLAYLIST_KEEP_TRACKS (18)
+
+typedef struct track_ {
+    char *uri;
+    bool is_played;
+    STAILQ_ENTRY(track_) next;
+} track_t;
+
+static void hls_remove_played_entry(http_playlist_t *playlist)
+{
+    track_t *track;
+    /* Remove head entry if total_entries are > MAX_PLAYLIST_KEEP_TRACKS */
+    if (playlist->total_tracks > MAX_PLAYLIST_KEEP_TRACKS) {
+        track = STAILQ_FIRST(&playlist->tracks);
+        if (track->is_played) {
+            STAILQ_REMOVE_HEAD(&playlist->tracks, next);
+            audio_free(track->uri);
+            audio_free(track);
+            playlist->total_tracks--;
+        }
+    }
+}
+
+void http_playlist_insert(http_playlist_t *playlist, char *track_uri)
+{
+    track_t *track;
+    const char *host_uri = (const char *) playlist->host_uri;
+    ESP_LOGD(TAG, "Insert url %s\n", track_uri);
+    while (playlist->total_tracks > MAX_PLAYLIST_TRACKS) {
+        track = STAILQ_FIRST(&playlist->tracks);
+        if (track == NULL) {
+            break;
+        }
+        STAILQ_REMOVE(&playlist->tracks, track, track_, next);
+        ESP_LOGD(TAG, "Remove %s", track->uri);
+        audio_free(track->uri);
+        audio_free(track);
+        playlist->total_tracks --;
+    }
+    track = audio_calloc(1, sizeof(track_t));
+    if (track == NULL) {
+        return;
+    }
+    if (strstr(track_uri, "http") == track_uri) { // Full URI
+        track->uri = audio_strdup(track_uri);
+    } else {
+        track->uri = join_url((char*)host_uri, track_uri);
+    }
+    if (track->uri == NULL) {
+        ESP_LOGE(TAG, "Error insert URI to playlist");
+        audio_free(track);
+        return;
+    }
+
+    track_t *find = NULL;
+    STAILQ_FOREACH(find, &playlist->tracks, next) {
+        if (strcmp(find->uri, track->uri) == 0) {
+            ESP_LOGD(TAG, "URI exist");
+            audio_free(track->uri);
+            audio_free(track);
+            return;
+        }
+    }
+
+    ESP_LOGD(TAG, "INSERT %s", track->uri);
+    STAILQ_INSERT_TAIL(&playlist->tracks, track, next);
+    playlist->total_tracks++;
+    hls_remove_played_entry(playlist);
+}
+
+char* http_playlist_get_next_track(http_playlist_t *playlist)
+{
+    track_t *track;
+    hls_remove_played_entry(playlist);
+    /* Find not played entry. */
+    STAILQ_FOREACH(track, &playlist->tracks, next) {
+        if (!track->is_played) {
+            track->is_played = true;
+            return track->uri;
+        }
+    }
+    return NULL;
+}
+
+char* http_playlist_get_last_track(http_playlist_t *playlist)
+{
+    track_t *track;
+    char* uri = NULL;
+    STAILQ_FOREACH(track, &playlist->tracks, next) {
+        if (!track->is_played) {
+            break;
+        } else {
+            uri = track->uri;
+        }
+    }
+    return uri;
+}
+
+void http_playlist_clear(http_playlist_t *playlist)
+{
+    track_t *track, *tmp;
+    STAILQ_FOREACH_SAFE(track, &playlist->tracks, next, tmp) {
+        STAILQ_REMOVE(&playlist->tracks, track, track_, next);
+        audio_free(track->uri);
+        audio_free(track);
+    }
+
+    if (playlist->host_uri) {
+        audio_free(playlist->host_uri);
+        playlist->host_uri = NULL;
+    }
+    playlist->is_incomplete = false;
+    playlist->total_tracks = 0;
+}
diff --git a/components/audio_stream/http_playlist.h b/components/audio_stream/http_playlist.h
index 5313110e..7bafdea6 100644
--- a/components/audio_stream/http_playlist.h
+++ b/components/audio_stream/http_playlist.h
@@ -1,95 +1,95 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _HLS_PLAYLIST_H_
-#define _HLS_PLAYLIST_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "esp_err.h"
-#include "stdbool.h"
-#include "sys/queue.h"
-
-struct track_; // Forward declaration
-typedef STAILQ_HEAD(track_list, track_) track_list_t;
-
-typedef struct {
-    char            *host_uri;
-    char            *data;
-    int             index;
-    track_list_t    tracks;
-    int             total_tracks;
-    bool            is_incomplete;       /*!< Indicates if playlist is live stream and must be fetched again */
-} http_playlist_t;
-
-/**
- * @brief       Insert a track into hls_playlist
- *
- * @param       playlist: Playlist handle
- * @param       track_uri: Track URI to be inserted in playlist
- *
- */
-void http_playlist_insert(http_playlist_t *playlist, char *track_uri);
-
-/**
- * @brief       Get next not-played track from playlist
- *
- * @param       playlist: Playlist handle
- *
- * @return
- *      - NULL: If no playable track
- *      - Others: Playable track
- *
- * @note        returned track must `not` be freed by application
- */
-char *http_playlist_get_next_track(http_playlist_t *playlist);
-
-/**
- * @brief       Get last played track from playlist
- *
- * @param       playlist: Playlist handle
- *
- * @return
- *      - NULL: If no playable track
- *      - Others: Playable track
- *
- * @note        returned track must `not` be freed by application
- */
-char *http_playlist_get_last_track(http_playlist_t *playlist);
-
-/**
- * @brief       Clear all the tracks from playlist
- *
- * @param       playlist: Playlist handle
- *
- */
-void http_playlist_clear(http_playlist_t *playlist);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* #ifndef _HLS_PLAYLIST_H_ */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _HLS_PLAYLIST_H_
+#define _HLS_PLAYLIST_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "esp_err.h"
+#include "stdbool.h"
+#include "sys/queue.h"
+
+struct track_; // Forward declaration
+typedef STAILQ_HEAD(track_list, track_) track_list_t;
+
+typedef struct {
+    char            *host_uri;
+    char            *data;
+    int             index;
+    track_list_t    tracks;
+    int             total_tracks;
+    bool            is_incomplete;       /*!< Indicates if playlist is live stream and must be fetched again */
+} http_playlist_t;
+
+/**
+ * @brief       Insert a track into hls_playlist
+ *
+ * @param       playlist: Playlist handle
+ * @param       track_uri: Track URI to be inserted in playlist
+ *
+ */
+void http_playlist_insert(http_playlist_t *playlist, char *track_uri);
+
+/**
+ * @brief       Get next not-played track from playlist
+ *
+ * @param       playlist: Playlist handle
+ *
+ * @return
+ *      - NULL: If no playable track
+ *      - Others: Playable track
+ *
+ * @note        returned track must `not` be freed by application
+ */
+char *http_playlist_get_next_track(http_playlist_t *playlist);
+
+/**
+ * @brief       Get last played track from playlist
+ *
+ * @param       playlist: Playlist handle
+ *
+ * @return
+ *      - NULL: If no playable track
+ *      - Others: Playable track
+ *
+ * @note        returned track must `not` be freed by application
+ */
+char *http_playlist_get_last_track(http_playlist_t *playlist);
+
+/**
+ * @brief       Clear all the tracks from playlist
+ *
+ * @param       playlist: Playlist handle
+ *
+ */
+void http_playlist_clear(http_playlist_t *playlist);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* #ifndef _HLS_PLAYLIST_H_ */
diff --git a/components/audio_stream/http_stream.c b/components/audio_stream/http_stream.c
index 1909fcd3..a568030f 100644
--- a/components/audio_stream/http_stream.c
+++ b/components/audio_stream/http_stream.c
@@ -1,1000 +1,1000 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <sys/unistd.h>
-#include <sys/stat.h>
-#include <string.h>
-#include <strings.h>
-#include <errno.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/ringbuf.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-
-#include "esp_log.h"
-#include "http_stream.h"
-#include "http_playlist.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "esp_system.h"
-#include "esp_http_client.h"
-#include "line_reader.h"
-#include "hls_playlist.h"
-#include "audio_idf_version.h"
-#include "gzip_miniz.h"
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
-#include "aes/esp_aes.h"
-#elif (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 1, 0))
-#if CONFIG_IDF_TARGET_ESP32
-#include "esp32/aes.h"
-#elif CONFIG_IDF_TARGET_ESP32S2
-#include "esp32s2/aes.h"
-#endif
-#else
-#include "hwcrypto/aes.h"
-#endif
-
-static const char *TAG = "HTTP_STREAM";
-#define MAX_PLAYLIST_LINE_SIZE (512)
-#define HTTP_STREAM_BUFFER_SIZE (2048)
-#define HTTP_MAX_CONNECT_TIMES  (5)
-
-#define HLS_PREFER_BITRATE      (200*1024)
-#define HLS_KEY_CACHE_SIZE      (32)
-typedef struct {
-    bool             key_loaded;
-    char             *key_url;
-    uint8_t          key_cache[HLS_KEY_CACHE_SIZE];
-    uint8_t          key_size;
-    hls_stream_key_t key;
-    uint64_t         sequence_no;
-    esp_aes_context  aes_ctx;
-    bool             aes_used;
-} http_stream_hls_key_t;
-
-typedef struct http_stream {
-    audio_stream_type_t             type;
-    bool                            is_open;
-    esp_http_client_handle_t        client;
-    http_stream_event_handle_t      hook;
-    audio_stream_type_t             stream_type;
-    void                            *user_data;
-    bool                            enable_playlist_parser;
-    bool                            auto_connect_next_track; /* connect next track without open/close */
-    bool                            is_playlist_resolved;
-    bool                            is_valid_playlist;
-    bool                            is_main_playlist;
-    http_playlist_t                 *playlist;         /* media playlist */
-    int                             _errno;            /* errno code for http */
-    int                             connect_times;     /* max reconnect times */
-    const char                     *cert_pem;
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
-    esp_err_t                      (*crt_bundle_attach)(void *conf); /*  Function pointer to esp_crt_bundle_attach*/
-#endif
-    bool                            gzip_encoding;     /* Content is encoded */
-    gzip_miniz_handle_t             gzip;              /* GZIP instance */
-    http_stream_hls_key_t           *hls_key;
-    hls_handle_t                    *hls_media;
-    int                             request_range_size;
-    int64_t                         request_range_end;
-    bool                            is_last_range;
-    const char                      *user_agent;
-} http_stream_t;
-
-static esp_err_t http_stream_auto_connect_next_track(audio_element_handle_t el);
-
-// `errno` is not thread safe in multiple HTTP-clients,
-// so it is necessary to save the errno number of HTTP clients to avoid reading and writing exceptions of HTTP-clients caused by errno exceptions
-int __attribute__((weak)) esp_http_client_get_errno(esp_http_client_handle_t client)
-{
-    (void) client;
-    ESP_LOGE(TAG, "Not found right %s.\r\nPlease enter ADF-PATH with \"cd $ADF_PATH/idf_patches\" and apply the ADF patch with \"git apply $ADF_PATH/idf_patches/idf_%.4s_esp_http_client.patch\" first\r\n", __func__, IDF_VER);
-    return errno;
-}
-
-static esp_codec_type_t get_audio_type(const char *content_type)
-{
-    if (strcasecmp(content_type, "mp3") == 0 ||
-        strcasecmp(content_type, "audio/mp3") == 0 ||
-        strcasecmp(content_type, "audio/mpeg") == 0 ||
-        strcasecmp(content_type, "binary/octet-stream") == 0 ||
-        strcasecmp(content_type, "application/octet-stream") == 0) {
-        return ESP_CODEC_TYPE_MP3;
-    }
-    if (strcasecmp(content_type, "audio/aac") == 0 ||
-        strcasecmp(content_type, "audio/x-aac") == 0 ||
-        strcasecmp(content_type, "audio/mp4") == 0 ||
-        strcasecmp(content_type, "audio/aacp") == 0 ||
-        strcasecmp(content_type, "video/MP2T") == 0) {
-        return ESP_CODEC_TYPE_AAC;
-    }
-    if (strcasecmp(content_type, "audio/wav") == 0) {
-        return ESP_CODEC_TYPE_WAV;
-    }
-    if (strcasecmp(content_type, "audio/opus") == 0) {
-        return ESP_CODEC_TYPE_OPUS;
-    }
-    if (strcasecmp(content_type, "application/vnd.apple.mpegurl") == 0 ||
-        strcasecmp(content_type, "vnd.apple.mpegURL") == 0) {
-        return ESP_AUDIO_TYPE_M3U8;
-    }
-    if (strncasecmp(content_type, "audio/x-scpls", strlen("audio/x-scpls")) == 0) {
-        return ESP_AUDIO_TYPE_PLS;
-    }
-    return ESP_CODEC_TYPE_UNKNOW;
-}
-
-static int _gzip_read_data(uint8_t *data, int size, void *ctx)
-{
-    http_stream_t *http = (http_stream_t *) ctx;
-    return esp_http_client_read(http->client, (char *)data, size);
-}
-
-static esp_err_t _http_event_handle(esp_http_client_event_t *evt)
-{
-    audio_element_handle_t el = (audio_element_handle_t)evt->user_data;
-    if (evt->event_id != HTTP_EVENT_ON_HEADER) {
-        return ESP_OK;
-    }
-    if (strcasecmp(evt->header_key, "Content-Type") == 0) {
-        ESP_LOGD(TAG, "%s = %s", evt->header_key, evt->header_value);
-        audio_element_set_codec_fmt(el, get_audio_type(evt->header_value));
-    }
-    else if (strcasecmp(evt->header_key, "Content-Encoding") == 0) {
-        http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-        http->gzip_encoding = true;
-        if (strcasecmp(evt->header_value, "gzip") == 0) {
-            gzip_miniz_cfg_t cfg = {
-                .chunk_size = 1024,
-                .ctx = http,
-                .read_cb = _gzip_read_data,
-            };
-            http->gzip = gzip_miniz_init(&cfg);
-        }
-        if (http->gzip == NULL) {
-            ESP_LOGE(TAG, "Content-Encoding %s not supported", evt->header_value);
-            return ESP_FAIL;
-        }
-    }
-    else if (strcasecmp(evt->header_key, "Content-Range") == 0) {
-        http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-        if (http->request_range_size) {
-            char* end_pos = strchr(evt->header_value, '-');
-            http->is_last_range = true;
-            if (end_pos) {
-                end_pos++;
-                int64_t range_end = atoll(end_pos);
-                if (range_end == http->request_range_end) {
-                    http->is_last_range = false;
-                }
-                // Update total bytes to range end
-                audio_element_set_total_bytes(el, range_end+1);
-            }
-        }
-    }
-    return ESP_OK;
-}
-
-static int dispatch_hook(audio_element_handle_t self, http_stream_event_id_t type, void *buffer, int buffer_len)
-{
-    http_stream_t *http_stream = (http_stream_t *)audio_element_getdata(self);
-
-    http_stream_event_msg_t msg;
-    msg.event_id = type;
-    msg.http_client = http_stream->client;
-    msg.user_data = http_stream->user_data;
-    msg.buffer = buffer;
-    msg.buffer_len = buffer_len;
-    msg.el = self;
-    if (http_stream->hook) {
-        return http_stream->hook(&msg);
-    }
-    return ESP_OK;
-}
-
-static bool _is_playlist(audio_element_info_t *info, const char *uri)
-{
-    if (info->codec_fmt == ESP_AUDIO_TYPE_M3U8 || info->codec_fmt == ESP_AUDIO_TYPE_PLS) {
-        return true;
-    }
-    const char *s = uri;
-    while (*s) {
-        if (*s == '.') {
-            if (strncasecmp(s, ".m3u", 3) == 0) {
-                return true;
-            }
-        }
-        s++;
-    }
-    return false;
-}
-
-static int _hls_uri_cb(char *uri, void *ctx)
-{
-    http_stream_t *http = (http_stream_t *) ctx;
-    if (uri) {
-        http_playlist_insert(http->playlist, uri);
-        http->is_valid_playlist = true;
-    }
-    return 0;
-}
-
-static int _http_read_data(http_stream_t *http, char *buffer, int len)
-{
-    if (http->gzip_encoding == false) {
-        return esp_http_client_read(http->client, buffer, len);
-    }
-    // use gzip to uncompress data
-    return gzip_miniz_read(http->gzip, (uint8_t*) buffer, len);
-}
-
-static esp_err_t _resolve_hls_key(http_stream_t *http)
-{
-    int ret = _http_read_data(http, (char*)http->hls_key->key_cache, sizeof(http->hls_key->key_cache));
-    if (ret < 0) {
-        return ESP_FAIL;
-    }
-    http->hls_key->key_size = (uint8_t)ret;
-    http->hls_key->key_loaded = true;
-    return ESP_OK;
-}
-
-static esp_err_t _prepare_crypt(http_stream_t *http)
-{
-    http_stream_hls_key_t* hls_key = http->hls_key;
-    if (hls_key->aes_used) {
-        esp_aes_free(&hls_key->aes_ctx);
-        hls_key->aes_used = false;
-    }
-    int ret = hls_playlist_parse_key(http->hls_media, http->hls_key->key_cache, http->hls_key->key_size);
-    if (ret < 0) {
-        return ESP_FAIL;
-    }
-    ret = hls_playlist_get_key(http->hls_media, http->hls_key->sequence_no, &http->hls_key->key);
-    if (ret != 0) {
-        return ESP_FAIL;
-    }
-    esp_aes_init(&hls_key->aes_ctx);
-    esp_aes_setkey(&hls_key->aes_ctx, (unsigned char*)hls_key->key.key, 128);
-    hls_key->aes_used = true;
-    http->hls_key->sequence_no++;
-    return ESP_OK;
-}
-
-static void _free_hls_key(http_stream_t *http)
-{
-    if (http->hls_key == NULL) {
-        return;
-    }
-    if (http->hls_key->aes_used) {
-        esp_aes_free(&http->hls_key->aes_ctx);
-        http->hls_key->aes_used = false;
-    }
-    if (http->hls_key->key_url) {
-        audio_free(http->hls_key->key_url);
-    }
-    audio_free(http->hls_key);
-    http->hls_key = NULL;
-}
-
-static esp_err_t _resolve_playlist(audio_element_handle_t self, const char *uri)
-{
-    audio_element_info_t info;
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    audio_element_getinfo(self, &info);
-    if (http->hls_media) {
-        hls_playlist_close(http->hls_media);
-        http->hls_media = NULL;
-    }
-    // backup new uri firstly
-    char *new_uri = audio_strdup(uri);
-    if (new_uri == NULL) {
-        return ESP_FAIL;
-    }
-    if (http->is_main_playlist) {
-        http_playlist_clear(http->playlist);
-    }
-    if (http->playlist->host_uri) {
-        audio_free(http->playlist->host_uri);
-    }
-    http->playlist->host_uri = new_uri;
-    http->is_valid_playlist = false;
-
-    // handle PLS playlist
-    if (info.codec_fmt == ESP_AUDIO_TYPE_PLS) {
-        line_reader_t *reader = line_reader_init(MAX_PLAYLIST_LINE_SIZE);
-        if (reader == NULL) {
-            return ESP_FAIL;
-        }
-        int need_read = MAX_PLAYLIST_LINE_SIZE;
-        int rlen = need_read;
-        while (rlen == need_read) {
-            rlen = _http_read_data(http, http->playlist->data, need_read);
-            if (rlen < 0) {
-                break;
-            }
-            line_reader_add_buffer(reader, (uint8_t *)http->playlist->data, rlen, (rlen < need_read));
-            char *line;
-            while ((line = line_reader_get_line(reader)) != NULL) {
-                if (!strncmp(line, "File", sizeof("File") - 1)) { // This line contains url
-                    int i = 4;
-                    while (line[i++] != '='); // Skip till '='
-                    http_playlist_insert(http->playlist, line + i);
-                    http->is_valid_playlist = true;
-                }
-            }
-        }
-        line_reader_deinit(reader);
-        return http->is_valid_playlist ? ESP_OK : ESP_FAIL;
-    }
-    http->is_main_playlist = false;
-    hls_playlist_cfg_t cfg = {
-        .prefer_bitrate = HLS_PREFER_BITRATE,
-        .cb = _hls_uri_cb,
-        .ctx = http,
-        .uri = (char *)new_uri,
-    };
-    hls_handle_t hls = hls_playlist_open(&cfg);
-    do {
-        if (hls == NULL) {
-            break;
-        }
-        int need_read = MAX_PLAYLIST_LINE_SIZE;
-        int rlen = need_read;
-        while (rlen == need_read) {
-            rlen = _http_read_data(http, http->playlist->data, need_read);
-            if (rlen < 0) {
-                break;
-            }
-            hls_playlist_parse_data(hls, (uint8_t *)http->playlist->data, rlen, (rlen < need_read));
-        }
-        if (hls_playlist_is_master(hls)) {
-            char *url = hls_playlist_get_prefer_url(hls, HLS_STREAM_TYPE_AUDIO);
-            if (url) {
-                http_playlist_insert(http->playlist, url);
-                ESP_LOGI(TAG, "Add media uri %s\n", url);
-                http->is_valid_playlist = true;
-                http->is_main_playlist = true;
-                audio_free(url);
-            }
-        } else {
-            http->playlist->is_incomplete = !hls_playlist_is_media_end(hls);
-            if (http->playlist->is_incomplete) {
-                ESP_LOGI(TAG, "Live stream URI. Need to be fetched again!");
-            }
-        }
-    } while (0);
-    if (hls) {
-        if (hls_playlist_is_encrypt(hls) == false) {
-            _free_hls_key(http);
-            hls_playlist_close(hls);
-        } else {
-            // When content is encrypted, need keep hls instance
-            http->hls_media = hls;
-            const char *key_url = hls_playlist_get_key_uri(hls);
-            if (key_url == NULL) {
-                ESP_LOGE(TAG, "Hls do not have key url");
-                return ESP_FAIL;
-            }
-            if (http->hls_key == NULL) {
-                http->hls_key = (http_stream_hls_key_t *) calloc(1, sizeof(http_stream_hls_key_t));
-                if (http->hls_key == NULL) {
-                    ESP_LOGE(TAG, "No memory for hls key");
-                    return ESP_FAIL;
-                }
-            }
-            if (http->hls_key->key_url && strcmp(http->hls_key->key_url, key_url) == 0) {
-                http->hls_key->key_loaded = true;
-            } else {
-                if (http->hls_key->key_url) {
-                    audio_free(http->hls_key->key_url);
-                }
-                http->hls_key->key_loaded = false;
-                http->hls_key->key_url = audio_strdup(key_url);
-                if (http->hls_key->key_url == NULL) {
-                    ESP_LOGE(TAG, "No memory for hls key url");
-                    return ESP_FAIL;
-                } 
-            }
-            http->hls_key->sequence_no = hls_playlist_get_sequence_no(hls);
-        }
-    }
-    return http->is_valid_playlist ? ESP_OK : ESP_FAIL;
-}
-
-static char *_playlist_get_next_track(audio_element_handle_t self)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    if (http->enable_playlist_parser && http->is_playlist_resolved) {
-        return http_playlist_get_next_track(http->playlist);
-    }
-    return NULL;
-}
-
-static void _prepare_range(http_stream_t *http, int64_t pos)
-{
-    if (http->request_range_size > 0 || pos != 0) {
-        char range_header[64] = {0};
-        if (http->request_range_size == 0) {
-            snprintf(range_header, sizeof(range_header), "bytes=%lld-", pos);
-        } else {
-            int64_t end_pos = pos + http->request_range_size - 1;
-            if (pos < 0 && end_pos > 0) {
-                end_pos = 0;
-            }
-            snprintf(range_header, sizeof(range_header), "bytes=%lld-%lld", pos, end_pos);
-            http->request_range_end = end_pos;
-        }
-        esp_http_client_set_header(http->client, "Range", range_header);
-    } else {
-        esp_http_client_delete_header(http->client, "Range");
-    }
-}
-
-static esp_err_t _http_load_uri(audio_element_handle_t self, audio_element_info_t* info)
-{
-    esp_err_t err;
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-
-    esp_http_client_close(http->client);
-
-    if (dispatch_hook(self, HTTP_STREAM_PRE_REQUEST, NULL, 0) != ESP_OK) {
-        ESP_LOGE(TAG, "Failed to process user callback");
-        return ESP_FAIL;
-    }
-
-    _prepare_range(http, info->byte_pos);
-
-    if (http->stream_type == AUDIO_STREAM_WRITER) {
-        err = esp_http_client_open(http->client, -1);
-        if (err == ESP_OK) {
-            http->is_open = true;
-        }
-        return err;
-    }
-
-    char *buffer = NULL;
-    int post_len = esp_http_client_get_post_field(http->client, &buffer);
-_stream_redirect:
-    if (http->gzip_encoding) {
-        gzip_miniz_deinit(http->gzip);
-        http->gzip = NULL;
-        http->gzip_encoding = false;
-    }
-    if ((err = esp_http_client_open(http->client, post_len)) != ESP_OK) {
-        ESP_LOGE(TAG, "Failed to open http stream");
-        return err;
-    }
-
-    int wrlen = dispatch_hook(self, HTTP_STREAM_ON_REQUEST, buffer, post_len);
-    if (wrlen < 0) {
-        ESP_LOGE(TAG, "Failed to process user callback");
-        return ESP_FAIL;
-    }
-
-    if (post_len && buffer && wrlen == 0) {
-        if (esp_http_client_write(http->client, buffer, post_len) <= 0) {
-            ESP_LOGE(TAG, "Failed to write data to http stream");
-            return ESP_FAIL;
-        }
-        ESP_LOGD(TAG, "len=%d, data=%s", post_len, buffer);
-    }
-
-    if (dispatch_hook(self, HTTP_STREAM_POST_REQUEST, NULL, 0) < 0) {
-        esp_http_client_close(http->client);
-        return ESP_FAIL;
-    }
-    /*
-    * Due to the total byte of content has been changed after seek, set info.total_bytes at beginning only.
-    */
-    int64_t cur_pos = esp_http_client_fetch_headers(http->client);
-    audio_element_getinfo(self, info);
-    if (info->byte_pos <= 0) {
-        info->total_bytes = cur_pos;
-        ESP_LOGI(TAG, "total_bytes=%d", (int)info->total_bytes);
-        audio_element_set_total_bytes(self, info->total_bytes);
-    }
-    int status_code = esp_http_client_get_status_code(http->client);
-    if (status_code == 301 || status_code == 302) {
-        esp_http_client_set_redirection(http->client);
-        goto _stream_redirect;
-    }
-    if (status_code != 200
-        && (esp_http_client_get_status_code(http->client) != 206)
-        && (esp_http_client_get_status_code(http->client) != 416)) {
-        ESP_LOGE(TAG, "Invalid HTTP stream, status code = %d", status_code);
-        if (http->enable_playlist_parser) {
-            http_playlist_clear(http->playlist);
-            http->is_playlist_resolved = false;
-        }
-        return ESP_FAIL;
-    }
-    return err;
-}
-
-static esp_err_t _http_open(audio_element_handle_t self)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    char *uri = NULL;
-    audio_element_info_t info;
-    ESP_LOGD(TAG, "_http_open");
-
-    if (http->is_open) {
-        ESP_LOGE(TAG, "already opened");
-        return ESP_OK;
-    }
-    http->_errno = 0;
-    audio_element_getinfo(self, &info);
-_stream_open_begin:
-    if (http->hls_key && http->hls_key->key_loaded == false) {
-        uri = http->hls_key->key_url;
-    } else if (info.byte_pos == 0) {
-        uri = _playlist_get_next_track(self);
-    } else if (http->is_playlist_resolved) {
-        uri = http_playlist_get_last_track(http->playlist);
-    }
-    if (uri == NULL) {
-        if (http->is_playlist_resolved && http->enable_playlist_parser) {
-            if (dispatch_hook(self, HTTP_STREAM_FINISH_PLAYLIST, NULL, 0) != ESP_OK) {
-                ESP_LOGE(TAG, "Failed to process user callback");
-                return ESP_FAIL;
-            }
-            goto _stream_open_begin;
-        }
-        uri = audio_element_get_uri(self);
-    }
-
-    if (uri == NULL) {
-        ESP_LOGE(TAG, "Error open connection, uri = NULL");
-        return ESP_FAIL;
-    }
-    
-    ESP_LOGD(TAG, "URI=%s", uri);
-    // if not initialize http client, initial it
-    if (http->client == NULL) {
-        esp_http_client_config_t http_cfg = {
-            .url = uri,
-            .event_handler = _http_event_handle,
-            .user_data = self,
-            .timeout_ms = 30 * 1000,
-            .buffer_size = HTTP_STREAM_BUFFER_SIZE,
-#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 1, 0)
-            .buffer_size_tx = 1024,
-#endif
-            .cert_pem = http->cert_pem,
-#if  (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0)) && defined CONFIG_MBEDTLS_CERTIFICATE_BUNDLE
-            .crt_bundle_attach = http->crt_bundle_attach,
-#endif //  (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0)) && defined CONFIG_MBEDTLS_CERTIFICATE_BUNDLE
-            .user_agent = http->user_agent,
-        };
-        http->client = esp_http_client_init(&http_cfg);
-        AUDIO_MEM_CHECK(TAG, http->client, return ESP_ERR_NO_MEM);
-    } else {
-        esp_http_client_set_url(http->client, uri);
-    }
-    audio_element_getinfo(self, &info);
-
-    if (_http_load_uri(self, &info) != ESP_OK) {
-        return ESP_FAIL;
-    }
-
-    if (_is_playlist(&info, uri) == true) {
-        /**
-         * `goto _stream_open_begin` blocks on http_open until it gets valid URL.
-         * Ensure that the stop command is processed
-        */
-        if (audio_element_is_stopping(self) == true) {
-            ESP_LOGW(TAG, "Http_open got stop cmd at opening");
-            return ESP_OK;
-        }
-
-        if (_resolve_playlist(self, uri) == ESP_OK) {
-            http->is_playlist_resolved = true;
-            goto _stream_open_begin;
-        }
-    }
-    // Load key and parse key
-    if (http->hls_key) {
-        if (http->hls_key->key_loaded == false) {
-            if (_resolve_hls_key(http) != ESP_OK) {
-                return ESP_FAIL;
-            }
-            // Load media url after key loaded
-            goto _stream_open_begin;
-        } else {
-            if (_prepare_crypt(http) != ESP_OK) {
-                return ESP_FAIL;
-            }
-        }
-    }
-    http->is_open = true;
-    audio_element_report_codec_fmt(self);
-    return ESP_OK;
-}
-
-static esp_err_t _http_close(audio_element_handle_t self)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    ESP_LOGD(TAG, "_http_close");
-    if (http->is_open) {
-        http->is_open = false;
-        do {
-            if (http->stream_type != AUDIO_STREAM_WRITER) {
-                break;
-            }
-            if (dispatch_hook(self, HTTP_STREAM_POST_REQUEST, NULL, 0) < 0) {
-                break;
-            }
-            esp_http_client_fetch_headers(http->client);
-            if (dispatch_hook(self, HTTP_STREAM_FINISH_REQUEST, NULL, 0) < 0) {
-                break;
-            }
-        } while (0);
-    }
-
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        if (http->enable_playlist_parser) {
-            http_playlist_clear(http->playlist);
-            http->is_playlist_resolved = false;
-        }
-        audio_element_report_pos(self);
-        audio_element_set_byte_pos(self, 0);
-    }
-    _free_hls_key(http);
-    if (http->hls_media) {
-        hls_playlist_close(http->hls_media);
-        http->hls_media = NULL;
-    }
-    if (http->gzip) {
-        gzip_miniz_deinit(http->gzip);
-        http->gzip = NULL;
-    }
-    if (http->client) {
-        esp_http_client_close(http->client);
-        esp_http_client_cleanup(http->client);
-        http->client = NULL;
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _http_reconnect(audio_element_handle_t self)
-{
-    esp_err_t err = ESP_OK;
-    audio_element_info_t info = {0};
-    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
-    err |= audio_element_getinfo(self, &info);
-    err |= _http_close(self);
-    err |= audio_element_set_byte_pos(self, info.byte_pos);
-    err |= _http_open(self);
-    return err;
-}
-
-static bool _check_range_done(audio_element_handle_t self)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    bool last_range = http->is_last_range;
-    audio_element_info_t info = {};
-    audio_element_getinfo(self, &info);
-    // If not last range need reload uri from last position
-    if (last_range == false && _http_load_uri(self, &info) != ESP_OK) {
-        return true;
-    }
-    return last_range;
-}
-
-static int _http_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-    int wrlen = dispatch_hook(self, HTTP_STREAM_ON_RESPONSE, buffer, len);
-    int rlen = wrlen;
-    if (rlen == 0) {
-        rlen = _http_read_data(http, buffer, len);
-    }
-    if (rlen <= 0 && http->request_range_size) {
-        if (_check_range_done(self) == false) {
-            rlen = _http_read_data(http, buffer, len);
-        }
-    }
-    if (rlen <= 0 && http->auto_connect_next_track) {
-        if (http_stream_auto_connect_next_track(self) == ESP_OK) {
-            rlen = _http_read_data(http, buffer, len);
-        }
-    }
-    if (rlen <= 0) {
-        http->_errno = esp_http_client_get_errno(http->client);
-        ESP_LOGW(TAG, "No more data,errno:%d, total_bytes:%llu, rlen = %d", http->_errno, info.byte_pos, rlen);
-        if (http->_errno != 0) {  // Error occuered, reset connection
-            ESP_LOGW(TAG, "Got %d errno(%s)", http->_errno, strerror(http->_errno));
-            return http->_errno;
-        }
-        if (http->auto_connect_next_track) {
-            if (dispatch_hook(self, HTTP_STREAM_FINISH_PLAYLIST, NULL, 0) != ESP_OK) {
-                ESP_LOGE(TAG, "Failed to process user callback");
-                return ESP_FAIL;
-            }
-        } else {
-            if (dispatch_hook(self, HTTP_STREAM_FINISH_TRACK, NULL, 0) != ESP_OK) {
-                ESP_LOGE(TAG, "Failed to process user callback");
-                return ESP_FAIL;
-            }
-        }
-        return ESP_OK;
-    } else {
-        if (http->hls_key) {
-            int ret = esp_aes_crypt_cbc(&http->hls_key->aes_ctx, ESP_AES_DECRYPT, 
-                 rlen, (unsigned char*)http->hls_key->key.iv, 
-                 (unsigned char*)buffer, (unsigned char*)buffer);
-            if (rlen % 16 != 0) {
-                ESP_LOGE(TAG, "Data length %d not aligned", rlen);
-            }
-            if (ret != 0) {
-                ESP_LOGE(TAG, "Fail to decrypt aes ret %d", ret);
-                return ESP_FAIL;
-            }
-            if ((info.total_bytes && rlen + info.byte_pos >= info.total_bytes) ||
-                rlen < len) {
-                // Remove padding according PKCS#7
-                uint8_t padding = buffer[rlen-1];
-                if (padding && padding <= rlen) {
-                    int idx = rlen - padding;
-                    int paddin_n = padding -1;
-                    while (paddin_n) {
-                        if (buffer[idx++] != padding) {
-                            break;
-                        }
-                        paddin_n--;
-                    }
-                    if (paddin_n == 0) {
-                        rlen -= padding;
-                    }
-                }
-            }
-        }
-        audio_element_update_byte_pos(self, rlen);
-    }
-    ESP_LOGD(TAG, "req lengh=%d, read=%d, pos=%d/%d", len, rlen, (int)info.byte_pos, (int)info.total_bytes);
-    return rlen;
-}
-
-static int _http_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    int wrlen = dispatch_hook(self, HTTP_STREAM_ON_REQUEST, buffer, len);
-    if (wrlen < 0) {
-        ESP_LOGE(TAG, "Failed to process user callback");
-        return ESP_FAIL;
-    }
-    if (wrlen > 0) {
-        return wrlen;
-    }
-
-    if ((wrlen = esp_http_client_write(http->client, buffer, len)) <= 0) {
-        http->_errno = esp_http_client_get_errno(http->client);
-        ESP_LOGE(TAG, "Failed to write data to http stream, wrlen=%d, errno=%d(%s)", wrlen, http->_errno, strerror(http->_errno));
-    }
-    return wrlen;
-}
-
-static int _http_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    if (audio_element_is_stopping(self) == true) {
-        ESP_LOGW(TAG, "No output due to stopping");
-        return AEL_IO_ABORT;
-    }
-    int w_size = 0;
-    if (r_size > 0) {
-        http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-        if (http->_errno != 0) {
-            esp_err_t ret = ESP_OK;
-            if (http->connect_times > HTTP_MAX_CONNECT_TIMES) {
-                ESP_LOGE(TAG, "reconnect times more than %d, disconnect http stream", HTTP_MAX_CONNECT_TIMES);
-                return ESP_FAIL;
-            };
-            http->connect_times++;
-            ret = _http_reconnect(self);
-            if (ret != ESP_OK) {
-                ESP_LOGE(TAG, "Failed to reset connection");
-                return ret;
-            }
-            ESP_LOGW(TAG, "reconnect to peer successful");
-            return ESP_ERR_INVALID_STATE;
-        } else {
-            http->connect_times = 0;
-            w_size = audio_element_output(self, in_buffer, r_size);
-            audio_element_multi_output(self, in_buffer, r_size, 0);
-        }
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _http_destroy(audio_element_handle_t self)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
-    if (http->playlist) {
-        audio_free(http->playlist->data);
-        audio_free(http->playlist);
-    }
-    audio_free(http);
-    return ESP_OK;
-}
-
-audio_element_handle_t http_stream_init(http_stream_cfg_t *config)
-{
-    audio_element_handle_t el;
-    http_stream_t *http = audio_calloc(1, sizeof(http_stream_t));
-
-    AUDIO_MEM_CHECK(TAG, http, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _http_open;
-    cfg.close = _http_close;
-    cfg.process = _http_process;
-    cfg.destroy = _http_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.stack_in_ext = config->stack_in_ext;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.multi_out_rb_num = config->multi_out_num;
-    cfg.tag = "http";
-
-    http->type = config->type;
-    http->enable_playlist_parser = config->enable_playlist_parser;
-    http->auto_connect_next_track = config->auto_connect_next_track;
-    http->hook = config->event_handle;
-    http->stream_type = config->type;
-    http->user_data = config->user_data;
-    http->cert_pem = config->cert_pem;
-    http->user_agent = config->user_agent;
-
-    if (config->crt_bundle_attach) {
-#if  (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
-    #if CONFIG_MBEDTLS_CERTIFICATE_BUNDLE
-        http->crt_bundle_attach = config->crt_bundle_attach;
-    #else
-        ESP_LOGW(TAG, "Please enbale CONFIG_MBEDTLS_CERTIFICATE_BUNDLE configuration in menuconfig");
-    #endif
-#else
-        ESP_LOGW(TAG, "Just support MBEDTLS_CERTIFICATE_BUNDLE on esp-idf to v4.3 or later");
-#endif // ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0)
-    }
-
-    if (http->enable_playlist_parser) {
-        http->playlist = audio_calloc(1, sizeof(http_playlist_t));
-        AUDIO_MEM_CHECK(TAG, http->playlist, {
-            audio_free(http);
-            return NULL;
-        });
-        http->playlist->data = audio_calloc(1, MAX_PLAYLIST_LINE_SIZE + 1);
-        AUDIO_MEM_CHECK(TAG, http->playlist->data, {
-            audio_free(http->playlist);
-            audio_free(http);
-            return NULL;
-        });
-        STAILQ_INIT(&http->playlist->tracks);
-    }
-
-    if (config->type == AUDIO_STREAM_READER) {
-        cfg.read = _http_read;
-    } else if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _http_write;
-    }
-    http->request_range_size = config->request_range_size;
-    if (config->request_size) {
-        cfg.buffer_len = config->request_size;
-    }
-
-    el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, {
-        audio_free(http->playlist);
-        audio_free(http);
-        return NULL;
-    });
-    audio_element_setdata(el, http);
-    return el;
-}
-
-esp_err_t http_stream_next_track(audio_element_handle_t el)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-    if (!(http->enable_playlist_parser && http->is_playlist_resolved)) {
-        /**
-         * This is not a playlist!
-         * Do not reset states for restart element.
-         * Just return.
-         */
-        ESP_LOGD(TAG, "Direct URI. Stream will be stopped");
-        return ESP_OK;
-    }
-    audio_element_reset_state(el);
-    audio_element_set_byte_pos(el, 0);
-    audio_element_set_total_bytes(el, 0);
-    http->is_open = false;
-    return ESP_OK;
-}
-
-esp_err_t http_stream_auto_connect_next_track(audio_element_handle_t el)
-{
-    audio_element_info_t info;
-    audio_element_getinfo(el, &info);
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-    char *track = _playlist_get_next_track(el);
-    if (track) {
-        esp_http_client_set_url(http->client, track);
-        char *buffer = NULL;
-        int post_len = esp_http_client_get_post_field(http->client, &buffer);
-redirection:
-        if ((esp_http_client_open(http->client, post_len)) != ESP_OK) {
-            ESP_LOGE(TAG, "Failed to open http stream");
-            return ESP_FAIL;
-        }
-        if (dispatch_hook(el, HTTP_STREAM_POST_REQUEST, NULL, 0) < 0) {
-            esp_http_client_close(http->client);
-            return ESP_FAIL;
-        }
-        info.total_bytes = esp_http_client_fetch_headers(http->client);
-        ESP_LOGI(TAG, "total_bytes=%d", (int)info.total_bytes);
-        int status_code = esp_http_client_get_status_code(http->client);
-        if (status_code == 301 || status_code == 302) {
-            esp_http_client_set_redirection(http->client);
-            goto redirection;
-        }
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t http_stream_fetch_again(audio_element_handle_t el)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-    if (!http->playlist->is_incomplete) {
-        ESP_LOGI(TAG, "Finished playing.");
-        return ESP_ERR_NOT_SUPPORTED;
-    } else {
-        ESP_LOGI(TAG, "Fetching again %s %p", http->playlist->host_uri, http->playlist->host_uri);
-        audio_element_set_uri(el, http->playlist->host_uri);
-        http->is_playlist_resolved = false;
-    }
-    return ESP_OK;
-}
-
-esp_err_t http_stream_restart(audio_element_handle_t el)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-    http->is_playlist_resolved = false;
-    return ESP_OK;
-}
-
-esp_err_t http_stream_set_server_cert(audio_element_handle_t el, const char *cert)
-{
-    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
-    http->cert_pem = cert;
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <sys/unistd.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <strings.h>
+#include <errno.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/ringbuf.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+
+#include "esp_log.h"
+#include "http_stream.h"
+#include "http_playlist.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "esp_system.h"
+#include "esp_http_client.h"
+#include "line_reader.h"
+#include "hls_playlist.h"
+#include "audio_idf_version.h"
+#include "gzip_miniz.h"
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
+#include "aes/esp_aes.h"
+#elif (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 1, 0))
+#if CONFIG_IDF_TARGET_ESP32
+#include "esp32/aes.h"
+#elif CONFIG_IDF_TARGET_ESP32S2
+#include "esp32s2/aes.h"
+#endif
+#else
+#include "hwcrypto/aes.h"
+#endif
+
+static const char *TAG = "HTTP_STREAM";
+#define MAX_PLAYLIST_LINE_SIZE (512)
+#define HTTP_STREAM_BUFFER_SIZE (2048)
+#define HTTP_MAX_CONNECT_TIMES  (5)
+
+#define HLS_PREFER_BITRATE      (200*1024)
+#define HLS_KEY_CACHE_SIZE      (32)
+typedef struct {
+    bool             key_loaded;
+    char             *key_url;
+    uint8_t          key_cache[HLS_KEY_CACHE_SIZE];
+    uint8_t          key_size;
+    hls_stream_key_t key;
+    uint64_t         sequence_no;
+    esp_aes_context  aes_ctx;
+    bool             aes_used;
+} http_stream_hls_key_t;
+
+typedef struct http_stream {
+    audio_stream_type_t             type;
+    bool                            is_open;
+    esp_http_client_handle_t        client;
+    http_stream_event_handle_t      hook;
+    audio_stream_type_t             stream_type;
+    void                            *user_data;
+    bool                            enable_playlist_parser;
+    bool                            auto_connect_next_track; /* connect next track without open/close */
+    bool                            is_playlist_resolved;
+    bool                            is_valid_playlist;
+    bool                            is_main_playlist;
+    http_playlist_t                 *playlist;         /* media playlist */
+    int                             _errno;            /* errno code for http */
+    int                             connect_times;     /* max reconnect times */
+    const char                     *cert_pem;
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
+    esp_err_t                      (*crt_bundle_attach)(void *conf); /*  Function pointer to esp_crt_bundle_attach*/
+#endif
+    bool                            gzip_encoding;     /* Content is encoded */
+    gzip_miniz_handle_t             gzip;              /* GZIP instance */
+    http_stream_hls_key_t           *hls_key;
+    hls_handle_t                    *hls_media;
+    int                             request_range_size;
+    int64_t                         request_range_end;
+    bool                            is_last_range;
+    const char                      *user_agent;
+} http_stream_t;
+
+static esp_err_t http_stream_auto_connect_next_track(audio_element_handle_t el);
+
+// `errno` is not thread safe in multiple HTTP-clients,
+// so it is necessary to save the errno number of HTTP clients to avoid reading and writing exceptions of HTTP-clients caused by errno exceptions
+int __attribute__((weak)) esp_http_client_get_errno(esp_http_client_handle_t client)
+{
+    (void) client;
+    ESP_LOGE(TAG, "Not found right %s.\r\nPlease enter ADF-PATH with \"cd $ADF_PATH/idf_patches\" and apply the ADF patch with \"git apply $ADF_PATH/idf_patches/idf_%.4s_esp_http_client.patch\" first\r\n", __func__, IDF_VER);
+    return errno;
+}
+
+static esp_codec_type_t get_audio_type(const char *content_type)
+{
+    if (strcasecmp(content_type, "mp3") == 0 ||
+        strcasecmp(content_type, "audio/mp3") == 0 ||
+        strcasecmp(content_type, "audio/mpeg") == 0 ||
+        strcasecmp(content_type, "binary/octet-stream") == 0 ||
+        strcasecmp(content_type, "application/octet-stream") == 0) {
+        return ESP_CODEC_TYPE_MP3;
+    }
+    if (strcasecmp(content_type, "audio/aac") == 0 ||
+        strcasecmp(content_type, "audio/x-aac") == 0 ||
+        strcasecmp(content_type, "audio/mp4") == 0 ||
+        strcasecmp(content_type, "audio/aacp") == 0 ||
+        strcasecmp(content_type, "video/MP2T") == 0) {
+        return ESP_CODEC_TYPE_AAC;
+    }
+    if (strcasecmp(content_type, "audio/wav") == 0) {
+        return ESP_CODEC_TYPE_WAV;
+    }
+    if (strcasecmp(content_type, "audio/opus") == 0) {
+        return ESP_CODEC_TYPE_OPUS;
+    }
+    if (strcasecmp(content_type, "application/vnd.apple.mpegurl") == 0 ||
+        strcasecmp(content_type, "vnd.apple.mpegURL") == 0) {
+        return ESP_AUDIO_TYPE_M3U8;
+    }
+    if (strncasecmp(content_type, "audio/x-scpls", strlen("audio/x-scpls")) == 0) {
+        return ESP_AUDIO_TYPE_PLS;
+    }
+    return ESP_CODEC_TYPE_UNKNOW;
+}
+
+static int _gzip_read_data(uint8_t *data, int size, void *ctx)
+{
+    http_stream_t *http = (http_stream_t *) ctx;
+    return esp_http_client_read(http->client, (char *)data, size);
+}
+
+static esp_err_t _http_event_handle(esp_http_client_event_t *evt)
+{
+    audio_element_handle_t el = (audio_element_handle_t)evt->user_data;
+    if (evt->event_id != HTTP_EVENT_ON_HEADER) {
+        return ESP_OK;
+    }
+    if (strcasecmp(evt->header_key, "Content-Type") == 0) {
+        ESP_LOGD(TAG, "%s = %s", evt->header_key, evt->header_value);
+        audio_element_set_codec_fmt(el, get_audio_type(evt->header_value));
+    }
+    else if (strcasecmp(evt->header_key, "Content-Encoding") == 0) {
+        http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+        http->gzip_encoding = true;
+        if (strcasecmp(evt->header_value, "gzip") == 0) {
+            gzip_miniz_cfg_t cfg = {
+                .chunk_size = 1024,
+                .ctx = http,
+                .read_cb = _gzip_read_data,
+            };
+            http->gzip = gzip_miniz_init(&cfg);
+        }
+        if (http->gzip == NULL) {
+            ESP_LOGE(TAG, "Content-Encoding %s not supported", evt->header_value);
+            return ESP_FAIL;
+        }
+    }
+    else if (strcasecmp(evt->header_key, "Content-Range") == 0) {
+        http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+        if (http->request_range_size) {
+            char* end_pos = strchr(evt->header_value, '-');
+            http->is_last_range = true;
+            if (end_pos) {
+                end_pos++;
+                int64_t range_end = atoll(end_pos);
+                if (range_end == http->request_range_end) {
+                    http->is_last_range = false;
+                }
+                // Update total bytes to range end
+                audio_element_set_total_bytes(el, range_end+1);
+            }
+        }
+    }
+    return ESP_OK;
+}
+
+static int dispatch_hook(audio_element_handle_t self, http_stream_event_id_t type, void *buffer, int buffer_len)
+{
+    http_stream_t *http_stream = (http_stream_t *)audio_element_getdata(self);
+
+    http_stream_event_msg_t msg;
+    msg.event_id = type;
+    msg.http_client = http_stream->client;
+    msg.user_data = http_stream->user_data;
+    msg.buffer = buffer;
+    msg.buffer_len = buffer_len;
+    msg.el = self;
+    if (http_stream->hook) {
+        return http_stream->hook(&msg);
+    }
+    return ESP_OK;
+}
+
+static bool _is_playlist(audio_element_info_t *info, const char *uri)
+{
+    if (info->codec_fmt == ESP_AUDIO_TYPE_M3U8 || info->codec_fmt == ESP_AUDIO_TYPE_PLS) {
+        return true;
+    }
+    const char *s = uri;
+    while (*s) {
+        if (*s == '.') {
+            if (strncasecmp(s, ".m3u", 3) == 0) {
+                return true;
+            }
+        }
+        s++;
+    }
+    return false;
+}
+
+static int _hls_uri_cb(char *uri, void *ctx)
+{
+    http_stream_t *http = (http_stream_t *) ctx;
+    if (uri) {
+        http_playlist_insert(http->playlist, uri);
+        http->is_valid_playlist = true;
+    }
+    return 0;
+}
+
+static int _http_read_data(http_stream_t *http, char *buffer, int len)
+{
+    if (http->gzip_encoding == false) {
+        return esp_http_client_read(http->client, buffer, len);
+    }
+    // use gzip to uncompress data
+    return gzip_miniz_read(http->gzip, (uint8_t*) buffer, len);
+}
+
+static esp_err_t _resolve_hls_key(http_stream_t *http)
+{
+    int ret = _http_read_data(http, (char*)http->hls_key->key_cache, sizeof(http->hls_key->key_cache));
+    if (ret < 0) {
+        return ESP_FAIL;
+    }
+    http->hls_key->key_size = (uint8_t)ret;
+    http->hls_key->key_loaded = true;
+    return ESP_OK;
+}
+
+static esp_err_t _prepare_crypt(http_stream_t *http)
+{
+    http_stream_hls_key_t* hls_key = http->hls_key;
+    if (hls_key->aes_used) {
+        esp_aes_free(&hls_key->aes_ctx);
+        hls_key->aes_used = false;
+    }
+    int ret = hls_playlist_parse_key(http->hls_media, http->hls_key->key_cache, http->hls_key->key_size);
+    if (ret < 0) {
+        return ESP_FAIL;
+    }
+    ret = hls_playlist_get_key(http->hls_media, http->hls_key->sequence_no, &http->hls_key->key);
+    if (ret != 0) {
+        return ESP_FAIL;
+    }
+    esp_aes_init(&hls_key->aes_ctx);
+    esp_aes_setkey(&hls_key->aes_ctx, (unsigned char*)hls_key->key.key, 128);
+    hls_key->aes_used = true;
+    http->hls_key->sequence_no++;
+    return ESP_OK;
+}
+
+static void _free_hls_key(http_stream_t *http)
+{
+    if (http->hls_key == NULL) {
+        return;
+    }
+    if (http->hls_key->aes_used) {
+        esp_aes_free(&http->hls_key->aes_ctx);
+        http->hls_key->aes_used = false;
+    }
+    if (http->hls_key->key_url) {
+        audio_free(http->hls_key->key_url);
+    }
+    audio_free(http->hls_key);
+    http->hls_key = NULL;
+}
+
+static esp_err_t _resolve_playlist(audio_element_handle_t self, const char *uri)
+{
+    audio_element_info_t info;
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    audio_element_getinfo(self, &info);
+    if (http->hls_media) {
+        hls_playlist_close(http->hls_media);
+        http->hls_media = NULL;
+    }
+    // backup new uri firstly
+    char *new_uri = audio_strdup(uri);
+    if (new_uri == NULL) {
+        return ESP_FAIL;
+    }
+    if (http->is_main_playlist) {
+        http_playlist_clear(http->playlist);
+    }
+    if (http->playlist->host_uri) {
+        audio_free(http->playlist->host_uri);
+    }
+    http->playlist->host_uri = new_uri;
+    http->is_valid_playlist = false;
+
+    // handle PLS playlist
+    if (info.codec_fmt == ESP_AUDIO_TYPE_PLS) {
+        line_reader_t *reader = line_reader_init(MAX_PLAYLIST_LINE_SIZE);
+        if (reader == NULL) {
+            return ESP_FAIL;
+        }
+        int need_read = MAX_PLAYLIST_LINE_SIZE;
+        int rlen = need_read;
+        while (rlen == need_read) {
+            rlen = _http_read_data(http, http->playlist->data, need_read);
+            if (rlen < 0) {
+                break;
+            }
+            line_reader_add_buffer(reader, (uint8_t *)http->playlist->data, rlen, (rlen < need_read));
+            char *line;
+            while ((line = line_reader_get_line(reader)) != NULL) {
+                if (!strncmp(line, "File", sizeof("File") - 1)) { // This line contains url
+                    int i = 4;
+                    while (line[i++] != '='); // Skip till '='
+                    http_playlist_insert(http->playlist, line + i);
+                    http->is_valid_playlist = true;
+                }
+            }
+        }
+        line_reader_deinit(reader);
+        return http->is_valid_playlist ? ESP_OK : ESP_FAIL;
+    }
+    http->is_main_playlist = false;
+    hls_playlist_cfg_t cfg = {
+        .prefer_bitrate = HLS_PREFER_BITRATE,
+        .cb = _hls_uri_cb,
+        .ctx = http,
+        .uri = (char *)new_uri,
+    };
+    hls_handle_t hls = hls_playlist_open(&cfg);
+    do {
+        if (hls == NULL) {
+            break;
+        }
+        int need_read = MAX_PLAYLIST_LINE_SIZE;
+        int rlen = need_read;
+        while (rlen == need_read) {
+            rlen = _http_read_data(http, http->playlist->data, need_read);
+            if (rlen < 0) {
+                break;
+            }
+            hls_playlist_parse_data(hls, (uint8_t *)http->playlist->data, rlen, (rlen < need_read));
+        }
+        if (hls_playlist_is_master(hls)) {
+            char *url = hls_playlist_get_prefer_url(hls, HLS_STREAM_TYPE_AUDIO);
+            if (url) {
+                http_playlist_insert(http->playlist, url);
+                ESP_LOGI(TAG, "Add media uri %s\n", url);
+                http->is_valid_playlist = true;
+                http->is_main_playlist = true;
+                audio_free(url);
+            }
+        } else {
+            http->playlist->is_incomplete = !hls_playlist_is_media_end(hls);
+            if (http->playlist->is_incomplete) {
+                ESP_LOGI(TAG, "Live stream URI. Need to be fetched again!");
+            }
+        }
+    } while (0);
+    if (hls) {
+        if (hls_playlist_is_encrypt(hls) == false) {
+            _free_hls_key(http);
+            hls_playlist_close(hls);
+        } else {
+            // When content is encrypted, need keep hls instance
+            http->hls_media = hls;
+            const char *key_url = hls_playlist_get_key_uri(hls);
+            if (key_url == NULL) {
+                ESP_LOGE(TAG, "Hls do not have key url");
+                return ESP_FAIL;
+            }
+            if (http->hls_key == NULL) {
+                http->hls_key = (http_stream_hls_key_t *) calloc(1, sizeof(http_stream_hls_key_t));
+                if (http->hls_key == NULL) {
+                    ESP_LOGE(TAG, "No memory for hls key");
+                    return ESP_FAIL;
+                }
+            }
+            if (http->hls_key->key_url && strcmp(http->hls_key->key_url, key_url) == 0) {
+                http->hls_key->key_loaded = true;
+            } else {
+                if (http->hls_key->key_url) {
+                    audio_free(http->hls_key->key_url);
+                }
+                http->hls_key->key_loaded = false;
+                http->hls_key->key_url = audio_strdup(key_url);
+                if (http->hls_key->key_url == NULL) {
+                    ESP_LOGE(TAG, "No memory for hls key url");
+                    return ESP_FAIL;
+                } 
+            }
+            http->hls_key->sequence_no = hls_playlist_get_sequence_no(hls);
+        }
+    }
+    return http->is_valid_playlist ? ESP_OK : ESP_FAIL;
+}
+
+static char *_playlist_get_next_track(audio_element_handle_t self)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    if (http->enable_playlist_parser && http->is_playlist_resolved) {
+        return http_playlist_get_next_track(http->playlist);
+    }
+    return NULL;
+}
+
+static void _prepare_range(http_stream_t *http, int64_t pos)
+{
+    if (http->request_range_size > 0 || pos != 0) {
+        char range_header[64] = {0};
+        if (http->request_range_size == 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%lld-", pos);
+        } else {
+            int64_t end_pos = pos + http->request_range_size - 1;
+            if (pos < 0 && end_pos > 0) {
+                end_pos = 0;
+            }
+            snprintf(range_header, sizeof(range_header), "bytes=%lld-%lld", pos, end_pos);
+            http->request_range_end = end_pos;
+        }
+        esp_http_client_set_header(http->client, "Range", range_header);
+    } else {
+        esp_http_client_delete_header(http->client, "Range");
+    }
+}
+
+static esp_err_t _http_load_uri(audio_element_handle_t self, audio_element_info_t* info)
+{
+    esp_err_t err;
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+
+    esp_http_client_close(http->client);
+
+    if (dispatch_hook(self, HTTP_STREAM_PRE_REQUEST, NULL, 0) != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to process user callback");
+        return ESP_FAIL;
+    }
+
+    _prepare_range(http, info->byte_pos);
+
+    if (http->stream_type == AUDIO_STREAM_WRITER) {
+        err = esp_http_client_open(http->client, -1);
+        if (err == ESP_OK) {
+            http->is_open = true;
+        }
+        return err;
+    }
+
+    char *buffer = NULL;
+    int post_len = esp_http_client_get_post_field(http->client, &buffer);
+_stream_redirect:
+    if (http->gzip_encoding) {
+        gzip_miniz_deinit(http->gzip);
+        http->gzip = NULL;
+        http->gzip_encoding = false;
+    }
+    if ((err = esp_http_client_open(http->client, post_len)) != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to open http stream");
+        return err;
+    }
+
+    int wrlen = dispatch_hook(self, HTTP_STREAM_ON_REQUEST, buffer, post_len);
+    if (wrlen < 0) {
+        ESP_LOGE(TAG, "Failed to process user callback");
+        return ESP_FAIL;
+    }
+
+    if (post_len && buffer && wrlen == 0) {
+        if (esp_http_client_write(http->client, buffer, post_len) <= 0) {
+            ESP_LOGE(TAG, "Failed to write data to http stream");
+            return ESP_FAIL;
+        }
+        ESP_LOGD(TAG, "len=%d, data=%s", post_len, buffer);
+    }
+
+    if (dispatch_hook(self, HTTP_STREAM_POST_REQUEST, NULL, 0) < 0) {
+        esp_http_client_close(http->client);
+        return ESP_FAIL;
+    }
+    /*
+    * Due to the total byte of content has been changed after seek, set info.total_bytes at beginning only.
+    */
+    int64_t cur_pos = esp_http_client_fetch_headers(http->client);
+    audio_element_getinfo(self, info);
+    if (info->byte_pos <= 0) {
+        info->total_bytes = cur_pos;
+        ESP_LOGI(TAG, "total_bytes=%d", (int)info->total_bytes);
+        audio_element_set_total_bytes(self, info->total_bytes);
+    }
+    int status_code = esp_http_client_get_status_code(http->client);
+    if (status_code == 301 || status_code == 302) {
+        esp_http_client_set_redirection(http->client);
+        goto _stream_redirect;
+    }
+    if (status_code != 200
+        && (esp_http_client_get_status_code(http->client) != 206)
+        && (esp_http_client_get_status_code(http->client) != 416)) {
+        ESP_LOGE(TAG, "Invalid HTTP stream, status code = %d", status_code);
+        if (http->enable_playlist_parser) {
+            http_playlist_clear(http->playlist);
+            http->is_playlist_resolved = false;
+        }
+        return ESP_FAIL;
+    }
+    return err;
+}
+
+static esp_err_t _http_open(audio_element_handle_t self)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    char *uri = NULL;
+    audio_element_info_t info;
+    ESP_LOGD(TAG, "_http_open");
+
+    if (http->is_open) {
+        ESP_LOGE(TAG, "already opened");
+        return ESP_OK;
+    }
+    http->_errno = 0;
+    audio_element_getinfo(self, &info);
+_stream_open_begin:
+    if (http->hls_key && http->hls_key->key_loaded == false) {
+        uri = http->hls_key->key_url;
+    } else if (info.byte_pos == 0) {
+        uri = _playlist_get_next_track(self);
+    } else if (http->is_playlist_resolved) {
+        uri = http_playlist_get_last_track(http->playlist);
+    }
+    if (uri == NULL) {
+        if (http->is_playlist_resolved && http->enable_playlist_parser) {
+            if (dispatch_hook(self, HTTP_STREAM_FINISH_PLAYLIST, NULL, 0) != ESP_OK) {
+                ESP_LOGE(TAG, "Failed to process user callback");
+                return ESP_FAIL;
+            }
+            goto _stream_open_begin;
+        }
+        uri = audio_element_get_uri(self);
+    }
+
+    if (uri == NULL) {
+        ESP_LOGE(TAG, "Error open connection, uri = NULL");
+        return ESP_FAIL;
+    }
+    
+    ESP_LOGD(TAG, "URI=%s", uri);
+    // if not initialize http client, initial it
+    if (http->client == NULL) {
+        esp_http_client_config_t http_cfg = {
+            .url = uri,
+            .event_handler = _http_event_handle,
+            .user_data = self,
+            .timeout_ms = 30 * 1000,
+            .buffer_size = HTTP_STREAM_BUFFER_SIZE,
+#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 1, 0)
+            .buffer_size_tx = 1024,
+#endif
+            .cert_pem = http->cert_pem,
+#if  (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0)) && defined CONFIG_MBEDTLS_CERTIFICATE_BUNDLE
+            .crt_bundle_attach = http->crt_bundle_attach,
+#endif //  (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0)) && defined CONFIG_MBEDTLS_CERTIFICATE_BUNDLE
+            .user_agent = http->user_agent,
+        };
+        http->client = esp_http_client_init(&http_cfg);
+        AUDIO_MEM_CHECK(TAG, http->client, return ESP_ERR_NO_MEM);
+    } else {
+        esp_http_client_set_url(http->client, uri);
+    }
+    audio_element_getinfo(self, &info);
+
+    if (_http_load_uri(self, &info) != ESP_OK) {
+        return ESP_FAIL;
+    }
+
+    if (_is_playlist(&info, uri) == true) {
+        /**
+         * `goto _stream_open_begin` blocks on http_open until it gets valid URL.
+         * Ensure that the stop command is processed
+        */
+        if (audio_element_is_stopping(self) == true) {
+            ESP_LOGW(TAG, "Http_open got stop cmd at opening");
+            return ESP_OK;
+        }
+
+        if (_resolve_playlist(self, uri) == ESP_OK) {
+            http->is_playlist_resolved = true;
+            goto _stream_open_begin;
+        }
+    }
+    // Load key and parse key
+    if (http->hls_key) {
+        if (http->hls_key->key_loaded == false) {
+            if (_resolve_hls_key(http) != ESP_OK) {
+                return ESP_FAIL;
+            }
+            // Load media url after key loaded
+            goto _stream_open_begin;
+        } else {
+            if (_prepare_crypt(http) != ESP_OK) {
+                return ESP_FAIL;
+            }
+        }
+    }
+    http->is_open = true;
+    audio_element_report_codec_fmt(self);
+    return ESP_OK;
+}
+
+static esp_err_t _http_close(audio_element_handle_t self)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    ESP_LOGD(TAG, "_http_close");
+    if (http->is_open) {
+        http->is_open = false;
+        do {
+            if (http->stream_type != AUDIO_STREAM_WRITER) {
+                break;
+            }
+            if (dispatch_hook(self, HTTP_STREAM_POST_REQUEST, NULL, 0) < 0) {
+                break;
+            }
+            esp_http_client_fetch_headers(http->client);
+            if (dispatch_hook(self, HTTP_STREAM_FINISH_REQUEST, NULL, 0) < 0) {
+                break;
+            }
+        } while (0);
+    }
+
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        if (http->enable_playlist_parser) {
+            http_playlist_clear(http->playlist);
+            http->is_playlist_resolved = false;
+        }
+        audio_element_report_pos(self);
+        audio_element_set_byte_pos(self, 0);
+    }
+    _free_hls_key(http);
+    if (http->hls_media) {
+        hls_playlist_close(http->hls_media);
+        http->hls_media = NULL;
+    }
+    if (http->gzip) {
+        gzip_miniz_deinit(http->gzip);
+        http->gzip = NULL;
+    }
+    if (http->client) {
+        esp_http_client_close(http->client);
+        esp_http_client_cleanup(http->client);
+        http->client = NULL;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _http_reconnect(audio_element_handle_t self)
+{
+    esp_err_t err = ESP_OK;
+    audio_element_info_t info = {0};
+    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
+    err |= audio_element_getinfo(self, &info);
+    err |= _http_close(self);
+    err |= audio_element_set_byte_pos(self, info.byte_pos);
+    err |= _http_open(self);
+    return err;
+}
+
+static bool _check_range_done(audio_element_handle_t self)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    bool last_range = http->is_last_range;
+    audio_element_info_t info = {};
+    audio_element_getinfo(self, &info);
+    // If not last range need reload uri from last position
+    if (last_range == false && _http_load_uri(self, &info) != ESP_OK) {
+        return true;
+    }
+    return last_range;
+}
+
+static int _http_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+    int wrlen = dispatch_hook(self, HTTP_STREAM_ON_RESPONSE, buffer, len);
+    int rlen = wrlen;
+    if (rlen == 0) {
+        rlen = _http_read_data(http, buffer, len);
+    }
+    if (rlen <= 0 && http->request_range_size) {
+        if (_check_range_done(self) == false) {
+            rlen = _http_read_data(http, buffer, len);
+        }
+    }
+    if (rlen <= 0 && http->auto_connect_next_track) {
+        if (http_stream_auto_connect_next_track(self) == ESP_OK) {
+            rlen = _http_read_data(http, buffer, len);
+        }
+    }
+    if (rlen <= 0) {
+        http->_errno = esp_http_client_get_errno(http->client);
+        ESP_LOGW(TAG, "No more data,errno:%d, total_bytes:%llu, rlen = %d", http->_errno, info.byte_pos, rlen);
+        if (http->_errno != 0) {  // Error occuered, reset connection
+            ESP_LOGW(TAG, "Got %d errno(%s)", http->_errno, strerror(http->_errno));
+            return http->_errno;
+        }
+        if (http->auto_connect_next_track) {
+            if (dispatch_hook(self, HTTP_STREAM_FINISH_PLAYLIST, NULL, 0) != ESP_OK) {
+                ESP_LOGE(TAG, "Failed to process user callback");
+                return ESP_FAIL;
+            }
+        } else {
+            if (dispatch_hook(self, HTTP_STREAM_FINISH_TRACK, NULL, 0) != ESP_OK) {
+                ESP_LOGE(TAG, "Failed to process user callback");
+                return ESP_FAIL;
+            }
+        }
+        return ESP_OK;
+    } else {
+        if (http->hls_key) {
+            int ret = esp_aes_crypt_cbc(&http->hls_key->aes_ctx, ESP_AES_DECRYPT, 
+                 rlen, (unsigned char*)http->hls_key->key.iv, 
+                 (unsigned char*)buffer, (unsigned char*)buffer);
+            if (rlen % 16 != 0) {
+                ESP_LOGE(TAG, "Data length %d not aligned", rlen);
+            }
+            if (ret != 0) {
+                ESP_LOGE(TAG, "Fail to decrypt aes ret %d", ret);
+                return ESP_FAIL;
+            }
+            if ((info.total_bytes && rlen + info.byte_pos >= info.total_bytes) ||
+                rlen < len) {
+                // Remove padding according PKCS#7
+                uint8_t padding = buffer[rlen-1];
+                if (padding && padding <= rlen) {
+                    int idx = rlen - padding;
+                    int paddin_n = padding -1;
+                    while (paddin_n) {
+                        if (buffer[idx++] != padding) {
+                            break;
+                        }
+                        paddin_n--;
+                    }
+                    if (paddin_n == 0) {
+                        rlen -= padding;
+                    }
+                }
+            }
+        }
+        audio_element_update_byte_pos(self, rlen);
+    }
+    ESP_LOGD(TAG, "req lengh=%d, read=%d, pos=%d/%d", len, rlen, (int)info.byte_pos, (int)info.total_bytes);
+    return rlen;
+}
+
+static int _http_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    int wrlen = dispatch_hook(self, HTTP_STREAM_ON_REQUEST, buffer, len);
+    if (wrlen < 0) {
+        ESP_LOGE(TAG, "Failed to process user callback");
+        return ESP_FAIL;
+    }
+    if (wrlen > 0) {
+        return wrlen;
+    }
+
+    if ((wrlen = esp_http_client_write(http->client, buffer, len)) <= 0) {
+        http->_errno = esp_http_client_get_errno(http->client);
+        ESP_LOGE(TAG, "Failed to write data to http stream, wrlen=%d, errno=%d(%s)", wrlen, http->_errno, strerror(http->_errno));
+    }
+    return wrlen;
+}
+
+static int _http_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    if (audio_element_is_stopping(self) == true) {
+        ESP_LOGW(TAG, "No output due to stopping");
+        return AEL_IO_ABORT;
+    }
+    int w_size = 0;
+    if (r_size > 0) {
+        http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+        if (http->_errno != 0) {
+            esp_err_t ret = ESP_OK;
+            if (http->connect_times > HTTP_MAX_CONNECT_TIMES) {
+                ESP_LOGE(TAG, "reconnect times more than %d, disconnect http stream", HTTP_MAX_CONNECT_TIMES);
+                return ESP_FAIL;
+            };
+            http->connect_times++;
+            ret = _http_reconnect(self);
+            if (ret != ESP_OK) {
+                ESP_LOGE(TAG, "Failed to reset connection");
+                return ret;
+            }
+            ESP_LOGW(TAG, "reconnect to peer successful");
+            return ESP_ERR_INVALID_STATE;
+        } else {
+            http->connect_times = 0;
+            w_size = audio_element_output(self, in_buffer, r_size);
+            audio_element_multi_output(self, in_buffer, r_size, 0);
+        }
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _http_destroy(audio_element_handle_t self)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(self);
+    if (http->playlist) {
+        audio_free(http->playlist->data);
+        audio_free(http->playlist);
+    }
+    audio_free(http);
+    return ESP_OK;
+}
+
+audio_element_handle_t http_stream_init(http_stream_cfg_t *config)
+{
+    audio_element_handle_t el;
+    http_stream_t *http = audio_calloc(1, sizeof(http_stream_t));
+
+    AUDIO_MEM_CHECK(TAG, http, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _http_open;
+    cfg.close = _http_close;
+    cfg.process = _http_process;
+    cfg.destroy = _http_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.stack_in_ext = config->stack_in_ext;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.multi_out_rb_num = config->multi_out_num;
+    cfg.tag = "http";
+
+    http->type = config->type;
+    http->enable_playlist_parser = config->enable_playlist_parser;
+    http->auto_connect_next_track = config->auto_connect_next_track;
+    http->hook = config->event_handle;
+    http->stream_type = config->type;
+    http->user_data = config->user_data;
+    http->cert_pem = config->cert_pem;
+    http->user_agent = config->user_agent;
+
+    if (config->crt_bundle_attach) {
+#if  (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
+    #if CONFIG_MBEDTLS_CERTIFICATE_BUNDLE
+        http->crt_bundle_attach = config->crt_bundle_attach;
+    #else
+        ESP_LOGW(TAG, "Please enbale CONFIG_MBEDTLS_CERTIFICATE_BUNDLE configuration in menuconfig");
+    #endif
+#else
+        ESP_LOGW(TAG, "Just support MBEDTLS_CERTIFICATE_BUNDLE on esp-idf to v4.3 or later");
+#endif // ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0)
+    }
+
+    if (http->enable_playlist_parser) {
+        http->playlist = audio_calloc(1, sizeof(http_playlist_t));
+        AUDIO_MEM_CHECK(TAG, http->playlist, {
+            audio_free(http);
+            return NULL;
+        });
+        http->playlist->data = audio_calloc(1, MAX_PLAYLIST_LINE_SIZE + 1);
+        AUDIO_MEM_CHECK(TAG, http->playlist->data, {
+            audio_free(http->playlist);
+            audio_free(http);
+            return NULL;
+        });
+        STAILQ_INIT(&http->playlist->tracks);
+    }
+
+    if (config->type == AUDIO_STREAM_READER) {
+        cfg.read = _http_read;
+    } else if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _http_write;
+    }
+    http->request_range_size = config->request_range_size;
+    if (config->request_size) {
+        cfg.buffer_len = config->request_size;
+    }
+
+    el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, {
+        audio_free(http->playlist);
+        audio_free(http);
+        return NULL;
+    });
+    audio_element_setdata(el, http);
+    return el;
+}
+
+esp_err_t http_stream_next_track(audio_element_handle_t el)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+    if (!(http->enable_playlist_parser && http->is_playlist_resolved)) {
+        /**
+         * This is not a playlist!
+         * Do not reset states for restart element.
+         * Just return.
+         */
+        ESP_LOGD(TAG, "Direct URI. Stream will be stopped");
+        return ESP_OK;
+    }
+    audio_element_reset_state(el);
+    audio_element_set_byte_pos(el, 0);
+    audio_element_set_total_bytes(el, 0);
+    http->is_open = false;
+    return ESP_OK;
+}
+
+esp_err_t http_stream_auto_connect_next_track(audio_element_handle_t el)
+{
+    audio_element_info_t info;
+    audio_element_getinfo(el, &info);
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+    char *track = _playlist_get_next_track(el);
+    if (track) {
+        esp_http_client_set_url(http->client, track);
+        char *buffer = NULL;
+        int post_len = esp_http_client_get_post_field(http->client, &buffer);
+redirection:
+        if ((esp_http_client_open(http->client, post_len)) != ESP_OK) {
+            ESP_LOGE(TAG, "Failed to open http stream");
+            return ESP_FAIL;
+        }
+        if (dispatch_hook(el, HTTP_STREAM_POST_REQUEST, NULL, 0) < 0) {
+            esp_http_client_close(http->client);
+            return ESP_FAIL;
+        }
+        info.total_bytes = esp_http_client_fetch_headers(http->client);
+        ESP_LOGI(TAG, "total_bytes=%d", (int)info.total_bytes);
+        int status_code = esp_http_client_get_status_code(http->client);
+        if (status_code == 301 || status_code == 302) {
+            esp_http_client_set_redirection(http->client);
+            goto redirection;
+        }
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t http_stream_fetch_again(audio_element_handle_t el)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+    if (!http->playlist->is_incomplete) {
+        ESP_LOGI(TAG, "Finished playing.");
+        return ESP_ERR_NOT_SUPPORTED;
+    } else {
+        ESP_LOGI(TAG, "Fetching again %s %p", http->playlist->host_uri, http->playlist->host_uri);
+        audio_element_set_uri(el, http->playlist->host_uri);
+        http->is_playlist_resolved = false;
+    }
+    return ESP_OK;
+}
+
+esp_err_t http_stream_restart(audio_element_handle_t el)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+    http->is_playlist_resolved = false;
+    return ESP_OK;
+}
+
+esp_err_t http_stream_set_server_cert(audio_element_handle_t el, const char *cert)
+{
+    http_stream_t *http = (http_stream_t *)audio_element_getdata(el);
+    http->cert_pem = cert;
+    return ESP_OK;
+}
diff --git a/components/audio_stream/i2s_stream.c b/components/audio_stream/i2s_stream.c
index 1e7f2188..6f5e7a7b 100644
--- a/components/audio_stream/i2s_stream.c
+++ b/components/audio_stream/i2s_stream.c
@@ -1,544 +1,544 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/ringbuf.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-
-#include "driver/i2s.h"
-#include "soc/io_mux_reg.h"
-#include "esp_log.h"
-#include "esp_err.h"
-
-#include "audio_common.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "i2s_stream.h"
-#include "esp_alc.h"
-#include "board_pins_config.h"
-#include "audio_idf_version.h"
-
-static const char *TAG = "I2S_STREAM";
-
-#define I2S_BUFFER_ALINED_BYTES_SIZE (12)
-
-#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 2, 0)
-#define SOC_I2S_SUPPORTS_ADC_DAC 1
-#elif (SOC_DAC_SUPPORTED)
-#if CONFIG_IDF_TARGET_ESP32
-#define SOC_I2S_SUPPORTS_ADC_DAC 1
-#endif
-#endif
-
-typedef struct i2s_stream {
-    audio_stream_type_t type;
-    i2s_stream_cfg_t    config;
-    bool                is_open;
-    bool                use_alc;
-    void               *volume_handle;
-    int                 volume;
-    bool                uninstall_drv;
-    int                 data_bit_width;
-} i2s_stream_t;
-#ifdef SOC_I2S_SUPPORTS_ADC_DAC
-static esp_err_t i2s_mono_fix(int bits, uint8_t *sbuff, uint32_t len)
-{
-    if (bits == 16) {
-        int16_t *temp_buf = (int16_t *)sbuff;
-        int16_t temp_box;
-        int k = len >> 1;
-        for (int i = 0; i < k; i += 2) {
-            temp_box = temp_buf[i];
-            temp_buf[i] = temp_buf[i + 1];
-            temp_buf[i + 1] = temp_box;
-        }
-    } else if (bits == 32) {
-        int32_t *temp_buf = (int32_t *)sbuff;
-        int32_t temp_box;
-        int k = len >> 2;
-        for (int i = 0; i < k; i += 4) {
-            temp_box = temp_buf[i];
-            temp_buf[i] = temp_buf[i + 1];
-            temp_buf[i + 1] = temp_box;
-        }
-    } else {
-        ESP_LOGE(TAG, "%s %dbits is not supported", __func__, bits);
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-/**
- * @brief Scale data to 16bit/32bit for I2S DMA output.
- *        DAC can only output 8bit data value.
- *        I2S DMA will still send 16bit or 32bit data, the highest 8bit contains DAC data.
- */
-static int i2s_dac_data_scale(int bits, uint8_t *sBuff, uint32_t len)
-{
-    if (bits == 16) {
-        short *buf16 = (short *)sBuff;
-        int k = len >> 1;
-        for (int i = 0; i < k; i++) {
-            buf16[i] &= 0xff00;
-            buf16[i] += 0x8000;//turn signed value into unsigned, expand negative value into positive range
-        }
-    } else if (bits == 32) {
-        int *buf32 = (int *)sBuff;
-        int k = len >> 2;
-        for (int i = 0; i < k; i++) {
-            buf32[i] &= 0xff000000;
-            buf32[i] += 0x80000000;//turn signed value into unsigned
-        }
-    } else {
-        ESP_LOGE(TAG, "in %s %dbits is not supported", __func__, bits);
-        return -1;
-    }
-
-    return 0;
-}
-#endif
-
-static inline esp_err_t i2s_stream_check_data_bits(i2s_stream_t *i2s, int bits)
-{
-#if CONFIG_IDF_TARGET_ESP32
-    if (bits == I2S_BITS_PER_SAMPLE_24BIT) {
-        i2s->config.expand_src_bits = bits;
-        i2s->data_bit_width = I2S_BITS_PER_SAMPLE_24BIT;
-    } else {
-        i2s->data_bit_width = 0;
-    }
-#endif
-    return ESP_OK;
-}
-
-static int i2s_stream_clear_dma_buffer(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    int index = i2s->config.i2s_config.dma_buf_count;
-    uint8_t *buf = audio_calloc(1, i2s->config.i2s_config.dma_buf_len * 4);
-    AUDIO_MEM_CHECK(TAG, buf, return ESP_ERR_NO_MEM);
-#if SOC_I2S_SUPPORTS_ADC_DAC
-    if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
-        memset(buf, 0x80, i2s->config.i2s_config.dma_buf_len * 4);
-    }
-#endif
-    while (index--) {
-        audio_element_output(self, (char *)buf, i2s->config.i2s_config.dma_buf_len * 4);
-    }
-    if (buf) {
-        audio_free(buf);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _i2s_set_clk(i2s_port_t i2s_num, uint32_t rate, uint32_t bits_cfg, int ch)
-{
-    i2s_channel_t channel;
-    if (ch == 1) {
-        channel = I2S_CHANNEL_MONO;
-    } else if (ch == 2) {
-        channel = I2S_CHANNEL_STEREO;
-    } else {
-        return ESP_FAIL;
-    }
-    return i2s_set_clk(i2s_num, rate, bits_cfg, channel);
-}
-
-static esp_err_t _i2s_open(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    ESP_LOGD(TAG, "_i2s_open %d", (int)i2s->config.i2s_port);
-    if (i2s->is_open) {
-        return ESP_OK;
-    }
-
-    if (i2s->type == AUDIO_STREAM_WRITER) {
-        audio_element_set_input_timeout(self, 10 / portTICK_RATE_MS);
-        ESP_LOGI(TAG, "AUDIO_STREAM_WRITER");
-    }
-    i2s->is_open = true;
-    if (i2s->use_alc) {
-        i2s->volume_handle = alc_volume_setup_open();
-        if (i2s->volume_handle == NULL) {
-            ESP_LOGE(TAG, "i2s create the handle for setting volume failed, in line(%d)", __LINE__);
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _i2s_destroy(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    if (i2s->uninstall_drv) {
-        i2s_driver_uninstall(i2s->config.i2s_port);
-    }
-    audio_free(i2s);
-    return ESP_OK;
-}
-
-static esp_err_t _i2s_close(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    esp_err_t ret = i2s_stream_clear_dma_buffer(self);
-    if (ret != ESP_OK) {
-        return ret;
-    }
-    i2s->is_open = false;
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_report_pos(self);
-        audio_element_set_byte_pos(self, 0);
-    }
-    if (i2s->use_alc) {
-        if (i2s->volume_handle != NULL) {
-            alc_volume_setup_close(i2s->volume_handle);
-        }
-    }
-    return ESP_OK;
-}
-
-static int _i2s_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    size_t bytes_read = 0;
-    i2s_read(i2s->config.i2s_port, buffer, len, &bytes_read, ticks_to_wait);
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-    if (bytes_read > 0) {
-#ifdef CONFIG_IDF_TARGET_ESP32
-        if (info.channels == 1) {
-            i2s_mono_fix(info.bits, (uint8_t *)buffer, bytes_read);
-        }
-#endif
-    }
-    return bytes_read;
-}
-
-static int _i2s_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    size_t bytes_written = 0;
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-    int target_bits = info.bits;
-    if (len > 0) {
-#ifdef CONFIG_IDF_TARGET_ESP32
-        target_bits = I2S_BITS_PER_SAMPLE_32BIT;
-        if (info.channels == 1) {
-            i2s_mono_fix(info.bits, (uint8_t *)buffer, len);
-        }
-#endif
-#if SOC_I2S_SUPPORTS_ADC_DAC
-        if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
-            i2s_dac_data_scale(info.bits, (uint8_t *)buffer, len);
-        }
-#endif
-    }
-
-    if (len) {
-        if ((i2s->config.need_expand && (target_bits != i2s->config.expand_src_bits)) || (i2s->data_bit_width == I2S_BITS_PER_SAMPLE_24BIT)) {
-            i2s_write_expand(i2s->config.i2s_port,
-                            buffer,
-                            len,
-                            i2s->config.expand_src_bits,
-                            target_bits,
-                            &bytes_written,
-                            ticks_to_wait);
-        } else {
-            i2s_write(i2s->config.i2s_port, buffer, len, &bytes_written, ticks_to_wait);
-        }
-    }
-
-    return bytes_written;
-}
-
-static int _i2s_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    audio_element_info_t i2s_info = {0};
-    if (r_size == AEL_IO_TIMEOUT) {
-#if SOC_I2S_SUPPORTS_ADC_DAC
-        if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
-            memset(in_buffer, 0x80, in_len);
-        } else
-#endif
-        {
-            memset(in_buffer, 0x00, in_len);
-        }
-        r_size = in_len;
-        audio_element_multi_output(self, in_buffer, r_size, 0);
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else if (r_size > 0) {
-        if (i2s->use_alc) {
-            audio_element_getinfo(self, &i2s_info);
-            alc_volume_setup_process(in_buffer, r_size, i2s_info.channels, i2s->volume_handle, i2s->volume);
-        }
-        audio_element_multi_output(self, in_buffer, r_size, 0);
-        w_size = audio_element_output(self, in_buffer, r_size);
-        audio_element_update_byte_pos(self, w_size);
-    } else {
-        esp_err_t ret = i2s_stream_clear_dma_buffer(self);
-        if (ret != ESP_OK) {
-            return ret;
-        }
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)
-#if CONFIG_IDF_TARGET_ESP32
-static esp_err_t i2s_mclk_gpio_select(i2s_port_t i2s_num, gpio_num_t gpio_num)
-{
-    if (i2s_num >= SOC_I2S_NUM) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    if (i2s_num == I2S_NUM_0) {
-        if (gpio_num == GPIO_NUM_0) {
-            PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
-            WRITE_PERI_REG(PIN_CTRL, 0xFFF0);
-        } else if (gpio_num == GPIO_NUM_1) {
-            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
-            WRITE_PERI_REG(PIN_CTRL, 0xF0F0);
-        } else {
-            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
-            WRITE_PERI_REG(PIN_CTRL, 0xFF00);
-        }
-    } else if (i2s_num == I2S_NUM_1) {
-        if (gpio_num == GPIO_NUM_0) {
-            PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
-            WRITE_PERI_REG(PIN_CTRL, 0xFFFF);
-        } else if (gpio_num == GPIO_NUM_1) {
-            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
-            WRITE_PERI_REG(PIN_CTRL, 0xF0FF);
-        } else {
-            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
-            WRITE_PERI_REG(PIN_CTRL, 0xFF0F);
-        }
-    }
-    return ESP_OK;
-}
-#else
-static esp_err_t i2s_mclk_gpio_select(i2s_port_t i2s_num, gpio_num_t gpio_num)
-{
-    return ESP_FAIL;
-}
-#endif
-#endif
-
-esp_err_t i2s_stream_set_clk(audio_element_handle_t i2s_stream, int rate, int bits, int ch)
-{
-    esp_err_t err = ESP_OK;
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-    audio_element_state_t state = audio_element_get_state(i2s_stream);
-    if (state == AEL_STATE_RUNNING) {
-        audio_element_pause(i2s_stream);
-    }
-    audio_element_set_music_info(i2s_stream, rate, ch, bits);
-
-    i2s_zero_dma_buffer(i2s->config.i2s_port);
-    i2s_stream_check_data_bits(i2s, bits);
-    if (_i2s_set_clk(i2s->config.i2s_port, rate, bits, ch) == ESP_FAIL) {
-        ESP_LOGE(TAG, "i2s_set_clk failed, type = %d,port:%d", i2s->config.type, i2s->config.i2s_port);
-        err = ESP_FAIL;
-    }
-    if (state == AEL_STATE_RUNNING) {
-        audio_element_resume(i2s_stream, 0, 0);
-    }
-    return err;
-}
-
-int i2s_alc_volume_set(audio_element_handle_t i2s_stream, int volume)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-    if (i2s->use_alc) {
-        i2s->volume = volume;
-        return ESP_OK;
-    } else {
-        ESP_LOGW(TAG, "The ALC don't be used. It can not be set.");
-        return ESP_FAIL;
-    }
-}
-
-int i2s_alc_volume_get(audio_element_handle_t i2s_stream, int *volume)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-    if (i2s->use_alc) {
-        *volume = i2s->volume;
-        return ESP_OK;
-    } else {
-        ESP_LOGW(TAG, "The ALC don't be used");
-        return ESP_FAIL;
-    }
-}
-
-audio_element_handle_t i2s_stream_init(i2s_stream_cfg_t *config)
-{
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    audio_element_handle_t el;
-    cfg.open = _i2s_open;
-    cfg.close = _i2s_close;
-    cfg.process = _i2s_process;
-    cfg.destroy = _i2s_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.stack_in_ext = config->stack_in_ext;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.multi_out_rb_num = config->multi_out_num;
-    cfg.tag = "iis";
-    cfg.buffer_len = config->buffer_len;
-
-    if (cfg.buffer_len % I2S_BUFFER_ALINED_BYTES_SIZE) {
-        ESP_LOGE(TAG, "The size of buffer must be a multiple of %d, current size is %d", I2S_BUFFER_ALINED_BYTES_SIZE, cfg.buffer_len);
-        return NULL;
-    }
-
-    i2s_stream_t *i2s = audio_calloc(1, sizeof(i2s_stream_t));
-    AUDIO_MEM_CHECK(TAG, i2s, return NULL);
-    memcpy(&i2s->config, config, sizeof(i2s_stream_cfg_t));
-
-    i2s->type = config->type;
-    i2s->use_alc = config->use_alc;
-    i2s->volume = config->volume;
-    i2s->uninstall_drv = config->uninstall_drv;
-
-    if (config->type == AUDIO_STREAM_READER) {
-        cfg.read = _i2s_read;
-    } else if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _i2s_write;
-    }
-
-    esp_err_t ret = i2s_driver_install(i2s->config.i2s_port, &i2s->config.i2s_config, 0, NULL);
-    if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
-        audio_free(i2s);
-        return NULL;
-    }
-    i2s_stream_check_data_bits(i2s, i2s->config.i2s_config.bits_per_sample);
-
-    el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, {
-        audio_free(i2s);
-        return NULL;
-    });
-    audio_element_setdata(el, i2s);
-
-    audio_element_set_music_info(el, config->i2s_config.sample_rate,
-                                 config->i2s_config.channel_format < I2S_CHANNEL_FMT_ONLY_RIGHT ? 2 : 1,
-                                 config->i2s_config.bits_per_sample);
-#if SOC_I2S_SUPPORTS_ADC_DAC
-    if ((config->i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
-        i2s_set_dac_mode(I2S_DAC_CHANNEL_BOTH_EN);
-    } else
-#endif
-    {
-        board_i2s_pin_t board_i2s_pin = {0};
-        i2s_pin_config_t i2s_pin_cfg;
-        get_i2s_pins(i2s->config.i2s_port, &board_i2s_pin);
-        i2s_pin_cfg.bck_io_num = board_i2s_pin.bck_io_num;
-        i2s_pin_cfg.ws_io_num = board_i2s_pin.ws_io_num;
-        i2s_pin_cfg.data_out_num = board_i2s_pin.data_out_num;
-        i2s_pin_cfg.data_in_num = board_i2s_pin.data_in_num;
-#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)
-        i2s_mclk_gpio_select(i2s->config.i2s_port, board_i2s_pin.mck_io_num);
-#else
-        i2s_pin_cfg.mck_io_num = board_i2s_pin.mck_io_num;
-#endif
-        i2s_set_pin(i2s->config.i2s_port, &i2s_pin_cfg);
-    }
-
-    return el;
-}
-
-esp_err_t i2s_stream_set_channel_type(i2s_stream_cfg_t *config, i2s_channel_type_t type)
-{
-    AUDIO_NULL_CHECK(TAG, config != NULL, {return ESP_ERR_INVALID_ARG;});
-    switch (type) {
-        case I2S_CHANNEL_TYPE_RIGHT_LEFT:
-            config->i2s_config.channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT;
-            break;
-        case I2S_CHANNEL_TYPE_ONLY_RIGHT:
-            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ONLY_RIGHT;
-            break;
-        case I2S_CHANNEL_TYPE_ONLY_LEFT:
-            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;
-            break;
-        case I2S_CHANNEL_TYPE_ALL_RIGHT:
-            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ALL_RIGHT;
-            break;
-        case I2S_CHANNEL_TYPE_ALL_LEFT:
-            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ALL_LEFT;
-            break;
-    }
-    return ESP_OK;
-}
-
-esp_err_t i2s_stream_sync_delay(audio_element_handle_t i2s_stream, int delay_ms)
-{
-    char *in_buffer = NULL;
-
-    audio_element_info_t info;
-    audio_element_getinfo(i2s_stream, &info);
-
-    if (delay_ms < 0) {
-        uint32_t delay_size = (~delay_ms + 1) * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
-        in_buffer = (char *)audio_malloc(delay_size);
-        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
-#if SOC_I2S_SUPPORTS_ADC_DAC
-        i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-        if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
-            memset(in_buffer, 0x80, delay_size);
-        } else
-#endif
-        {
-            memset(in_buffer, 0x00, delay_size);
-        }
-        ringbuf_handle_t input_rb = audio_element_get_input_ringbuf(i2s_stream);
-        if (input_rb) {
-            rb_write(input_rb, in_buffer, delay_size, 0);
-        }
-        audio_free(in_buffer);
-    } else if (delay_ms > 0) {
-        uint32_t drop_size = delay_ms * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
-        in_buffer = (char *)audio_malloc(drop_size);
-        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
-        uint32_t r_size = audio_element_input(i2s_stream, in_buffer, drop_size);
-        audio_free(in_buffer);
-
-        if (r_size > 0) {
-            audio_element_update_byte_pos(i2s_stream, r_size);
-        } else {
-            ESP_LOGW(TAG, "Can't get enough data to drop.");
-            return ESP_FAIL;
-        }
-    }
-
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/ringbuf.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+
+#include "driver/i2s.h"
+#include "soc/io_mux_reg.h"
+#include "esp_log.h"
+#include "esp_err.h"
+
+#include "audio_common.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "i2s_stream.h"
+#include "esp_alc.h"
+#include "board_pins_config.h"
+#include "audio_idf_version.h"
+
+static const char *TAG = "I2S_STREAM";
+
+#define I2S_BUFFER_ALINED_BYTES_SIZE (12)
+
+#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 2, 0)
+#define SOC_I2S_SUPPORTS_ADC_DAC 1
+#elif (SOC_DAC_SUPPORTED)
+#if CONFIG_IDF_TARGET_ESP32
+#define SOC_I2S_SUPPORTS_ADC_DAC 1
+#endif
+#endif
+
+typedef struct i2s_stream {
+    audio_stream_type_t type;
+    i2s_stream_cfg_t    config;
+    bool                is_open;
+    bool                use_alc;
+    void               *volume_handle;
+    int                 volume;
+    bool                uninstall_drv;
+    int                 data_bit_width;
+} i2s_stream_t;
+#ifdef SOC_I2S_SUPPORTS_ADC_DAC
+static esp_err_t i2s_mono_fix(int bits, uint8_t *sbuff, uint32_t len)
+{
+    if (bits == 16) {
+        int16_t *temp_buf = (int16_t *)sbuff;
+        int16_t temp_box;
+        int k = len >> 1;
+        for (int i = 0; i < k; i += 2) {
+            temp_box = temp_buf[i];
+            temp_buf[i] = temp_buf[i + 1];
+            temp_buf[i + 1] = temp_box;
+        }
+    } else if (bits == 32) {
+        int32_t *temp_buf = (int32_t *)sbuff;
+        int32_t temp_box;
+        int k = len >> 2;
+        for (int i = 0; i < k; i += 4) {
+            temp_box = temp_buf[i];
+            temp_buf[i] = temp_buf[i + 1];
+            temp_buf[i + 1] = temp_box;
+        }
+    } else {
+        ESP_LOGE(TAG, "%s %dbits is not supported", __func__, bits);
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+/**
+ * @brief Scale data to 16bit/32bit for I2S DMA output.
+ *        DAC can only output 8bit data value.
+ *        I2S DMA will still send 16bit or 32bit data, the highest 8bit contains DAC data.
+ */
+static int i2s_dac_data_scale(int bits, uint8_t *sBuff, uint32_t len)
+{
+    if (bits == 16) {
+        short *buf16 = (short *)sBuff;
+        int k = len >> 1;
+        for (int i = 0; i < k; i++) {
+            buf16[i] &= 0xff00;
+            buf16[i] += 0x8000;//turn signed value into unsigned, expand negative value into positive range
+        }
+    } else if (bits == 32) {
+        int *buf32 = (int *)sBuff;
+        int k = len >> 2;
+        for (int i = 0; i < k; i++) {
+            buf32[i] &= 0xff000000;
+            buf32[i] += 0x80000000;//turn signed value into unsigned
+        }
+    } else {
+        ESP_LOGE(TAG, "in %s %dbits is not supported", __func__, bits);
+        return -1;
+    }
+
+    return 0;
+}
+#endif
+
+static inline esp_err_t i2s_stream_check_data_bits(i2s_stream_t *i2s, int bits)
+{
+#if CONFIG_IDF_TARGET_ESP32
+    if (bits == I2S_BITS_PER_SAMPLE_24BIT) {
+        i2s->config.expand_src_bits = bits;
+        i2s->data_bit_width = I2S_BITS_PER_SAMPLE_24BIT;
+    } else {
+        i2s->data_bit_width = 0;
+    }
+#endif
+    return ESP_OK;
+}
+
+static int i2s_stream_clear_dma_buffer(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    int index = i2s->config.i2s_config.dma_buf_count;
+    uint8_t *buf = audio_calloc(1, i2s->config.i2s_config.dma_buf_len * 4);
+    AUDIO_MEM_CHECK(TAG, buf, return ESP_ERR_NO_MEM);
+#if SOC_I2S_SUPPORTS_ADC_DAC
+    if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
+        memset(buf, 0x80, i2s->config.i2s_config.dma_buf_len * 4);
+    }
+#endif
+    while (index--) {
+        audio_element_output(self, (char *)buf, i2s->config.i2s_config.dma_buf_len * 4);
+    }
+    if (buf) {
+        audio_free(buf);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _i2s_set_clk(i2s_port_t i2s_num, uint32_t rate, uint32_t bits_cfg, int ch)
+{
+    i2s_channel_t channel;
+    if (ch == 1) {
+        channel = I2S_CHANNEL_MONO;
+    } else if (ch == 2) {
+        channel = I2S_CHANNEL_STEREO;
+    } else {
+        return ESP_FAIL;
+    }
+    return i2s_set_clk(i2s_num, rate, bits_cfg, channel);
+}
+
+static esp_err_t _i2s_open(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    ESP_LOGD(TAG, "_i2s_open %d", (int)i2s->config.i2s_port);
+    if (i2s->is_open) {
+        return ESP_OK;
+    }
+
+    if (i2s->type == AUDIO_STREAM_WRITER) {
+        audio_element_set_input_timeout(self, 10 / portTICK_RATE_MS);
+        ESP_LOGI(TAG, "AUDIO_STREAM_WRITER");
+    }
+    i2s->is_open = true;
+    if (i2s->use_alc) {
+        i2s->volume_handle = alc_volume_setup_open();
+        if (i2s->volume_handle == NULL) {
+            ESP_LOGE(TAG, "i2s create the handle for setting volume failed, in line(%d)", __LINE__);
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _i2s_destroy(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    if (i2s->uninstall_drv) {
+        i2s_driver_uninstall(i2s->config.i2s_port);
+    }
+    audio_free(i2s);
+    return ESP_OK;
+}
+
+static esp_err_t _i2s_close(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    esp_err_t ret = i2s_stream_clear_dma_buffer(self);
+    if (ret != ESP_OK) {
+        return ret;
+    }
+    i2s->is_open = false;
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_report_pos(self);
+        audio_element_set_byte_pos(self, 0);
+    }
+    if (i2s->use_alc) {
+        if (i2s->volume_handle != NULL) {
+            alc_volume_setup_close(i2s->volume_handle);
+        }
+    }
+    return ESP_OK;
+}
+
+static int _i2s_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    size_t bytes_read = 0;
+    i2s_read(i2s->config.i2s_port, buffer, len, &bytes_read, ticks_to_wait);
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+    if (bytes_read > 0) {
+#ifdef CONFIG_IDF_TARGET_ESP32
+        if (info.channels == 1) {
+            i2s_mono_fix(info.bits, (uint8_t *)buffer, bytes_read);
+        }
+#endif
+    }
+    return bytes_read;
+}
+
+static int _i2s_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    size_t bytes_written = 0;
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+    int target_bits = info.bits;
+    if (len > 0) {
+#ifdef CONFIG_IDF_TARGET_ESP32
+        target_bits = I2S_BITS_PER_SAMPLE_32BIT;
+        if (info.channels == 1) {
+            i2s_mono_fix(info.bits, (uint8_t *)buffer, len);
+        }
+#endif
+#if SOC_I2S_SUPPORTS_ADC_DAC
+        if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
+            i2s_dac_data_scale(info.bits, (uint8_t *)buffer, len);
+        }
+#endif
+    }
+
+    if (len) {
+        if ((i2s->config.need_expand && (target_bits != i2s->config.expand_src_bits)) || (i2s->data_bit_width == I2S_BITS_PER_SAMPLE_24BIT)) {
+            i2s_write_expand(i2s->config.i2s_port,
+                            buffer,
+                            len,
+                            i2s->config.expand_src_bits,
+                            target_bits,
+                            &bytes_written,
+                            ticks_to_wait);
+        } else {
+            i2s_write(i2s->config.i2s_port, buffer, len, &bytes_written, ticks_to_wait);
+        }
+    }
+
+    return bytes_written;
+}
+
+static int _i2s_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    audio_element_info_t i2s_info = {0};
+    if (r_size == AEL_IO_TIMEOUT) {
+#if SOC_I2S_SUPPORTS_ADC_DAC
+        if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
+            memset(in_buffer, 0x80, in_len);
+        } else
+#endif
+        {
+            memset(in_buffer, 0x00, in_len);
+        }
+        r_size = in_len;
+        audio_element_multi_output(self, in_buffer, r_size, 0);
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else if (r_size > 0) {
+        if (i2s->use_alc) {
+            audio_element_getinfo(self, &i2s_info);
+            alc_volume_setup_process(in_buffer, r_size, i2s_info.channels, i2s->volume_handle, i2s->volume);
+        }
+        audio_element_multi_output(self, in_buffer, r_size, 0);
+        w_size = audio_element_output(self, in_buffer, r_size);
+        audio_element_update_byte_pos(self, w_size);
+    } else {
+        esp_err_t ret = i2s_stream_clear_dma_buffer(self);
+        if (ret != ESP_OK) {
+            return ret;
+        }
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)
+#if CONFIG_IDF_TARGET_ESP32
+static esp_err_t i2s_mclk_gpio_select(i2s_port_t i2s_num, gpio_num_t gpio_num)
+{
+    if (i2s_num >= SOC_I2S_NUM) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    if (i2s_num == I2S_NUM_0) {
+        if (gpio_num == GPIO_NUM_0) {
+            PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
+            WRITE_PERI_REG(PIN_CTRL, 0xFFF0);
+        } else if (gpio_num == GPIO_NUM_1) {
+            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
+            WRITE_PERI_REG(PIN_CTRL, 0xF0F0);
+        } else {
+            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
+            WRITE_PERI_REG(PIN_CTRL, 0xFF00);
+        }
+    } else if (i2s_num == I2S_NUM_1) {
+        if (gpio_num == GPIO_NUM_0) {
+            PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
+            WRITE_PERI_REG(PIN_CTRL, 0xFFFF);
+        } else if (gpio_num == GPIO_NUM_1) {
+            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
+            WRITE_PERI_REG(PIN_CTRL, 0xF0FF);
+        } else {
+            PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
+            WRITE_PERI_REG(PIN_CTRL, 0xFF0F);
+        }
+    }
+    return ESP_OK;
+}
+#else
+static esp_err_t i2s_mclk_gpio_select(i2s_port_t i2s_num, gpio_num_t gpio_num)
+{
+    return ESP_FAIL;
+}
+#endif
+#endif
+
+esp_err_t i2s_stream_set_clk(audio_element_handle_t i2s_stream, int rate, int bits, int ch)
+{
+    esp_err_t err = ESP_OK;
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+    audio_element_state_t state = audio_element_get_state(i2s_stream);
+    if (state == AEL_STATE_RUNNING) {
+        audio_element_pause(i2s_stream);
+    }
+    audio_element_set_music_info(i2s_stream, rate, ch, bits);
+
+    i2s_zero_dma_buffer(i2s->config.i2s_port);
+    i2s_stream_check_data_bits(i2s, bits);
+    if (_i2s_set_clk(i2s->config.i2s_port, rate, bits, ch) == ESP_FAIL) {
+        ESP_LOGE(TAG, "i2s_set_clk failed, type = %d,port:%d", i2s->config.type, i2s->config.i2s_port);
+        err = ESP_FAIL;
+    }
+    if (state == AEL_STATE_RUNNING) {
+        audio_element_resume(i2s_stream, 0, 0);
+    }
+    return err;
+}
+
+int i2s_alc_volume_set(audio_element_handle_t i2s_stream, int volume)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+    if (i2s->use_alc) {
+        i2s->volume = volume;
+        return ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "The ALC don't be used. It can not be set.");
+        return ESP_FAIL;
+    }
+}
+
+int i2s_alc_volume_get(audio_element_handle_t i2s_stream, int *volume)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+    if (i2s->use_alc) {
+        *volume = i2s->volume;
+        return ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "The ALC don't be used");
+        return ESP_FAIL;
+    }
+}
+
+audio_element_handle_t i2s_stream_init(i2s_stream_cfg_t *config)
+{
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    audio_element_handle_t el;
+    cfg.open = _i2s_open;
+    cfg.close = _i2s_close;
+    cfg.process = _i2s_process;
+    cfg.destroy = _i2s_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.stack_in_ext = config->stack_in_ext;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.multi_out_rb_num = config->multi_out_num;
+    cfg.tag = "iis";
+    cfg.buffer_len = config->buffer_len;
+
+    if (cfg.buffer_len % I2S_BUFFER_ALINED_BYTES_SIZE) {
+        ESP_LOGE(TAG, "The size of buffer must be a multiple of %d, current size is %d", I2S_BUFFER_ALINED_BYTES_SIZE, cfg.buffer_len);
+        return NULL;
+    }
+
+    i2s_stream_t *i2s = audio_calloc(1, sizeof(i2s_stream_t));
+    AUDIO_MEM_CHECK(TAG, i2s, return NULL);
+    memcpy(&i2s->config, config, sizeof(i2s_stream_cfg_t));
+
+    i2s->type = config->type;
+    i2s->use_alc = config->use_alc;
+    i2s->volume = config->volume;
+    i2s->uninstall_drv = config->uninstall_drv;
+
+    if (config->type == AUDIO_STREAM_READER) {
+        cfg.read = _i2s_read;
+    } else if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _i2s_write;
+    }
+
+    esp_err_t ret = i2s_driver_install(i2s->config.i2s_port, &i2s->config.i2s_config, 0, NULL);
+    if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
+        audio_free(i2s);
+        return NULL;
+    }
+    i2s_stream_check_data_bits(i2s, i2s->config.i2s_config.bits_per_sample);
+
+    el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, {
+        audio_free(i2s);
+        return NULL;
+    });
+    audio_element_setdata(el, i2s);
+
+    audio_element_set_music_info(el, config->i2s_config.sample_rate,
+                                 config->i2s_config.channel_format < I2S_CHANNEL_FMT_ONLY_RIGHT ? 2 : 1,
+                                 config->i2s_config.bits_per_sample);
+#if SOC_I2S_SUPPORTS_ADC_DAC
+    if ((config->i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
+        i2s_set_dac_mode(I2S_DAC_CHANNEL_BOTH_EN);
+    } else
+#endif
+    {
+        board_i2s_pin_t board_i2s_pin = {0};
+        i2s_pin_config_t i2s_pin_cfg;
+        get_i2s_pins(i2s->config.i2s_port, &board_i2s_pin);
+        i2s_pin_cfg.bck_io_num = board_i2s_pin.bck_io_num;
+        i2s_pin_cfg.ws_io_num = board_i2s_pin.ws_io_num;
+        i2s_pin_cfg.data_out_num = board_i2s_pin.data_out_num;
+        i2s_pin_cfg.data_in_num = board_i2s_pin.data_in_num;
+#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)
+        i2s_mclk_gpio_select(i2s->config.i2s_port, board_i2s_pin.mck_io_num);
+#else
+        i2s_pin_cfg.mck_io_num = board_i2s_pin.mck_io_num;
+#endif
+        i2s_set_pin(i2s->config.i2s_port, &i2s_pin_cfg);
+    }
+
+    return el;
+}
+
+esp_err_t i2s_stream_set_channel_type(i2s_stream_cfg_t *config, i2s_channel_type_t type)
+{
+    AUDIO_NULL_CHECK(TAG, config != NULL, {return ESP_ERR_INVALID_ARG;});
+    switch (type) {
+        case I2S_CHANNEL_TYPE_RIGHT_LEFT:
+            config->i2s_config.channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT;
+            break;
+        case I2S_CHANNEL_TYPE_ONLY_RIGHT:
+            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ONLY_RIGHT;
+            break;
+        case I2S_CHANNEL_TYPE_ONLY_LEFT:
+            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;
+            break;
+        case I2S_CHANNEL_TYPE_ALL_RIGHT:
+            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ALL_RIGHT;
+            break;
+        case I2S_CHANNEL_TYPE_ALL_LEFT:
+            config->i2s_config.channel_format = I2S_CHANNEL_FMT_ALL_LEFT;
+            break;
+    }
+    return ESP_OK;
+}
+
+esp_err_t i2s_stream_sync_delay(audio_element_handle_t i2s_stream, int delay_ms)
+{
+    char *in_buffer = NULL;
+
+    audio_element_info_t info;
+    audio_element_getinfo(i2s_stream, &info);
+
+    if (delay_ms < 0) {
+        uint32_t delay_size = (~delay_ms + 1) * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
+        in_buffer = (char *)audio_malloc(delay_size);
+        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
+#if SOC_I2S_SUPPORTS_ADC_DAC
+        i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+        if ((i2s->config.i2s_config.mode & I2S_MODE_DAC_BUILT_IN) != 0) {
+            memset(in_buffer, 0x80, delay_size);
+        } else
+#endif
+        {
+            memset(in_buffer, 0x00, delay_size);
+        }
+        ringbuf_handle_t input_rb = audio_element_get_input_ringbuf(i2s_stream);
+        if (input_rb) {
+            rb_write(input_rb, in_buffer, delay_size, 0);
+        }
+        audio_free(in_buffer);
+    } else if (delay_ms > 0) {
+        uint32_t drop_size = delay_ms * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
+        in_buffer = (char *)audio_malloc(drop_size);
+        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
+        uint32_t r_size = audio_element_input(i2s_stream, in_buffer, drop_size);
+        audio_free(in_buffer);
+
+        if (r_size > 0) {
+            audio_element_update_byte_pos(i2s_stream, r_size);
+        } else {
+            ESP_LOGW(TAG, "Can't get enough data to drop.");
+            return ESP_FAIL;
+        }
+    }
+
+    return ESP_OK;
+}
diff --git a/components/audio_stream/i2s_stream_idf5.c b/components/audio_stream/i2s_stream_idf5.c
index b26b6d64..6fe3171e 100644
--- a/components/audio_stream/i2s_stream_idf5.c
+++ b/components/audio_stream/i2s_stream_idf5.c
@@ -1,747 +1,747 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "audio_idf_version.h"
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-#include <string.h>
-
-#include "esp_log.h"
-
-#include "audio_mem.h"
-#include "esp_alc.h"
-#include "i2s_stream.h"
-#include "board_pins_config.h"
-
-static const char *TAG = "I2S_STREAM_IDF5.x";
-
-#define I2S_BUFFER_ALINED_BYTES_SIZE (12)
-
-typedef struct i2s_stream {
-    audio_stream_type_t type;
-    i2s_stream_cfg_t    config;
-    bool                is_open;
-    bool                use_alc;
-    void               *volume_handle;
-    int                 volume;
-    bool                uninstall_drv;
-    i2s_port_t          port;
-    int                 buffer_length;
-    struct {
-        char           *buf;
-        int             buffer_size;
-    } expand;
-} i2s_stream_t;
-
-struct i2s_key_slot_s {
-    i2s_chan_handle_t       rx_handle;
-    i2s_chan_handle_t       tx_handle;
-    union {
-        i2s_std_config_t    rx_std_cfg;
-#if SOC_I2S_SUPPORTS_PDM_RX
-        i2s_pdm_rx_config_t rx_pdm_cfg;
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-#if SOC_I2S_SUPPORTS_TDM
-        i2s_tdm_config_t    rx_tdm_cfg;
-#endif // SOC_I2S_SUPPORTS_TDM
-    };
-    union {
-        i2s_std_config_t    tx_std_cfg;
-#if SOC_I2S_SUPPORTS_PDM_TX
-        i2s_pdm_tx_config_t tx_pdm_cfg;
-#endif // SOC_I2S_SUPPORTS_PDM_TX
-#if SOC_I2S_SUPPORTS_TDM
-        i2s_tdm_config_t    tx_tdm_cfg;
-#endif // SOC_I2S_SUPPORTS_TDM
-    };
-    i2s_chan_config_t       chan_cfg;
-    i2s_dir_t               dir;
-    int                     i2s_refcount;
-};
-
-static void *s_i2s_tx_mutex[SOC_I2S_NUM];
-static void *s_i2s_rx_mutex[SOC_I2S_NUM];
-
-static struct i2s_key_slot_s i2s_key_slot[SOC_I2S_NUM];
-
-#define i2s_safe_lock_create(lock) do {           \
-    if (lock == NULL) {                           \
-        lock = xSemaphoreCreateRecursiveMutex();  \
-    }                                             \
-} while (0)
-
-#define i2s_safe_lock(lock) do {                       \
-    if (lock) {                                        \
-        xSemaphoreTakeRecursive(lock, portMAX_DELAY);  \
-    }                                                  \
-} while (0)
-
-#define i2s_safe_unlock(lock) do {      \
-    if (lock) {                         \
-        xSemaphoreGiveRecursive(lock);  \
-    }                                   \
-} while (0)
-
-static int i2s_driver_startup(audio_element_handle_t self, i2s_stream_cfg_t *i2s_cfg)
-{
-    esp_err_t ret = ESP_OK;
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    i2s_comm_mode_t i2s_mode = i2s_cfg->transmit_mode;
-    int i2s_port = i2s_cfg->chan_cfg.id;
-    board_i2s_pin_t board_i2s_pin = { 0 };
-    get_i2s_pins(i2s_port, &board_i2s_pin);
-
-    i2s_key_slot[i2s->port].chan_cfg.auto_clear = true;
-    ret = i2s_new_channel(&i2s_key_slot[i2s->port].chan_cfg, i2s_key_slot[i2s->port].dir & I2S_DIR_TX ?  &i2s_key_slot[i2s->port].tx_handle : NULL,
-                          i2s_key_slot[i2s->port].dir & I2S_DIR_RX ?  &i2s_key_slot[i2s->port].rx_handle : NULL);
-    switch (i2s_mode) {
-        case I2S_COMM_MODE_STD:
-            if (i2s_key_slot[i2s->port].dir & I2S_DIR_TX) {
-                memcpy(&i2s_key_slot[i2s->port].tx_std_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
-                ret |= i2s_channel_init_std_mode(i2s_key_slot[i2s->port].tx_handle, &i2s_key_slot[i2s->port].tx_std_cfg);
-            }
-            if (i2s_key_slot[i2s->port].dir & I2S_DIR_RX) {
-                memcpy(&i2s_key_slot[i2s->port].rx_std_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
-                ret |= i2s_channel_init_std_mode(i2s_key_slot[i2s->port].rx_handle, &i2s_key_slot[i2s->port].rx_std_cfg);
-            }
-            break;
-#if SOC_I2S_SUPPORTS_PDM
-        case I2S_COMM_MODE_PDM:
-#if SOC_I2S_SUPPORTS_PDM_RX
-            if (i2s_key_slot[i2s->port].dir & I2S_DIR_RX) {
-                i2s_key_slot[i2s->port].rx_pdm_cfg.gpio_cfg.clk = board_i2s_pin.bck_io_num;
-                i2s_key_slot[i2s->port].rx_pdm_cfg.gpio_cfg.din = board_i2s_pin.data_in_num;
-                ret |= i2s_channel_init_pdm_rx_mode(i2s_key_slot[i2s->port].rx_handle, &i2s_key_slot[i2s->port].rx_pdm_cfg);
-            }
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-#if SOC_I2S_SUPPORTS_PDM_TX
-            if (i2s_key_slot[i2s->port].dir & I2S_DIR_TX) {
-                i2s_key_slot[i2s->port].tx_pdm_cfg.gpio_cfg.clk = board_i2s_pin.bck_io_num;
-                i2s_key_slot[i2s->port].tx_pdm_cfg.gpio_cfg.dout = board_i2s_pin.data_out_num;
-                ret |= i2s_channel_init_pdm_tx_mode(i2s_key_slot[i2s->port].tx_handle, &i2s_key_slot[i2s->port].tx_pdm_cfg);
-            }
-#endif // SOC_I2S_SUPPORTS_PDM_TX
-            break;
-#endif // SOC_I2S_SUPPORTS_PDM
-
-#if SOC_I2S_SUPPORTS_TDM
-        case I2S_COMM_MODE_TDM:
-            if (i2s_key_slot[i2s->port].dir & I2S_DIR_TX) {
-                memcpy(&i2s_key_slot[i2s->port].tx_tdm_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
-                ret |= i2s_channel_init_tdm_mode(i2s_key_slot[i2s->port].tx_handle, &i2s_key_slot[i2s->port].tx_tdm_cfg);
-            }
-            if (i2s_key_slot[i2s->port].dir & I2S_DIR_RX) {
-                memcpy(&i2s_key_slot[i2s->port].rx_tdm_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
-                ret |= i2s_channel_init_tdm_mode(i2s_key_slot[i2s->port].rx_handle, &i2s_key_slot[i2s->port].rx_tdm_cfg);
-            }
-            break;
-#endif // SOC_I2S_SUPPORTS_TDM
-        default:
-            ESP_LOGE(TAG, "Invalid I2S transmit mode, %d", i2s_mode);
-            ret = ESP_FAIL;
-            break;
-    }
-    return ret;
-}
-
-static esp_err_t i2s_driver_cleanup(i2s_stream_t *i2s, bool deep_cleanup)
-{
-    esp_err_t ret = ESP_OK;
-#if (defined CONFIG_IDF_TARGET_ESP32)|| (defined CONFIG_IDF_TARGET_ESP32S2)
-    i2s_key_slot[i2s->port].i2s_refcount--;
-    if (i2s_key_slot[i2s->port].i2s_refcount > 0) {
-        return ret;
-    }
-#endif // (defined CONFIG_IDF_TARGET_ESP32)|| (defined CONFIG_IDF_TARGET_ESP32S2)
-    if (i2s_key_slot[i2s->port].tx_handle) {
-        ret |= i2s_channel_disable(i2s_key_slot[i2s->port].tx_handle);
-        ret |= i2s_del_channel(i2s_key_slot[i2s->port].tx_handle);
-        i2s_key_slot[i2s->port].tx_handle = NULL;
-        if (deep_cleanup) {
-            i2s_key_slot[i2s->port].dir &= ~I2S_DIR_TX;
-        }
-    }
-    if (i2s_key_slot[i2s->port].rx_handle) {
-        ret |= i2s_channel_disable(i2s_key_slot[i2s->port].rx_handle);
-        ret |= i2s_del_channel(i2s_key_slot[i2s->port].rx_handle);
-        i2s_key_slot[i2s->port].rx_handle = NULL;
-        if (deep_cleanup) {
-            i2s_key_slot[i2s->port].dir &= ~I2S_DIR_RX;
-        }
-    }
-    return ret;
-}
-
-static esp_err_t i2s_config_backup(i2s_stream_cfg_t *i2s_cfg)
-{
-    int i2s_port = i2s_cfg->chan_cfg.id;
-    memcpy(&i2s_key_slot[i2s_port].chan_cfg, &i2s_cfg->chan_cfg, sizeof(i2s_chan_config_t));
-
-    if (i2s_cfg->type == AUDIO_STREAM_READER) {
-        if (i2s_cfg->transmit_mode == I2S_COMM_MODE_STD) {
-            memcpy(&i2s_key_slot[i2s_port].rx_std_cfg, &i2s_cfg->std_cfg, sizeof(i2s_cfg->std_cfg));
-        }
-#if SOC_I2S_SUPPORTS_PDM_RX
-        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_PDM) {
-            memcpy(&i2s_key_slot[i2s_port].rx_pdm_cfg, &i2s_cfg->pdm_rx_cfg, sizeof(i2s_cfg->pdm_rx_cfg));
-        }
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-#if SOC_I2S_SUPPORTS_TDM
-        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_TDM) {
-            memcpy(&i2s_key_slot[i2s_port].rx_tdm_cfg, &i2s_cfg->tdm_cfg, sizeof(i2s_cfg->tdm_cfg));
-        }
-#endif // SOC_I2S_SUPPORTS_TDM
-    } else if (i2s_cfg->type == AUDIO_STREAM_WRITER) {
-        if (i2s_cfg->transmit_mode == I2S_COMM_MODE_STD) {
-            memcpy(&i2s_key_slot[i2s_port].tx_std_cfg, &i2s_cfg->std_cfg, sizeof(i2s_cfg->std_cfg));
-        }
-#if SOC_I2S_SUPPORTS_PDM_TX
-        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_PDM) {
-            memcpy(&i2s_key_slot[i2s_port].tx_pdm_cfg, &i2s_cfg->pdm_tx_cfg, sizeof(i2s_cfg->pdm_tx_cfg));
-        }
-#endif // SOC_I2S_SUPPORTS_PDM_TX
-#if SOC_I2S_SUPPORTS_TDM
-        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_TDM) {
-            memcpy(&i2s_key_slot[i2s_port].tx_tdm_cfg, &i2s_cfg->tdm_cfg, sizeof(i2s_cfg->tdm_cfg));
-        }
-#endif // SOC_I2S_SUPPORTS_TDM
-    } else {
-        ESP_LOGE(TAG, "Invalid audio stream type: %d", i2s_cfg->type);
-    }
-    return ESP_OK;
-}
-
-static inline esp_err_t i2s_stream_check_data_bits(i2s_stream_t *i2s, int *bits)
-{
-    if (i2s->config.transmit_mode == I2S_COMM_MODE_STD) {
-#if (defined (CONFIG_IDF_TARGET_ESP32) || defined(CONFIG_IDF_TARGET_ESP32S2))
-        if (*bits == I2S_DATA_BIT_WIDTH_24BIT) {
-            i2s->config.need_expand = true;
-            *bits = I2S_DATA_BIT_WIDTH_32BIT;
-            i2s->config.std_cfg.slot_cfg.data_bit_width = I2S_DATA_BIT_WIDTH_32BIT;
-            i2s->config.std_cfg.slot_cfg.ws_width = I2S_DATA_BIT_WIDTH_32BIT;
-        } else {
-            i2s->config.std_cfg.slot_cfg.data_bit_width = *bits;
-            i2s->config.std_cfg.slot_cfg.ws_width = *bits;
-        }
-#else
-        if (*bits == I2S_DATA_BIT_WIDTH_24BIT) {
-            i2s->config.std_cfg.clk_cfg.mclk_multiple = I2S_MCLK_MULTIPLE_384;
-        }
-#endif // (defined (CONFIG_IDF_TARGET_ESP32) || defined(CONFIG_IDF_TARGET_ESP32S2))
-    }
-    return ESP_OK;
-}
-
-static esp_err_t i2s_stream_setup_music_info(audio_element_handle_t el, i2s_stream_t *i2s)
-{
-    int sample_rate_hz = 0;
-    int slot_mode = 0;
-    int data_bit_width = 0;
-    switch (i2s->config.transmit_mode) {
-        case I2S_COMM_MODE_STD:
-            sample_rate_hz = i2s->config.std_cfg.clk_cfg.sample_rate_hz;
-            slot_mode = i2s->config.std_cfg.slot_cfg.slot_mode;
-            data_bit_width = i2s->config.std_cfg.slot_cfg.data_bit_width;
-            break;
-#if SOC_I2S_SUPPORTS_PDM
-        case I2S_COMM_MODE_PDM:
-#if SOC_I2S_SUPPORTS_PDM_TX
-            if (i2s->type == AUDIO_STREAM_WRITER) {
-                sample_rate_hz = i2s->config.pdm_tx_cfg.clk_cfg.sample_rate_hz;
-                slot_mode = i2s->config.pdm_tx_cfg.slot_cfg.slot_mode;
-                data_bit_width = i2s->config.pdm_tx_cfg.slot_cfg.data_bit_width;
-            }
-#endif // SOC_I2S_SUPPORTS_PDM_TX
-#if SOC_I2S_SUPPORTS_PDM_RX
-            if (i2s->type == AUDIO_STREAM_READER) {
-                sample_rate_hz = i2s->config.pdm_rx_cfg.clk_cfg.sample_rate_hz;
-                slot_mode = i2s->config.pdm_rx_cfg.slot_cfg.slot_mode;
-                data_bit_width = i2s->config.pdm_rx_cfg.slot_cfg.data_bit_width;
-            }
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-            break;
-#endif
-#if SOC_I2S_SUPPORTS_TDM
-        case I2S_COMM_MODE_TDM:
-            sample_rate_hz = i2s->config.tdm_cfg.clk_cfg.sample_rate_hz;
-            slot_mode = i2s->config.tdm_cfg.slot_cfg.slot_mode;
-            data_bit_width = i2s->config.tdm_cfg.slot_cfg.data_bit_width;
-            break;
-#endif
-        default:
-            sample_rate_hz = i2s->config.std_cfg.clk_cfg.sample_rate_hz;
-            slot_mode = i2s->config.std_cfg.slot_cfg.slot_mode;
-            data_bit_width = i2s->config.std_cfg.slot_cfg.data_bit_width;
-            break;
-    }
-    i2s_stream_check_data_bits(i2s, &data_bit_width);
-
-    audio_element_set_music_info(el, sample_rate_hz, slot_mode, data_bit_width);
-    return ESP_OK;
-}
-
-static esp_err_t _i2s_set_clk(i2s_stream_t *i2s, int rate, int bits, int ch)
-{
-    esp_err_t err = ESP_OK;
-    i2s_port_t port = i2s->port;
-    i2s_slot_mode_t slot_mode;
-    if (ch == 1) {
-        slot_mode = I2S_SLOT_MODE_MONO;
-    } else if (ch == 2) {
-        slot_mode = I2S_SLOT_MODE_STEREO;
-    } else {
-        ESP_LOGE(TAG, "Invalid ch: %d", ch);
-        return ESP_FAIL;
-    }
-    if (i2s->config.transmit_mode == I2S_COMM_MODE_STD) {
-        if (i2s_key_slot[port].tx_handle != NULL && i2s->type == AUDIO_STREAM_WRITER) {
-            i2s_key_slot[port].tx_std_cfg.slot_cfg.data_bit_width = bits;
-            i2s_key_slot[port].tx_std_cfg.slot_cfg.ws_width = bits;
-            i2s_key_slot[port].tx_std_cfg.slot_cfg.slot_mode = slot_mode;
-            i2s_key_slot[port].tx_std_cfg.clk_cfg.sample_rate_hz = rate;
-            i2s_channel_disable(i2s_key_slot[port].tx_handle);
-            err |= i2s_channel_reconfig_std_slot(i2s_key_slot[port].tx_handle, &i2s_key_slot[port].tx_std_cfg.slot_cfg);
-            err |= i2s_channel_reconfig_std_clock(i2s_key_slot[port].tx_handle, &i2s_key_slot[port].tx_std_cfg.clk_cfg);
-            err |= i2s_channel_enable(i2s_key_slot[port].tx_handle);
-        }
-        if (i2s_key_slot[port].rx_handle != NULL && i2s->type == AUDIO_STREAM_READER) {
-            i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg.data_bit_width = bits;
-            i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg.ws_width = bits;
-            i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg.slot_mode = slot_mode;
-            i2s_key_slot[i2s->port].rx_std_cfg.clk_cfg.sample_rate_hz = rate;
-            i2s_channel_disable(i2s_key_slot[port].rx_handle);
-            err |= i2s_channel_reconfig_std_slot(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg);
-            err |= i2s_channel_reconfig_std_clock(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_std_cfg.clk_cfg);
-            err |= i2s_channel_enable(i2s_key_slot[port].rx_handle);
-        }
-#if SOC_I2S_SUPPORTS_PDM
-    } else if (i2s->config.transmit_mode == I2S_COMM_MODE_PDM) {
-#if SOC_I2S_SUPPORTS_PDM_TX
-        if (i2s_key_slot[port].tx_handle != NULL && i2s->type == AUDIO_STREAM_WRITER) {
-            i2s_key_slot[i2s->port].tx_pdm_cfg.clk_cfg.sample_rate_hz = rate;
-            i2s_key_slot[i2s->port].tx_pdm_cfg.slot_cfg.data_bit_width = bits;
-            i2s_key_slot[i2s->port].tx_pdm_cfg.slot_cfg.slot_mode = slot_mode;
-            i2s_channel_disable(i2s_key_slot[port].tx_handle);
-            err |= i2s_channel_reconfig_pdm_tx_slot(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_pdm_cfg.slot_cfg);
-            err |= i2s_channel_reconfig_pdm_tx_clock(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_pdm_cfg.clk_cfg);
-            err |= i2s_channel_enable(i2s_key_slot[port].tx_handle);
-        }
-#endif // SOC_I2S_SUPPORTS_PDM_TX
-#if SOC_I2S_SUPPORTS_PDM_RX
-        if (i2s_key_slot[port].rx_handle != NULL && i2s->type == AUDIO_STREAM_READER) {
-            i2s_key_slot[i2s->port].rx_pdm_cfg.clk_cfg.sample_rate_hz = rate;
-            i2s_key_slot[i2s->port].rx_pdm_cfg.slot_cfg.data_bit_width = bits;
-            i2s_key_slot[i2s->port].rx_pdm_cfg.slot_cfg.slot_mode = slot_mode;
-            i2s_channel_disable(i2s_key_slot[port].rx_handle);
-            err |= i2s_channel_reconfig_pdm_rx_slot(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_pdm_cfg.slot_cfg);
-            err |= i2s_channel_reconfig_pdm_rx_clock(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_pdm_cfg.clk_cfg);
-            err |= i2s_channel_enable(i2s_key_slot[port].rx_handle);
-        }
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-
-#endif // SOC_I2S_SUPPORTS_PDM
-#if SOC_I2S_SUPPORTS_TDM
-    } else if (i2s->config.transmit_mode == I2S_COMM_MODE_TDM) {
-        if (i2s_key_slot[port].tx_handle != NULL && i2s->type == AUDIO_STREAM_WRITER) {
-            i2s_key_slot[i2s->port].tx_tdm_cfg.clk_cfg.sample_rate_hz = rate;
-            i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg.data_bit_width = bits;
-            i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg.ws_width = bits;
-            i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg.slot_mode = slot_mode;
-            i2s_channel_disable(i2s_key_slot[port].tx_handle);
-            err |= i2s_channel_reconfig_tdm_slot(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg);
-            err |= i2s_channel_reconfig_tdm_clock(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_tdm_cfg.clk_cfg);
-            err |= i2s_channel_enable(i2s_key_slot[port].tx_handle);
-        }
-        if (i2s_key_slot[port].rx_handle != NULL && i2s->type == AUDIO_STREAM_READER) {
-            i2s_key_slot[i2s->port].rx_tdm_cfg.clk_cfg.sample_rate_hz = rate;
-            i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg.data_bit_width = bits;
-            i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg.ws_width = bits;
-            i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg.slot_mode = slot_mode;
-            i2s_channel_disable(i2s_key_slot[port].rx_handle);
-            err |= i2s_channel_reconfig_tdm_slot(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg);
-            err |= i2s_channel_reconfig_tdm_clock(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_tdm_cfg.clk_cfg);
-            err |= i2s_channel_enable(i2s_key_slot[port].rx_handle);
-        }
-#endif // SOC_I2S_SUPPORTS_TDM
-    } else {
-        ESP_LOGE(TAG, "Invalid I2S type, %d", i2s->config.transmit_mode);
-    }
-    return err;
-}
-
-static int cal_i2s_buffer_timeout(audio_element_handle_t self)
-{
-#define  DEFAULT_I2S_BUFFER_NUM (2)
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    int timeout_ms = 0;
-    audio_element_info_t stream_info = { 0 };
-    audio_element_getinfo(self, &stream_info);
-    timeout_ms = i2s->buffer_length * DEFAULT_I2S_BUFFER_NUM / ((stream_info.sample_rates * stream_info.channels * stream_info.bits >> 3) / 1000) ;
-    ESP_LOGD(TAG, "I2S buffer timeout: %dms\n", timeout_ms);
-    return timeout_ms;
-}
-
-static esp_err_t _i2s_open(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    if (i2s->is_open) {
-        return ESP_OK;
-    }
-    if (i2s->type == AUDIO_STREAM_WRITER) {
-        audio_element_set_input_timeout(self, pdMS_TO_TICKS(cal_i2s_buffer_timeout(self)));
-    }
-    i2s->is_open = true;
-    if (i2s->use_alc) {
-        i2s->volume_handle = alc_volume_setup_open();
-        if (i2s->volume_handle == NULL) {
-            ESP_LOGE(TAG, "I2S create the handle for setting volume failed, in line(%d)", __LINE__);
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _i2s_destroy(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    if (i2s->uninstall_drv) {
-        i2s_driver_cleanup(i2s, true);
-    }
-    if (i2s->expand.buf) {
-        audio_free(i2s->expand.buf);
-    }
-    audio_free(i2s);
-    return ESP_OK;
-}
-
-static esp_err_t _i2s_close(audio_element_handle_t self)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-
-    i2s->is_open = false;
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_report_pos(self);
-        audio_element_set_byte_pos(self, 0);
-    }
-    if (i2s->use_alc) {
-        if (i2s->volume_handle != NULL) {
-            alc_volume_setup_close(i2s->volume_handle);
-        }
-    }
-    return ESP_OK;
-}
-
-static esp_err_t i2s_channel_write_expand(i2s_stream_t *i2s, const char *src, size_t src_len, int src_bit, int dst_bit, size_t *bytes_written, uint32_t timeout_ms)
-{
-    int src_bytes = src_bit / 8;
-    int dst_bytes = dst_bit / 8;
-    int filled_bytes = dst_bytes - src_bytes;
-    int target_len = (src_len * dst_bytes) / src_bytes;
-    if ((i2s->expand.buf == NULL) || (target_len > i2s->expand.buffer_size)) {
-        if (i2s->expand.buf) {
-            audio_free(i2s->expand.buf);
-        }
-        i2s->expand.buf = audio_calloc(1, target_len);
-        AUDIO_MEM_CHECK(TAG, i2s->expand.buf, return ESP_ERR_NO_MEM);
-        i2s->expand.buffer_size = target_len;
-    }
-    memset(i2s->expand.buf, 0, target_len);
-
-    size_t k = 0;
-    for (size_t i = 0; i < src_len; i += src_bytes) {
-        k += filled_bytes;
-        memcpy(&i2s->expand.buf[k], (const char *)(src + i), src_bytes);
-        k += src_bytes;
-    }
-    i2s_channel_write(i2s_key_slot[i2s->port].tx_handle, i2s->expand.buf, target_len, bytes_written, timeout_ms);
-    return ESP_OK;
-}
-
-static int _i2s_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    size_t bytes_read = 0;
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    i2s_safe_lock(s_i2s_tx_mutex[i2s->port]);
-    i2s_channel_read(i2s_key_slot[i2s->port].rx_handle, buffer, len, &bytes_read, ticks_to_wait);
-    i2s_safe_unlock(s_i2s_tx_mutex[i2s->port]);
-    return bytes_read;
-}
-
-static int _i2s_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    size_t bytes_written = 0;
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-    int target_bits = info.bits;
-    if (len) {
-#ifdef CONFIG_IDF_TARGET_ESP32
-        target_bits = I2S_DATA_BIT_WIDTH_32BIT;
-#endif
-        i2s_safe_lock(s_i2s_rx_mutex[i2s->port]);
-        if (i2s->config.need_expand && (target_bits != i2s->config.expand_src_bits)) {
-            i2s_channel_write_expand(i2s, buffer, len, i2s->config.expand_src_bits, target_bits,
-                                     &bytes_written, ticks_to_wait);
-        } else {
-            i2s_channel_write(i2s_key_slot[i2s->port].tx_handle, buffer, len, &bytes_written, ticks_to_wait);
-        }
-        i2s_safe_unlock(s_i2s_rx_mutex[i2s->port]);
-    }
-    return bytes_written;
-}
-
-static int _i2s_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int w_size = 0;
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
-    if (r_size == AEL_IO_TIMEOUT) {
-        memset(in_buffer, 0x00, in_len);
-        r_size = in_len;
-        audio_element_multi_output(self, in_buffer, r_size, 0);
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else if (r_size > 0) {
-        if (i2s->use_alc) {
-            audio_element_info_t i2s_info = { 0 };
-            audio_element_getinfo(self, &i2s_info);
-            alc_volume_setup_process(in_buffer, r_size, i2s_info.channels, i2s->volume_handle, i2s->volume);
-        }
-        audio_element_multi_output(self, in_buffer, r_size, 0);
-        w_size = audio_element_output(self, in_buffer, r_size);
-        audio_element_update_byte_pos(self, w_size);
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-esp_err_t i2s_stream_set_clk(audio_element_handle_t i2s_stream, int rate, int bits, int ch)
-{
-    esp_err_t err = ESP_OK;
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-    audio_element_state_t state = audio_element_get_state(i2s_stream);
-    if (state == AEL_STATE_RUNNING) {
-        audio_element_pause(i2s_stream);
-    }
-    i2s_stream_check_data_bits(i2s, &bits);
-    i2s_config_backup(&i2s->config);
-    if (_i2s_set_clk(i2s, rate, bits, ch) == ESP_FAIL) {
-        ESP_LOGE(TAG, "i2s_set_clk failed");
-        err = ESP_FAIL;
-    } else {
-        audio_element_set_music_info(i2s_stream, rate, ch, bits);
-    }
-    if (state == AEL_STATE_RUNNING) {
-        audio_element_resume(i2s_stream, 0, 0);
-    }
-    return err;
-}
-
-esp_err_t i2s_alc_volume_set(audio_element_handle_t i2s_stream, int volume)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-    if (i2s->use_alc) {
-        i2s->volume = volume;
-        return ESP_OK;
-    } else {
-        ESP_LOGW(TAG, "The ALC don't be used. It can not be set.");
-        return ESP_FAIL;
-    }
-}
-
-esp_err_t i2s_alc_volume_get(audio_element_handle_t i2s_stream, int *volume)
-{
-    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
-    if (i2s->use_alc) {
-        *volume = i2s->volume;
-        return ESP_OK;
-    } else {
-        ESP_LOGW(TAG, "The ALC don't be used");
-        return ESP_FAIL;
-    }
-}
-
-audio_element_handle_t i2s_stream_init(i2s_stream_cfg_t *config)
-{
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    audio_element_handle_t el = NULL;
-    cfg.open = _i2s_open;
-    cfg.close = _i2s_close;
-    cfg.process = _i2s_process;
-    cfg.destroy = _i2s_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.stack_in_ext = config->stack_in_ext;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.multi_out_rb_num = config->multi_out_num;
-    cfg.tag = "iis";
-    config->buffer_len = config->buffer_len > 0 ? config->buffer_len : I2S_STREAM_BUF_SIZE;
-    cfg.buffer_len = config->buffer_len;
-    if (cfg.buffer_len % I2S_BUFFER_ALINED_BYTES_SIZE) {
-        ESP_LOGE(TAG, "The size of buffer must be a multiple of %d, current size is %d", I2S_BUFFER_ALINED_BYTES_SIZE, cfg.buffer_len);
-        return NULL;
-    }
-    int i2s_port = config->chan_cfg.id;
-    i2s_dir_t i2s_dir = 0;
-    if (i2s_port == I2S_NUM_AUTO) {
-        ESP_LOGE(TAG, "Please specify the port number of I2S.");
-        return NULL;
-    }
-    i2s_stream_t *i2s = audio_calloc(1, sizeof(i2s_stream_t));
-    AUDIO_MEM_CHECK(TAG, i2s, return NULL);
-
-    i2s->type = config->type;
-    i2s->use_alc = config->use_alc;
-    i2s->volume = config->volume;
-    i2s->uninstall_drv = config->uninstall_drv;
-    i2s->port = i2s_port;
-    i2s->buffer_length = config->buffer_len;
-    if (config->type == AUDIO_STREAM_READER) {
-        cfg.read = _i2s_read;
-        i2s_dir = I2S_DIR_RX;
-    } else if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _i2s_write;
-        i2s_dir = I2S_DIR_TX;
-    }
-
-#if (!defined (CONFIG_IDF_TARGET_ESP32) && !defined (CONFIG_IDF_TARGET_ESP32S2))
-    if (config->need_expand && config->transmit_mode == I2S_COMM_MODE_STD) {
-        config->std_cfg.slot_cfg.slot_bit_width = config->std_cfg.slot_cfg.data_bit_width;
-        config->std_cfg.slot_cfg.data_bit_width = config->expand_src_bits;
-    }
-#endif // (defined (CONFIG_IDF_TARGET_ESP32) && defined(CONFIG_IDF_TARGET_ESP32S2))
-    memcpy(&i2s->config, config, sizeof(i2s_stream_cfg_t));
-
-    el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, {
-        audio_free(i2s);
-        return NULL;
-    });
-    audio_element_setdata(el, i2s);
-
-    i2s_stream_setup_music_info(el, i2s);
-    /* backup i2s configure */
-    i2s_config_backup(&i2s->config);
-
-    // In order to be compatible with esp32 and esp32s2, the Tx and TRx of i2s channel use the same controller.
-    // However, there is a problem that if RX channel is enabled and then TX channel is enabled, RX channel needs to be turned off first,
-    // which will cause it to be turned off during rx operation. Therefore, mutex is used for protection and will never be released
-    if (i2s_key_slot[i2s_port].i2s_refcount > 0) {
-        i2s_safe_lock_create(s_i2s_tx_mutex[i2s_port]);
-        i2s_safe_lock_create(s_i2s_rx_mutex[i2s_port]);
-    }
-    i2s_safe_lock(s_i2s_tx_mutex[i2s_port]);
-    i2s_safe_lock(s_i2s_rx_mutex[i2s_port]);
-    if (i2s_key_slot[i2s_port].dir) {
-        if (i2s_key_slot[i2s_port].dir & i2s_dir) {
-            ESP_LOGW(TAG, "I2S(%d) already startup", i2s_dir);
-            goto i2s_end;
-        } else {
-            i2s_driver_cleanup(i2s, false);
-        }
-    }
-    i2s_key_slot[i2s_port].dir |= i2s_dir;
-
-    if (i2s_driver_startup(el, &i2s->config) != ESP_OK) {
-        ESP_LOGE(TAG, "I2S stream init failed");
-        i2s_safe_unlock(s_i2s_tx_mutex[i2s_port]);
-        i2s_safe_unlock(s_i2s_rx_mutex[i2s_port]);
-        return NULL;
-    }
-    if (i2s_key_slot[i2s_port].dir & I2S_DIR_TX) {
-        i2s_channel_enable(i2s_key_slot[i2s_port].tx_handle);
-    }
-    if (i2s_key_slot[i2s_port].dir & I2S_DIR_RX) {
-        i2s_channel_enable(i2s_key_slot[i2s_port].rx_handle);
-    }
-
-i2s_end:
-    i2s_safe_unlock(s_i2s_tx_mutex[i2s_port]);
-    i2s_safe_unlock(s_i2s_rx_mutex[i2s_port]);
-    i2s_key_slot[i2s_port].i2s_refcount++;
-    return el;
-}
-
-esp_err_t i2s_stream_set_channel_type(i2s_stream_cfg_t *config, i2s_channel_type_t type)
-{
-    AUDIO_NULL_CHECK(TAG, config != NULL, {return ESP_ERR_INVALID_ARG;});
-    switch (type) {
-        case I2S_CHANNEL_TYPE_RIGHT_LEFT:
-            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
-            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_BOTH;
-            break;
-        case I2S_CHANNEL_TYPE_ONLY_RIGHT:
-            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_MONO;
-            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_RIGHT;
-            break;
-        case I2S_CHANNEL_TYPE_ONLY_LEFT:
-            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_MONO;
-            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_LEFT;
-            break;
-        case I2S_CHANNEL_TYPE_ALL_RIGHT:
-            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
-            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_RIGHT;
-            break;
-        case I2S_CHANNEL_TYPE_ALL_LEFT:
-            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
-            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_LEFT;
-            break;
-    }
-    return ESP_OK;
-}
-
-esp_err_t i2s_stream_sync_delay(audio_element_handle_t i2s_stream, int delay_ms)
-{
-    char *in_buffer = NULL;
-    audio_element_info_t info = { 0 };
-    audio_element_getinfo(i2s_stream, &info);
-
-    if (delay_ms < 0) {
-        uint32_t delay_size = (~delay_ms + 1) * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
-        in_buffer = (char *)audio_malloc(delay_size);
-        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
-        memset(in_buffer, 0x00, delay_size);
-        ringbuf_handle_t input_rb = audio_element_get_input_ringbuf(i2s_stream);
-        if (input_rb) {
-            rb_write(input_rb, in_buffer, delay_size, 0);
-        }
-        audio_free(in_buffer);
-    } else if (delay_ms > 0) {
-        uint32_t drop_size = delay_ms * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
-        in_buffer = (char *)audio_malloc(drop_size);
-        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
-        uint32_t r_size = audio_element_input(i2s_stream, in_buffer, drop_size);
-        audio_free(in_buffer);
-
-        if (r_size > 0) {
-            audio_element_update_byte_pos(i2s_stream, r_size);
-        } else {
-            ESP_LOGW(TAG, "Can't get enough data to drop.");
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "audio_idf_version.h"
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+#include <string.h>
+
+#include "esp_log.h"
+
+#include "audio_mem.h"
+#include "esp_alc.h"
+#include "i2s_stream.h"
+#include "board_pins_config.h"
+
+static const char *TAG = "I2S_STREAM_IDF5.x";
+
+#define I2S_BUFFER_ALINED_BYTES_SIZE (12)
+
+typedef struct i2s_stream {
+    audio_stream_type_t type;
+    i2s_stream_cfg_t    config;
+    bool                is_open;
+    bool                use_alc;
+    void               *volume_handle;
+    int                 volume;
+    bool                uninstall_drv;
+    i2s_port_t          port;
+    int                 buffer_length;
+    struct {
+        char           *buf;
+        int             buffer_size;
+    } expand;
+} i2s_stream_t;
+
+struct i2s_key_slot_s {
+    i2s_chan_handle_t       rx_handle;
+    i2s_chan_handle_t       tx_handle;
+    union {
+        i2s_std_config_t    rx_std_cfg;
+#if SOC_I2S_SUPPORTS_PDM_RX
+        i2s_pdm_rx_config_t rx_pdm_cfg;
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+#if SOC_I2S_SUPPORTS_TDM
+        i2s_tdm_config_t    rx_tdm_cfg;
+#endif // SOC_I2S_SUPPORTS_TDM
+    };
+    union {
+        i2s_std_config_t    tx_std_cfg;
+#if SOC_I2S_SUPPORTS_PDM_TX
+        i2s_pdm_tx_config_t tx_pdm_cfg;
+#endif // SOC_I2S_SUPPORTS_PDM_TX
+#if SOC_I2S_SUPPORTS_TDM
+        i2s_tdm_config_t    tx_tdm_cfg;
+#endif // SOC_I2S_SUPPORTS_TDM
+    };
+    i2s_chan_config_t       chan_cfg;
+    i2s_dir_t               dir;
+    int                     i2s_refcount;
+};
+
+static void *s_i2s_tx_mutex[SOC_I2S_NUM];
+static void *s_i2s_rx_mutex[SOC_I2S_NUM];
+
+static struct i2s_key_slot_s i2s_key_slot[SOC_I2S_NUM];
+
+#define i2s_safe_lock_create(lock) do {           \
+    if (lock == NULL) {                           \
+        lock = xSemaphoreCreateRecursiveMutex();  \
+    }                                             \
+} while (0)
+
+#define i2s_safe_lock(lock) do {                       \
+    if (lock) {                                        \
+        xSemaphoreTakeRecursive(lock, portMAX_DELAY);  \
+    }                                                  \
+} while (0)
+
+#define i2s_safe_unlock(lock) do {      \
+    if (lock) {                         \
+        xSemaphoreGiveRecursive(lock);  \
+    }                                   \
+} while (0)
+
+static int i2s_driver_startup(audio_element_handle_t self, i2s_stream_cfg_t *i2s_cfg)
+{
+    esp_err_t ret = ESP_OK;
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    i2s_comm_mode_t i2s_mode = i2s_cfg->transmit_mode;
+    int i2s_port = i2s_cfg->chan_cfg.id;
+    board_i2s_pin_t board_i2s_pin = { 0 };
+    get_i2s_pins(i2s_port, &board_i2s_pin);
+
+    i2s_key_slot[i2s->port].chan_cfg.auto_clear = true;
+    ret = i2s_new_channel(&i2s_key_slot[i2s->port].chan_cfg, i2s_key_slot[i2s->port].dir & I2S_DIR_TX ?  &i2s_key_slot[i2s->port].tx_handle : NULL,
+                          i2s_key_slot[i2s->port].dir & I2S_DIR_RX ?  &i2s_key_slot[i2s->port].rx_handle : NULL);
+    switch (i2s_mode) {
+        case I2S_COMM_MODE_STD:
+            if (i2s_key_slot[i2s->port].dir & I2S_DIR_TX) {
+                memcpy(&i2s_key_slot[i2s->port].tx_std_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
+                ret |= i2s_channel_init_std_mode(i2s_key_slot[i2s->port].tx_handle, &i2s_key_slot[i2s->port].tx_std_cfg);
+            }
+            if (i2s_key_slot[i2s->port].dir & I2S_DIR_RX) {
+                memcpy(&i2s_key_slot[i2s->port].rx_std_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
+                ret |= i2s_channel_init_std_mode(i2s_key_slot[i2s->port].rx_handle, &i2s_key_slot[i2s->port].rx_std_cfg);
+            }
+            break;
+#if SOC_I2S_SUPPORTS_PDM
+        case I2S_COMM_MODE_PDM:
+#if SOC_I2S_SUPPORTS_PDM_RX
+            if (i2s_key_slot[i2s->port].dir & I2S_DIR_RX) {
+                i2s_key_slot[i2s->port].rx_pdm_cfg.gpio_cfg.clk = board_i2s_pin.bck_io_num;
+                i2s_key_slot[i2s->port].rx_pdm_cfg.gpio_cfg.din = board_i2s_pin.data_in_num;
+                ret |= i2s_channel_init_pdm_rx_mode(i2s_key_slot[i2s->port].rx_handle, &i2s_key_slot[i2s->port].rx_pdm_cfg);
+            }
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+#if SOC_I2S_SUPPORTS_PDM_TX
+            if (i2s_key_slot[i2s->port].dir & I2S_DIR_TX) {
+                i2s_key_slot[i2s->port].tx_pdm_cfg.gpio_cfg.clk = board_i2s_pin.bck_io_num;
+                i2s_key_slot[i2s->port].tx_pdm_cfg.gpio_cfg.dout = board_i2s_pin.data_out_num;
+                ret |= i2s_channel_init_pdm_tx_mode(i2s_key_slot[i2s->port].tx_handle, &i2s_key_slot[i2s->port].tx_pdm_cfg);
+            }
+#endif // SOC_I2S_SUPPORTS_PDM_TX
+            break;
+#endif // SOC_I2S_SUPPORTS_PDM
+
+#if SOC_I2S_SUPPORTS_TDM
+        case I2S_COMM_MODE_TDM:
+            if (i2s_key_slot[i2s->port].dir & I2S_DIR_TX) {
+                memcpy(&i2s_key_slot[i2s->port].tx_tdm_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
+                ret |= i2s_channel_init_tdm_mode(i2s_key_slot[i2s->port].tx_handle, &i2s_key_slot[i2s->port].tx_tdm_cfg);
+            }
+            if (i2s_key_slot[i2s->port].dir & I2S_DIR_RX) {
+                memcpy(&i2s_key_slot[i2s->port].rx_tdm_cfg.gpio_cfg, &board_i2s_pin, sizeof(board_i2s_pin_t));
+                ret |= i2s_channel_init_tdm_mode(i2s_key_slot[i2s->port].rx_handle, &i2s_key_slot[i2s->port].rx_tdm_cfg);
+            }
+            break;
+#endif // SOC_I2S_SUPPORTS_TDM
+        default:
+            ESP_LOGE(TAG, "Invalid I2S transmit mode, %d", i2s_mode);
+            ret = ESP_FAIL;
+            break;
+    }
+    return ret;
+}
+
+static esp_err_t i2s_driver_cleanup(i2s_stream_t *i2s, bool deep_cleanup)
+{
+    esp_err_t ret = ESP_OK;
+#if (defined CONFIG_IDF_TARGET_ESP32)|| (defined CONFIG_IDF_TARGET_ESP32S2)
+    i2s_key_slot[i2s->port].i2s_refcount--;
+    if (i2s_key_slot[i2s->port].i2s_refcount > 0) {
+        return ret;
+    }
+#endif // (defined CONFIG_IDF_TARGET_ESP32)|| (defined CONFIG_IDF_TARGET_ESP32S2)
+    if (i2s_key_slot[i2s->port].tx_handle) {
+        ret |= i2s_channel_disable(i2s_key_slot[i2s->port].tx_handle);
+        ret |= i2s_del_channel(i2s_key_slot[i2s->port].tx_handle);
+        i2s_key_slot[i2s->port].tx_handle = NULL;
+        if (deep_cleanup) {
+            i2s_key_slot[i2s->port].dir &= ~I2S_DIR_TX;
+        }
+    }
+    if (i2s_key_slot[i2s->port].rx_handle) {
+        ret |= i2s_channel_disable(i2s_key_slot[i2s->port].rx_handle);
+        ret |= i2s_del_channel(i2s_key_slot[i2s->port].rx_handle);
+        i2s_key_slot[i2s->port].rx_handle = NULL;
+        if (deep_cleanup) {
+            i2s_key_slot[i2s->port].dir &= ~I2S_DIR_RX;
+        }
+    }
+    return ret;
+}
+
+static esp_err_t i2s_config_backup(i2s_stream_cfg_t *i2s_cfg)
+{
+    int i2s_port = i2s_cfg->chan_cfg.id;
+    memcpy(&i2s_key_slot[i2s_port].chan_cfg, &i2s_cfg->chan_cfg, sizeof(i2s_chan_config_t));
+
+    if (i2s_cfg->type == AUDIO_STREAM_READER) {
+        if (i2s_cfg->transmit_mode == I2S_COMM_MODE_STD) {
+            memcpy(&i2s_key_slot[i2s_port].rx_std_cfg, &i2s_cfg->std_cfg, sizeof(i2s_cfg->std_cfg));
+        }
+#if SOC_I2S_SUPPORTS_PDM_RX
+        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_PDM) {
+            memcpy(&i2s_key_slot[i2s_port].rx_pdm_cfg, &i2s_cfg->pdm_rx_cfg, sizeof(i2s_cfg->pdm_rx_cfg));
+        }
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+#if SOC_I2S_SUPPORTS_TDM
+        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_TDM) {
+            memcpy(&i2s_key_slot[i2s_port].rx_tdm_cfg, &i2s_cfg->tdm_cfg, sizeof(i2s_cfg->tdm_cfg));
+        }
+#endif // SOC_I2S_SUPPORTS_TDM
+    } else if (i2s_cfg->type == AUDIO_STREAM_WRITER) {
+        if (i2s_cfg->transmit_mode == I2S_COMM_MODE_STD) {
+            memcpy(&i2s_key_slot[i2s_port].tx_std_cfg, &i2s_cfg->std_cfg, sizeof(i2s_cfg->std_cfg));
+        }
+#if SOC_I2S_SUPPORTS_PDM_TX
+        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_PDM) {
+            memcpy(&i2s_key_slot[i2s_port].tx_pdm_cfg, &i2s_cfg->pdm_tx_cfg, sizeof(i2s_cfg->pdm_tx_cfg));
+        }
+#endif // SOC_I2S_SUPPORTS_PDM_TX
+#if SOC_I2S_SUPPORTS_TDM
+        else if (i2s_cfg->transmit_mode == I2S_COMM_MODE_TDM) {
+            memcpy(&i2s_key_slot[i2s_port].tx_tdm_cfg, &i2s_cfg->tdm_cfg, sizeof(i2s_cfg->tdm_cfg));
+        }
+#endif // SOC_I2S_SUPPORTS_TDM
+    } else {
+        ESP_LOGE(TAG, "Invalid audio stream type: %d", i2s_cfg->type);
+    }
+    return ESP_OK;
+}
+
+static inline esp_err_t i2s_stream_check_data_bits(i2s_stream_t *i2s, int *bits)
+{
+    if (i2s->config.transmit_mode == I2S_COMM_MODE_STD) {
+#if (defined (CONFIG_IDF_TARGET_ESP32) || defined(CONFIG_IDF_TARGET_ESP32S2))
+        if (*bits == I2S_DATA_BIT_WIDTH_24BIT) {
+            i2s->config.need_expand = true;
+            *bits = I2S_DATA_BIT_WIDTH_32BIT;
+            i2s->config.std_cfg.slot_cfg.data_bit_width = I2S_DATA_BIT_WIDTH_32BIT;
+            i2s->config.std_cfg.slot_cfg.ws_width = I2S_DATA_BIT_WIDTH_32BIT;
+        } else {
+            i2s->config.std_cfg.slot_cfg.data_bit_width = *bits;
+            i2s->config.std_cfg.slot_cfg.ws_width = *bits;
+        }
+#else
+        if (*bits == I2S_DATA_BIT_WIDTH_24BIT) {
+            i2s->config.std_cfg.clk_cfg.mclk_multiple = I2S_MCLK_MULTIPLE_384;
+        }
+#endif // (defined (CONFIG_IDF_TARGET_ESP32) || defined(CONFIG_IDF_TARGET_ESP32S2))
+    }
+    return ESP_OK;
+}
+
+static esp_err_t i2s_stream_setup_music_info(audio_element_handle_t el, i2s_stream_t *i2s)
+{
+    int sample_rate_hz = 0;
+    int slot_mode = 0;
+    int data_bit_width = 0;
+    switch (i2s->config.transmit_mode) {
+        case I2S_COMM_MODE_STD:
+            sample_rate_hz = i2s->config.std_cfg.clk_cfg.sample_rate_hz;
+            slot_mode = i2s->config.std_cfg.slot_cfg.slot_mode;
+            data_bit_width = i2s->config.std_cfg.slot_cfg.data_bit_width;
+            break;
+#if SOC_I2S_SUPPORTS_PDM
+        case I2S_COMM_MODE_PDM:
+#if SOC_I2S_SUPPORTS_PDM_TX
+            if (i2s->type == AUDIO_STREAM_WRITER) {
+                sample_rate_hz = i2s->config.pdm_tx_cfg.clk_cfg.sample_rate_hz;
+                slot_mode = i2s->config.pdm_tx_cfg.slot_cfg.slot_mode;
+                data_bit_width = i2s->config.pdm_tx_cfg.slot_cfg.data_bit_width;
+            }
+#endif // SOC_I2S_SUPPORTS_PDM_TX
+#if SOC_I2S_SUPPORTS_PDM_RX
+            if (i2s->type == AUDIO_STREAM_READER) {
+                sample_rate_hz = i2s->config.pdm_rx_cfg.clk_cfg.sample_rate_hz;
+                slot_mode = i2s->config.pdm_rx_cfg.slot_cfg.slot_mode;
+                data_bit_width = i2s->config.pdm_rx_cfg.slot_cfg.data_bit_width;
+            }
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+            break;
+#endif
+#if SOC_I2S_SUPPORTS_TDM
+        case I2S_COMM_MODE_TDM:
+            sample_rate_hz = i2s->config.tdm_cfg.clk_cfg.sample_rate_hz;
+            slot_mode = i2s->config.tdm_cfg.slot_cfg.slot_mode;
+            data_bit_width = i2s->config.tdm_cfg.slot_cfg.data_bit_width;
+            break;
+#endif
+        default:
+            sample_rate_hz = i2s->config.std_cfg.clk_cfg.sample_rate_hz;
+            slot_mode = i2s->config.std_cfg.slot_cfg.slot_mode;
+            data_bit_width = i2s->config.std_cfg.slot_cfg.data_bit_width;
+            break;
+    }
+    i2s_stream_check_data_bits(i2s, &data_bit_width);
+
+    audio_element_set_music_info(el, sample_rate_hz, slot_mode, data_bit_width);
+    return ESP_OK;
+}
+
+static esp_err_t _i2s_set_clk(i2s_stream_t *i2s, int rate, int bits, int ch)
+{
+    esp_err_t err = ESP_OK;
+    i2s_port_t port = i2s->port;
+    i2s_slot_mode_t slot_mode;
+    if (ch == 1) {
+        slot_mode = I2S_SLOT_MODE_MONO;
+    } else if (ch == 2) {
+        slot_mode = I2S_SLOT_MODE_STEREO;
+    } else {
+        ESP_LOGE(TAG, "Invalid ch: %d", ch);
+        return ESP_FAIL;
+    }
+    if (i2s->config.transmit_mode == I2S_COMM_MODE_STD) {
+        if (i2s_key_slot[port].tx_handle != NULL && i2s->type == AUDIO_STREAM_WRITER) {
+            i2s_key_slot[port].tx_std_cfg.slot_cfg.data_bit_width = bits;
+            i2s_key_slot[port].tx_std_cfg.slot_cfg.ws_width = bits;
+            i2s_key_slot[port].tx_std_cfg.slot_cfg.slot_mode = slot_mode;
+            i2s_key_slot[port].tx_std_cfg.clk_cfg.sample_rate_hz = rate;
+            i2s_channel_disable(i2s_key_slot[port].tx_handle);
+            err |= i2s_channel_reconfig_std_slot(i2s_key_slot[port].tx_handle, &i2s_key_slot[port].tx_std_cfg.slot_cfg);
+            err |= i2s_channel_reconfig_std_clock(i2s_key_slot[port].tx_handle, &i2s_key_slot[port].tx_std_cfg.clk_cfg);
+            err |= i2s_channel_enable(i2s_key_slot[port].tx_handle);
+        }
+        if (i2s_key_slot[port].rx_handle != NULL && i2s->type == AUDIO_STREAM_READER) {
+            i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg.data_bit_width = bits;
+            i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg.ws_width = bits;
+            i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg.slot_mode = slot_mode;
+            i2s_key_slot[i2s->port].rx_std_cfg.clk_cfg.sample_rate_hz = rate;
+            i2s_channel_disable(i2s_key_slot[port].rx_handle);
+            err |= i2s_channel_reconfig_std_slot(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_std_cfg.slot_cfg);
+            err |= i2s_channel_reconfig_std_clock(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_std_cfg.clk_cfg);
+            err |= i2s_channel_enable(i2s_key_slot[port].rx_handle);
+        }
+#if SOC_I2S_SUPPORTS_PDM
+    } else if (i2s->config.transmit_mode == I2S_COMM_MODE_PDM) {
+#if SOC_I2S_SUPPORTS_PDM_TX
+        if (i2s_key_slot[port].tx_handle != NULL && i2s->type == AUDIO_STREAM_WRITER) {
+            i2s_key_slot[i2s->port].tx_pdm_cfg.clk_cfg.sample_rate_hz = rate;
+            i2s_key_slot[i2s->port].tx_pdm_cfg.slot_cfg.data_bit_width = bits;
+            i2s_key_slot[i2s->port].tx_pdm_cfg.slot_cfg.slot_mode = slot_mode;
+            i2s_channel_disable(i2s_key_slot[port].tx_handle);
+            err |= i2s_channel_reconfig_pdm_tx_slot(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_pdm_cfg.slot_cfg);
+            err |= i2s_channel_reconfig_pdm_tx_clock(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_pdm_cfg.clk_cfg);
+            err |= i2s_channel_enable(i2s_key_slot[port].tx_handle);
+        }
+#endif // SOC_I2S_SUPPORTS_PDM_TX
+#if SOC_I2S_SUPPORTS_PDM_RX
+        if (i2s_key_slot[port].rx_handle != NULL && i2s->type == AUDIO_STREAM_READER) {
+            i2s_key_slot[i2s->port].rx_pdm_cfg.clk_cfg.sample_rate_hz = rate;
+            i2s_key_slot[i2s->port].rx_pdm_cfg.slot_cfg.data_bit_width = bits;
+            i2s_key_slot[i2s->port].rx_pdm_cfg.slot_cfg.slot_mode = slot_mode;
+            i2s_channel_disable(i2s_key_slot[port].rx_handle);
+            err |= i2s_channel_reconfig_pdm_rx_slot(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_pdm_cfg.slot_cfg);
+            err |= i2s_channel_reconfig_pdm_rx_clock(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_pdm_cfg.clk_cfg);
+            err |= i2s_channel_enable(i2s_key_slot[port].rx_handle);
+        }
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+
+#endif // SOC_I2S_SUPPORTS_PDM
+#if SOC_I2S_SUPPORTS_TDM
+    } else if (i2s->config.transmit_mode == I2S_COMM_MODE_TDM) {
+        if (i2s_key_slot[port].tx_handle != NULL && i2s->type == AUDIO_STREAM_WRITER) {
+            i2s_key_slot[i2s->port].tx_tdm_cfg.clk_cfg.sample_rate_hz = rate;
+            i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg.data_bit_width = bits;
+            i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg.ws_width = bits;
+            i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg.slot_mode = slot_mode;
+            i2s_channel_disable(i2s_key_slot[port].tx_handle);
+            err |= i2s_channel_reconfig_tdm_slot(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_tdm_cfg.slot_cfg);
+            err |= i2s_channel_reconfig_tdm_clock(i2s_key_slot[port].tx_handle, &i2s_key_slot[i2s->port].tx_tdm_cfg.clk_cfg);
+            err |= i2s_channel_enable(i2s_key_slot[port].tx_handle);
+        }
+        if (i2s_key_slot[port].rx_handle != NULL && i2s->type == AUDIO_STREAM_READER) {
+            i2s_key_slot[i2s->port].rx_tdm_cfg.clk_cfg.sample_rate_hz = rate;
+            i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg.data_bit_width = bits;
+            i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg.ws_width = bits;
+            i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg.slot_mode = slot_mode;
+            i2s_channel_disable(i2s_key_slot[port].rx_handle);
+            err |= i2s_channel_reconfig_tdm_slot(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_tdm_cfg.slot_cfg);
+            err |= i2s_channel_reconfig_tdm_clock(i2s_key_slot[port].rx_handle, &i2s_key_slot[i2s->port].rx_tdm_cfg.clk_cfg);
+            err |= i2s_channel_enable(i2s_key_slot[port].rx_handle);
+        }
+#endif // SOC_I2S_SUPPORTS_TDM
+    } else {
+        ESP_LOGE(TAG, "Invalid I2S type, %d", i2s->config.transmit_mode);
+    }
+    return err;
+}
+
+static int cal_i2s_buffer_timeout(audio_element_handle_t self)
+{
+#define  DEFAULT_I2S_BUFFER_NUM (2)
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    int timeout_ms = 0;
+    audio_element_info_t stream_info = { 0 };
+    audio_element_getinfo(self, &stream_info);
+    timeout_ms = i2s->buffer_length * DEFAULT_I2S_BUFFER_NUM / ((stream_info.sample_rates * stream_info.channels * stream_info.bits >> 3) / 1000) ;
+    ESP_LOGD(TAG, "I2S buffer timeout: %dms\n", timeout_ms);
+    return timeout_ms;
+}
+
+static esp_err_t _i2s_open(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    if (i2s->is_open) {
+        return ESP_OK;
+    }
+    if (i2s->type == AUDIO_STREAM_WRITER) {
+        audio_element_set_input_timeout(self, pdMS_TO_TICKS(cal_i2s_buffer_timeout(self)));
+    }
+    i2s->is_open = true;
+    if (i2s->use_alc) {
+        i2s->volume_handle = alc_volume_setup_open();
+        if (i2s->volume_handle == NULL) {
+            ESP_LOGE(TAG, "I2S create the handle for setting volume failed, in line(%d)", __LINE__);
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _i2s_destroy(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    if (i2s->uninstall_drv) {
+        i2s_driver_cleanup(i2s, true);
+    }
+    if (i2s->expand.buf) {
+        audio_free(i2s->expand.buf);
+    }
+    audio_free(i2s);
+    return ESP_OK;
+}
+
+static esp_err_t _i2s_close(audio_element_handle_t self)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+
+    i2s->is_open = false;
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_report_pos(self);
+        audio_element_set_byte_pos(self, 0);
+    }
+    if (i2s->use_alc) {
+        if (i2s->volume_handle != NULL) {
+            alc_volume_setup_close(i2s->volume_handle);
+        }
+    }
+    return ESP_OK;
+}
+
+static esp_err_t i2s_channel_write_expand(i2s_stream_t *i2s, const char *src, size_t src_len, int src_bit, int dst_bit, size_t *bytes_written, uint32_t timeout_ms)
+{
+    int src_bytes = src_bit / 8;
+    int dst_bytes = dst_bit / 8;
+    int filled_bytes = dst_bytes - src_bytes;
+    int target_len = (src_len * dst_bytes) / src_bytes;
+    if ((i2s->expand.buf == NULL) || (target_len > i2s->expand.buffer_size)) {
+        if (i2s->expand.buf) {
+            audio_free(i2s->expand.buf);
+        }
+        i2s->expand.buf = audio_calloc(1, target_len);
+        AUDIO_MEM_CHECK(TAG, i2s->expand.buf, return ESP_ERR_NO_MEM);
+        i2s->expand.buffer_size = target_len;
+    }
+    memset(i2s->expand.buf, 0, target_len);
+
+    size_t k = 0;
+    for (size_t i = 0; i < src_len; i += src_bytes) {
+        k += filled_bytes;
+        memcpy(&i2s->expand.buf[k], (const char *)(src + i), src_bytes);
+        k += src_bytes;
+    }
+    i2s_channel_write(i2s_key_slot[i2s->port].tx_handle, i2s->expand.buf, target_len, bytes_written, timeout_ms);
+    return ESP_OK;
+}
+
+static int _i2s_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    size_t bytes_read = 0;
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    i2s_safe_lock(s_i2s_tx_mutex[i2s->port]);
+    i2s_channel_read(i2s_key_slot[i2s->port].rx_handle, buffer, len, &bytes_read, ticks_to_wait);
+    i2s_safe_unlock(s_i2s_tx_mutex[i2s->port]);
+    return bytes_read;
+}
+
+static int _i2s_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    size_t bytes_written = 0;
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+    int target_bits = info.bits;
+    if (len) {
+#ifdef CONFIG_IDF_TARGET_ESP32
+        target_bits = I2S_DATA_BIT_WIDTH_32BIT;
+#endif
+        i2s_safe_lock(s_i2s_rx_mutex[i2s->port]);
+        if (i2s->config.need_expand && (target_bits != i2s->config.expand_src_bits)) {
+            i2s_channel_write_expand(i2s, buffer, len, i2s->config.expand_src_bits, target_bits,
+                                     &bytes_written, ticks_to_wait);
+        } else {
+            i2s_channel_write(i2s_key_slot[i2s->port].tx_handle, buffer, len, &bytes_written, ticks_to_wait);
+        }
+        i2s_safe_unlock(s_i2s_rx_mutex[i2s->port]);
+    }
+    return bytes_written;
+}
+
+static int _i2s_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int w_size = 0;
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(self);
+    if (r_size == AEL_IO_TIMEOUT) {
+        memset(in_buffer, 0x00, in_len);
+        r_size = in_len;
+        audio_element_multi_output(self, in_buffer, r_size, 0);
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else if (r_size > 0) {
+        if (i2s->use_alc) {
+            audio_element_info_t i2s_info = { 0 };
+            audio_element_getinfo(self, &i2s_info);
+            alc_volume_setup_process(in_buffer, r_size, i2s_info.channels, i2s->volume_handle, i2s->volume);
+        }
+        audio_element_multi_output(self, in_buffer, r_size, 0);
+        w_size = audio_element_output(self, in_buffer, r_size);
+        audio_element_update_byte_pos(self, w_size);
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+esp_err_t i2s_stream_set_clk(audio_element_handle_t i2s_stream, int rate, int bits, int ch)
+{
+    esp_err_t err = ESP_OK;
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+    audio_element_state_t state = audio_element_get_state(i2s_stream);
+    if (state == AEL_STATE_RUNNING) {
+        audio_element_pause(i2s_stream);
+    }
+    i2s_stream_check_data_bits(i2s, &bits);
+    i2s_config_backup(&i2s->config);
+    if (_i2s_set_clk(i2s, rate, bits, ch) == ESP_FAIL) {
+        ESP_LOGE(TAG, "i2s_set_clk failed");
+        err = ESP_FAIL;
+    } else {
+        audio_element_set_music_info(i2s_stream, rate, ch, bits);
+    }
+    if (state == AEL_STATE_RUNNING) {
+        audio_element_resume(i2s_stream, 0, 0);
+    }
+    return err;
+}
+
+esp_err_t i2s_alc_volume_set(audio_element_handle_t i2s_stream, int volume)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+    if (i2s->use_alc) {
+        i2s->volume = volume;
+        return ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "The ALC don't be used. It can not be set.");
+        return ESP_FAIL;
+    }
+}
+
+esp_err_t i2s_alc_volume_get(audio_element_handle_t i2s_stream, int *volume)
+{
+    i2s_stream_t *i2s = (i2s_stream_t *)audio_element_getdata(i2s_stream);
+    if (i2s->use_alc) {
+        *volume = i2s->volume;
+        return ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "The ALC don't be used");
+        return ESP_FAIL;
+    }
+}
+
+audio_element_handle_t i2s_stream_init(i2s_stream_cfg_t *config)
+{
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    audio_element_handle_t el = NULL;
+    cfg.open = _i2s_open;
+    cfg.close = _i2s_close;
+    cfg.process = _i2s_process;
+    cfg.destroy = _i2s_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.stack_in_ext = config->stack_in_ext;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.multi_out_rb_num = config->multi_out_num;
+    cfg.tag = "iis";
+    config->buffer_len = config->buffer_len > 0 ? config->buffer_len : I2S_STREAM_BUF_SIZE;
+    cfg.buffer_len = config->buffer_len;
+    if (cfg.buffer_len % I2S_BUFFER_ALINED_BYTES_SIZE) {
+        ESP_LOGE(TAG, "The size of buffer must be a multiple of %d, current size is %d", I2S_BUFFER_ALINED_BYTES_SIZE, cfg.buffer_len);
+        return NULL;
+    }
+    int i2s_port = config->chan_cfg.id;
+    i2s_dir_t i2s_dir = 0;
+    if (i2s_port == I2S_NUM_AUTO) {
+        ESP_LOGE(TAG, "Please specify the port number of I2S.");
+        return NULL;
+    }
+    i2s_stream_t *i2s = audio_calloc(1, sizeof(i2s_stream_t));
+    AUDIO_MEM_CHECK(TAG, i2s, return NULL);
+
+    i2s->type = config->type;
+    i2s->use_alc = config->use_alc;
+    i2s->volume = config->volume;
+    i2s->uninstall_drv = config->uninstall_drv;
+    i2s->port = i2s_port;
+    i2s->buffer_length = config->buffer_len;
+    if (config->type == AUDIO_STREAM_READER) {
+        cfg.read = _i2s_read;
+        i2s_dir = I2S_DIR_RX;
+    } else if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _i2s_write;
+        i2s_dir = I2S_DIR_TX;
+    }
+
+#if (!defined (CONFIG_IDF_TARGET_ESP32) && !defined (CONFIG_IDF_TARGET_ESP32S2))
+    if (config->need_expand && config->transmit_mode == I2S_COMM_MODE_STD) {
+        config->std_cfg.slot_cfg.slot_bit_width = config->std_cfg.slot_cfg.data_bit_width;
+        config->std_cfg.slot_cfg.data_bit_width = config->expand_src_bits;
+    }
+#endif // (defined (CONFIG_IDF_TARGET_ESP32) && defined(CONFIG_IDF_TARGET_ESP32S2))
+    memcpy(&i2s->config, config, sizeof(i2s_stream_cfg_t));
+
+    el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, {
+        audio_free(i2s);
+        return NULL;
+    });
+    audio_element_setdata(el, i2s);
+
+    i2s_stream_setup_music_info(el, i2s);
+    /* backup i2s configure */
+    i2s_config_backup(&i2s->config);
+
+    // In order to be compatible with esp32 and esp32s2, the Tx and TRx of i2s channel use the same controller.
+    // However, there is a problem that if RX channel is enabled and then TX channel is enabled, RX channel needs to be turned off first,
+    // which will cause it to be turned off during rx operation. Therefore, mutex is used for protection and will never be released
+    if (i2s_key_slot[i2s_port].i2s_refcount > 0) {
+        i2s_safe_lock_create(s_i2s_tx_mutex[i2s_port]);
+        i2s_safe_lock_create(s_i2s_rx_mutex[i2s_port]);
+    }
+    i2s_safe_lock(s_i2s_tx_mutex[i2s_port]);
+    i2s_safe_lock(s_i2s_rx_mutex[i2s_port]);
+    if (i2s_key_slot[i2s_port].dir) {
+        if (i2s_key_slot[i2s_port].dir & i2s_dir) {
+            ESP_LOGW(TAG, "I2S(%d) already startup", i2s_dir);
+            goto i2s_end;
+        } else {
+            i2s_driver_cleanup(i2s, false);
+        }
+    }
+    i2s_key_slot[i2s_port].dir |= i2s_dir;
+
+    if (i2s_driver_startup(el, &i2s->config) != ESP_OK) {
+        ESP_LOGE(TAG, "I2S stream init failed");
+        i2s_safe_unlock(s_i2s_tx_mutex[i2s_port]);
+        i2s_safe_unlock(s_i2s_rx_mutex[i2s_port]);
+        return NULL;
+    }
+    if (i2s_key_slot[i2s_port].dir & I2S_DIR_TX) {
+        i2s_channel_enable(i2s_key_slot[i2s_port].tx_handle);
+    }
+    if (i2s_key_slot[i2s_port].dir & I2S_DIR_RX) {
+        i2s_channel_enable(i2s_key_slot[i2s_port].rx_handle);
+    }
+
+i2s_end:
+    i2s_safe_unlock(s_i2s_tx_mutex[i2s_port]);
+    i2s_safe_unlock(s_i2s_rx_mutex[i2s_port]);
+    i2s_key_slot[i2s_port].i2s_refcount++;
+    return el;
+}
+
+esp_err_t i2s_stream_set_channel_type(i2s_stream_cfg_t *config, i2s_channel_type_t type)
+{
+    AUDIO_NULL_CHECK(TAG, config != NULL, {return ESP_ERR_INVALID_ARG;});
+    switch (type) {
+        case I2S_CHANNEL_TYPE_RIGHT_LEFT:
+            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
+            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_BOTH;
+            break;
+        case I2S_CHANNEL_TYPE_ONLY_RIGHT:
+            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_MONO;
+            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_RIGHT;
+            break;
+        case I2S_CHANNEL_TYPE_ONLY_LEFT:
+            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_MONO;
+            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_LEFT;
+            break;
+        case I2S_CHANNEL_TYPE_ALL_RIGHT:
+            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
+            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_RIGHT;
+            break;
+        case I2S_CHANNEL_TYPE_ALL_LEFT:
+            config->std_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
+            config->std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_LEFT;
+            break;
+    }
+    return ESP_OK;
+}
+
+esp_err_t i2s_stream_sync_delay(audio_element_handle_t i2s_stream, int delay_ms)
+{
+    char *in_buffer = NULL;
+    audio_element_info_t info = { 0 };
+    audio_element_getinfo(i2s_stream, &info);
+
+    if (delay_ms < 0) {
+        uint32_t delay_size = (~delay_ms + 1) * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
+        in_buffer = (char *)audio_malloc(delay_size);
+        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
+        memset(in_buffer, 0x00, delay_size);
+        ringbuf_handle_t input_rb = audio_element_get_input_ringbuf(i2s_stream);
+        if (input_rb) {
+            rb_write(input_rb, in_buffer, delay_size, 0);
+        }
+        audio_free(in_buffer);
+    } else if (delay_ms > 0) {
+        uint32_t drop_size = delay_ms * ((uint32_t)(info.sample_rates * info.channels * info.bits / 8) / 1000);
+        in_buffer = (char *)audio_malloc(drop_size);
+        AUDIO_MEM_CHECK(TAG, in_buffer, return ESP_FAIL);
+        uint32_t r_size = audio_element_input(i2s_stream, in_buffer, drop_size);
+        audio_free(in_buffer);
+
+        if (r_size > 0) {
+            audio_element_update_byte_pos(i2s_stream, r_size);
+        } else {
+            ESP_LOGW(TAG, "Can't get enough data to drop.");
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+#endif
diff --git a/components/audio_stream/include/algorithm_stream.h b/components/audio_stream/include/algorithm_stream.h
index c29f2434..49400d79 100644
--- a/components/audio_stream/include/algorithm_stream.h
+++ b/components/audio_stream/include/algorithm_stream.h
@@ -1,198 +1,198 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ALGORITHM_STREAM_H_
-#define _ALGORITHM_STREAM_H_
-
-#include "audio_element.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ALGORITHM_STREAM_PINNED_TO_CORE     0
-#define ALGORITHM_STREAM_TASK_PERIOD        21
-#define ALGORITHM_STREAM_RINGBUFFER_SIZE    1024
-#define ALGORITHM_STREAM_TASK_STACK_SIZE    (5 * 1024)
-
-#define ALGORITHM_STREAM_DEFAULT_SAMPLE_RATE_HZ   8000
-#define ALGORITHM_STREAM_DEFAULT_SAMPLE_BIT       16
-#define ALGORITHM_STREAM_DEFAULT_MIC_CHANNELS     1
-#define ALGORITHM_STREAM_DEFAULT_AGC_GAIN_DB      5
-
-/*
-
-//  AEC: Acoustic Echo Cancellation
-//  AGC: Automatic Gain Control
-//  WWE: Wake Word Engine
-//  NS:  Noise Suppression
-
-
-                                                           +-----------+
-                                                           |           |
-                                                           |  TYPE 1   |
-                                                           |           |
-                    +--------------------------------------+-----------+----------------------------------------+
-                    |                                                                                           |
-                    |                   reference signal                                                        |
-+-----------+       |  +-----------+    +-----------\      +-----------+    +-----------+    +-----------+      |
-|           |       |  |           |    |            \     |           |    |           |    |           |      |
-| I2S read  |-------|->| Resample  |--->| Data split  |--->|    AEC    |--->|    NS     |--->|    AGC    |      |
-|           |       |  |           |    |            /     |           |    |           |    |           |      |
-+-----------+       |  +-----------+    +-----------/      +------------    +-----------+    +-----------+      |
-                    |                   record signal                                                           |
-                    |                                                                                           |
-                    +-------------------------------------------------------------------------------------------+
-
-                                                           +-----------+
-                                                           |           |
-                                                           |  TYPE 2   |
-                                                           |           |
-                    +--------------------------------------+-----------+----------------------------------------+
-                    |                                                                                           |
-                    |                                                                                           |
-+-----------+       |  +-----------+    +-----------+    +-----------+    +-----------+    +-----------+        |
-|           |       |  |           |    |           |    |           |    |           |    |           |        |
-| I2S read  |-------|->| Resample  |--->| rec signal|--->|    AEC    |--->|    NS     |--->|    AGC    |        |
-|           |       |  |           |    |           |    |           |    |           |    |           |        |
-+-----------+       |  +-----------+    +-----------+    +-----^-----+    +-----------+    +-----------+        |
-                    |                                          |                                                |
-+-----------+       |  +-----------+    +-----------+          |                                                |
-|           |       |  |           |    |           |          |                                                |
-| input_rb  |-------|->| Resample  |--->| ref signal|----------+                                                |
-|           |       |  |           |    |           |                                                           |
-+-----------+       |  +-----------+    +-----------+                                                           |
-                    |                                                                                           |
-                    +-------------------------------------------------------------------------------------------+
-
-*/
-
-/**
- * @brief Two types of algorithm stream input method
- */
-typedef enum {
-    ALGORITHM_STREAM_INPUT_TYPE1 = 0, /*!< Type 1 is default used by mini-board, the reference signal and the recording signal are respectively read in from the left channel and the right channel of the same I2S */
-    ALGORITHM_STREAM_INPUT_TYPE2 = 1, /*!< As the simple diagram above shows, when type2 is choosen, the recording signal and reference signal should be input by users. */
-} algorithm_stream_input_type_t;      /*!< The recording signal is inputted by I2S element by default, and the reference signal should be inputted to the algorithm element by using multiple input buffer. */
-                                      /*!< When use type2, you can combine arbitrarily the algorithm modules you want to use, use algo_mask parameters below to configure that. */
-
-/**
- * @brief Choose the algorithm to be used
- */
-typedef enum {
-    ALGORITHM_STREAM_USE_AEC = (0x1 << 0), /*!< Use AEC */
-    ALGORITHM_STREAM_USE_AGC = (0x1 << 1), /*!< Use AGC */
-    ALGORITHM_STREAM_USE_NS  = (0x1 << 2), /*!< Use NS  */
-    ALGORITHM_STREAM_USE_VAD = (0x1 << 3)  /*!< Use VAD  */
-} algorithm_stream_mask_t;
-
-/**
- * @brief Algorithm stream configurations
- */
-typedef struct {
-    algorithm_stream_input_type_t input_type;   /*!< Input type of stream */
-    int task_stack;                             /*!< Task stack size */
-    int task_prio;                              /*!< Task peroid */
-    int task_core;                              /*!< The core that task to be created */
-    int out_rb_size;                            /*!< Size of output ringbuffer */
-    bool stack_in_ext;                          /*!< Try to allocate stack in external memory */
-    int rec_linear_factor;                      /*!< The linear amplication factor of record signal*/
-    int ref_linear_factor;                      /*!< The linear amplication factor of reference signal */
-    bool debug_input;                           /*!< debug algorithm input data */
-    bool swap_ch;                               /*!< Swap left and right channels */
-    int8_t algo_mask;                           /*!< Choose algorithm to use */
-    int sample_rate;                            /*!< The sampling rate of the input PCM (in Hz) */
-    int mic_ch;                                 /*!< MIC channel num */
-    int agc_gain;                               /*!< AGC gain(dB) for voice communication */
-    bool aec_low_cost;                          /*!< AEC uses less cpu and ram resources, but has poor suppression of nonlinear distortion */
-    char *partition_label;                      /*!< Partition label which stored the model data */
-} algorithm_stream_cfg_t;
-
-#define ALGORITHM_STREAM_DEFAULT_MASK    (ALGORITHM_STREAM_USE_AEC | ALGORITHM_STREAM_USE_NS)
-
-#define ALGORITHM_STREAM_CFG_DEFAULT() {                                                          \
-    .input_type = ALGORITHM_STREAM_INPUT_TYPE1,                                                   \
-    .task_stack = ALGORITHM_STREAM_TASK_STACK_SIZE,                                               \
-    .task_prio  = ALGORITHM_STREAM_TASK_PERIOD,                                                   \
-    .task_core  = ALGORITHM_STREAM_PINNED_TO_CORE,                                                \
-    .out_rb_size = ALGORITHM_STREAM_RINGBUFFER_SIZE,                                              \
-    .stack_in_ext = true,                                                                         \
-    .rec_linear_factor = 1,                                                                       \
-    .ref_linear_factor = 1,                                                                       \
-    .debug_input = false,                                                                         \
-    .swap_ch = false,                                                                             \
-    .algo_mask = ALGORITHM_STREAM_DEFAULT_MASK,                                                   \
-    .sample_rate = ALGORITHM_STREAM_DEFAULT_SAMPLE_RATE_HZ,                                       \
-    .mic_ch = ALGORITHM_STREAM_DEFAULT_MIC_CHANNELS,                                              \
-    .agc_gain = ALGORITHM_STREAM_DEFAULT_AGC_GAIN_DB,                                             \
-    .aec_low_cost = false,                                                                        \
-    .partition_label = "model",                                                                   \
-}
-
-/**
- * @brief      Initialize algorithm stream
- *
- * @param      config   The algorithm Stream configuration
- *
- * @return     The audio element handle
- */
-audio_element_handle_t algo_stream_init(algorithm_stream_cfg_t *config);
-
-/**
- * @brief      Set playback signal or recording signal delay when use type2
- *
- * @note       The AEC internal buffering mechanism requires that the recording signal
- *             is delayed by around 0 - 10 ms compared to the corresponding reference (playback) signal.
- *
- * @param      el           Handle of element
- * @param      ringbuf      Handle of ringbuf
- * @param      delay_ms     The delay between playback and recording in ms
- *                          This delay_ms can be debugged by yourself, you can set the configuration debug_input to true,
- *                          then get the original input data (left channel is the signal captured from the microphone,
- *                                                            right channel is the signal played to the speaker),
- *                          and check the delay with an audio analysis tool.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- *     - ESP_ERR_INVALID_ARG
- */
-audio_element_err_t algo_stream_set_delay(audio_element_handle_t el, ringbuf_handle_t ringbuf, int delay_ms);
-
-/**
- * @brief      Fix I2S mono noise issue
- *
- * @note       This API only for ESP32 with I2S 16bits
- *
- * @param      sbuff    I2S data buffer
- * @param      len      I2S data len
- *
- * @return     ESP_OK
- */
-esp_err_t algorithm_mono_fix(uint8_t *sbuff, uint32_t len);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ALGORITHM_STREAM_H_
+#define _ALGORITHM_STREAM_H_
+
+#include "audio_element.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ALGORITHM_STREAM_PINNED_TO_CORE     0
+#define ALGORITHM_STREAM_TASK_PERIOD        21
+#define ALGORITHM_STREAM_RINGBUFFER_SIZE    1024
+#define ALGORITHM_STREAM_TASK_STACK_SIZE    (5 * 1024)
+
+#define ALGORITHM_STREAM_DEFAULT_SAMPLE_RATE_HZ   8000
+#define ALGORITHM_STREAM_DEFAULT_SAMPLE_BIT       16
+#define ALGORITHM_STREAM_DEFAULT_MIC_CHANNELS     1
+#define ALGORITHM_STREAM_DEFAULT_AGC_GAIN_DB      5
+
+/*
+
+//  AEC: Acoustic Echo Cancellation
+//  AGC: Automatic Gain Control
+//  WWE: Wake Word Engine
+//  NS:  Noise Suppression
+
+
+                                                           +-----------+
+                                                           |           |
+                                                           |  TYPE 1   |
+                                                           |           |
+                    +--------------------------------------+-----------+----------------------------------------+
+                    |                                                                                           |
+                    |                   reference signal                                                        |
++-----------+       |  +-----------+    +-----------\      +-----------+    +-----------+    +-----------+      |
+|           |       |  |           |    |            \     |           |    |           |    |           |      |
+| I2S read  |-------|->| Resample  |--->| Data split  |--->|    AEC    |--->|    NS     |--->|    AGC    |      |
+|           |       |  |           |    |            /     |           |    |           |    |           |      |
++-----------+       |  +-----------+    +-----------/      +------------    +-----------+    +-----------+      |
+                    |                   record signal                                                           |
+                    |                                                                                           |
+                    +-------------------------------------------------------------------------------------------+
+
+                                                           +-----------+
+                                                           |           |
+                                                           |  TYPE 2   |
+                                                           |           |
+                    +--------------------------------------+-----------+----------------------------------------+
+                    |                                                                                           |
+                    |                                                                                           |
++-----------+       |  +-----------+    +-----------+    +-----------+    +-----------+    +-----------+        |
+|           |       |  |           |    |           |    |           |    |           |    |           |        |
+| I2S read  |-------|->| Resample  |--->| rec signal|--->|    AEC    |--->|    NS     |--->|    AGC    |        |
+|           |       |  |           |    |           |    |           |    |           |    |           |        |
++-----------+       |  +-----------+    +-----------+    +-----^-----+    +-----------+    +-----------+        |
+                    |                                          |                                                |
++-----------+       |  +-----------+    +-----------+          |                                                |
+|           |       |  |           |    |           |          |                                                |
+| input_rb  |-------|->| Resample  |--->| ref signal|----------+                                                |
+|           |       |  |           |    |           |                                                           |
++-----------+       |  +-----------+    +-----------+                                                           |
+                    |                                                                                           |
+                    +-------------------------------------------------------------------------------------------+
+
+*/
+
+/**
+ * @brief Two types of algorithm stream input method
+ */
+typedef enum {
+    ALGORITHM_STREAM_INPUT_TYPE1 = 0, /*!< Type 1 is default used by mini-board, the reference signal and the recording signal are respectively read in from the left channel and the right channel of the same I2S */
+    ALGORITHM_STREAM_INPUT_TYPE2 = 1, /*!< As the simple diagram above shows, when type2 is choosen, the recording signal and reference signal should be input by users. */
+} algorithm_stream_input_type_t;      /*!< The recording signal is inputted by I2S element by default, and the reference signal should be inputted to the algorithm element by using multiple input buffer. */
+                                      /*!< When use type2, you can combine arbitrarily the algorithm modules you want to use, use algo_mask parameters below to configure that. */
+
+/**
+ * @brief Choose the algorithm to be used
+ */
+typedef enum {
+    ALGORITHM_STREAM_USE_AEC = (0x1 << 0), /*!< Use AEC */
+    ALGORITHM_STREAM_USE_AGC = (0x1 << 1), /*!< Use AGC */
+    ALGORITHM_STREAM_USE_NS  = (0x1 << 2), /*!< Use NS  */
+    ALGORITHM_STREAM_USE_VAD = (0x1 << 3)  /*!< Use VAD  */
+} algorithm_stream_mask_t;
+
+/**
+ * @brief Algorithm stream configurations
+ */
+typedef struct {
+    algorithm_stream_input_type_t input_type;   /*!< Input type of stream */
+    int task_stack;                             /*!< Task stack size */
+    int task_prio;                              /*!< Task peroid */
+    int task_core;                              /*!< The core that task to be created */
+    int out_rb_size;                            /*!< Size of output ringbuffer */
+    bool stack_in_ext;                          /*!< Try to allocate stack in external memory */
+    int rec_linear_factor;                      /*!< The linear amplication factor of record signal*/
+    int ref_linear_factor;                      /*!< The linear amplication factor of reference signal */
+    bool debug_input;                           /*!< debug algorithm input data */
+    bool swap_ch;                               /*!< Swap left and right channels */
+    int8_t algo_mask;                           /*!< Choose algorithm to use */
+    int sample_rate;                            /*!< The sampling rate of the input PCM (in Hz) */
+    int mic_ch;                                 /*!< MIC channel num */
+    int agc_gain;                               /*!< AGC gain(dB) for voice communication */
+    bool aec_low_cost;                          /*!< AEC uses less cpu and ram resources, but has poor suppression of nonlinear distortion */
+    char *partition_label;                      /*!< Partition label which stored the model data */
+} algorithm_stream_cfg_t;
+
+#define ALGORITHM_STREAM_DEFAULT_MASK    (ALGORITHM_STREAM_USE_AEC | ALGORITHM_STREAM_USE_NS)
+
+#define ALGORITHM_STREAM_CFG_DEFAULT() {                                                          \
+    .input_type = ALGORITHM_STREAM_INPUT_TYPE1,                                                   \
+    .task_stack = ALGORITHM_STREAM_TASK_STACK_SIZE,                                               \
+    .task_prio  = ALGORITHM_STREAM_TASK_PERIOD,                                                   \
+    .task_core  = ALGORITHM_STREAM_PINNED_TO_CORE,                                                \
+    .out_rb_size = ALGORITHM_STREAM_RINGBUFFER_SIZE,                                              \
+    .stack_in_ext = true,                                                                         \
+    .rec_linear_factor = 1,                                                                       \
+    .ref_linear_factor = 1,                                                                       \
+    .debug_input = false,                                                                         \
+    .swap_ch = false,                                                                             \
+    .algo_mask = ALGORITHM_STREAM_DEFAULT_MASK,                                                   \
+    .sample_rate = ALGORITHM_STREAM_DEFAULT_SAMPLE_RATE_HZ,                                       \
+    .mic_ch = ALGORITHM_STREAM_DEFAULT_MIC_CHANNELS,                                              \
+    .agc_gain = ALGORITHM_STREAM_DEFAULT_AGC_GAIN_DB,                                             \
+    .aec_low_cost = false,                                                                        \
+    .partition_label = "model",                                                                   \
+}
+
+/**
+ * @brief      Initialize algorithm stream
+ *
+ * @param      config   The algorithm Stream configuration
+ *
+ * @return     The audio element handle
+ */
+audio_element_handle_t algo_stream_init(algorithm_stream_cfg_t *config);
+
+/**
+ * @brief      Set playback signal or recording signal delay when use type2
+ *
+ * @note       The AEC internal buffering mechanism requires that the recording signal
+ *             is delayed by around 0 - 10 ms compared to the corresponding reference (playback) signal.
+ *
+ * @param      el           Handle of element
+ * @param      ringbuf      Handle of ringbuf
+ * @param      delay_ms     The delay between playback and recording in ms
+ *                          This delay_ms can be debugged by yourself, you can set the configuration debug_input to true,
+ *                          then get the original input data (left channel is the signal captured from the microphone,
+ *                                                            right channel is the signal played to the speaker),
+ *                          and check the delay with an audio analysis tool.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ *     - ESP_ERR_INVALID_ARG
+ */
+audio_element_err_t algo_stream_set_delay(audio_element_handle_t el, ringbuf_handle_t ringbuf, int delay_ms);
+
+/**
+ * @brief      Fix I2S mono noise issue
+ *
+ * @note       This API only for ESP32 with I2S 16bits
+ *
+ * @param      sbuff    I2S data buffer
+ * @param      len      I2S data len
+ *
+ * @return     ESP_OK
+ */
+esp_err_t algorithm_mono_fix(uint8_t *sbuff, uint32_t len);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/components/audio_stream/include/embed_flash_stream.h b/components/audio_stream/include/embed_flash_stream.h
index 95c6da1c..93b4748e 100644
--- a/components/audio_stream/include/embed_flash_stream.h
+++ b/components/audio_stream/include/embed_flash_stream.h
@@ -1,101 +1,101 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __EMBED_FLASH_H__
-#define __EMBED_FLASH_H__
-
-#include "audio_element.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   Flash-embedding stream configurations, if any entry is zero then the configuration will be set to default values
- */
-typedef struct
-{
-    int buf_sz;               /*!< Audio Element Buffer size */
-    int out_rb_size;          /*!< Size of output ringbuffer */
-    int task_stack;           /*!< Task stack size */
-    int task_core;            /*!< Task running in core (0 or 1) */
-    int task_prio;            /*!< Task priority (based on freeRTOS priority) */
-    bool extern_stack;        /**< At present, task stack can only be placed on `SRAM`, so it should always be set to `false` */
-} embed_flash_stream_cfg_t;
-
-/**
- * @brief   Embed tone information in flash
- */
-typedef struct embed_item_info
-{
-    const uint8_t *address;   /*!< The corresponding address in flash */
-    int            size;      /*!< Size of corresponding data */
-} embed_item_info_t;
-
-#define EMBED_FLASH_STREAM_BUF_SIZE        (4096)
-#define EMBED_FLASH_STREAM_TASK_STACK      (3072)
-#define EMBED_FLASH_STREAM_TASK_CORE       (0)
-#define EMBED_FLASH_STREAM_TASK_PRIO       (4)
-#define EMBED_FLASH_STREAM_RINGBUFFER_SIZE (2 * 1024)
-#define EMBED_FLASH_STREAM_EXT_STACK       (false)
-
-#define EMBED_FLASH_STREAM_CFG_DEFAULT()               \
-{                                                      \
-    .buf_sz       = EMBED_FLASH_STREAM_BUF_SIZE,       \
-    .out_rb_size  = EMBED_FLASH_STREAM_RINGBUFFER_SIZE,\
-    .task_stack   = EMBED_FLASH_STREAM_TASK_STACK,     \
-    .task_core    = EMBED_FLASH_STREAM_TASK_CORE,      \
-    .task_prio    = EMBED_FLASH_STREAM_TASK_PRIO,      \
-    .extern_stack = EMBED_FLASH_STREAM_EXT_STACK,      \
-}
-
-/**
- * @brief      Create an Audio Element handle to stream data from flash to another Element, only support AUDIO_STREAM_READER type
- *
- * @param      config  The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t embed_flash_stream_init(embed_flash_stream_cfg_t *config);
-
-/**
- * @brief      Set the embed flash context
- *
- *             This function mainly provides information about embed flash data
- *
- * @param[in]  embed_stream         The embed flash element handle
- * @param[in]  context              The embed flash context
- * @param[in]  max_num              The number of embed flash context
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t  embed_flash_stream_set_context(audio_element_handle_t embed_stream, const embed_item_info_t *context, int max_num);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __EMBED_FLASH_H__
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __EMBED_FLASH_H__
+#define __EMBED_FLASH_H__
+
+#include "audio_element.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   Flash-embedding stream configurations, if any entry is zero then the configuration will be set to default values
+ */
+typedef struct
+{
+    int buf_sz;               /*!< Audio Element Buffer size */
+    int out_rb_size;          /*!< Size of output ringbuffer */
+    int task_stack;           /*!< Task stack size */
+    int task_core;            /*!< Task running in core (0 or 1) */
+    int task_prio;            /*!< Task priority (based on freeRTOS priority) */
+    bool extern_stack;        /**< At present, task stack can only be placed on `SRAM`, so it should always be set to `false` */
+} embed_flash_stream_cfg_t;
+
+/**
+ * @brief   Embed tone information in flash
+ */
+typedef struct embed_item_info
+{
+    const uint8_t *address;   /*!< The corresponding address in flash */
+    int            size;      /*!< Size of corresponding data */
+} embed_item_info_t;
+
+#define EMBED_FLASH_STREAM_BUF_SIZE        (4096)
+#define EMBED_FLASH_STREAM_TASK_STACK      (3072)
+#define EMBED_FLASH_STREAM_TASK_CORE       (0)
+#define EMBED_FLASH_STREAM_TASK_PRIO       (4)
+#define EMBED_FLASH_STREAM_RINGBUFFER_SIZE (2 * 1024)
+#define EMBED_FLASH_STREAM_EXT_STACK       (false)
+
+#define EMBED_FLASH_STREAM_CFG_DEFAULT()               \
+{                                                      \
+    .buf_sz       = EMBED_FLASH_STREAM_BUF_SIZE,       \
+    .out_rb_size  = EMBED_FLASH_STREAM_RINGBUFFER_SIZE,\
+    .task_stack   = EMBED_FLASH_STREAM_TASK_STACK,     \
+    .task_core    = EMBED_FLASH_STREAM_TASK_CORE,      \
+    .task_prio    = EMBED_FLASH_STREAM_TASK_PRIO,      \
+    .extern_stack = EMBED_FLASH_STREAM_EXT_STACK,      \
+}
+
+/**
+ * @brief      Create an Audio Element handle to stream data from flash to another Element, only support AUDIO_STREAM_READER type
+ *
+ * @param      config  The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t embed_flash_stream_init(embed_flash_stream_cfg_t *config);
+
+/**
+ * @brief      Set the embed flash context
+ *
+ *             This function mainly provides information about embed flash data
+ *
+ * @param[in]  embed_stream         The embed flash element handle
+ * @param[in]  context              The embed flash context
+ * @param[in]  max_num              The number of embed flash context
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t  embed_flash_stream_set_context(audio_element_handle_t embed_stream, const embed_item_info_t *context, int max_num);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __EMBED_FLASH_H__
diff --git a/components/audio_stream/include/fatfs_stream.h b/components/audio_stream/include/fatfs_stream.h
index ac5bcecc..ffa8e5a8 100644
--- a/components/audio_stream/include/fatfs_stream.h
+++ b/components/audio_stream/include/fatfs_stream.h
@@ -1,83 +1,83 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _FATFS_STREAM_H_
-#define _FATFS_STREAM_H_
-
-#include "audio_error.h"
-#include "audio_element.h"
-#include "audio_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   FATFS Stream configurations, if any entry is zero then the configuration will be set to default values
- */
-typedef struct {
-    audio_stream_type_t     type;           /*!< Stream type */
-    int                     buf_sz;         /*!< Audio Element Buffer size */
-    int                     out_rb_size;    /*!< Size of output ringbuffer */
-    int                     task_stack;     /*!< Task stack size */
-    int                     task_core;      /*!< Task running in core (0 or 1) */
-    int                     task_prio;      /*!< Task priority (based on freeRTOS priority) */
-    bool                    ext_stack;      /*!< Allocate stack on extern ram */
-    bool                    write_header;   /*!< Choose to write amrnb/amrwb header in fatfs whether or not (true or false, true means choose to write amrnb header) */
-} fatfs_stream_cfg_t;
-
-
-#define FATFS_STREAM_BUF_SIZE            (4096)
-#define FATFS_STREAM_TASK_STACK          (4096)
-#define FATFS_STREAM_TASK_CORE           (0)
-#define FATFS_STREAM_TASK_PRIO           (4)
-#define FATFS_STREAM_RINGBUFFER_SIZE     (8 * 1024)
-
-#define FATFS_STREAM_CFG_DEFAULT() {             \
-    .type = AUDIO_STREAM_NONE,                   \
-    .buf_sz = FATFS_STREAM_BUF_SIZE,             \
-    .out_rb_size = FATFS_STREAM_RINGBUFFER_SIZE, \
-    .task_stack = FATFS_STREAM_TASK_STACK,       \
-    .task_core = FATFS_STREAM_TASK_CORE,         \
-    .task_prio = FATFS_STREAM_TASK_PRIO,         \
-    .ext_stack = false,                          \
-    .write_header = true,                        \
-}
-
-/**
- * @brief      Create a handle to an Audio Element to stream data from FatFs to another Element
- *             or get data from other elements written to FatFs, depending on the configuration
- *             the stream type, either AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
- *
- * @param      config  The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t fatfs_stream_init(fatfs_stream_cfg_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _FATFS_STREAM_H_
+#define _FATFS_STREAM_H_
+
+#include "audio_error.h"
+#include "audio_element.h"
+#include "audio_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   FATFS Stream configurations, if any entry is zero then the configuration will be set to default values
+ */
+typedef struct {
+    audio_stream_type_t     type;           /*!< Stream type */
+    int                     buf_sz;         /*!< Audio Element Buffer size */
+    int                     out_rb_size;    /*!< Size of output ringbuffer */
+    int                     task_stack;     /*!< Task stack size */
+    int                     task_core;      /*!< Task running in core (0 or 1) */
+    int                     task_prio;      /*!< Task priority (based on freeRTOS priority) */
+    bool                    ext_stack;      /*!< Allocate stack on extern ram */
+    bool                    write_header;   /*!< Choose to write amrnb/amrwb header in fatfs whether or not (true or false, true means choose to write amrnb header) */
+} fatfs_stream_cfg_t;
+
+
+#define FATFS_STREAM_BUF_SIZE            (4096)
+#define FATFS_STREAM_TASK_STACK          (4096)
+#define FATFS_STREAM_TASK_CORE           (0)
+#define FATFS_STREAM_TASK_PRIO           (4)
+#define FATFS_STREAM_RINGBUFFER_SIZE     (8 * 1024)
+
+#define FATFS_STREAM_CFG_DEFAULT() {             \
+    .type = AUDIO_STREAM_NONE,                   \
+    .buf_sz = FATFS_STREAM_BUF_SIZE,             \
+    .out_rb_size = FATFS_STREAM_RINGBUFFER_SIZE, \
+    .task_stack = FATFS_STREAM_TASK_STACK,       \
+    .task_core = FATFS_STREAM_TASK_CORE,         \
+    .task_prio = FATFS_STREAM_TASK_PRIO,         \
+    .ext_stack = false,                          \
+    .write_header = true,                        \
+}
+
+/**
+ * @brief      Create a handle to an Audio Element to stream data from FatFs to another Element
+ *             or get data from other elements written to FatFs, depending on the configuration
+ *             the stream type, either AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
+ *
+ * @param      config  The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t fatfs_stream_init(fatfs_stream_cfg_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/http_stream.h b/components/audio_stream/include/http_stream.h
index b12d3d0a..afb0039f 100644
--- a/components/audio_stream/include/http_stream.h
+++ b/components/audio_stream/include/http_stream.h
@@ -1,177 +1,177 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _HTTP_STREAM_H_
-#define _HTTP_STREAM_H_
-
-#include "audio_error.h"
-#include "audio_element.h"
-#include "audio_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      HTTP Stream hook type
- */
-typedef enum {
-    HTTP_STREAM_PRE_REQUEST = 0x01, /*!< The event handler will be called before HTTP Client making the connection to the server */
-    HTTP_STREAM_ON_REQUEST,         /*!< The event handler will be called when HTTP Client is requesting data,
-                                     * If the fucntion return the value (-1: ESP_FAIL), HTTP Client will be stopped
-                                     * If the fucntion return the value > 0, HTTP Stream will ignore the post_field
-                                     * If the fucntion return the value = 0, HTTP Stream continue send data from post_field (if any)
-                                     */
-    HTTP_STREAM_ON_RESPONSE,        /*!< The event handler will be called when HTTP Client is receiving data
-                                     * If the fucntion return the value (-1: ESP_FAIL), HTTP Client will be stopped
-                                     * If the fucntion return the value > 0, HTTP Stream will ignore the read function
-                                     * If the fucntion return the value = 0, HTTP Stream continue read data from HTTP Server
-                                     */
-    HTTP_STREAM_POST_REQUEST,       /*!< The event handler will be called after HTTP Client send header and body to the server, before fetching the headers */
-    HTTP_STREAM_FINISH_REQUEST,     /*!< The event handler will be called after HTTP Client fetch the header and ready to read HTTP body */
-    HTTP_STREAM_RESOLVE_ALL_TRACKS,
-    HTTP_STREAM_FINISH_TRACK,
-    HTTP_STREAM_FINISH_PLAYLIST,
-} http_stream_event_id_t;
-
-/**
- * @brief      Stream event message
- */
-typedef struct {
-    http_stream_event_id_t  event_id;       /*!< Event ID */
-    void                    *http_client;   /*!< Reference to HTTP Client using by this HTTP Stream */
-    void                    *buffer;        /*!< Reference to Buffer using by the Audio Element */
-    int                     buffer_len;     /*!< Length of buffer */
-    void                    *user_data;     /*!< User data context, from `http_stream_cfg_t` */
-    audio_element_handle_t  el;             /*!< Audio element context */
-} http_stream_event_msg_t;
-
-typedef int (*http_stream_event_handle_t)(http_stream_event_msg_t *msg);
-
-/**
- * @brief      HTTP Stream configurations
- *             Default value will be used if any entry is zero
- */
-typedef struct {
-    audio_stream_type_t         type;                   /*!< Type of stream */
-    int                         out_rb_size;            /*!< Size of output ringbuffer */
-    int                         task_stack;             /*!< Task stack size */
-    int                         task_core;              /*!< Task running in core (0 or 1) */
-    int                         task_prio;              /*!< Task priority (based on freeRTOS priority) */
-    bool                        stack_in_ext;           /*!< Try to allocate stack in external memory */
-    http_stream_event_handle_t  event_handle;           /*!< The hook function for HTTP Stream */
-    void                        *user_data;             /*!< User data context */
-    bool                        auto_connect_next_track;/*!< connect next track without open/close */
-    bool                        enable_playlist_parser; /*!< Enable playlist parser*/
-    int                         multi_out_num;          /*!< The number of multiple output */
-    const char                  *cert_pem;              /*!< SSL server certification, PEM format as string, if the client requires to verify server */
-    esp_err_t (*crt_bundle_attach)(void *conf);         /*!< Function pointer to esp_crt_bundle_attach. Enables the use of certification
-                                                             bundle for server verification, must be enabled in menuconfig */
-    int                         request_size;           /*!< Request data size each time from `http_client`
-                                                             Defaults use DEFAULT_ELEMENT_BUFFER_LENGTH if set to 0
-                                                             Need care this setting if audio frame size is small and want low latency playback */                                                         
-    int                         request_range_size;     /*!< Range size setting for header `Range: bytes=start-end`
-                                                             Request full range of resource if set to 0
-                                                             Range size bigger than request size is recommended */
-    const char                  *user_agent;            /*!< The User Agent string to send with HTTP requests */
-} http_stream_cfg_t;
-
-#define HTTP_STREAM_TASK_STACK          (6 * 1024)
-#define HTTP_STREAM_TASK_CORE           (0)
-#define HTTP_STREAM_TASK_PRIO           (4)
-#define HTTP_STREAM_RINGBUFFER_SIZE     (20 * 1024)
-
-#define HTTP_STREAM_CFG_DEFAULT() {              \
-    .type = AUDIO_STREAM_READER,                 \
-    .out_rb_size = HTTP_STREAM_RINGBUFFER_SIZE,  \
-    .task_stack = HTTP_STREAM_TASK_STACK,        \
-    .task_core = HTTP_STREAM_TASK_CORE,          \
-    .task_prio = HTTP_STREAM_TASK_PRIO,          \
-    .stack_in_ext = true,                        \
-    .event_handle = NULL,                        \
-    .user_data = NULL,                           \
-    .auto_connect_next_track = false,            \
-    .enable_playlist_parser = false,             \
-    .multi_out_num = 0,                          \
-    .cert_pem  = NULL,                           \
-    .crt_bundle_attach = NULL,                   \
-    .user_agent = NULL,                          \
-}
-
-/**
- * @brief      Create a handle to an Audio Element to stream data from HTTP to another Element
- *             or get data from other elements sent to HTTP, depending on the configuration
- *             the stream type, either AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
- *
- * @param      config  The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t http_stream_init(http_stream_cfg_t *config);
-
-/**
- * @brief      Connect to next track in the playlist.
- *
- *             This function can be used in event_handler of http_stream.
- *             User can call this function to connect to next track in playlist when he/she gets `HTTP_STREAM_FINISH_TRACK` event
- *
- * @param      el  The http_stream element handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL on errors
- */
-esp_err_t http_stream_next_track(audio_element_handle_t el);
-esp_err_t http_stream_restart(audio_element_handle_t el);
-
-/**
- * @brief       Try to fetch the tracks again.
- *
- *              If this is live stream we will need to keep fetching URIs.
- *
- * @param       el  The http_stream element handle
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_ERR_NOT_SUPPORTED if playlist is finished
- */
-esp_err_t http_stream_fetch_again(audio_element_handle_t el);
-
-/**
- * @brief       Set SSL server certification
- * @note        EM format as string, if the client requires to verify server
- *
- * @param       el    The http_stream element handle
- * @param       cert  server certification
- *
- * @return
- *     - ESP_OK on success
- */
-esp_err_t http_stream_set_server_cert(audio_element_handle_t el, const char *cert);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _HTTP_STREAM_H_
+#define _HTTP_STREAM_H_
+
+#include "audio_error.h"
+#include "audio_element.h"
+#include "audio_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      HTTP Stream hook type
+ */
+typedef enum {
+    HTTP_STREAM_PRE_REQUEST = 0x01, /*!< The event handler will be called before HTTP Client making the connection to the server */
+    HTTP_STREAM_ON_REQUEST,         /*!< The event handler will be called when HTTP Client is requesting data,
+                                     * If the fucntion return the value (-1: ESP_FAIL), HTTP Client will be stopped
+                                     * If the fucntion return the value > 0, HTTP Stream will ignore the post_field
+                                     * If the fucntion return the value = 0, HTTP Stream continue send data from post_field (if any)
+                                     */
+    HTTP_STREAM_ON_RESPONSE,        /*!< The event handler will be called when HTTP Client is receiving data
+                                     * If the fucntion return the value (-1: ESP_FAIL), HTTP Client will be stopped
+                                     * If the fucntion return the value > 0, HTTP Stream will ignore the read function
+                                     * If the fucntion return the value = 0, HTTP Stream continue read data from HTTP Server
+                                     */
+    HTTP_STREAM_POST_REQUEST,       /*!< The event handler will be called after HTTP Client send header and body to the server, before fetching the headers */
+    HTTP_STREAM_FINISH_REQUEST,     /*!< The event handler will be called after HTTP Client fetch the header and ready to read HTTP body */
+    HTTP_STREAM_RESOLVE_ALL_TRACKS,
+    HTTP_STREAM_FINISH_TRACK,
+    HTTP_STREAM_FINISH_PLAYLIST,
+} http_stream_event_id_t;
+
+/**
+ * @brief      Stream event message
+ */
+typedef struct {
+    http_stream_event_id_t  event_id;       /*!< Event ID */
+    void                    *http_client;   /*!< Reference to HTTP Client using by this HTTP Stream */
+    void                    *buffer;        /*!< Reference to Buffer using by the Audio Element */
+    int                     buffer_len;     /*!< Length of buffer */
+    void                    *user_data;     /*!< User data context, from `http_stream_cfg_t` */
+    audio_element_handle_t  el;             /*!< Audio element context */
+} http_stream_event_msg_t;
+
+typedef int (*http_stream_event_handle_t)(http_stream_event_msg_t *msg);
+
+/**
+ * @brief      HTTP Stream configurations
+ *             Default value will be used if any entry is zero
+ */
+typedef struct {
+    audio_stream_type_t         type;                   /*!< Type of stream */
+    int                         out_rb_size;            /*!< Size of output ringbuffer */
+    int                         task_stack;             /*!< Task stack size */
+    int                         task_core;              /*!< Task running in core (0 or 1) */
+    int                         task_prio;              /*!< Task priority (based on freeRTOS priority) */
+    bool                        stack_in_ext;           /*!< Try to allocate stack in external memory */
+    http_stream_event_handle_t  event_handle;           /*!< The hook function for HTTP Stream */
+    void                        *user_data;             /*!< User data context */
+    bool                        auto_connect_next_track;/*!< connect next track without open/close */
+    bool                        enable_playlist_parser; /*!< Enable playlist parser*/
+    int                         multi_out_num;          /*!< The number of multiple output */
+    const char                  *cert_pem;              /*!< SSL server certification, PEM format as string, if the client requires to verify server */
+    esp_err_t (*crt_bundle_attach)(void *conf);         /*!< Function pointer to esp_crt_bundle_attach. Enables the use of certification
+                                                             bundle for server verification, must be enabled in menuconfig */
+    int                         request_size;           /*!< Request data size each time from `http_client`
+                                                             Defaults use DEFAULT_ELEMENT_BUFFER_LENGTH if set to 0
+                                                             Need care this setting if audio frame size is small and want low latency playback */                                                         
+    int                         request_range_size;     /*!< Range size setting for header `Range: bytes=start-end`
+                                                             Request full range of resource if set to 0
+                                                             Range size bigger than request size is recommended */
+    const char                  *user_agent;            /*!< The User Agent string to send with HTTP requests */
+} http_stream_cfg_t;
+
+#define HTTP_STREAM_TASK_STACK          (6 * 1024)
+#define HTTP_STREAM_TASK_CORE           (0)
+#define HTTP_STREAM_TASK_PRIO           (4)
+#define HTTP_STREAM_RINGBUFFER_SIZE     (20 * 1024)
+
+#define HTTP_STREAM_CFG_DEFAULT() {              \
+    .type = AUDIO_STREAM_READER,                 \
+    .out_rb_size = HTTP_STREAM_RINGBUFFER_SIZE,  \
+    .task_stack = HTTP_STREAM_TASK_STACK,        \
+    .task_core = HTTP_STREAM_TASK_CORE,          \
+    .task_prio = HTTP_STREAM_TASK_PRIO,          \
+    .stack_in_ext = true,                        \
+    .event_handle = NULL,                        \
+    .user_data = NULL,                           \
+    .auto_connect_next_track = false,            \
+    .enable_playlist_parser = false,             \
+    .multi_out_num = 0,                          \
+    .cert_pem  = NULL,                           \
+    .crt_bundle_attach = NULL,                   \
+    .user_agent = NULL,                          \
+}
+
+/**
+ * @brief      Create a handle to an Audio Element to stream data from HTTP to another Element
+ *             or get data from other elements sent to HTTP, depending on the configuration
+ *             the stream type, either AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
+ *
+ * @param      config  The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t http_stream_init(http_stream_cfg_t *config);
+
+/**
+ * @brief      Connect to next track in the playlist.
+ *
+ *             This function can be used in event_handler of http_stream.
+ *             User can call this function to connect to next track in playlist when he/she gets `HTTP_STREAM_FINISH_TRACK` event
+ *
+ * @param      el  The http_stream element handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL on errors
+ */
+esp_err_t http_stream_next_track(audio_element_handle_t el);
+esp_err_t http_stream_restart(audio_element_handle_t el);
+
+/**
+ * @brief       Try to fetch the tracks again.
+ *
+ *              If this is live stream we will need to keep fetching URIs.
+ *
+ * @param       el  The http_stream element handle
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_ERR_NOT_SUPPORTED if playlist is finished
+ */
+esp_err_t http_stream_fetch_again(audio_element_handle_t el);
+
+/**
+ * @brief       Set SSL server certification
+ * @note        EM format as string, if the client requires to verify server
+ *
+ * @param       el    The http_stream element handle
+ * @param       cert  server certification
+ *
+ * @return
+ *     - ESP_OK on success
+ */
+esp_err_t http_stream_set_server_cert(audio_element_handle_t el, const char *cert);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/i2s_stream.h b/components/audio_stream/include/i2s_stream.h
index b6536cba..f9f5c216 100644
--- a/components/audio_stream/include/i2s_stream.h
+++ b/components/audio_stream/include/i2s_stream.h
@@ -1,463 +1,463 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _I2S_STREAM_WRITER_H_
-#define _I2S_STREAM_WRITER_H_
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0) && ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 0, 0))
-#include "driver/i2s.h"
-#else
-#include "driver/i2s_pdm.h"
-#include "driver/i2s_tdm.h"
-#include "driver/i2s_std.h"
-#endif
-
-#include "audio_element.h"
-#include "audio_error.h"
-#include "audio_idf_version.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define I2S_STREAM_TASK_STACK           (3584)
-#define I2S_STREAM_BUF_SIZE             (3600)
-#define I2S_STREAM_TASK_PRIO            (23)
-#define I2S_STREAM_TASK_CORE            (0)
-#define I2S_STREAM_RINGBUFFER_SIZE      (8 * 1024)
-
-typedef enum {
-    I2S_CHANNEL_TYPE_RIGHT_LEFT,  /*!< Separated left and right channel */
-    I2S_CHANNEL_TYPE_ALL_RIGHT,   /*!< Load right channel data in both two channels */
-    I2S_CHANNEL_TYPE_ALL_LEFT,    /*!< Load left channel data in both two channels */
-    I2S_CHANNEL_TYPE_ONLY_RIGHT,  /*!< Only load data in right channel (mono mode) */
-    I2S_CHANNEL_TYPE_ONLY_LEFT,   /*!< Only load data in left channel (mono mode) */
-} i2s_channel_type_t;
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0) && ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 0, 0))
-
-/**
- * @brief      I2S Stream configurations
- *             Default value will be used if any entry is zero
- */
-typedef struct {
-    audio_stream_type_t   type;            /*!< Type of stream */
-    i2s_port_t            i2s_port;        /*!< I2S driver hardware port */
-    i2s_bits_per_sample_t expand_src_bits; /*!< The source bits per sample when data expand */
-    i2s_config_t          i2s_config;      /*!< I2S driver configurations */
-    bool                  use_alc;         /*!< It is a flag for ALC. If use ALC, the value is true. Or the value is false */
-    int                   volume;          /*!< The volume of audio input data will be set. */
-    int                   out_rb_size;     /*!< Size of output ringbuffer */
-    int                   task_stack;      /*!< Task stack size */
-    int                   task_core;       /*!< Task running in core (0 or 1) */
-    int                   task_prio;       /*!< Task priority (based on freeRTOS priority) */
-    bool                  stack_in_ext;    /*!< Try to allocate stack in external memory */
-    int                   multi_out_num;   /*!< The number of multiple output */
-    bool                  uninstall_drv;   /*!< whether uninstall the i2s driver when stream destroyed*/
-    bool                  need_expand;     /*!< whether to expand i2s data */
-    int                   buffer_len;      /*!< Buffer length use for an Element. Note: when 'bits_per_sample' is 24 bit, the buffer length must be a multiple of 3. The recommended value is 3600 */
-} i2s_stream_cfg_t;
-
-#define I2S_STREAM_CFG_DEFAULT() I2S_STREAM_CFG_DEFAULT_WITH_PARA(I2S_NUM_0, 44100, I2S_BITS_PER_SAMPLE_16BIT, AUDIO_STREAM_WRITER)
-
-#define I2S_STREAM_CFG_DEFAULT_WITH_PARA(port, rate, bits, stream_type)  {      \
-    .type = stream_type,                                                        \
-    .i2s_config = {                                                             \
-        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX),      \
-        .sample_rate = rate,                                                    \
-        .bits_per_sample = bits,                                                \
-        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,                           \
-        .communication_format = I2S_COMM_FORMAT_STAND_I2S,                      \
-        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2 | ESP_INTR_FLAG_IRAM,          \
-        .dma_buf_count = 3,                                                     \
-        .dma_buf_len = 300,                                                     \
-        .use_apll = true,                                                       \
-        .tx_desc_auto_clear = true,                                             \
-        .fixed_mclk = 0                                                         \
-    },                                                                          \
-    .i2s_port = port,                                                           \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = true,                                                      \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_BITS_PER_SAMPLE_16BIT,                               \
-    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
-}
-
-#define I2S_STREAM_INTERNAL_DAC_CFG_DEFAULT() {                                 \
-    .type = AUDIO_STREAM_WRITER,                                                \
-    .i2s_config = {                                                             \
-        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_DAC_BUILT_IN | I2S_MODE_TX),\
-        .sample_rate = 44100,                                                   \
-        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,                           \
-        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,                           \
-        .communication_format = I2S_COMM_FORMAT_STAND_MSB,                      \
-        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2,                               \
-        .dma_buf_count = 3,                                                     \
-        .dma_buf_len = 300,                                                     \
-        .use_apll = false,                                                      \
-        .tx_desc_auto_clear = true,                                             \
-        .fixed_mclk = 0                                                         \
-    },                                                                          \
-    .i2s_port = I2S_NUM_0,                                                      \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = false,                                                     \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_BITS_PER_SAMPLE_16BIT,                               \
-}
-
-#define I2S_STREAM_PDM_TX_CFG_DEFAULT() {                                       \
-    .type = AUDIO_STREAM_WRITER,                                                \
-    .i2s_config = {                                                             \
-        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_PDM | I2S_MODE_TX),     \
-        .sample_rate = 44100,                                                   \
-        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,                           \
-        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,                           \
-        .communication_format = I2S_COMM_FORMAT_STAND_MSB,                      \
-        .dma_buf_count = 3,                                                     \
-        .dma_buf_len = 300,                                                     \
-        .use_apll = true,                                                       \
-        .tx_desc_auto_clear = true,                                             \
-        .fixed_mclk = 0                                                         \
-    },                                                                          \
-    .i2s_port = I2S_NUM_0,                                                      \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = false,                                                     \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_BITS_PER_SAMPLE_16BIT,                               \
-}
-
-#else
-// ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)
-
-/**
- * @brief      I2S Stream configurations
- *             Default value will be used if any entry is zero
- */
-typedef struct {
-    audio_stream_type_t  type;                  /*!< Type of stream */
-    i2s_comm_mode_t      transmit_mode;         /*!< I2S transmit mode */
-    i2s_chan_config_t    chan_cfg;              /*!< I2S controller channel configuration */
-    i2s_std_config_t     std_cfg;               /*!< I2S standard mode major configuration that including clock/slot/gpio configuration  */
-#if SOC_I2S_SUPPORTS_PDM_RX
-    i2s_pdm_rx_config_t  pdm_rx_cfg;            /*!< I2S PDM RX mode major configuration that including clock/slot/gpio configuration  */
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-#if SOC_I2S_SUPPORTS_PDM_TX
-    i2s_pdm_tx_config_t  pdm_tx_cfg;            /*!< I2S PDM TX mode major configuration that including clock/slot/gpio configuration  */
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-#if SOC_I2S_SUPPORTS_TDM
-    i2s_tdm_config_t     tdm_cfg;               /*!< I2S TDM mode major configuration that including clock/slot/gpio configuration  */
-#endif // SOC_I2S_SUPPORTS_TDM
-    bool                 use_alc;               /*!< It is a flag for ALC. If use ALC, the value is true. Or the value is false */
-    int                  volume;                /*!< The volume of audio input data will be set. */
-    int                  out_rb_size;           /*!< Size of output ringbuffer */
-    int                  task_stack;            /*!< Task stack size */
-    int                  task_core;             /*!< Task running in core (0 or 1) */
-    int                  task_prio;             /*!< Task priority (based on freeRTOS priority) */
-    bool                 stack_in_ext;          /*!< Try to allocate stack in external memory */
-    int                  multi_out_num;         /*!< The number of multiple output */
-    bool                 uninstall_drv;         /*!< whether uninstall the i2s driver when stream destroyed*/
-    bool                 need_expand;           /*!< whether to expand i2s data */
-    i2s_data_bit_width_t expand_src_bits;       /*!< The source bits per sample when data expand */
-    int                  buffer_len;            /*!< Buffer length use for an Element. Note: when 'bits_per_sample' is 24 bit, the buffer length must be a multiple of 3. The recommended value is 3600 */
-} i2s_stream_cfg_t;
-
-#define I2S_STREAM_CFG_DEFAULT() I2S_STREAM_CFG_DEFAULT_WITH_PARA(I2S_NUM_0, 44100, I2S_DATA_BIT_WIDTH_16BIT, AUDIO_STREAM_WRITER)
-
-#define I2S_STREAM_CFG_DEFAULT_WITH_PARA(port, rate, bits, stream_type)  I2S_STREAM_CFG_DEFAULT_WITH_TYLE_AND_CH(port, rate, bits, stream_type, I2S_SLOT_MODE_STEREO)
-
-#if CONFIG_IDF_TARGET_ESP32
-#define I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits_per_sample, mono_or_stereo) { \
-    .data_bit_width = bits_per_sample,                                        \
-    .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,                                \
-    .slot_mode = mono_or_stereo,                                              \
-    .slot_mask = (mono_or_stereo == I2S_SLOT_MODE_MONO) ?                     \
-                I2S_STD_SLOT_LEFT : I2S_STD_SLOT_BOTH,                        \
-    .ws_width = bits_per_sample,                                              \
-    .ws_pol = false,                                                          \
-    .bit_shift = true,                                                        \
-    .msb_right = (bits_per_sample <= I2S_DATA_BIT_WIDTH_16BIT) ?              \
-                true : false,                                                 \
-}
-#elif CONFIG_IDF_TARGET_ESP32S2
-#define I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits_per_sample, mono_or_stereo) { \
-    .data_bit_width = bits_per_sample,                                        \
-    .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,                                \
-    .slot_mode = mono_or_stereo,                                              \
-    .slot_mask = (mono_or_stereo == I2S_SLOT_MODE_MONO) ?                     \
-                 I2S_STD_SLOT_LEFT : I2S_STD_SLOT_BOTH,                       \
-    .ws_width = bits_per_sample,                                              \
-    .ws_pol = false,                                                          \
-    .bit_shift = true,                                                        \
-    .msb_right = true,                                                        \
-}
-#else
-#define I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits_per_sample, mono_or_stereo) { \
-    .data_bit_width = bits_per_sample,                                         \
-    .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,                                 \
-    .slot_mode = mono_or_stereo,                                               \
-    .slot_mask = (mono_or_stereo == I2S_SLOT_MODE_MONO) ?                      \
-                 I2S_STD_SLOT_LEFT : I2S_STD_SLOT_BOTH,                        \
-    .ws_width = bits_per_sample,                                               \
-    .ws_pol = false,                                                           \
-    .bit_shift = true,                                                         \
-    .left_align = true,                                                        \
-    .big_endian = false,                                                       \
-    .bit_order_lsb = false                                                     \
-}
-#endif
-
-
-#define I2S_STREAM_CFG_DEFAULT_WITH_TYLE_AND_CH(port, rate, bits, stream_type, channel)  { \
-    .type = stream_type,                                                        \
-    .transmit_mode = I2S_COMM_MODE_STD,                                         \
-    .chan_cfg = {                                                               \
-        .id = port,                                                             \
-        .role = I2S_ROLE_MASTER,                                                \
-        .dma_desc_num = 3,                                                      \
-        .dma_frame_num = 312,                                                   \
-        .auto_clear = true,                                                     \
-    },                                                                          \
-    .std_cfg = {                                                                \
-        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(rate),                           \
-        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits, channel),     \
-        .gpio_cfg = {                                                           \
-            .invert_flags = {                                                   \
-                .mclk_inv = false,                                              \
-                .bclk_inv = false,                                              \
-            },                                                                  \
-        },                                                                      \
-    },                                                                          \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = true,                                                      \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
-    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
-}
-
-#if SOC_I2S_SUPPORTS_PDM_TX
-#define I2S_STREAM_PDM_TX_CFG_DEFAULT() {                                       \
-    .type = AUDIO_STREAM_WRITER,                                                \
-    .transmit_mode = I2S_COMM_MODE_PDM,                                         \
-    .chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER),         \
-    .pdm_tx_cfg = {                                                             \
-        .clk_cfg = I2S_PDM_TX_CLK_DEFAULT_CONFIG(16000),                        \
-        .slot_cfg = I2S_PDM_TX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),\
-        .gpio_cfg = {                                                           \
-            .invert_flags = {                                                   \
-                .clk_inv = false,                                               \
-            },                                                                  \
-        },                                                                      \
-    },                                                                          \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = true,                                                      \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
-    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
-}
-#endif // SOC_I2S_SUPPORTS_PDM_TX
-
-#if SOC_I2S_SUPPORTS_PDM_RX
-#define I2S_STREAM_PDM_RX_CFG_DEFAULT() {                                       \
-    .type = AUDIO_STREAM_READER,                                                \
-    .transmit_mode = I2S_COMM_MODE_PDM,                                         \
-    .chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER),         \
-    .pdm_rx_cfg = {                                                             \
-        .clk_cfg = I2S_PDM_RX_CLK_DEFAULT_CONFIG(16000),                        \
-        .slot_cfg = I2S_PDM_RX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),\
-        .gpio_cfg = {                                                           \
-            .invert_flags = {                                                   \
-                .clk_inv = false,                                               \
-            },                                                                  \
-        },                                                                      \
-    },                                                                          \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = true,                                                      \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
-    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
-}
-#endif // SOC_I2S_SUPPORTS_PDM_RX
-
-#if SOC_I2S_SUPPORTS_TDM
-#define I2S_STREAM_TDM_CFG_DEFAULT() {                                          \
-    .type = AUDIO_STREAM_READER,                                                \
-    .transmit_mode = I2S_COMM_MODE_TDM,                                         \
-    .chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER),         \
-    .tdm_cfg = {                                                                \
-        .clk_cfg  = I2S_TDM_CLK_DEFAULT_CONFIG(16000),                          \
-        .slot_cfg = I2S_TDM_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO,                  \
-                                                        I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3),  \
-        .gpio_cfg = {                                                           \
-            .invert_flags = {                                                   \
-                .mclk_inv = false,                                              \
-                .bclk_inv = false,                                              \
-                .ws_inv   = false,                                              \
-            },                                                                  \
-        },                                                                      \
-    },                                                                          \
-    .use_alc = false,                                                           \
-    .volume = 0,                                                                \
-    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
-    .task_stack = I2S_STREAM_TASK_STACK,                                        \
-    .task_core = I2S_STREAM_TASK_CORE,                                          \
-    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
-    .stack_in_ext = false,                                                      \
-    .multi_out_num = 0,                                                         \
-    .uninstall_drv = true,                                                      \
-    .need_expand = false,                                                       \
-    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
-    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
-}
-#endif // SOC_I2S_SUPPORTS_TDM
-
-#endif
-
-/**
- * @brief      Create a handle to an Audio Element to stream data from I2S to another Element
- *             or get data from other elements sent to I2S, depending on the configuration of stream type
- *             is AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
- * @note       If I2S stream is enabled with built-in DAC mode, please don't use I2S_NUM_1. The built-in
- *             DAC functions are only supported on I2S0 for the current ESP32 chip.
- * @param      config  The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t i2s_stream_init(i2s_stream_cfg_t *config);
-
-/**
- * @brief      Set I2S stream channel format type
- *
- * @note:  This function only updates i2s_stream_cfg_t, so it needs to be called before i2s_stream_init.
- *
- * @param[in]  config   The I2S stream configuration
- * @param[in]  type     I2S channel format type
- *
- * @return
- *     - ESP_OK
- *     - ESP_ERR_INVALID_ARG
- */
-esp_err_t i2s_stream_set_channel_type(i2s_stream_cfg_t *config, i2s_channel_type_t type);
-
-/**
- * @brief      Setup clock for I2S Stream, this function is only used with handle created by `i2s_stream_init`
- *
- * @param[in]  i2s_stream   The i2s element handle
- * @param[in]  rate  Clock rate (in Hz)
- * @param[in]  bits  Audio bit width (8, 16, 24, 32)
- * @param[in]  ch    Number of Audio channels (1: Mono, 2: Stereo).
- *                   But when set to tdm mode, ch is slot mask.(ex: I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t i2s_stream_set_clk(audio_element_handle_t i2s_stream, int rate, int bits, int ch);
-
-/**
- * @brief  Set the volume of input audio stream with ALC.
- *         Positive value indicates an increase in volume,
- *         negative value indicates a decrease in volume,
- *         0 indicates the volume level remains unchanged.
- *
- * @param[in]  i2s_stream  The i2s element handle
- * @param[in]  volume      The gain of input audio stream:
- *                         - Supported range [-64, 63], unit: dB
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t i2s_alc_volume_set(audio_element_handle_t i2s_stream, int volume);
-
-/**
- * @brief      Get volume of stream
- *
- * @param[in]  i2s_stream   The i2s element handle
- * @param[in]  volume       The volume of stream
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t i2s_alc_volume_get(audio_element_handle_t i2s_stream, int *volume);
-
-/**
- * @brief      Set sync delay of stream
- *
- * @param[in]  i2s_stream   The i2s element handle
- * @param[in]  delay_ms     The delay of stream
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t i2s_stream_sync_delay(audio_element_handle_t i2s_stream, int delay_ms);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _I2S_STREAM_WRITER_H_
+#define _I2S_STREAM_WRITER_H_
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0) && ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 0, 0))
+#include "driver/i2s.h"
+#else
+#include "driver/i2s_pdm.h"
+#include "driver/i2s_tdm.h"
+#include "driver/i2s_std.h"
+#endif
+
+#include "audio_element.h"
+#include "audio_error.h"
+#include "audio_idf_version.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define I2S_STREAM_TASK_STACK           (3584)
+#define I2S_STREAM_BUF_SIZE             (3600)
+#define I2S_STREAM_TASK_PRIO            (23)
+#define I2S_STREAM_TASK_CORE            (0)
+#define I2S_STREAM_RINGBUFFER_SIZE      (8 * 1024)
+
+typedef enum {
+    I2S_CHANNEL_TYPE_RIGHT_LEFT,  /*!< Separated left and right channel */
+    I2S_CHANNEL_TYPE_ALL_RIGHT,   /*!< Load right channel data in both two channels */
+    I2S_CHANNEL_TYPE_ALL_LEFT,    /*!< Load left channel data in both two channels */
+    I2S_CHANNEL_TYPE_ONLY_RIGHT,  /*!< Only load data in right channel (mono mode) */
+    I2S_CHANNEL_TYPE_ONLY_LEFT,   /*!< Only load data in left channel (mono mode) */
+} i2s_channel_type_t;
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0) && ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 0, 0))
+
+/**
+ * @brief      I2S Stream configurations
+ *             Default value will be used if any entry is zero
+ */
+typedef struct {
+    audio_stream_type_t   type;            /*!< Type of stream */
+    i2s_port_t            i2s_port;        /*!< I2S driver hardware port */
+    i2s_bits_per_sample_t expand_src_bits; /*!< The source bits per sample when data expand */
+    i2s_config_t          i2s_config;      /*!< I2S driver configurations */
+    bool                  use_alc;         /*!< It is a flag for ALC. If use ALC, the value is true. Or the value is false */
+    int                   volume;          /*!< The volume of audio input data will be set. */
+    int                   out_rb_size;     /*!< Size of output ringbuffer */
+    int                   task_stack;      /*!< Task stack size */
+    int                   task_core;       /*!< Task running in core (0 or 1) */
+    int                   task_prio;       /*!< Task priority (based on freeRTOS priority) */
+    bool                  stack_in_ext;    /*!< Try to allocate stack in external memory */
+    int                   multi_out_num;   /*!< The number of multiple output */
+    bool                  uninstall_drv;   /*!< whether uninstall the i2s driver when stream destroyed*/
+    bool                  need_expand;     /*!< whether to expand i2s data */
+    int                   buffer_len;      /*!< Buffer length use for an Element. Note: when 'bits_per_sample' is 24 bit, the buffer length must be a multiple of 3. The recommended value is 3600 */
+} i2s_stream_cfg_t;
+
+#define I2S_STREAM_CFG_DEFAULT() I2S_STREAM_CFG_DEFAULT_WITH_PARA(I2S_NUM_0, 44100, I2S_BITS_PER_SAMPLE_16BIT, AUDIO_STREAM_WRITER)
+
+#define I2S_STREAM_CFG_DEFAULT_WITH_PARA(port, rate, bits, stream_type)  {      \
+    .type = stream_type,                                                        \
+    .i2s_config = {                                                             \
+        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX),      \
+        .sample_rate = rate,                                                    \
+        .bits_per_sample = bits,                                                \
+        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,                           \
+        .communication_format = I2S_COMM_FORMAT_STAND_I2S,                      \
+        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2 | ESP_INTR_FLAG_IRAM,          \
+        .dma_buf_count = 3,                                                     \
+        .dma_buf_len = 300,                                                     \
+        .use_apll = true,                                                       \
+        .tx_desc_auto_clear = true,                                             \
+        .fixed_mclk = 0                                                         \
+    },                                                                          \
+    .i2s_port = port,                                                           \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = true,                                                      \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_BITS_PER_SAMPLE_16BIT,                               \
+    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
+}
+
+#define I2S_STREAM_INTERNAL_DAC_CFG_DEFAULT() {                                 \
+    .type = AUDIO_STREAM_WRITER,                                                \
+    .i2s_config = {                                                             \
+        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_DAC_BUILT_IN | I2S_MODE_TX),\
+        .sample_rate = 44100,                                                   \
+        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,                           \
+        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,                           \
+        .communication_format = I2S_COMM_FORMAT_STAND_MSB,                      \
+        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL2,                               \
+        .dma_buf_count = 3,                                                     \
+        .dma_buf_len = 300,                                                     \
+        .use_apll = false,                                                      \
+        .tx_desc_auto_clear = true,                                             \
+        .fixed_mclk = 0                                                         \
+    },                                                                          \
+    .i2s_port = I2S_NUM_0,                                                      \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = false,                                                     \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_BITS_PER_SAMPLE_16BIT,                               \
+}
+
+#define I2S_STREAM_PDM_TX_CFG_DEFAULT() {                                       \
+    .type = AUDIO_STREAM_WRITER,                                                \
+    .i2s_config = {                                                             \
+        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_PDM | I2S_MODE_TX),     \
+        .sample_rate = 44100,                                                   \
+        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,                           \
+        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,                           \
+        .communication_format = I2S_COMM_FORMAT_STAND_MSB,                      \
+        .dma_buf_count = 3,                                                     \
+        .dma_buf_len = 300,                                                     \
+        .use_apll = true,                                                       \
+        .tx_desc_auto_clear = true,                                             \
+        .fixed_mclk = 0                                                         \
+    },                                                                          \
+    .i2s_port = I2S_NUM_0,                                                      \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = false,                                                     \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_BITS_PER_SAMPLE_16BIT,                               \
+}
+
+#else
+// ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)
+
+/**
+ * @brief      I2S Stream configurations
+ *             Default value will be used if any entry is zero
+ */
+typedef struct {
+    audio_stream_type_t  type;                  /*!< Type of stream */
+    i2s_comm_mode_t      transmit_mode;         /*!< I2S transmit mode */
+    i2s_chan_config_t    chan_cfg;              /*!< I2S controller channel configuration */
+    i2s_std_config_t     std_cfg;               /*!< I2S standard mode major configuration that including clock/slot/gpio configuration  */
+#if SOC_I2S_SUPPORTS_PDM_RX
+    i2s_pdm_rx_config_t  pdm_rx_cfg;            /*!< I2S PDM RX mode major configuration that including clock/slot/gpio configuration  */
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+#if SOC_I2S_SUPPORTS_PDM_TX
+    i2s_pdm_tx_config_t  pdm_tx_cfg;            /*!< I2S PDM TX mode major configuration that including clock/slot/gpio configuration  */
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+#if SOC_I2S_SUPPORTS_TDM
+    i2s_tdm_config_t     tdm_cfg;               /*!< I2S TDM mode major configuration that including clock/slot/gpio configuration  */
+#endif // SOC_I2S_SUPPORTS_TDM
+    bool                 use_alc;               /*!< It is a flag for ALC. If use ALC, the value is true. Or the value is false */
+    int                  volume;                /*!< The volume of audio input data will be set. */
+    int                  out_rb_size;           /*!< Size of output ringbuffer */
+    int                  task_stack;            /*!< Task stack size */
+    int                  task_core;             /*!< Task running in core (0 or 1) */
+    int                  task_prio;             /*!< Task priority (based on freeRTOS priority) */
+    bool                 stack_in_ext;          /*!< Try to allocate stack in external memory */
+    int                  multi_out_num;         /*!< The number of multiple output */
+    bool                 uninstall_drv;         /*!< whether uninstall the i2s driver when stream destroyed*/
+    bool                 need_expand;           /*!< whether to expand i2s data */
+    i2s_data_bit_width_t expand_src_bits;       /*!< The source bits per sample when data expand */
+    int                  buffer_len;            /*!< Buffer length use for an Element. Note: when 'bits_per_sample' is 24 bit, the buffer length must be a multiple of 3. The recommended value is 3600 */
+} i2s_stream_cfg_t;
+
+#define I2S_STREAM_CFG_DEFAULT() I2S_STREAM_CFG_DEFAULT_WITH_PARA(I2S_NUM_0, 44100, I2S_DATA_BIT_WIDTH_16BIT, AUDIO_STREAM_WRITER)
+
+#define I2S_STREAM_CFG_DEFAULT_WITH_PARA(port, rate, bits, stream_type)  I2S_STREAM_CFG_DEFAULT_WITH_TYLE_AND_CH(port, rate, bits, stream_type, I2S_SLOT_MODE_STEREO)
+
+#if CONFIG_IDF_TARGET_ESP32
+#define I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits_per_sample, mono_or_stereo) { \
+    .data_bit_width = bits_per_sample,                                        \
+    .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,                                \
+    .slot_mode = mono_or_stereo,                                              \
+    .slot_mask = (mono_or_stereo == I2S_SLOT_MODE_MONO) ?                     \
+                I2S_STD_SLOT_LEFT : I2S_STD_SLOT_BOTH,                        \
+    .ws_width = bits_per_sample,                                              \
+    .ws_pol = false,                                                          \
+    .bit_shift = true,                                                        \
+    .msb_right = (bits_per_sample <= I2S_DATA_BIT_WIDTH_16BIT) ?              \
+                true : false,                                                 \
+}
+#elif CONFIG_IDF_TARGET_ESP32S2
+#define I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits_per_sample, mono_or_stereo) { \
+    .data_bit_width = bits_per_sample,                                        \
+    .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,                                \
+    .slot_mode = mono_or_stereo,                                              \
+    .slot_mask = (mono_or_stereo == I2S_SLOT_MODE_MONO) ?                     \
+                 I2S_STD_SLOT_LEFT : I2S_STD_SLOT_BOTH,                       \
+    .ws_width = bits_per_sample,                                              \
+    .ws_pol = false,                                                          \
+    .bit_shift = true,                                                        \
+    .msb_right = true,                                                        \
+}
+#else
+#define I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits_per_sample, mono_or_stereo) { \
+    .data_bit_width = bits_per_sample,                                         \
+    .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,                                 \
+    .slot_mode = mono_or_stereo,                                               \
+    .slot_mask = (mono_or_stereo == I2S_SLOT_MODE_MONO) ?                      \
+                 I2S_STD_SLOT_LEFT : I2S_STD_SLOT_BOTH,                        \
+    .ws_width = bits_per_sample,                                               \
+    .ws_pol = false,                                                           \
+    .bit_shift = true,                                                         \
+    .left_align = true,                                                        \
+    .big_endian = false,                                                       \
+    .bit_order_lsb = false                                                     \
+}
+#endif
+
+
+#define I2S_STREAM_CFG_DEFAULT_WITH_TYLE_AND_CH(port, rate, bits, stream_type, channel)  { \
+    .type = stream_type,                                                        \
+    .transmit_mode = I2S_COMM_MODE_STD,                                         \
+    .chan_cfg = {                                                               \
+        .id = port,                                                             \
+        .role = I2S_ROLE_MASTER,                                                \
+        .dma_desc_num = 3,                                                      \
+        .dma_frame_num = 312,                                                   \
+        .auto_clear = true,                                                     \
+    },                                                                          \
+    .std_cfg = {                                                                \
+        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(rate),                           \
+        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_ADF_CONFIG(bits, channel),     \
+        .gpio_cfg = {                                                           \
+            .invert_flags = {                                                   \
+                .mclk_inv = false,                                              \
+                .bclk_inv = false,                                              \
+            },                                                                  \
+        },                                                                      \
+    },                                                                          \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = true,                                                      \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
+    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
+}
+
+#if SOC_I2S_SUPPORTS_PDM_TX
+#define I2S_STREAM_PDM_TX_CFG_DEFAULT() {                                       \
+    .type = AUDIO_STREAM_WRITER,                                                \
+    .transmit_mode = I2S_COMM_MODE_PDM,                                         \
+    .chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER),         \
+    .pdm_tx_cfg = {                                                             \
+        .clk_cfg = I2S_PDM_TX_CLK_DEFAULT_CONFIG(16000),                        \
+        .slot_cfg = I2S_PDM_TX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),\
+        .gpio_cfg = {                                                           \
+            .invert_flags = {                                                   \
+                .clk_inv = false,                                               \
+            },                                                                  \
+        },                                                                      \
+    },                                                                          \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = true,                                                      \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
+    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
+}
+#endif // SOC_I2S_SUPPORTS_PDM_TX
+
+#if SOC_I2S_SUPPORTS_PDM_RX
+#define I2S_STREAM_PDM_RX_CFG_DEFAULT() {                                       \
+    .type = AUDIO_STREAM_READER,                                                \
+    .transmit_mode = I2S_COMM_MODE_PDM,                                         \
+    .chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER),         \
+    .pdm_rx_cfg = {                                                             \
+        .clk_cfg = I2S_PDM_RX_CLK_DEFAULT_CONFIG(16000),                        \
+        .slot_cfg = I2S_PDM_RX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),\
+        .gpio_cfg = {                                                           \
+            .invert_flags = {                                                   \
+                .clk_inv = false,                                               \
+            },                                                                  \
+        },                                                                      \
+    },                                                                          \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = true,                                                      \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
+    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
+}
+#endif // SOC_I2S_SUPPORTS_PDM_RX
+
+#if SOC_I2S_SUPPORTS_TDM
+#define I2S_STREAM_TDM_CFG_DEFAULT() {                                          \
+    .type = AUDIO_STREAM_READER,                                                \
+    .transmit_mode = I2S_COMM_MODE_TDM,                                         \
+    .chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER),         \
+    .tdm_cfg = {                                                                \
+        .clk_cfg  = I2S_TDM_CLK_DEFAULT_CONFIG(16000),                          \
+        .slot_cfg = I2S_TDM_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO,                  \
+                                                        I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3),  \
+        .gpio_cfg = {                                                           \
+            .invert_flags = {                                                   \
+                .mclk_inv = false,                                              \
+                .bclk_inv = false,                                              \
+                .ws_inv   = false,                                              \
+            },                                                                  \
+        },                                                                      \
+    },                                                                          \
+    .use_alc = false,                                                           \
+    .volume = 0,                                                                \
+    .out_rb_size = I2S_STREAM_RINGBUFFER_SIZE,                                  \
+    .task_stack = I2S_STREAM_TASK_STACK,                                        \
+    .task_core = I2S_STREAM_TASK_CORE,                                          \
+    .task_prio = I2S_STREAM_TASK_PRIO,                                          \
+    .stack_in_ext = false,                                                      \
+    .multi_out_num = 0,                                                         \
+    .uninstall_drv = true,                                                      \
+    .need_expand = false,                                                       \
+    .expand_src_bits = I2S_DATA_BIT_WIDTH_16BIT,                                \
+    .buffer_len = I2S_STREAM_BUF_SIZE,                                          \
+}
+#endif // SOC_I2S_SUPPORTS_TDM
+
+#endif
+
+/**
+ * @brief      Create a handle to an Audio Element to stream data from I2S to another Element
+ *             or get data from other elements sent to I2S, depending on the configuration of stream type
+ *             is AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
+ * @note       If I2S stream is enabled with built-in DAC mode, please don't use I2S_NUM_1. The built-in
+ *             DAC functions are only supported on I2S0 for the current ESP32 chip.
+ * @param      config  The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t i2s_stream_init(i2s_stream_cfg_t *config);
+
+/**
+ * @brief      Set I2S stream channel format type
+ *
+ * @note:  This function only updates i2s_stream_cfg_t, so it needs to be called before i2s_stream_init.
+ *
+ * @param[in]  config   The I2S stream configuration
+ * @param[in]  type     I2S channel format type
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_ERR_INVALID_ARG
+ */
+esp_err_t i2s_stream_set_channel_type(i2s_stream_cfg_t *config, i2s_channel_type_t type);
+
+/**
+ * @brief      Setup clock for I2S Stream, this function is only used with handle created by `i2s_stream_init`
+ *
+ * @param[in]  i2s_stream   The i2s element handle
+ * @param[in]  rate  Clock rate (in Hz)
+ * @param[in]  bits  Audio bit width (8, 16, 24, 32)
+ * @param[in]  ch    Number of Audio channels (1: Mono, 2: Stereo).
+ *                   But when set to tdm mode, ch is slot mask.(ex: I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t i2s_stream_set_clk(audio_element_handle_t i2s_stream, int rate, int bits, int ch);
+
+/**
+ * @brief  Set the volume of input audio stream with ALC.
+ *         Positive value indicates an increase in volume,
+ *         negative value indicates a decrease in volume,
+ *         0 indicates the volume level remains unchanged.
+ *
+ * @param[in]  i2s_stream  The i2s element handle
+ * @param[in]  volume      The gain of input audio stream:
+ *                         - Supported range [-64, 63], unit: dB
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t i2s_alc_volume_set(audio_element_handle_t i2s_stream, int volume);
+
+/**
+ * @brief      Get volume of stream
+ *
+ * @param[in]  i2s_stream   The i2s element handle
+ * @param[in]  volume       The volume of stream
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t i2s_alc_volume_get(audio_element_handle_t i2s_stream, int *volume);
+
+/**
+ * @brief      Set sync delay of stream
+ *
+ * @param[in]  i2s_stream   The i2s element handle
+ * @param[in]  delay_ms     The delay of stream
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t i2s_stream_sync_delay(audio_element_handle_t i2s_stream, int delay_ms);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/pwm_stream.h b/components/audio_stream/include/pwm_stream.h
old mode 100755
new mode 100644
index 62bc7606..e13e3915
--- a/components/audio_stream/include/pwm_stream.h
+++ b/components/audio_stream/include/pwm_stream.h
@@ -1,127 +1,127 @@
-/*
- *  * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PWM_STREAM_H_
-#define _PWM_STREAM_H_
-
-#include "driver/ledc.h"
-#include "driver/timer.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      PWM audio configurations
- *           
- */
-typedef struct
-{
-    timer_group_t       tg_num;               /*!< timer group number (0 - 1) */
-    timer_idx_t         timer_num;            /*!< timer number  (0 - 1) */
-    int                 gpio_num_left;        /*!< the LEDC output gpio_num, Left channel */
-    int                 gpio_num_right;       /*!< the LEDC output gpio_num, Right channel */
-    ledc_channel_t      ledc_channel_left;    /*!< LEDC channel (0 - 7), Corresponding to left channel*/
-    ledc_channel_t      ledc_channel_right;   /*!< LEDC channel (0 - 7), Corresponding to right channel*/
-    ledc_timer_t        ledc_timer_sel;       /*!< Select the timer source of channel (0 - 3) */
-    ledc_timer_bit_t    duty_resolution;      /*!< ledc pwm bits */
-    uint32_t            data_len;             /*!< ringbuffer size */
-
-} audio_pwm_config_t;
-
-/**
- * @brief      PWM Stream configurations
- *             Default value will be used if any entry is zero
- */
-typedef struct {
-    audio_stream_type_t     type;               /*!< Type of stream */
-    audio_pwm_config_t      pwm_config;         /*!<  driver configurations */
-    int                     out_rb_size;        /*!< Size of output ringbuffer */
-    int                     task_stack;         /*!< Task stack size */
-    int                     task_core;          /*!< Task running in core (0 or 1) */
-    int                     task_prio;          /*!< Task priority (based on freeRTOS priority) */
-    int                     buffer_len;         /*!< pwm_stream buffer length */
-    bool                    ext_stack;          /*!< Allocate stack on extern ram */
-} pwm_stream_cfg_t;
-
-#define PWM_STREAM_GPIO_NUM_LEFT  GPIO_NUM_18
-#define PWM_STREAM_GPIO_NUM_RIGHT GPIO_NUM_17
-
-#define PWM_STREAM_TASK_STACK           (3072+512)
-#define PWM_STREAM_BUF_SIZE             (2048)
-#define PWM_STREAM_TASK_PRIO            (23)
-#define PWM_STREAM_TASK_CORE            (0)
-#define PWM_STREAM_RINGBUFFER_SIZE      (0)
-#define PWM_CONFIG_RINGBUFFER_SIZE      (1024*8)
-
-#define PWM_STREAM_CFG_DEFAULT() {                    \
-    .type = AUDIO_STREAM_WRITER,                      \
-    .pwm_config = {                                   \
-        .tg_num = TIMER_GROUP_0,                      \
-        .timer_num = TIMER_0,                         \
-        .gpio_num_left = PWM_STREAM_GPIO_NUM_LEFT,    \
-        .gpio_num_right = PWM_STREAM_GPIO_NUM_RIGHT,  \
-        .ledc_channel_left = LEDC_CHANNEL_0,          \
-        .ledc_channel_right = LEDC_CHANNEL_1,         \
-        .ledc_timer_sel = LEDC_TIMER_0,               \
-        .duty_resolution = LEDC_TIMER_8_BIT,          \
-        .data_len = PWM_CONFIG_RINGBUFFER_SIZE,       \
-    },                                                \
-    .out_rb_size = PWM_STREAM_RINGBUFFER_SIZE,        \
-    .task_stack = PWM_STREAM_TASK_STACK,              \
-    .task_core = PWM_STREAM_TASK_CORE,                \
-    .task_prio = PWM_STREAM_TASK_PRIO,                \
-    .buffer_len =  PWM_STREAM_BUF_SIZE,               \
-    .ext_stack = false,                               \
-}
-
-/**
- * @brief      Initialize PWM stream
- *             Only support AUDIO_STREAM_READER type
- *
- * @param      config   The PWM Stream configuration
- *
- * @return     The audio element handle
- */
-audio_element_handle_t pwm_stream_init(pwm_stream_cfg_t *config);
-
-/**
- * @brief      Setup clock for PWM Stream, this function is only used with handle created by `pwm_stream_init`
- *
- * @param[in]  pwm_stream   The pwm element handle
- * @param[in]  rate  Clock rate (in Hz)
- * @param[in]  bits  Audio bit width (16, 32)
- * @param[in]  ch    Number of Audio channels (1: Mono, 2: Stereo)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t pwm_stream_set_clk(audio_element_handle_t pwm_stream, int rate, int bits, int ch);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ *  * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PWM_STREAM_H_
+#define _PWM_STREAM_H_
+
+#include "driver/ledc.h"
+#include "driver/timer.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      PWM audio configurations
+ *           
+ */
+typedef struct
+{
+    timer_group_t       tg_num;               /*!< timer group number (0 - 1) */
+    timer_idx_t         timer_num;            /*!< timer number  (0 - 1) */
+    int                 gpio_num_left;        /*!< the LEDC output gpio_num, Left channel */
+    int                 gpio_num_right;       /*!< the LEDC output gpio_num, Right channel */
+    ledc_channel_t      ledc_channel_left;    /*!< LEDC channel (0 - 7), Corresponding to left channel*/
+    ledc_channel_t      ledc_channel_right;   /*!< LEDC channel (0 - 7), Corresponding to right channel*/
+    ledc_timer_t        ledc_timer_sel;       /*!< Select the timer source of channel (0 - 3) */
+    ledc_timer_bit_t    duty_resolution;      /*!< ledc pwm bits */
+    uint32_t            data_len;             /*!< ringbuffer size */
+
+} audio_pwm_config_t;
+
+/**
+ * @brief      PWM Stream configurations
+ *             Default value will be used if any entry is zero
+ */
+typedef struct {
+    audio_stream_type_t     type;               /*!< Type of stream */
+    audio_pwm_config_t      pwm_config;         /*!<  driver configurations */
+    int                     out_rb_size;        /*!< Size of output ringbuffer */
+    int                     task_stack;         /*!< Task stack size */
+    int                     task_core;          /*!< Task running in core (0 or 1) */
+    int                     task_prio;          /*!< Task priority (based on freeRTOS priority) */
+    int                     buffer_len;         /*!< pwm_stream buffer length */
+    bool                    ext_stack;          /*!< Allocate stack on extern ram */
+} pwm_stream_cfg_t;
+
+#define PWM_STREAM_GPIO_NUM_LEFT  GPIO_NUM_18
+#define PWM_STREAM_GPIO_NUM_RIGHT GPIO_NUM_17
+
+#define PWM_STREAM_TASK_STACK           (3072+512)
+#define PWM_STREAM_BUF_SIZE             (2048)
+#define PWM_STREAM_TASK_PRIO            (23)
+#define PWM_STREAM_TASK_CORE            (0)
+#define PWM_STREAM_RINGBUFFER_SIZE      (0)
+#define PWM_CONFIG_RINGBUFFER_SIZE      (1024*8)
+
+#define PWM_STREAM_CFG_DEFAULT() {                    \
+    .type = AUDIO_STREAM_WRITER,                      \
+    .pwm_config = {                                   \
+        .tg_num = TIMER_GROUP_0,                      \
+        .timer_num = TIMER_0,                         \
+        .gpio_num_left = PWM_STREAM_GPIO_NUM_LEFT,    \
+        .gpio_num_right = PWM_STREAM_GPIO_NUM_RIGHT,  \
+        .ledc_channel_left = LEDC_CHANNEL_0,          \
+        .ledc_channel_right = LEDC_CHANNEL_1,         \
+        .ledc_timer_sel = LEDC_TIMER_0,               \
+        .duty_resolution = LEDC_TIMER_8_BIT,          \
+        .data_len = PWM_CONFIG_RINGBUFFER_SIZE,       \
+    },                                                \
+    .out_rb_size = PWM_STREAM_RINGBUFFER_SIZE,        \
+    .task_stack = PWM_STREAM_TASK_STACK,              \
+    .task_core = PWM_STREAM_TASK_CORE,                \
+    .task_prio = PWM_STREAM_TASK_PRIO,                \
+    .buffer_len =  PWM_STREAM_BUF_SIZE,               \
+    .ext_stack = false,                               \
+}
+
+/**
+ * @brief      Initialize PWM stream
+ *             Only support AUDIO_STREAM_READER type
+ *
+ * @param      config   The PWM Stream configuration
+ *
+ * @return     The audio element handle
+ */
+audio_element_handle_t pwm_stream_init(pwm_stream_cfg_t *config);
+
+/**
+ * @brief      Setup clock for PWM Stream, this function is only used with handle created by `pwm_stream_init`
+ *
+ * @param[in]  pwm_stream   The pwm element handle
+ * @param[in]  rate  Clock rate (in Hz)
+ * @param[in]  bits  Audio bit width (16, 32)
+ * @param[in]  ch    Number of Audio channels (1: Mono, 2: Stereo)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t pwm_stream_set_clk(audio_element_handle_t pwm_stream, int rate, int bits, int ch);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/raw_stream.h b/components/audio_stream/include/raw_stream.h
old mode 100755
new mode 100644
index 185c29f6..0d5f3028
--- a/components/audio_stream/include/raw_stream.h
+++ b/components/audio_stream/include/raw_stream.h
@@ -1,96 +1,96 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _RAW_STREAM_H_
-#define _RAW_STREAM_H_
-
-#include "audio_error.h"
-#include "audio_element.h"
-#include "audio_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/**
- * @brief Raw stream provides APIs to obtain the pipeline data without output stream or
- *        fill the pipeline data without input stream.
- *        The stream has two types / modes, reader and writer:
- *
- *        - AUDIO_STREAM_READER, e.g. [i2s]->[filter]->[raw],[i2s]->[codec-amr]->[raw]
- *        - AUDIO_STREAM_WRITER, e.g. [raw]->[codec-mp3]->[i2s]
- */
-
-/**
- * Raw Stream configurations
- */
-typedef struct {
-    audio_stream_type_t     type;               /*!< Type of stream */
-    int                     out_rb_size;        /*!< Size of output ringbuffer */
-} raw_stream_cfg_t;
-
-#define RAW_STREAM_RINGBUFFER_SIZE     (8 * 1024)
-
-#define RAW_STREAM_CFG_DEFAULT() {\
-    .type = AUDIO_STREAM_NONE, \
-    .out_rb_size = RAW_STREAM_RINGBUFFER_SIZE, \
-}
-
-/**
- * @brief      Initialize RAW stream
- *
- * @param      cfg   The RAW Stream configuration
- *
- * @return     The audio element handle
- */
-audio_element_handle_t raw_stream_init(raw_stream_cfg_t *cfg);
-
-/**
- * @brief      Read data from Stream
- *
- * @param      pipeline     The audio pipeline handle
- * @param      buffer       The buffer
- * @param      buf_size     Maximum number of bytes to be read.
- *
- * @return     Number of bytes actually read.
- */
-int raw_stream_read(audio_element_handle_t pipeline, char *buffer, int buf_size);
-
-/**
- * @brief      Write data to Stream
- *
- * @param      pipeline     The audio pipeline handle
- * @param      buffer       The buffer
- * @param      buf_size     Number of bytes to write
- *
- * @return     Number of bytes written
- */
-int raw_stream_write(audio_element_handle_t pipeline, char *buffer, int buf_size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _RAW_STREAM_H_
+#define _RAW_STREAM_H_
+
+#include "audio_error.h"
+#include "audio_element.h"
+#include "audio_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * @brief Raw stream provides APIs to obtain the pipeline data without output stream or
+ *        fill the pipeline data without input stream.
+ *        The stream has two types / modes, reader and writer:
+ *
+ *        - AUDIO_STREAM_READER, e.g. [i2s]->[filter]->[raw],[i2s]->[codec-amr]->[raw]
+ *        - AUDIO_STREAM_WRITER, e.g. [raw]->[codec-mp3]->[i2s]
+ */
+
+/**
+ * Raw Stream configurations
+ */
+typedef struct {
+    audio_stream_type_t     type;               /*!< Type of stream */
+    int                     out_rb_size;        /*!< Size of output ringbuffer */
+} raw_stream_cfg_t;
+
+#define RAW_STREAM_RINGBUFFER_SIZE     (8 * 1024)
+
+#define RAW_STREAM_CFG_DEFAULT() {\
+    .type = AUDIO_STREAM_NONE, \
+    .out_rb_size = RAW_STREAM_RINGBUFFER_SIZE, \
+}
+
+/**
+ * @brief      Initialize RAW stream
+ *
+ * @param      cfg   The RAW Stream configuration
+ *
+ * @return     The audio element handle
+ */
+audio_element_handle_t raw_stream_init(raw_stream_cfg_t *cfg);
+
+/**
+ * @brief      Read data from Stream
+ *
+ * @param      pipeline     The audio pipeline handle
+ * @param      buffer       The buffer
+ * @param      buf_size     Maximum number of bytes to be read.
+ *
+ * @return     Number of bytes actually read.
+ */
+int raw_stream_read(audio_element_handle_t pipeline, char *buffer, int buf_size);
+
+/**
+ * @brief      Write data to Stream
+ *
+ * @param      pipeline     The audio pipeline handle
+ * @param      buffer       The buffer
+ * @param      buf_size     Number of bytes to write
+ *
+ * @return     Number of bytes written
+ */
+int raw_stream_write(audio_element_handle_t pipeline, char *buffer, int buf_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/spiffs_stream.h b/components/audio_stream/include/spiffs_stream.h
index f2ccd619..92d73c73 100644
--- a/components/audio_stream/include/spiffs_stream.h
+++ b/components/audio_stream/include/spiffs_stream.h
@@ -1,80 +1,80 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _SPIFFS_STREAM_H_
-#define _SPIFFS_STREAM_H_
-
-#include "audio_error.h"
-#include "audio_element.h"
-#include "audio_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   SPIFFS Stream configuration, if any entry is zero then the configuration will be set to default values
- */
-typedef struct {
-    audio_stream_type_t     type;           /*!< Stream type */
-    int                     buf_sz;         /*!< Audio Element Buffer size */
-    int                     out_rb_size;    /*!< Size of output ringbuffer */
-    int                     task_stack;     /*!< Task stack size */
-    int                     task_core;      /*!< Task running in core (0 or 1) */
-    int                     task_prio;      /*!< Task priority (based on freeRTOS priority) */
-    bool                    write_header;   /*!< Choose to write amrnb/armwb header in spiffs whether or not (true or false, true means choose to write amrnb header) */
-} spiffs_stream_cfg_t;
-
-#define SPIFFS_STREAM_BUF_SIZE            (4096)
-#define SPIFFS_STREAM_TASK_STACK          (3072)
-#define SPIFFS_STREAM_TASK_CORE           (0)
-#define SPIFFS_STREAM_TASK_PRIO           (4)
-#define SPIFFS_STREAM_RINGBUFFER_SIZE     (8 * 1024)
-
-#define SPIFFS_STREAM_CFG_DEFAULT() {             \
-    .type = AUDIO_STREAM_NONE,                    \
-    .buf_sz = SPIFFS_STREAM_BUF_SIZE,             \
-    .out_rb_size = SPIFFS_STREAM_RINGBUFFER_SIZE, \
-    .task_stack = SPIFFS_STREAM_TASK_STACK,       \
-    .task_core = SPIFFS_STREAM_TASK_CORE,         \
-    .task_prio = SPIFFS_STREAM_TASK_PRIO,         \
-    .write_header = true,                         \
-}
-
-/**
- * @brief      Create a handle to an Audio Element to stream data from SPIFFS to another Element
- *             or get data from other elements written to SPIFFS, depending on the configuration
- *             the stream type, either AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
- *
- * @param      config The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t spiffs_stream_init(spiffs_stream_cfg_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _SPIFFS_STREAM_H_
+#define _SPIFFS_STREAM_H_
+
+#include "audio_error.h"
+#include "audio_element.h"
+#include "audio_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   SPIFFS Stream configuration, if any entry is zero then the configuration will be set to default values
+ */
+typedef struct {
+    audio_stream_type_t     type;           /*!< Stream type */
+    int                     buf_sz;         /*!< Audio Element Buffer size */
+    int                     out_rb_size;    /*!< Size of output ringbuffer */
+    int                     task_stack;     /*!< Task stack size */
+    int                     task_core;      /*!< Task running in core (0 or 1) */
+    int                     task_prio;      /*!< Task priority (based on freeRTOS priority) */
+    bool                    write_header;   /*!< Choose to write amrnb/armwb header in spiffs whether or not (true or false, true means choose to write amrnb header) */
+} spiffs_stream_cfg_t;
+
+#define SPIFFS_STREAM_BUF_SIZE            (4096)
+#define SPIFFS_STREAM_TASK_STACK          (3072)
+#define SPIFFS_STREAM_TASK_CORE           (0)
+#define SPIFFS_STREAM_TASK_PRIO           (4)
+#define SPIFFS_STREAM_RINGBUFFER_SIZE     (8 * 1024)
+
+#define SPIFFS_STREAM_CFG_DEFAULT() {             \
+    .type = AUDIO_STREAM_NONE,                    \
+    .buf_sz = SPIFFS_STREAM_BUF_SIZE,             \
+    .out_rb_size = SPIFFS_STREAM_RINGBUFFER_SIZE, \
+    .task_stack = SPIFFS_STREAM_TASK_STACK,       \
+    .task_core = SPIFFS_STREAM_TASK_CORE,         \
+    .task_prio = SPIFFS_STREAM_TASK_PRIO,         \
+    .write_header = true,                         \
+}
+
+/**
+ * @brief      Create a handle to an Audio Element to stream data from SPIFFS to another Element
+ *             or get data from other elements written to SPIFFS, depending on the configuration
+ *             the stream type, either AUDIO_STREAM_READER or AUDIO_STREAM_WRITER.
+ *
+ * @param      config The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t spiffs_stream_init(spiffs_stream_cfg_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/tcp_client_stream.h b/components/audio_stream/include/tcp_client_stream.h
index e46227b0..93176b4b 100644
--- a/components/audio_stream/include/tcp_client_stream.h
+++ b/components/audio_stream/include/tcp_client_stream.h
@@ -1,109 +1,109 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TCP_CLIENT_STREAM_H_
-#define _TCP_CLIENT_STREAM_H_
-
-#include "audio_error.h"
-#include "audio_element.h"
-#include "esp_transport.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum {
-    TCP_STREAM_STATE_NONE,
-    TCP_STREAM_STATE_CONNECTED,
-} tcp_stream_status_t;
-
-/**
- * @brief   TCP Stream massage configuration
- */
-typedef struct tcp_stream_event_msg {
-    void                          *source;          /*!< Element handle */
-    void                          *data;            /*!< Data of input/output */
-    int                           data_len;         /*!< Data length of input/output */
-    esp_transport_handle_t        sock_fd;          /*!< handle of socket*/
-} tcp_stream_event_msg_t;
-
-typedef esp_err_t (*tcp_stream_event_handle_cb)(tcp_stream_event_msg_t *msg, tcp_stream_status_t state, void *event_ctx);
-
-/**
- * @brief   TCP Stream configuration, if any entry is zero then the configuration will be set to default values
- */
-typedef struct {
-    audio_stream_type_t         type;               /*!< Type of stream */
-    int                         timeout_ms;         /*!< time timeout for read/write*/
-    int                         port;               /*!< TCP port> */
-    char                        *host;              /*!< TCP host> */
-    int                         task_stack;         /*!< Task stack size */
-    int                         task_core;          /*!< Task running in core (0 or 1) */
-    int                         task_prio;          /*!< Task priority (based on freeRTOS priority) */
-    bool                        ext_stack;          /*!< Allocate stack on extern ram */
-    tcp_stream_event_handle_cb  event_handler;      /*!< TCP stream event callback*/
-    void                        *event_ctx;         /*!< User context*/
-} tcp_stream_cfg_t;
-
-/**
-* @brief    TCP stream parameters
-*/
-#define TCP_STREAM_DEFAULT_PORT             (8080)
-
-#define TCP_STREAM_TASK_STACK               (3072)
-#define TCP_STREAM_BUF_SIZE                 (2048)
-#define TCP_STREAM_TASK_PRIO                (5)
-#define TCP_STREAM_TASK_CORE                (0)
-
-#define TCP_SERVER_DEFAULT_RESPONSE_LENGTH  (512)
-
-#define TCP_STREAM_CFG_DEFAULT() {              \
-    .type          = AUDIO_STREAM_READER,       \
-    .timeout_ms    = 30 *1000,                  \
-    .port          = TCP_STREAM_DEFAULT_PORT,   \
-    .host          = NULL,                      \
-    .task_stack    = TCP_STREAM_TASK_STACK,     \
-    .task_core     = TCP_STREAM_TASK_CORE,      \
-    .task_prio     = TCP_STREAM_TASK_PRIO,      \
-    .ext_stack     = true,                      \
-    .event_handler = NULL,                      \
-    .event_ctx     = NULL,                      \
-}
-
-/**
- * @brief       Initialize a TCP stream to/from an audio element 
- *              This function creates a TCP stream to/from an audio element depending on the stream type configuration (e.g., 
- *              AUDIO_STREAM_READER or AUDIO_STREAM_WRITER). The handle of the audio element is the returned.
- *
- * @param      config The configuration
- *
- * @return     The audio element handle
- */
-audio_element_handle_t tcp_stream_init(tcp_stream_cfg_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TCP_CLIENT_STREAM_H_
+#define _TCP_CLIENT_STREAM_H_
+
+#include "audio_error.h"
+#include "audio_element.h"
+#include "esp_transport.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    TCP_STREAM_STATE_NONE,
+    TCP_STREAM_STATE_CONNECTED,
+} tcp_stream_status_t;
+
+/**
+ * @brief   TCP Stream massage configuration
+ */
+typedef struct tcp_stream_event_msg {
+    void                          *source;          /*!< Element handle */
+    void                          *data;            /*!< Data of input/output */
+    int                           data_len;         /*!< Data length of input/output */
+    esp_transport_handle_t        sock_fd;          /*!< handle of socket*/
+} tcp_stream_event_msg_t;
+
+typedef esp_err_t (*tcp_stream_event_handle_cb)(tcp_stream_event_msg_t *msg, tcp_stream_status_t state, void *event_ctx);
+
+/**
+ * @brief   TCP Stream configuration, if any entry is zero then the configuration will be set to default values
+ */
+typedef struct {
+    audio_stream_type_t         type;               /*!< Type of stream */
+    int                         timeout_ms;         /*!< time timeout for read/write*/
+    int                         port;               /*!< TCP port> */
+    char                        *host;              /*!< TCP host> */
+    int                         task_stack;         /*!< Task stack size */
+    int                         task_core;          /*!< Task running in core (0 or 1) */
+    int                         task_prio;          /*!< Task priority (based on freeRTOS priority) */
+    bool                        ext_stack;          /*!< Allocate stack on extern ram */
+    tcp_stream_event_handle_cb  event_handler;      /*!< TCP stream event callback*/
+    void                        *event_ctx;         /*!< User context*/
+} tcp_stream_cfg_t;
+
+/**
+* @brief    TCP stream parameters
+*/
+#define TCP_STREAM_DEFAULT_PORT             (8080)
+
+#define TCP_STREAM_TASK_STACK               (3072)
+#define TCP_STREAM_BUF_SIZE                 (2048)
+#define TCP_STREAM_TASK_PRIO                (5)
+#define TCP_STREAM_TASK_CORE                (0)
+
+#define TCP_SERVER_DEFAULT_RESPONSE_LENGTH  (512)
+
+#define TCP_STREAM_CFG_DEFAULT() {              \
+    .type          = AUDIO_STREAM_READER,       \
+    .timeout_ms    = 30 *1000,                  \
+    .port          = TCP_STREAM_DEFAULT_PORT,   \
+    .host          = NULL,                      \
+    .task_stack    = TCP_STREAM_TASK_STACK,     \
+    .task_core     = TCP_STREAM_TASK_CORE,      \
+    .task_prio     = TCP_STREAM_TASK_PRIO,      \
+    .ext_stack     = true,                      \
+    .event_handler = NULL,                      \
+    .event_ctx     = NULL,                      \
+}
+
+/**
+ * @brief       Initialize a TCP stream to/from an audio element 
+ *              This function creates a TCP stream to/from an audio element depending on the stream type configuration (e.g., 
+ *              AUDIO_STREAM_READER or AUDIO_STREAM_WRITER). The handle of the audio element is the returned.
+ *
+ * @param      config The configuration
+ *
+ * @return     The audio element handle
+ */
+audio_element_handle_t tcp_stream_init(tcp_stream_cfg_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/include/tone_stream.h b/components/audio_stream/include/tone_stream.h
index e2e914ae..633fe186 100644
--- a/components/audio_stream/include/tone_stream.h
+++ b/components/audio_stream/include/tone_stream.h
@@ -1,85 +1,85 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TONE_STREAM_H_
-#define _TONE_STREAM_H_
-
-#include "audio_element.h"
-#include "esp_image_format.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   TONE Stream configurations, if any entry is zero then the configuration will be set to default values
- */
-typedef struct
-{
-    audio_stream_type_t type; /*!< Stream type */
-    int buf_sz;               /*!< Audio Element Buffer size */
-    int out_rb_size;          /*!< Size of output ringbuffer */
-    int task_stack;           /*!< Task stack size */
-    int task_core;            /*!< Task running in core (0 or 1) */
-    int task_prio;            /*!< Task priority (based on freeRTOS priority) */
-    const char *label;        /*!< Label of tone stored in flash. The default value is `flash_tone`*/
-    bool extern_stack;        /*!< Task stack allocate on the extern ram */
-    bool use_delegate;        /*!< Read tone partition with esp_delegate. If task stack is on extern ram, this MUST be TRUE */
-} tone_stream_cfg_t;
-
-#define TONE_STREAM_BUF_SIZE        (4096)
-#define TONE_STREAM_TASK_STACK      (3072)
-#define TONE_STREAM_TASK_CORE       (0)
-#define TONE_STREAM_TASK_PRIO       (4)
-#define TONE_STREAM_RINGBUFFER_SIZE (2 * 1024)
-#define TONE_STREAM_EXT_STACK       (false)
-#define TONE_STREAM_USE_DELEGATE    (false)
-
-#define TONE_STREAM_CFG_DEFAULT()               \
-{                                               \
-    .type         = AUDIO_STREAM_NONE,          \
-    .buf_sz       = TONE_STREAM_BUF_SIZE,       \
-    .out_rb_size  = TONE_STREAM_RINGBUFFER_SIZE,\
-    .task_stack   = TONE_STREAM_TASK_STACK,     \
-    .task_core    = TONE_STREAM_TASK_CORE,      \
-    .task_prio    = TONE_STREAM_TASK_PRIO,      \
-    .label        = "flash_tone",               \
-    .extern_stack = TONE_STREAM_EXT_STACK,      \
-    .use_delegate = TONE_STREAM_USE_DELEGATE,   \
-}
-
-/**
- * @brief      Create an Audio Element handle to stream data from flash to another Element, only support AUDIO_STREAM_READER type
- *
- * @param      config  The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t tone_stream_init(tone_stream_cfg_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TONE_STREAM_H_
+#define _TONE_STREAM_H_
+
+#include "audio_element.h"
+#include "esp_image_format.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   TONE Stream configurations, if any entry is zero then the configuration will be set to default values
+ */
+typedef struct
+{
+    audio_stream_type_t type; /*!< Stream type */
+    int buf_sz;               /*!< Audio Element Buffer size */
+    int out_rb_size;          /*!< Size of output ringbuffer */
+    int task_stack;           /*!< Task stack size */
+    int task_core;            /*!< Task running in core (0 or 1) */
+    int task_prio;            /*!< Task priority (based on freeRTOS priority) */
+    const char *label;        /*!< Label of tone stored in flash. The default value is `flash_tone`*/
+    bool extern_stack;        /*!< Task stack allocate on the extern ram */
+    bool use_delegate;        /*!< Read tone partition with esp_delegate. If task stack is on extern ram, this MUST be TRUE */
+} tone_stream_cfg_t;
+
+#define TONE_STREAM_BUF_SIZE        (4096)
+#define TONE_STREAM_TASK_STACK      (3072)
+#define TONE_STREAM_TASK_CORE       (0)
+#define TONE_STREAM_TASK_PRIO       (4)
+#define TONE_STREAM_RINGBUFFER_SIZE (2 * 1024)
+#define TONE_STREAM_EXT_STACK       (false)
+#define TONE_STREAM_USE_DELEGATE    (false)
+
+#define TONE_STREAM_CFG_DEFAULT()               \
+{                                               \
+    .type         = AUDIO_STREAM_NONE,          \
+    .buf_sz       = TONE_STREAM_BUF_SIZE,       \
+    .out_rb_size  = TONE_STREAM_RINGBUFFER_SIZE,\
+    .task_stack   = TONE_STREAM_TASK_STACK,     \
+    .task_core    = TONE_STREAM_TASK_CORE,      \
+    .task_prio    = TONE_STREAM_TASK_PRIO,      \
+    .label        = "flash_tone",               \
+    .extern_stack = TONE_STREAM_EXT_STACK,      \
+    .use_delegate = TONE_STREAM_USE_DELEGATE,   \
+}
+
+/**
+ * @brief      Create an Audio Element handle to stream data from flash to another Element, only support AUDIO_STREAM_READER type
+ *
+ * @param      config  The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t tone_stream_init(tone_stream_cfg_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif
\ No newline at end of file
diff --git a/components/audio_stream/include/tts_stream.h b/components/audio_stream/include/tts_stream.h
index afee4989..9d4d7861 100644
--- a/components/audio_stream/include/tts_stream.h
+++ b/components/audio_stream/include/tts_stream.h
@@ -1,125 +1,125 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TTS_STREAM_H_
-#define _TTS_STREAM_H_
-
-#include "audio_error.h"
-#include "audio_element.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* The speech speed speed of synthesized speech */
-typedef enum {
-    TTS_VOICE_SPEED_0,          /* the slowest speed */
-    TTS_VOICE_SPEED_1,
-    TTS_VOICE_SPEED_2,
-    TTS_VOICE_SPEED_3,
-    TTS_VOICE_SPEED_4,
-    TTS_VOICE_SPEED_5,          /* the fastest speech */
-    TTS_VOICE_SPEED_MAX,
-} tts_voice_speed_t;
-
-/**
- * @brief   TTS Stream configurations, if any entry is zero then the configuration will be set to default values
- */
-typedef struct {
-    audio_stream_type_t     type;               /*!< Stream type */
-    int                     buf_sz;             /*!< Audio Element Buffer size */
-    int                     out_rb_size;        /*!< Size of output ringbuffer */
-    int                     task_stack;         /*!< Task stack size */
-    int                     task_core;          /*!< Task running in core (0 or 1) */
-    int                     task_prio;          /*!< Task priority (based on freeRTOS priority) */
-    bool                    ext_stack;          /*!< Allocate stack on extern ram */
-} tts_stream_cfg_t;
-
-#define TTS_STREAM_BUF_SIZE             (4096)
-#define TTS_STREAM_TASK_STACK           (3072)
-#define TTS_STREAM_TASK_CORE            (0)
-#define TTS_STREAM_TASK_PRIO            (4)
-#define TTS_STREAM_RINGBUFFER_SIZE      (8 * 1024)
-
-#define TTS_STREAM_CFG_DEFAULT() {                  \
-    .type = AUDIO_STREAM_READER,                    \
-    .buf_sz = TTS_STREAM_BUF_SIZE,                  \
-    .out_rb_size = TTS_STREAM_RINGBUFFER_SIZE,      \
-    .task_stack = TTS_STREAM_TASK_STACK,            \
-    .task_core = TTS_STREAM_TASK_CORE,              \
-    .task_prio = TTS_STREAM_TASK_PRIO,              \
-    .ext_stack = false,                             \
-}
-
-/**
- * @brief      Create a handle to an Audio Element to stream data from TTS to another Element,
- *             the stream type only support AUDIO_STREAM_READER for now.
- *
- * @param      config  The configuration
- *
- * @return     The Audio Element handle
- */
-audio_element_handle_t tts_stream_init(tts_stream_cfg_t *config);
-
-/**
- * @brief      Set tts stream strings.
- *
- * @param[in]  el       The audio element handle
- * @param[in]  strings   The string pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tts_stream_set_strings(audio_element_handle_t el, const char *strings);
-
-/**
- * @brief Setting tts stream voice speed.
- *
- * @param[in] el       The esp_audio instance
- * @param[in] speed    Speed will be set. 0-5 is legal. 0 is the slowest speed.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tts_stream_set_speed(audio_element_handle_t el, tts_voice_speed_t speed);
-
-/**
- * @brief Get tts stream voice speed.
- *
- * @param[in] el        The esp_audio instance
- * @param[in] speed     Return tts stream Speed will be [0,5]
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tts_stream_get_speed(audio_element_handle_t el, tts_voice_speed_t *speed);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TTS_STREAM_H_
+#define _TTS_STREAM_H_
+
+#include "audio_error.h"
+#include "audio_element.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The speech speed speed of synthesized speech */
+typedef enum {
+    TTS_VOICE_SPEED_0,          /* the slowest speed */
+    TTS_VOICE_SPEED_1,
+    TTS_VOICE_SPEED_2,
+    TTS_VOICE_SPEED_3,
+    TTS_VOICE_SPEED_4,
+    TTS_VOICE_SPEED_5,          /* the fastest speech */
+    TTS_VOICE_SPEED_MAX,
+} tts_voice_speed_t;
+
+/**
+ * @brief   TTS Stream configurations, if any entry is zero then the configuration will be set to default values
+ */
+typedef struct {
+    audio_stream_type_t     type;               /*!< Stream type */
+    int                     buf_sz;             /*!< Audio Element Buffer size */
+    int                     out_rb_size;        /*!< Size of output ringbuffer */
+    int                     task_stack;         /*!< Task stack size */
+    int                     task_core;          /*!< Task running in core (0 or 1) */
+    int                     task_prio;          /*!< Task priority (based on freeRTOS priority) */
+    bool                    ext_stack;          /*!< Allocate stack on extern ram */
+} tts_stream_cfg_t;
+
+#define TTS_STREAM_BUF_SIZE             (4096)
+#define TTS_STREAM_TASK_STACK           (3072)
+#define TTS_STREAM_TASK_CORE            (0)
+#define TTS_STREAM_TASK_PRIO            (4)
+#define TTS_STREAM_RINGBUFFER_SIZE      (8 * 1024)
+
+#define TTS_STREAM_CFG_DEFAULT() {                  \
+    .type = AUDIO_STREAM_READER,                    \
+    .buf_sz = TTS_STREAM_BUF_SIZE,                  \
+    .out_rb_size = TTS_STREAM_RINGBUFFER_SIZE,      \
+    .task_stack = TTS_STREAM_TASK_STACK,            \
+    .task_core = TTS_STREAM_TASK_CORE,              \
+    .task_prio = TTS_STREAM_TASK_PRIO,              \
+    .ext_stack = false,                             \
+}
+
+/**
+ * @brief      Create a handle to an Audio Element to stream data from TTS to another Element,
+ *             the stream type only support AUDIO_STREAM_READER for now.
+ *
+ * @param      config  The configuration
+ *
+ * @return     The Audio Element handle
+ */
+audio_element_handle_t tts_stream_init(tts_stream_cfg_t *config);
+
+/**
+ * @brief      Set tts stream strings.
+ *
+ * @param[in]  el       The audio element handle
+ * @param[in]  strings   The string pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tts_stream_set_strings(audio_element_handle_t el, const char *strings);
+
+/**
+ * @brief Setting tts stream voice speed.
+ *
+ * @param[in] el       The esp_audio instance
+ * @param[in] speed    Speed will be set. 0-5 is legal. 0 is the slowest speed.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tts_stream_set_speed(audio_element_handle_t el, tts_voice_speed_t speed);
+
+/**
+ * @brief Get tts stream voice speed.
+ *
+ * @param[in] el        The esp_audio instance
+ * @param[in] speed     Return tts stream Speed will be [0,5]
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tts_stream_get_speed(audio_element_handle_t el, tts_voice_speed_t *speed);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/lib/gzip/gzip_miniz.c b/components/audio_stream/lib/gzip/gzip_miniz.c
index 76e07013..20dee88a 100644
--- a/components/audio_stream/lib/gzip/gzip_miniz.c
+++ b/components/audio_stream/lib/gzip/gzip_miniz.c
@@ -1,327 +1,327 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdbool.h>
-#include "esp_log.h"
-#include "gzip_miniz.h"
-#include "miniz_inflate.h"
-
-#define TAG              "GZIP_MINIZ"
-#define GZIP_HEADER_SIZE (10)
-
-typedef struct {
-    gzip_miniz_cfg_t cfg;
-    uint8_t         *chunk_ptr;
-    int              chunk_filled;
-    int              chunk_consumed;
-    bool             unzip_error;
-    bool             first_data;
-    bool             final_data;
-    int              head_flag;
-    int              extra_len;
-    int              head_filled;
-    mz_stream        s;
-} gzip_miniz_t;
-
-static bool verify_gzip_header(gzip_miniz_t *zip, uint8_t *data, int size)
-{
-    if (size < GZIP_HEADER_SIZE) {
-        return false;
-    }
-    if (data[0] != 0x1F || data[1] != 0x8B || data[2] != 0x8) {
-        return false;
-    }
-    zip->head_flag = data[3];
-    return true;
-}
-
-static int gzip_miniz_skip_head(gzip_miniz_t *zip, uint8_t *data, int size)
-{
-    if (zip->head_flag == 0) {
-        return 0;
-    }
-    int org_size = size;
-    if (zip->head_flag & 4) {
-        // 2 bytes extra len
-        if (zip->head_filled > 2) {
-            return -1;
-        }
-        if (zip->head_filled + size >= 2) {
-            int used = 2 - zip->head_filled;
-            if (used) {
-                size -= used;
-                while (used--) {
-                    zip->extra_len = zip->extra_len + (*data << (zip->head_filled * 8));
-                    zip->head_filled++;
-                    data++;
-                }
-            }
-            if (size >= zip->extra_len) {
-                size -= zip->extra_len;
-                data += zip->extra_len;
-                zip->extra_len = 0;
-                zip->head_flag &= ~4;
-                zip->head_filled = 0;
-            } else {
-                zip->extra_len -= size;
-                return org_size;
-            }
-        } else {
-            for (int i = 0; i < size; i++) {
-                zip->extra_len = zip->extra_len + (*data << (zip->head_filled * 8));
-                zip->head_filled++;
-                data++;
-            }
-            zip->head_filled += size;
-            return org_size;
-        }
-    }
-    if (zip->head_flag & 8) {
-        // name
-        while (size) {
-            size--;
-            data++;
-            if (*(data - 1) == '\0') {
-                zip->head_flag &= ~8;
-                break;
-            }
-        }
-        if (size == 0) {
-            return org_size;
-        }
-    }
-    if (zip->head_flag & 0x10) {
-        // comment
-        while (size) {
-            size--;
-            data++;
-            if (*(data - 1) == '\0') {
-                zip->head_flag &= ~0x10;
-                break;
-            }
-        }
-        if (size == 0) {
-            return org_size;
-        }
-    }
-    if (zip->head_flag & 0x2) {
-        // CRC16
-        if (zip->head_filled > 2) {
-            return -1;
-        }
-        if (zip->head_filled + size >= 2) {
-            int used = 2 - zip->head_filled;
-            size -= used;
-            data += used;
-            zip->head_flag &= ~0x2;
-        } else {
-            zip->head_filled += size;
-            return org_size;
-        }
-    }
-    return org_size - size;
-}
-
-gzip_miniz_handle_t gzip_miniz_init(gzip_miniz_cfg_t *cfg)
-{
-    if (cfg->read_cb == NULL) {
-        ESP_LOGE(TAG, "Read callback must be provided");
-        return NULL;
-    }
-    gzip_miniz_t *zip = (gzip_miniz_t *) calloc(1, sizeof(gzip_miniz_t));
-    if (zip == NULL) {
-        ESP_LOGE(TAG, "No memory for instance");
-        return NULL;
-    }
-    zip->cfg = *cfg;
-    int chunk_size = cfg->chunk_size ? cfg->chunk_size : 32;
-    zip->chunk_ptr = (uint8_t *) malloc(chunk_size);
-    if (zip->chunk_ptr == NULL) {
-        free(zip);
-        ESP_LOGE(TAG, "No memory for chunk");
-        return NULL;
-    }
-    zip->cfg.chunk_size = chunk_size;
-    zip->first_data = true;
-    mz_inflateInit2(&zip->s, -MZ_DEFAULT_WINDOW_BITS);
-    return (gzip_miniz_handle_t)zip;
-}
-
-int gzip_miniz_read(gzip_miniz_handle_t h, uint8_t *out, int out_size)
-{
-    gzip_miniz_t *zip = (gzip_miniz_t *) h;
-    if (zip == NULL) {
-        return -1;
-    }
-    if (zip->unzip_error) {
-        return -2;
-    }
-    if (zip->final_data) {
-        return 0;
-    }
-    int size = 0;
-    if (zip->first_data == true) {
-        zip->first_data = false;
-        int size = zip->cfg.read_cb(zip->chunk_ptr, zip->cfg.chunk_size, zip->cfg.ctx);
-        if (size < 0) {
-            zip->unzip_error = true;
-            return -1;
-        }
-        zip->chunk_filled = size;
-        if (verify_gzip_header(zip, zip->chunk_ptr, zip->chunk_filled) == false) {
-            zip->unzip_error = true;
-            ESP_LOGE(TAG, "Wrong data not match gzip header");
-            return -1;
-        }
-        zip->chunk_consumed = GZIP_HEADER_SIZE;
-    }
-
-    while (1) {
-        uint8_t *data = zip->chunk_ptr + zip->chunk_consumed;
-        size = zip->chunk_filled - zip->chunk_consumed;
-        if (size) {
-            int skip = gzip_miniz_skip_head(zip, data, size);
-            if (skip == 0) {
-                break;
-            }
-            zip->chunk_consumed += skip;
-            if (size > skip) {
-                break;
-            }
-        }
-        size = zip->cfg.read_cb(zip->chunk_ptr, zip->cfg.chunk_size, zip->cfg.ctx);
-        if (size < 0) {
-            zip->unzip_error = true;
-            ESP_LOGE(TAG, "Fail to read data");
-            return -1;
-        }
-        if (size == 0) {
-            zip->final_data = true;
-            return 0;
-        }
-        zip->chunk_filled = size;
-        zip->chunk_consumed = 0;
-    }
-
-    int org_size = out_size;
-    // set input buffer
-    mz_stream *s = &zip->s;
-    s->next_in = zip->chunk_ptr + zip->chunk_consumed;
-    s->avail_in = zip->chunk_filled - zip->chunk_consumed;
-    s->next_out = out;
-    s->avail_out = out_size;
-    while (1) {
-        int ret = mz_inflate(s, MZ_SYNC_FLUSH);
-        if (ret < 0) {
-            zip->unzip_error = true;
-            ESP_LOGE(TAG, "Fail to inflate ret %d", ret);
-            break;
-        }
-        int out_consume = out_size - s->avail_out;
-        out += out_consume;
-        out_size -= out_consume;
-        if (ret == MZ_STREAM_END) {
-            zip->final_data = true;
-            break;
-        }
-        if (s->avail_out == 0) {
-            // All output consumed
-            int org_size = zip->chunk_filled - zip->chunk_consumed;
-            zip->chunk_consumed += (org_size - s->avail_in);
-            break;
-        }
-        if (s->avail_in == 0) {
-            size = zip->cfg.read_cb(zip->chunk_ptr, zip->cfg.chunk_size, zip->cfg.ctx);
-            if (size < 0) {
-                zip->unzip_error = true;
-                ESP_LOGE(TAG, "Fail to read data");
-                return -1;
-            }
-            zip->chunk_filled = size;
-            zip->chunk_consumed = 0;
-            // Update pointer
-            s->next_in = zip->chunk_ptr;
-            s->avail_in = zip->chunk_filled - zip->chunk_consumed;
-            s->next_out = out;
-            s->avail_out = out_size;
-
-        } else {
-            // Impossible case
-            break;
-        }
-    }
-    return org_size - out_size;
-}
-
-int gzip_miniz_deinit(gzip_miniz_handle_t h)
-{
-    gzip_miniz_t *zip = (gzip_miniz_t *) h;
-    if (zip == NULL) {
-        return -1;
-    }
-    mz_inflateEnd(&zip->s);
-    free(zip->chunk_ptr);
-    free(zip);
-    return 0;
-}
-
-int gzip_miniz_zip(const uint8_t *input, size_t input_size, uint8_t *out, int out_size)
-{
-    int pos = 0;
-    const uint8_t header[10] = {0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03};
-    memcpy(out, header, 10);
-    pos += 10;
-
-    mz_stream stream = {0};
-    if (mz_deflateInit2(&stream, MZ_BEST_COMPRESSION, MZ_DEFLATED, -MZ_DEFAULT_WINDOW_BITS, 1, MZ_DEFAULT_STRATEGY) != MZ_OK) {
-        ESP_LOGE(TAG, "Failed to init deflate");
-        return -1;
-    }
-
-    stream.next_in = (const unsigned char *)input;
-    stream.avail_in = input_size;
-    int ret;
-    do {
-        stream.next_out = out + pos;
-        stream.avail_out = out_size - pos;
-        ret = mz_deflate(&stream, MZ_FINISH);
-        if (ret != MZ_OK && ret != MZ_STREAM_END) {
-            ESP_LOGE(TAG, "Failed to deflate ret %d", ret);
-            mz_deflateEnd(&stream);
-            return -2;
-        }
-        pos += (out_size - pos) - stream.avail_out;
-    } while (ret != MZ_STREAM_END);
-    // Clean up compression stream
-    mz_deflateEnd(&stream);
-
-    uint32_t crc_value = mz_crc32(0, input, input_size);
-    memcpy(out + pos, &crc_value, 4);
-    pos += 4;
-    memcpy(out + pos, &input_size, 4);
-    pos += 4;
-    return pos;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include "esp_log.h"
+#include "gzip_miniz.h"
+#include "miniz_inflate.h"
+
+#define TAG              "GZIP_MINIZ"
+#define GZIP_HEADER_SIZE (10)
+
+typedef struct {
+    gzip_miniz_cfg_t cfg;
+    uint8_t         *chunk_ptr;
+    int              chunk_filled;
+    int              chunk_consumed;
+    bool             unzip_error;
+    bool             first_data;
+    bool             final_data;
+    int              head_flag;
+    int              extra_len;
+    int              head_filled;
+    mz_stream        s;
+} gzip_miniz_t;
+
+static bool verify_gzip_header(gzip_miniz_t *zip, uint8_t *data, int size)
+{
+    if (size < GZIP_HEADER_SIZE) {
+        return false;
+    }
+    if (data[0] != 0x1F || data[1] != 0x8B || data[2] != 0x8) {
+        return false;
+    }
+    zip->head_flag = data[3];
+    return true;
+}
+
+static int gzip_miniz_skip_head(gzip_miniz_t *zip, uint8_t *data, int size)
+{
+    if (zip->head_flag == 0) {
+        return 0;
+    }
+    int org_size = size;
+    if (zip->head_flag & 4) {
+        // 2 bytes extra len
+        if (zip->head_filled > 2) {
+            return -1;
+        }
+        if (zip->head_filled + size >= 2) {
+            int used = 2 - zip->head_filled;
+            if (used) {
+                size -= used;
+                while (used--) {
+                    zip->extra_len = zip->extra_len + (*data << (zip->head_filled * 8));
+                    zip->head_filled++;
+                    data++;
+                }
+            }
+            if (size >= zip->extra_len) {
+                size -= zip->extra_len;
+                data += zip->extra_len;
+                zip->extra_len = 0;
+                zip->head_flag &= ~4;
+                zip->head_filled = 0;
+            } else {
+                zip->extra_len -= size;
+                return org_size;
+            }
+        } else {
+            for (int i = 0; i < size; i++) {
+                zip->extra_len = zip->extra_len + (*data << (zip->head_filled * 8));
+                zip->head_filled++;
+                data++;
+            }
+            zip->head_filled += size;
+            return org_size;
+        }
+    }
+    if (zip->head_flag & 8) {
+        // name
+        while (size) {
+            size--;
+            data++;
+            if (*(data - 1) == '\0') {
+                zip->head_flag &= ~8;
+                break;
+            }
+        }
+        if (size == 0) {
+            return org_size;
+        }
+    }
+    if (zip->head_flag & 0x10) {
+        // comment
+        while (size) {
+            size--;
+            data++;
+            if (*(data - 1) == '\0') {
+                zip->head_flag &= ~0x10;
+                break;
+            }
+        }
+        if (size == 0) {
+            return org_size;
+        }
+    }
+    if (zip->head_flag & 0x2) {
+        // CRC16
+        if (zip->head_filled > 2) {
+            return -1;
+        }
+        if (zip->head_filled + size >= 2) {
+            int used = 2 - zip->head_filled;
+            size -= used;
+            data += used;
+            zip->head_flag &= ~0x2;
+        } else {
+            zip->head_filled += size;
+            return org_size;
+        }
+    }
+    return org_size - size;
+}
+
+gzip_miniz_handle_t gzip_miniz_init(gzip_miniz_cfg_t *cfg)
+{
+    if (cfg->read_cb == NULL) {
+        ESP_LOGE(TAG, "Read callback must be provided");
+        return NULL;
+    }
+    gzip_miniz_t *zip = (gzip_miniz_t *) calloc(1, sizeof(gzip_miniz_t));
+    if (zip == NULL) {
+        ESP_LOGE(TAG, "No memory for instance");
+        return NULL;
+    }
+    zip->cfg = *cfg;
+    int chunk_size = cfg->chunk_size ? cfg->chunk_size : 32;
+    zip->chunk_ptr = (uint8_t *) malloc(chunk_size);
+    if (zip->chunk_ptr == NULL) {
+        free(zip);
+        ESP_LOGE(TAG, "No memory for chunk");
+        return NULL;
+    }
+    zip->cfg.chunk_size = chunk_size;
+    zip->first_data = true;
+    mz_inflateInit2(&zip->s, -MZ_DEFAULT_WINDOW_BITS);
+    return (gzip_miniz_handle_t)zip;
+}
+
+int gzip_miniz_read(gzip_miniz_handle_t h, uint8_t *out, int out_size)
+{
+    gzip_miniz_t *zip = (gzip_miniz_t *) h;
+    if (zip == NULL) {
+        return -1;
+    }
+    if (zip->unzip_error) {
+        return -2;
+    }
+    if (zip->final_data) {
+        return 0;
+    }
+    int size = 0;
+    if (zip->first_data == true) {
+        zip->first_data = false;
+        int size = zip->cfg.read_cb(zip->chunk_ptr, zip->cfg.chunk_size, zip->cfg.ctx);
+        if (size < 0) {
+            zip->unzip_error = true;
+            return -1;
+        }
+        zip->chunk_filled = size;
+        if (verify_gzip_header(zip, zip->chunk_ptr, zip->chunk_filled) == false) {
+            zip->unzip_error = true;
+            ESP_LOGE(TAG, "Wrong data not match gzip header");
+            return -1;
+        }
+        zip->chunk_consumed = GZIP_HEADER_SIZE;
+    }
+
+    while (1) {
+        uint8_t *data = zip->chunk_ptr + zip->chunk_consumed;
+        size = zip->chunk_filled - zip->chunk_consumed;
+        if (size) {
+            int skip = gzip_miniz_skip_head(zip, data, size);
+            if (skip == 0) {
+                break;
+            }
+            zip->chunk_consumed += skip;
+            if (size > skip) {
+                break;
+            }
+        }
+        size = zip->cfg.read_cb(zip->chunk_ptr, zip->cfg.chunk_size, zip->cfg.ctx);
+        if (size < 0) {
+            zip->unzip_error = true;
+            ESP_LOGE(TAG, "Fail to read data");
+            return -1;
+        }
+        if (size == 0) {
+            zip->final_data = true;
+            return 0;
+        }
+        zip->chunk_filled = size;
+        zip->chunk_consumed = 0;
+    }
+
+    int org_size = out_size;
+    // set input buffer
+    mz_stream *s = &zip->s;
+    s->next_in = zip->chunk_ptr + zip->chunk_consumed;
+    s->avail_in = zip->chunk_filled - zip->chunk_consumed;
+    s->next_out = out;
+    s->avail_out = out_size;
+    while (1) {
+        int ret = mz_inflate(s, MZ_SYNC_FLUSH);
+        if (ret < 0) {
+            zip->unzip_error = true;
+            ESP_LOGE(TAG, "Fail to inflate ret %d", ret);
+            break;
+        }
+        int out_consume = out_size - s->avail_out;
+        out += out_consume;
+        out_size -= out_consume;
+        if (ret == MZ_STREAM_END) {
+            zip->final_data = true;
+            break;
+        }
+        if (s->avail_out == 0) {
+            // All output consumed
+            int org_size = zip->chunk_filled - zip->chunk_consumed;
+            zip->chunk_consumed += (org_size - s->avail_in);
+            break;
+        }
+        if (s->avail_in == 0) {
+            size = zip->cfg.read_cb(zip->chunk_ptr, zip->cfg.chunk_size, zip->cfg.ctx);
+            if (size < 0) {
+                zip->unzip_error = true;
+                ESP_LOGE(TAG, "Fail to read data");
+                return -1;
+            }
+            zip->chunk_filled = size;
+            zip->chunk_consumed = 0;
+            // Update pointer
+            s->next_in = zip->chunk_ptr;
+            s->avail_in = zip->chunk_filled - zip->chunk_consumed;
+            s->next_out = out;
+            s->avail_out = out_size;
+
+        } else {
+            // Impossible case
+            break;
+        }
+    }
+    return org_size - out_size;
+}
+
+int gzip_miniz_deinit(gzip_miniz_handle_t h)
+{
+    gzip_miniz_t *zip = (gzip_miniz_t *) h;
+    if (zip == NULL) {
+        return -1;
+    }
+    mz_inflateEnd(&zip->s);
+    free(zip->chunk_ptr);
+    free(zip);
+    return 0;
+}
+
+int gzip_miniz_zip(const uint8_t *input, size_t input_size, uint8_t *out, int out_size)
+{
+    int pos = 0;
+    const uint8_t header[10] = {0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03};
+    memcpy(out, header, 10);
+    pos += 10;
+
+    mz_stream stream = {0};
+    if (mz_deflateInit2(&stream, MZ_BEST_COMPRESSION, MZ_DEFLATED, -MZ_DEFAULT_WINDOW_BITS, 1, MZ_DEFAULT_STRATEGY) != MZ_OK) {
+        ESP_LOGE(TAG, "Failed to init deflate");
+        return -1;
+    }
+
+    stream.next_in = (const unsigned char *)input;
+    stream.avail_in = input_size;
+    int ret;
+    do {
+        stream.next_out = out + pos;
+        stream.avail_out = out_size - pos;
+        ret = mz_deflate(&stream, MZ_FINISH);
+        if (ret != MZ_OK && ret != MZ_STREAM_END) {
+            ESP_LOGE(TAG, "Failed to deflate ret %d", ret);
+            mz_deflateEnd(&stream);
+            return -2;
+        }
+        pos += (out_size - pos) - stream.avail_out;
+    } while (ret != MZ_STREAM_END);
+    // Clean up compression stream
+    mz_deflateEnd(&stream);
+
+    uint32_t crc_value = mz_crc32(0, input, input_size);
+    memcpy(out + pos, &crc_value, 4);
+    pos += 4;
+    memcpy(out + pos, &input_size, 4);
+    pos += 4;
+    return pos;
+}
diff --git a/components/audio_stream/lib/gzip/include/gzip_miniz.h b/components/audio_stream/lib/gzip/include/gzip_miniz.h
index ac1c2de1..04ef4fc4 100644
--- a/components/audio_stream/lib/gzip/include/gzip_miniz.h
+++ b/components/audio_stream/lib/gzip/include/gzip_miniz.h
@@ -1,88 +1,88 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef _GZIP_MINIZ_H_
-#define _GZIP_MINIZ_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Configuration for gzip using miniz library
- */
-typedef struct {
-    int   (*read_cb)(uint8_t *data, int size, void *ctx); /*!< Read callback return size being read */
-    int   chunk_size;                                    /*!< Chunk size default 32 if set to 0 */
-    void  *ctx;                                          /*!< Read context */
-} gzip_miniz_cfg_t;
-
-/**
- * @brief Handle for gzip
- */
-typedef void *gzip_miniz_handle_t;
-
-/**
- * @brief         Initialize for gzip using miniz
- * @param         cfg: Configuration for gzip using miniz
- * @return        NULL: Input parameter wrong or no memory
- *                Others: Handle for gzip inflate operation
- */
-gzip_miniz_handle_t gzip_miniz_init(gzip_miniz_cfg_t *cfg);
-
-/**
- * @brief         Inflate and read data
- * @param         out: Data to read after inflated
- * @param         out_size: Data size to read
- * @return        >= 0: Data size being read
- *                -1: Wrong input parameter or wrong data
- *                -2: Inflate error by miniz         
- */
-int gzip_miniz_read(gzip_miniz_handle_t zip, uint8_t *out, int out_size);
-
-/**
- * @brief         Deinitialize gzip using miniz
- * @param         zip: Handle for gzip
- * @return        0: On success
- *                -1: Input parameter wrong            
- */
-int gzip_miniz_deinit(gzip_miniz_handle_t zip);
-
-/**
- * @brief         Zip data into gzip format
- * @param         in: Data to be zipped
- * @param         in_size: Data size to be zipped
- * @param         in_size: Data size to be zipped
- * @param         out: Store output gzip format data
- * @param         out_size: Zipped data size
- * @return        >= 0: On success
- *                -1: Fail to init gzip deflate
- *                -2: Fail to deflate           
- */
-int gzip_miniz_zip(const uint8_t* in, size_t in_size, uint8_t *out, int out_size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef _GZIP_MINIZ_H_
+#define _GZIP_MINIZ_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Configuration for gzip using miniz library
+ */
+typedef struct {
+    int   (*read_cb)(uint8_t *data, int size, void *ctx); /*!< Read callback return size being read */
+    int   chunk_size;                                    /*!< Chunk size default 32 if set to 0 */
+    void  *ctx;                                          /*!< Read context */
+} gzip_miniz_cfg_t;
+
+/**
+ * @brief Handle for gzip
+ */
+typedef void *gzip_miniz_handle_t;
+
+/**
+ * @brief         Initialize for gzip using miniz
+ * @param         cfg: Configuration for gzip using miniz
+ * @return        NULL: Input parameter wrong or no memory
+ *                Others: Handle for gzip inflate operation
+ */
+gzip_miniz_handle_t gzip_miniz_init(gzip_miniz_cfg_t *cfg);
+
+/**
+ * @brief         Inflate and read data
+ * @param         out: Data to read after inflated
+ * @param         out_size: Data size to read
+ * @return        >= 0: Data size being read
+ *                -1: Wrong input parameter or wrong data
+ *                -2: Inflate error by miniz         
+ */
+int gzip_miniz_read(gzip_miniz_handle_t zip, uint8_t *out, int out_size);
+
+/**
+ * @brief         Deinitialize gzip using miniz
+ * @param         zip: Handle for gzip
+ * @return        0: On success
+ *                -1: Input parameter wrong            
+ */
+int gzip_miniz_deinit(gzip_miniz_handle_t zip);
+
+/**
+ * @brief         Zip data into gzip format
+ * @param         in: Data to be zipped
+ * @param         in_size: Data size to be zipped
+ * @param         in_size: Data size to be zipped
+ * @param         out: Store output gzip format data
+ * @param         out_size: Zipped data size
+ * @return        >= 0: On success
+ *                -1: Fail to init gzip deflate
+ *                -2: Fail to deflate           
+ */
+int gzip_miniz_zip(const uint8_t* in, size_t in_size, uint8_t *out, int out_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/lib/gzip/miniz_inflate.h b/components/audio_stream/lib/gzip/miniz_inflate.h
index a807751b..3c5198b7 100644
--- a/components/audio_stream/lib/gzip/miniz_inflate.h
+++ b/components/audio_stream/lib/gzip/miniz_inflate.h
@@ -1,382 +1,382 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef _MINIZ_INFLATE_H
-#define _MINIZ_INFLATE_H
-
-#include <string.h>
-#include "esp_idf_version.h"
-#if (ESP_IDF_VERSION_MAJOR == 4) && (ESP_IDF_VERSION_MINOR < 3)
-#include "esp32/rom/miniz.h"
-#elif (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0) && ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 3, 0))
-#include "rom/miniz.h"
-#else
-#include "miniz.h"
-#endif
-
-// Add the API missing in miniz of ROM code
-// Original code can be gotten from: https://github.com/richgel999/miniz/blob/master/miniz.c
-#ifdef MINIZ_NO_ZLIB_APIS
-
-// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer
-// to the zlib docs).
-enum { MZ_NO_FLUSH = 0, MZ_PARTIAL_FLUSH = 1, MZ_SYNC_FLUSH = 2, MZ_FULL_FLUSH = 3, MZ_FINISH = 4, MZ_BLOCK = 5 };
-
-// Return status codes. MZ_PARAM_ERROR is non-standard.
-enum {
-    MZ_OK = 0,
-    MZ_STREAM_END = 1,
-    MZ_NEED_DICT = 2,
-    MZ_ERRNO = -1,
-    MZ_STREAM_ERROR = -2,
-    MZ_DATA_ERROR = -3,
-    MZ_MEM_ERROR = -4,
-    MZ_BUF_ERROR = -5,
-    MZ_VERSION_ERROR = -6,
-    MZ_PARAM_ERROR = -10000
-};
-
-// Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and
-// may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
-enum {
-    MZ_NO_COMPRESSION = 0,
-    MZ_BEST_SPEED = 1,
-    MZ_BEST_COMPRESSION = 9,
-    MZ_UBER_COMPRESSION = 10,
-    MZ_DEFAULT_LEVEL = 6,
-    MZ_DEFAULT_COMPRESSION = -1
-};
-
-// Window bits
-#define MZ_DEFAULT_WINDOW_BITS 15
-#define MZ_MIN(a, b)           (a > b ? b : a)
-
-struct mz_internal_state;
-
-// Compression/decompression stream struct.
-typedef struct mz_stream_s {
-    const unsigned char      *next_in;   // pointer to next byte to read
-    unsigned int              avail_in;  // number of bytes available at next_in
-    mz_ulong                  total_in;  // total number of bytes consumed so far
-
-    unsigned char            *next_out;  // pointer to next byte to write
-    unsigned int              avail_out; // number of bytes that can be written to next_out
-    mz_ulong                  total_out; // total number of bytes produced so far
-
-    char                     *msg;       // error msg (unused)
-    struct mz_internal_state *state;     // internal state, allocated by zalloc/zfree
-
-    int                       data_type; // data_type (unused)
-    mz_ulong                  adler;     // adler32 of the source or uncompressed data
-    mz_ulong                  crc32;     // crc32 of the source or uncompressed data
-} mz_stream;
-
-typedef mz_stream *mz_streamp;
-
-typedef struct {
-    tinfl_decompressor m_decomp;
-    mz_uint            m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
-    int                m_window_bits;
-    mz_uint8           m_dict[TINFL_LZ_DICT_SIZE];
-    tinfl_status       m_last_status;
-} inflate_state;
-
-static int mz_inflateInit2(mz_streamp pStream, int window_bits)
-{
-    inflate_state *pDecomp;
-    if (!pStream)
-        return MZ_STREAM_ERROR;
-    if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))
-        return MZ_PARAM_ERROR;
-
-    pStream->data_type = 0;
-    pStream->adler = 0;
-    pStream->crc32 = 0;
-    pStream->msg = NULL;
-    pStream->total_in = 0;
-    pStream->total_out = 0;
-
-    pDecomp = (inflate_state *) calloc(1, sizeof(inflate_state));
-    if (!pDecomp)
-        return MZ_MEM_ERROR;
-
-    pStream->state = (struct mz_internal_state *) pDecomp;
-
-    tinfl_init(&pDecomp->m_decomp);
-    pDecomp->m_dict_ofs = 0;
-    pDecomp->m_dict_avail = 0;
-    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
-    pDecomp->m_first_call = 1;
-    pDecomp->m_has_flushed = 0;
-    pDecomp->m_window_bits = window_bits;
-
-    return MZ_OK;
-}
-
-static int mz_inflate(mz_streamp pStream, int flush)
-{
-    inflate_state *pState;
-    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
-    size_t in_bytes, out_bytes, orig_avail_in;
-    tinfl_status status;
-
-    if ((!pStream) || (!pStream->state))
-        return MZ_STREAM_ERROR;
-    if (flush == MZ_PARTIAL_FLUSH)
-        flush = MZ_SYNC_FLUSH;
-    if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
-        return MZ_STREAM_ERROR;
-
-    pState = (inflate_state *) pStream->state;
-    if (pState->m_window_bits > 0)
-        decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
-    orig_avail_in = pStream->avail_in;
-
-    first_call = pState->m_first_call;
-    pState->m_first_call = 0;
-    if (pState->m_last_status < 0)
-        return MZ_DATA_ERROR;
-
-    if (pState->m_has_flushed && (flush != MZ_FINISH))
-        return MZ_STREAM_ERROR;
-    pState->m_has_flushed |= (flush == MZ_FINISH);
-
-    if ((flush == MZ_FINISH) && (first_call)) {
-        // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire
-        // compressed/decompressed file.
-        decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-        in_bytes = pStream->avail_in;
-        out_bytes = pStream->avail_out;
-        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out,
-                                  &out_bytes, decomp_flags);
-        pState->m_last_status = status;
-        pStream->next_in += (mz_uint) in_bytes;
-        pStream->avail_in -= (mz_uint) in_bytes;
-        pStream->total_in += (mz_uint) in_bytes;
-        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
-        pStream->next_out += (mz_uint) out_bytes;
-        pStream->avail_out -= (mz_uint) out_bytes;
-        pStream->total_out += (mz_uint) out_bytes;
-
-        if (status < 0)
-            return MZ_DATA_ERROR;
-        else if (status != TINFL_STATUS_DONE) {
-            pState->m_last_status = TINFL_STATUS_FAILED;
-            return MZ_BUF_ERROR;
-        }
-        return MZ_STREAM_END;
-    }
-    // flush != MZ_FINISH then we must assume there's more input.
-    if (flush != MZ_FINISH)
-        decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;
-
-    if (pState->m_dict_avail) {
-        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
-        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
-        pStream->next_out += n;
-        pStream->avail_out -= n;
-        pStream->total_out += n;
-        pState->m_dict_avail -= n;
-        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
-        return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
-    }
-
-    for (;;) {
-        in_bytes = pStream->avail_in;
-        out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;
-
-        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict,
-                                  pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
-        pState->m_last_status = status;
-
-        pStream->next_in += (mz_uint) in_bytes;
-        pStream->avail_in -= (mz_uint) in_bytes;
-        pStream->total_in += (mz_uint) in_bytes;
-        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
-
-        pState->m_dict_avail = (mz_uint) out_bytes;
-
-        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
-        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
-        pStream->next_out += n;
-        pStream->avail_out -= n;
-        pStream->total_out += n;
-        pState->m_dict_avail -= n;
-        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
-
-        if (status < 0)
-            return MZ_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output
-                                  // dictionary - oh well).
-        else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
-            return MZ_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input or by
-                                 // setting flush to MZ_FINISH.
-        else if (flush == MZ_FINISH) {
-            // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
-            if (status == TINFL_STATUS_DONE)
-                return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
-            // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If
-            // there's no more room left in the output buffer then something is wrong.
-            else if (!pStream->avail_out)
-                return MZ_BUF_ERROR;
-        } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) ||
-                   (pState->m_dict_avail))
-            break;
-    }
-
-    return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
-}
-
-static int mz_inflateEnd(mz_streamp pStream)
-{
-    if (!pStream)
-        return MZ_STREAM_ERROR;
-    if (pStream->state) {
-        free(pStream->state);
-        pStream->state = NULL;
-    }
-    return MZ_OK;
-}
-
-static int mz_deflateEnd(mz_streamp pStream)
-{
-    if (!pStream)
-        return MZ_STREAM_ERROR;
-    if (pStream->state)
-    {
-        free(pStream->state);
-        pStream->state = NULL;
-    }
-    return MZ_OK;
-}
-
-static int tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
-{
-    static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
-    mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
-    if (window_bits > 0)
-        comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
-
-    if (!level)
-        comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
-    else if (strategy == MZ_FILTERED)
-        comp_flags |= TDEFL_FILTER_MATCHES;
-    else if (strategy == MZ_HUFFMAN_ONLY)
-        comp_flags &= ~TDEFL_MAX_PROBES_MASK;
-    else if (strategy == MZ_FIXED)
-        comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
-    else if (strategy == MZ_RLE)
-        comp_flags |= TDEFL_RLE_MATCHES;
-
-    return comp_flags;
-}
-
-static int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
-{
-    tdefl_compressor *pComp;
-    mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);
-
-    if (!pStream)
-        return MZ_STREAM_ERROR;
-    if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
-        return MZ_PARAM_ERROR;
-
-    pStream->data_type = 0;
-    pStream->adler = MZ_ADLER32_INIT;
-    pStream->msg = NULL;
-    pStream->total_in = 0;
-    pStream->total_out = 0;
-    pComp = (tdefl_compressor *)calloc(1, sizeof(tdefl_compressor));
-    if (!pComp)
-        return MZ_MEM_ERROR;
-
-    pStream->state = (struct mz_internal_state *)pComp;
-
-    if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
-    {
-        mz_deflateEnd(pStream);
-        return MZ_PARAM_ERROR;
-    }
-
-    return MZ_OK;
-}
-
-static int mz_deflate(mz_streamp pStream, int flush)
-{
-    size_t in_bytes, out_bytes;
-    mz_ulong orig_total_in, orig_total_out;
-    int mz_status = MZ_OK;
-
-    if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))
-        return MZ_STREAM_ERROR;
-    if (!pStream->avail_out)
-        return MZ_BUF_ERROR;
-
-    if (flush == MZ_PARTIAL_FLUSH)
-        flush = MZ_SYNC_FLUSH;
-
-    if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
-        return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;
-
-    orig_total_in = pStream->total_in;
-    orig_total_out = pStream->total_out;
-    for (;;)
-    {
-        tdefl_status defl_status;
-        in_bytes = pStream->avail_in;
-        out_bytes = pStream->avail_out;
-
-        defl_status = tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
-        pStream->next_in += (mz_uint)in_bytes;
-        pStream->avail_in -= (mz_uint)in_bytes;
-        pStream->total_in += (mz_uint)in_bytes;
-        pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);
-
-        pStream->next_out += (mz_uint)out_bytes;
-        pStream->avail_out -= (mz_uint)out_bytes;
-        pStream->total_out += (mz_uint)out_bytes;
-
-        if (defl_status < 0)
-        {
-            mz_status = MZ_STREAM_ERROR;
-            break;
-        }
-        else if (defl_status == TDEFL_STATUS_DONE)
-        {
-            mz_status = MZ_STREAM_END;
-            break;
-        }
-        else if (!pStream->avail_out)
-            break;
-        else if ((!pStream->avail_in) && (flush != MZ_FINISH))
-        {
-            if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
-                break;
-            return MZ_BUF_ERROR; /* Can't make forward progress without some input.
-                                    */
-        }
-    }
-    return mz_status;
-}
-
-#endif
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef _MINIZ_INFLATE_H
+#define _MINIZ_INFLATE_H
+
+#include <string.h>
+#include "esp_idf_version.h"
+#if (ESP_IDF_VERSION_MAJOR == 4) && (ESP_IDF_VERSION_MINOR < 3)
+#include "esp32/rom/miniz.h"
+#elif (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0) && ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 3, 0))
+#include "rom/miniz.h"
+#else
+#include "miniz.h"
+#endif
+
+// Add the API missing in miniz of ROM code
+// Original code can be gotten from: https://github.com/richgel999/miniz/blob/master/miniz.c
+#ifdef MINIZ_NO_ZLIB_APIS
+
+// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer
+// to the zlib docs).
+enum { MZ_NO_FLUSH = 0, MZ_PARTIAL_FLUSH = 1, MZ_SYNC_FLUSH = 2, MZ_FULL_FLUSH = 3, MZ_FINISH = 4, MZ_BLOCK = 5 };
+
+// Return status codes. MZ_PARAM_ERROR is non-standard.
+enum {
+    MZ_OK = 0,
+    MZ_STREAM_END = 1,
+    MZ_NEED_DICT = 2,
+    MZ_ERRNO = -1,
+    MZ_STREAM_ERROR = -2,
+    MZ_DATA_ERROR = -3,
+    MZ_MEM_ERROR = -4,
+    MZ_BUF_ERROR = -5,
+    MZ_VERSION_ERROR = -6,
+    MZ_PARAM_ERROR = -10000
+};
+
+// Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and
+// may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
+enum {
+    MZ_NO_COMPRESSION = 0,
+    MZ_BEST_SPEED = 1,
+    MZ_BEST_COMPRESSION = 9,
+    MZ_UBER_COMPRESSION = 10,
+    MZ_DEFAULT_LEVEL = 6,
+    MZ_DEFAULT_COMPRESSION = -1
+};
+
+// Window bits
+#define MZ_DEFAULT_WINDOW_BITS 15
+#define MZ_MIN(a, b)           (a > b ? b : a)
+
+struct mz_internal_state;
+
+// Compression/decompression stream struct.
+typedef struct mz_stream_s {
+    const unsigned char      *next_in;   // pointer to next byte to read
+    unsigned int              avail_in;  // number of bytes available at next_in
+    mz_ulong                  total_in;  // total number of bytes consumed so far
+
+    unsigned char            *next_out;  // pointer to next byte to write
+    unsigned int              avail_out; // number of bytes that can be written to next_out
+    mz_ulong                  total_out; // total number of bytes produced so far
+
+    char                     *msg;       // error msg (unused)
+    struct mz_internal_state *state;     // internal state, allocated by zalloc/zfree
+
+    int                       data_type; // data_type (unused)
+    mz_ulong                  adler;     // adler32 of the source or uncompressed data
+    mz_ulong                  crc32;     // crc32 of the source or uncompressed data
+} mz_stream;
+
+typedef mz_stream *mz_streamp;
+
+typedef struct {
+    tinfl_decompressor m_decomp;
+    mz_uint            m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
+    int                m_window_bits;
+    mz_uint8           m_dict[TINFL_LZ_DICT_SIZE];
+    tinfl_status       m_last_status;
+} inflate_state;
+
+static int mz_inflateInit2(mz_streamp pStream, int window_bits)
+{
+    inflate_state *pDecomp;
+    if (!pStream)
+        return MZ_STREAM_ERROR;
+    if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))
+        return MZ_PARAM_ERROR;
+
+    pStream->data_type = 0;
+    pStream->adler = 0;
+    pStream->crc32 = 0;
+    pStream->msg = NULL;
+    pStream->total_in = 0;
+    pStream->total_out = 0;
+
+    pDecomp = (inflate_state *) calloc(1, sizeof(inflate_state));
+    if (!pDecomp)
+        return MZ_MEM_ERROR;
+
+    pStream->state = (struct mz_internal_state *) pDecomp;
+
+    tinfl_init(&pDecomp->m_decomp);
+    pDecomp->m_dict_ofs = 0;
+    pDecomp->m_dict_avail = 0;
+    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
+    pDecomp->m_first_call = 1;
+    pDecomp->m_has_flushed = 0;
+    pDecomp->m_window_bits = window_bits;
+
+    return MZ_OK;
+}
+
+static int mz_inflate(mz_streamp pStream, int flush)
+{
+    inflate_state *pState;
+    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
+    size_t in_bytes, out_bytes, orig_avail_in;
+    tinfl_status status;
+
+    if ((!pStream) || (!pStream->state))
+        return MZ_STREAM_ERROR;
+    if (flush == MZ_PARTIAL_FLUSH)
+        flush = MZ_SYNC_FLUSH;
+    if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
+        return MZ_STREAM_ERROR;
+
+    pState = (inflate_state *) pStream->state;
+    if (pState->m_window_bits > 0)
+        decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
+    orig_avail_in = pStream->avail_in;
+
+    first_call = pState->m_first_call;
+    pState->m_first_call = 0;
+    if (pState->m_last_status < 0)
+        return MZ_DATA_ERROR;
+
+    if (pState->m_has_flushed && (flush != MZ_FINISH))
+        return MZ_STREAM_ERROR;
+    pState->m_has_flushed |= (flush == MZ_FINISH);
+
+    if ((flush == MZ_FINISH) && (first_call)) {
+        // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire
+        // compressed/decompressed file.
+        decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
+        in_bytes = pStream->avail_in;
+        out_bytes = pStream->avail_out;
+        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out,
+                                  &out_bytes, decomp_flags);
+        pState->m_last_status = status;
+        pStream->next_in += (mz_uint) in_bytes;
+        pStream->avail_in -= (mz_uint) in_bytes;
+        pStream->total_in += (mz_uint) in_bytes;
+        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
+        pStream->next_out += (mz_uint) out_bytes;
+        pStream->avail_out -= (mz_uint) out_bytes;
+        pStream->total_out += (mz_uint) out_bytes;
+
+        if (status < 0)
+            return MZ_DATA_ERROR;
+        else if (status != TINFL_STATUS_DONE) {
+            pState->m_last_status = TINFL_STATUS_FAILED;
+            return MZ_BUF_ERROR;
+        }
+        return MZ_STREAM_END;
+    }
+    // flush != MZ_FINISH then we must assume there's more input.
+    if (flush != MZ_FINISH)
+        decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;
+
+    if (pState->m_dict_avail) {
+        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
+        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
+        pStream->next_out += n;
+        pStream->avail_out -= n;
+        pStream->total_out += n;
+        pState->m_dict_avail -= n;
+        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
+        return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
+    }
+
+    for (;;) {
+        in_bytes = pStream->avail_in;
+        out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;
+
+        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict,
+                                  pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
+        pState->m_last_status = status;
+
+        pStream->next_in += (mz_uint) in_bytes;
+        pStream->avail_in -= (mz_uint) in_bytes;
+        pStream->total_in += (mz_uint) in_bytes;
+        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
+
+        pState->m_dict_avail = (mz_uint) out_bytes;
+
+        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
+        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
+        pStream->next_out += n;
+        pStream->avail_out -= n;
+        pStream->total_out += n;
+        pState->m_dict_avail -= n;
+        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
+
+        if (status < 0)
+            return MZ_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output
+                                  // dictionary - oh well).
+        else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
+            return MZ_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input or by
+                                 // setting flush to MZ_FINISH.
+        else if (flush == MZ_FINISH) {
+            // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
+            if (status == TINFL_STATUS_DONE)
+                return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
+            // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If
+            // there's no more room left in the output buffer then something is wrong.
+            else if (!pStream->avail_out)
+                return MZ_BUF_ERROR;
+        } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) ||
+                   (pState->m_dict_avail))
+            break;
+    }
+
+    return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
+}
+
+static int mz_inflateEnd(mz_streamp pStream)
+{
+    if (!pStream)
+        return MZ_STREAM_ERROR;
+    if (pStream->state) {
+        free(pStream->state);
+        pStream->state = NULL;
+    }
+    return MZ_OK;
+}
+
+static int mz_deflateEnd(mz_streamp pStream)
+{
+    if (!pStream)
+        return MZ_STREAM_ERROR;
+    if (pStream->state)
+    {
+        free(pStream->state);
+        pStream->state = NULL;
+    }
+    return MZ_OK;
+}
+
+static int tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
+{
+    static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
+    mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
+    if (window_bits > 0)
+        comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
+
+    if (!level)
+        comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
+    else if (strategy == MZ_FILTERED)
+        comp_flags |= TDEFL_FILTER_MATCHES;
+    else if (strategy == MZ_HUFFMAN_ONLY)
+        comp_flags &= ~TDEFL_MAX_PROBES_MASK;
+    else if (strategy == MZ_FIXED)
+        comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
+    else if (strategy == MZ_RLE)
+        comp_flags |= TDEFL_RLE_MATCHES;
+
+    return comp_flags;
+}
+
+static int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
+{
+    tdefl_compressor *pComp;
+    mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);
+
+    if (!pStream)
+        return MZ_STREAM_ERROR;
+    if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
+        return MZ_PARAM_ERROR;
+
+    pStream->data_type = 0;
+    pStream->adler = MZ_ADLER32_INIT;
+    pStream->msg = NULL;
+    pStream->total_in = 0;
+    pStream->total_out = 0;
+    pComp = (tdefl_compressor *)calloc(1, sizeof(tdefl_compressor));
+    if (!pComp)
+        return MZ_MEM_ERROR;
+
+    pStream->state = (struct mz_internal_state *)pComp;
+
+    if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
+    {
+        mz_deflateEnd(pStream);
+        return MZ_PARAM_ERROR;
+    }
+
+    return MZ_OK;
+}
+
+static int mz_deflate(mz_streamp pStream, int flush)
+{
+    size_t in_bytes, out_bytes;
+    mz_ulong orig_total_in, orig_total_out;
+    int mz_status = MZ_OK;
+
+    if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))
+        return MZ_STREAM_ERROR;
+    if (!pStream->avail_out)
+        return MZ_BUF_ERROR;
+
+    if (flush == MZ_PARTIAL_FLUSH)
+        flush = MZ_SYNC_FLUSH;
+
+    if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
+        return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;
+
+    orig_total_in = pStream->total_in;
+    orig_total_out = pStream->total_out;
+    for (;;)
+    {
+        tdefl_status defl_status;
+        in_bytes = pStream->avail_in;
+        out_bytes = pStream->avail_out;
+
+        defl_status = tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
+        pStream->next_in += (mz_uint)in_bytes;
+        pStream->avail_in -= (mz_uint)in_bytes;
+        pStream->total_in += (mz_uint)in_bytes;
+        pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);
+
+        pStream->next_out += (mz_uint)out_bytes;
+        pStream->avail_out -= (mz_uint)out_bytes;
+        pStream->total_out += (mz_uint)out_bytes;
+
+        if (defl_status < 0)
+        {
+            mz_status = MZ_STREAM_ERROR;
+            break;
+        }
+        else if (defl_status == TDEFL_STATUS_DONE)
+        {
+            mz_status = MZ_STREAM_END;
+            break;
+        }
+        else if (!pStream->avail_out)
+            break;
+        else if ((!pStream->avail_in) && (flush != MZ_FINISH))
+        {
+            if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
+                break;
+            return MZ_BUF_ERROR; /* Can't make forward progress without some input.
+                                    */
+        }
+    }
+    return mz_status;
+}
+
+#endif
+#endif
diff --git a/components/audio_stream/lib/hls/hls_parse.c b/components/audio_stream/lib/hls/hls_parse.c
index 58f79b06..9b815c2f 100644
--- a/components/audio_stream/lib/hls/hls_parse.c
+++ b/components/audio_stream/lib/hls/hls_parse.c
@@ -1,542 +1,542 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "hls_parse.h"
-
-#define TAG "HLS_PARSER"
-
-#define MEM_SAME(a, b) (memcmp(a, b, sizeof(b)-1) == 0)
-#define STR_SAME(a, b) (strcmp((char*)a, b) == 0)
-
-static hls_playlist_type_t hls_get_playlist_type(char* attr)
-{
-    if (STR_SAME(attr, HLS_STR_EVENT)) {
-        return HLS_PLAYLIST_TYPE_EVENT;
-    }
-    if (STR_SAME(attr, HLS_STR_VOD)) {
-        return HLS_PLAYLIST_TYPE_VOD;
-    }
-    return HLS_PLAYLIST_TYPE_EVENT;
-}
-
-static hls_type_t hls_get_type(char* attr)
-{
-    if (STR_SAME(attr, HLS_STR_AUDIO)) {
-        return HLS_TYPE_AUDIO;
-    }
-    if (STR_SAME(attr, HLS_STR_VIDEO)) {
-        return HLS_TYPE_VIDEO;
-    }
-    if (STR_SAME(attr, HLS_STR_SUBTITLES)) {
-        return HLS_TYPE_SUBTITLES;
-    }
-    if (STR_SAME(attr, HLS_STR_CLOSED_CAPTIONS)) {
-        return HLS_TYPE_CLOSED_CAPTION;
-    }
-    return HLS_TYPE_AUDIO;
-}
-
-static int hls_get_bool_value(char* attr)
-{
-    if (STR_SAME(attr, HLS_STR_YES)) {
-        return 1;
-    }
-    return 0;
-}
-
-static uint64_t hls_get_int_value(char* attr)
-{
-    return (uint64_t)atoll(attr);
-}
-
-static int hls_get_float_value(char* attr)
-{
-    return atof(attr);
-}
-
-static hls_encrypt_method_t hls_get_method(char* attr)
-{
-    if (STR_SAME(attr, HLS_STR_AES_128)) {
-        return HLS_ENCRYPT_METHOD_AES128;
-    }
-    if (STR_SAME(attr, HLS_STR_SAMPLE_AES)) {
-        return HLS_ENCRYPT_METHOD_SAMPLE_AES;
-    }
-    return HLS_ENCRYPT_METHOD_NONE;
-}
-
-static hls_attr_t hls_get_attr(char* attr)
-{
-    switch (*attr) {
-        case 'A':
-            if (STR_SAME(attr, HLS_STR_AUTOSELECT)) {
-                return HLS_ATTR_AUTO_SELECT;
-            }
-            if (STR_SAME(attr, HLS_STR_AUDIO)) {
-                return HLS_ATTR_AUDIO;
-            }
-            break;
-        case 'B':
-            if (STR_SAME(attr, HLS_STR_BANDWIDTH)) {
-                return HLS_ATTR_BANDWIDTH;
-            }
-            break;
-        case 'C':
-            if (STR_SAME(attr, HLS_STR_CODECS)) {
-                return HLS_ATTR_CODECS;
-            }
-            break;
-        case 'D':
-            if (STR_SAME(attr, HLS_STR_DEFAULT)) {
-                return HLS_ATTR_DEFAULT;
-            }
-            break;
-        case 'F':
-            if (STR_SAME(attr, HLS_STR_FORCED)) {
-                return HLS_ATTR_FORCED;
-            }
-            break;
-        case 'G':
-            if (STR_SAME(attr, HLS_STR_GROUP_ID)) {
-                return HLS_ATTR_GROUP_ID;
-            }
-            break;
-        case 'I':
-            if (STR_SAME(attr, HLS_STR_IV)) {
-                return HLS_ATTR_IV;
-            }
-            break;
-        case 'K':
-            if (STR_SAME(attr, HLS_STR_KEYFORMAT)) {
-                return HLS_ATTR_KEYFORMAT;
-            }
-            if (STR_SAME(attr, HLS_STR_KEYFORMATVERSION)) {
-                return HLS_ATTR_KEYFORMAT_VERSION;
-            }
-            break;
-        case 'L':
-            if (STR_SAME(attr, HLS_STR_LANGUAGE)) {
-                return HLS_ATTR_LANGUAGE;
-            }
-            break;
-            case 'M':
-            if (STR_SAME(attr, HLS_STR_METHOD)) {
-                return HLS_ATTR_METHOD;
-            }
-            break;
-        case 'N':
-            if (STR_SAME(attr, HLS_STR_NAME)) {
-                return HLS_ATTR_NAME;
-            }
-            break;
-        case 'P':
-            if (STR_SAME(attr, HLS_STR_PROGRAM_ID)) {
-                return HLS_ATTR_PROGRAM_ID;
-            }
-            break;
-        case 'R':
-            if (STR_SAME(attr, HLS_STR_RESOLUTION)) {
-                return HLS_ATTR_RESOLUTION;
-            }
-            break;
-        case 'S':
-            if (STR_SAME(attr, HLS_STR_SUBTITLES)) {
-                return HLS_ATTR_SUBTITLES;
-            }
-            break;
-        case 'T':
-            if (STR_SAME(attr, HLS_STR_TYPE)) {
-                return HLS_ATTR_TYPE;
-            }
-            break;
-        case 'U':
-            if (STR_SAME(attr, HLS_STR_URI)) {
-                return HLS_ATTR_URI;
-            }
-            break;
-        default:
-            break;
-    }
-    return HLS_ATTR_IGNORE;
-}
-
-static hls_tag_t hls_get_tag(char* tag)
-{
-    if (MEM_SAME(tag, HLS_STR_EXT_X_)) {
-        tag += sizeof(HLS_STR_EXT_X_) - 1;
-    } else if (MEM_SAME(tag, HLS_STR_EXT)) {
-        tag += sizeof(HLS_STR_EXT) -1;
-    } else {
-        return HLS_TAG_IGNORE;
-    }
-    switch (*tag) {
-        case 'B':
-            if (STR_SAME(tag, HLS_STR_BYTERANGE)) {
-                return HLS_TAG_BYTE_RANGE;
-            }
-            break;
-        case 'D':
-            if (STR_SAME(tag, HLS_STR_DISCONTINUITY)) {
-                return HLS_TAG_DISCONTINUITY;
-            }
-            break;
-        case 'E':
-            if (STR_SAME(tag, HLS_STR_ENDLIST)) {
-                return HLS_TAG_ENDLIST;
-            }
-            break;
-        case 'I':
-            if (STR_SAME(tag, HLS_STR_INF)) {
-                return HLS_TAG_INF;
-            }
-            if (STR_SAME(tag, HLS_STR_I_FRAME_STREAM_INF)) {
-                return HLS_TAG_I_FRAME_STREAM_INF;
-            }
-            if (STR_SAME(tag, HLS_STR_INDEPENDENT_SEGMENTS)) {
-                return HLS_TAG_INDEPENDENT_SEGMENTS;
-            }
-            break;
-        case 'K':
-            if (STR_SAME(tag, HLS_STR_KEY)) {
-                return HLS_TAG_KEY;
-            }
-            break;
-        case 'M':
-            if (STR_SAME(tag, HLS_STR_MEDIA)) {
-                return HLS_TAG_MEDIA;
-            }
-            if (STR_SAME(tag, HLS_STR_MEDIA_SEQUENCE)) {
-                return HLS_TAG_MEDIA_SEQUENCE;
-            }
-            if (STR_SAME(tag, HLS_STR_MAP)) {
-                return HLS_TAG_MAP;
-            }
-            break;
-        case 'P':
-            if (STR_SAME(tag, HLS_STR_PLAYLIST_TYPE)) {
-                return HLS_TAG_PLAYLIST_TYPE;
-            }
-            break;
-        case 'S':
-            if (STR_SAME(tag, HLS_STR_STREAM_INF)) {
-                return HLS_TAG_STREAM_INF;
-            }
-            if (STR_SAME(tag, HLS_STR_SESSION_KEY)) {
-                return HLS_TAG_SESSION_KEY;
-            }
-            break;
-        case 'T':
-            if (STR_SAME(tag, HLS_STR_TARGETDURATION)) {
-                return HLS_TAG_TARGET_DURATION;
-            }
-            break;
-        case 'V':
-            if (STR_SAME(tag, HLS_STR_VERSION)) {
-                return HLS_TAG_VERSION;
-            }
-            break;
-        default:
-            break;
-    }
-    return HLS_TAG_IGNORE;
-}
-
-static char* hls_get_tag_sep(char* s)
-{
-    if (*s == '#') {
-        s++;
-        while (*s) {
-            if ((*s >= 'A' && *s <= 'Z') || *s == '-') {
-
-            } else if (*s == ':') {
-                return s;
-            } else {
-                return NULL;
-            }
-            s++;
-        }
-    }
-    return NULL;
-}
-
-static int hls_parse_attr(hls_parse_t* parser, char* s, int attr_num) {
-    bool in_string = false;
-    bool is_slash  = false;
-    while (*s) {
-        if (in_string && *s == '\\') {
-            is_slash = true;
-        } else {
-            if (*s == '"') {
-                if (is_slash == false) {
-                    in_string = !in_string;
-                }
-            } else if (*s == ',') {
-                if (in_string == false) {
-                    if (attr_num < HLS_MAX_ATTR_NUM) {
-                        *(s++) = 0;
-                        if (*s == 0) {
-                            break;
-                        }
-                        parser->attr[attr_num++] = s;
-                    } else {
-                        ESP_LOGE(TAG, "Too many hls attributes try to enlarge HLS_MAX_ATTR_NUM");
-                    }
-                }
-            }
-            if (is_slash) {
-                is_slash = false;
-            }
-        }
-        s++;
-    }
-    return attr_num;
-}
-
-static void hls_parse_key(hls_parse_t* parser, hls_tag_t tag, int attr_num) {
-    for (int i = 0; i < attr_num; i++) {
-        char* k = parser->attr[i];
-        char* sep = strchr(k, '=');
-        if (sep) {
-            *(sep++) = 0;
-            parser->k[i] = hls_get_attr(k);
-            parser->v[i].s = sep;
-        } else {
-            parser->k[i] = HLS_ATTR_IGNORE;
-            if (i == 0) {
-                switch (tag) {
-                    case HLS_TAG_INF:
-                    case HLS_TAG_TARGET_DURATION:
-                        parser->k[i] = HLS_ATTR_DURATION;
-                        break;
-                    case HLS_TAG_MEDIA_SEQUENCE:
-                    case HLS_TAG_VERSION:
-                        parser->k[i] = HLS_ATTR_INT;
-                        break;
-                    case HLS_TAG_PLAYLIST_TYPE:
-                        parser->k[i] = HLS_ATTR_INT;
-                        parser->v[i].v = (uint64_t)hls_get_playlist_type(k);
-                        continue;
-                    default:
-                        break;
-                }
-            }
-            parser->v[i].s = k;
-        }
-    }
-}
-
-static void hls_parse_value(hls_parse_t* parser, int attr_num) {
-    for (int i = 0; i < attr_num; i++) {
-        switch (parser->k[i]) {
-            case HLS_ATTR_DURATION:
-                parser->v[i].f = hls_get_float_value(parser->v[i].s);
-                break;
-            case HLS_ATTR_TYPE:
-                parser->v[i].v = (uint64_t)hls_get_type(parser->v[i].s);
-                break;
-            case HLS_ATTR_BANDWIDTH:
-            case HLS_ATTR_PROGRAM_ID:
-            case HLS_ATTR_INT:
-                parser->v[i].v = hls_get_int_value(parser->v[i].s);
-             break;
-            case HLS_ATTR_DEFAULT:
-            case HLS_ATTR_AUTO_SELECT:
-            case HLS_ATTR_FORCED:
-                parser->v[i].v = hls_get_bool_value(parser->v[i].s);
-                break;
-            case HLS_ATTR_METHOD:
-                parser->v[i].v = (uint64_t)hls_get_method(parser->v[i].s);
-                break;
-            default: {
-                // remove start and end "
-                char* v = parser->v[i].s;
-                if (v[0] == '"') {
-                    int len = strlen(v);
-                    if (v[--len] == '"') {
-                        v[len] = 0;
-                    }
-                    parser->v[i].s = v+1;
-                }
-                break;
-            }
-        }
-    }
-}
-
-int hls_parse_init(hls_parse_t* parser)
-{
-    memset(parser, 0, sizeof(hls_parse_t));
-    parser->reader = line_reader_init(HLS_MAX_LINE_CHAR);
-    if (parser->reader == NULL) {
-        return -1;
-    }
-    return 0;
-}
-
-void hls_parse_deinit(hls_parse_t* parser)
-{
-    if (parser->reader) {
-        line_reader_deinit(parser->reader);
-        parser->reader = NULL;
-    }
-}
-
-bool hls_matched(uint8_t* b, int len)
-{
-    if (STR_SAME(b, HLS_STR_EXTM3U) == 0) {
-        return true;
-    }
-    return false;
-}
-
-hls_file_type_t hls_get_file_type(uint8_t* b, int len)
-{
-    while (len > sizeof(HLS_STR_EXT_X_STREAM_INF)) {
-        if (MEM_SAME(b, HLS_STR_EXT_X_STREAM_INF) || MEM_SAME(b, HLS_STR_EXT_X_MEDIA)) {
-            return HLS_FILE_TYPE_MASTER_PLAYLIST;
-        }
-        if (MEM_SAME(b, HLS_STR_EXTINF)) {
-            return HLS_FILE_TYPE_MEDIA_PLAYLIST;
-        }
-        len--;
-        b++;
-    }
-    return HLS_FILE_TYPE_NONE;
-}
-
-int hls_parse_add_buffer(hls_parse_t* parser, uint8_t* buffer, int size, bool eos)
-{
-    if (parser->reader == NULL) {
-        return -1;
-    }
-    line_reader_add_buffer(parser->reader, buffer, size, eos);
-    return 0;
-}
-
-int hls_parse(hls_parse_t* parser, hls_tag_callback cb, void* ctx)
-{
-    while (1) {
-        char* line = line_reader_get_line(parser->reader);
-        if (line == NULL) {
-            break;
-        }
-        hls_tag_t tag;
-        int attr_num = 0;
-        char* sep = hls_get_tag_sep(line);
-        if (sep == NULL) {
-            tag = hls_get_tag(line);
-            if (tag == HLS_TAG_IGNORE) {
-                // append tag attribute to previous tag
-                if (parser->tag == HLS_TAG_STREAM_INF || parser->tag == HLS_TAG_INF) {
-                    tag = (parser->tag == HLS_TAG_STREAM_INF)? HLS_TAG_STREAM_INF_APPEND : HLS_TAG_INF_APPEND;
-                    parser->k[attr_num] = HLS_ATTR_URI;
-                    parser->v[attr_num++].s = line;
-                }
-                parser->tag = HLS_TAG_IGNORE;
-                if (attr_num == 0) {
-                    continue;
-                }
-            }
-            parser->tag = tag;
-        } else {
-            char* tag_str = line;
-            *(sep++) = 0;
-            char* attr = sep;
-            tag = hls_get_tag(tag_str);
-            // set previous tag
-            parser->tag = tag;
-            if (tag == HLS_TAG_IGNORE) {
-                continue;
-            }
-            parser->attr[attr_num++] = attr;
-            attr_num = hls_parse_attr(parser, sep, attr_num);
-            hls_parse_key(parser, tag, attr_num);
-            hls_parse_value(parser, attr_num);
-        }
-        if (cb) {
-            hls_tag_info_t tag_info = {
-                .tag = tag,
-                .attr_num = attr_num,
-                .k = parser->k,
-                .v = parser->v,
-            };
-            cb(&tag_info, ctx);
-        }
-    }
-    return 0;
-}
-
-const char* hls_tag2str(hls_tag_t tag)
-{
-    switch (tag) {
-        default:
-        case HLS_TAG_IGNORE: return HLS_STR_IGNORE;
-        case HLS_TAG_VERSION: return HLS_STR_VERSION;
-        case HLS_TAG_MEDIA_SEQUENCE: return HLS_STR_MEDIA_SEQUENCE;
-        case HLS_TAG_TARGET_DURATION: return HLS_STR_TARGETDURATION;
-        case HLS_TAG_INF: return HLS_STR_INF;
-        case HLS_TAG_MEDIA: return HLS_STR_MEDIA;
-        case HLS_TAG_STREAM_INF: return HLS_STR_STREAM_INF;
-        case HLS_TAG_INDEPENDENT_SEGMENTS: return HLS_STR_INDEPENDENT_SEGMENTS;
-        case HLS_TAG_I_FRAME_STREAM_INF: return HLS_STR_I_FRAME_STREAM_INF;
-        case HLS_TAG_KEY: return HLS_STR_KEY;
-        case HLS_TAG_SESSION_KEY: return HLS_STR_SESSION_KEY;
-        case HLS_TAG_BYTE_RANGE: return HLS_STR_BYTERANGE;
-        case HLS_TAG_PLAYLIST_TYPE: return HLS_STR_PLAYLIST_TYPE;
-        case HLS_TAG_MAP: return HLS_STR_MAP;
-        case HLS_TAG_DISCONTINUITY: return HLS_STR_DISCONTINUITY;
-        case HLS_TAG_ENDLIST: return HLS_STR_ENDLIST;
-    }
-}
-
-const char* hls_attr2str(hls_attr_t attr)
-{
-    switch (attr) {
-        default:
-        case HLS_ATTR_IGNORE: return HLS_STR_IGNORE;
-        case HLS_ATTR_VERSION: return HLS_STR_VERSION;
-        case HLS_ATTR_DURATION: return HLS_STR_DURATION;
-        case HLS_ATTR_TITLE: return HLS_STR_TITLE;
-        case HLS_ATTR_TYPE: return HLS_STR_TYPE;
-        case HLS_ATTR_GROUP_ID: return HLS_STR_GROUP_ID;
-        case HLS_ATTR_NAME: return HLS_STR_NAME;
-        case HLS_ATTR_LANGUAGE: return HLS_STR_LANGUAGE;
-        case HLS_ATTR_AUTO_SELECT: return HLS_STR_AUTO_SELECT;
-        case HLS_ATTR_URI: return HLS_STR_URI;
-        case HLS_ATTR_BANDWIDTH: return HLS_STR_BANDWIDTH;
-        case HLS_ATTR_CODECS: return HLS_STR_CODECS;
-        case HLS_ATTR_RESOLUTION: return HLS_STR_RESOLUTION;
-        case HLS_ATTR_DEFAULT: return HLS_STR_DEFAULT;
-        case HLS_ATTR_FORCED: return HLS_STR_FORCED;
-        case HLS_ATTR_AUDIO: return HLS_STR_AUDIO;
-        case HLS_ATTR_SUBTITLES: return HLS_STR_SUBTITLES;
-        case HLS_ATTR_PROGRAM_ID: return HLS_STR_PROGRAM_ID;
-        case HLS_ATTR_INT: return HLS_STR_INT;
-        case HLS_ATTR_METHOD: return HLS_STR_METHOD;
-        case HLS_ATTR_IV: return HLS_STR_IV;
-        case HLS_ATTR_KEYFORMAT: return HLS_STR_KEYFORMAT;
-        case HLS_ATTR_KEYFORMAT_VERSION: return HLS_STR_KEYFORMATVERSION;
-    }
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "hls_parse.h"
+
+#define TAG "HLS_PARSER"
+
+#define MEM_SAME(a, b) (memcmp(a, b, sizeof(b)-1) == 0)
+#define STR_SAME(a, b) (strcmp((char*)a, b) == 0)
+
+static hls_playlist_type_t hls_get_playlist_type(char* attr)
+{
+    if (STR_SAME(attr, HLS_STR_EVENT)) {
+        return HLS_PLAYLIST_TYPE_EVENT;
+    }
+    if (STR_SAME(attr, HLS_STR_VOD)) {
+        return HLS_PLAYLIST_TYPE_VOD;
+    }
+    return HLS_PLAYLIST_TYPE_EVENT;
+}
+
+static hls_type_t hls_get_type(char* attr)
+{
+    if (STR_SAME(attr, HLS_STR_AUDIO)) {
+        return HLS_TYPE_AUDIO;
+    }
+    if (STR_SAME(attr, HLS_STR_VIDEO)) {
+        return HLS_TYPE_VIDEO;
+    }
+    if (STR_SAME(attr, HLS_STR_SUBTITLES)) {
+        return HLS_TYPE_SUBTITLES;
+    }
+    if (STR_SAME(attr, HLS_STR_CLOSED_CAPTIONS)) {
+        return HLS_TYPE_CLOSED_CAPTION;
+    }
+    return HLS_TYPE_AUDIO;
+}
+
+static int hls_get_bool_value(char* attr)
+{
+    if (STR_SAME(attr, HLS_STR_YES)) {
+        return 1;
+    }
+    return 0;
+}
+
+static uint64_t hls_get_int_value(char* attr)
+{
+    return (uint64_t)atoll(attr);
+}
+
+static int hls_get_float_value(char* attr)
+{
+    return atof(attr);
+}
+
+static hls_encrypt_method_t hls_get_method(char* attr)
+{
+    if (STR_SAME(attr, HLS_STR_AES_128)) {
+        return HLS_ENCRYPT_METHOD_AES128;
+    }
+    if (STR_SAME(attr, HLS_STR_SAMPLE_AES)) {
+        return HLS_ENCRYPT_METHOD_SAMPLE_AES;
+    }
+    return HLS_ENCRYPT_METHOD_NONE;
+}
+
+static hls_attr_t hls_get_attr(char* attr)
+{
+    switch (*attr) {
+        case 'A':
+            if (STR_SAME(attr, HLS_STR_AUTOSELECT)) {
+                return HLS_ATTR_AUTO_SELECT;
+            }
+            if (STR_SAME(attr, HLS_STR_AUDIO)) {
+                return HLS_ATTR_AUDIO;
+            }
+            break;
+        case 'B':
+            if (STR_SAME(attr, HLS_STR_BANDWIDTH)) {
+                return HLS_ATTR_BANDWIDTH;
+            }
+            break;
+        case 'C':
+            if (STR_SAME(attr, HLS_STR_CODECS)) {
+                return HLS_ATTR_CODECS;
+            }
+            break;
+        case 'D':
+            if (STR_SAME(attr, HLS_STR_DEFAULT)) {
+                return HLS_ATTR_DEFAULT;
+            }
+            break;
+        case 'F':
+            if (STR_SAME(attr, HLS_STR_FORCED)) {
+                return HLS_ATTR_FORCED;
+            }
+            break;
+        case 'G':
+            if (STR_SAME(attr, HLS_STR_GROUP_ID)) {
+                return HLS_ATTR_GROUP_ID;
+            }
+            break;
+        case 'I':
+            if (STR_SAME(attr, HLS_STR_IV)) {
+                return HLS_ATTR_IV;
+            }
+            break;
+        case 'K':
+            if (STR_SAME(attr, HLS_STR_KEYFORMAT)) {
+                return HLS_ATTR_KEYFORMAT;
+            }
+            if (STR_SAME(attr, HLS_STR_KEYFORMATVERSION)) {
+                return HLS_ATTR_KEYFORMAT_VERSION;
+            }
+            break;
+        case 'L':
+            if (STR_SAME(attr, HLS_STR_LANGUAGE)) {
+                return HLS_ATTR_LANGUAGE;
+            }
+            break;
+            case 'M':
+            if (STR_SAME(attr, HLS_STR_METHOD)) {
+                return HLS_ATTR_METHOD;
+            }
+            break;
+        case 'N':
+            if (STR_SAME(attr, HLS_STR_NAME)) {
+                return HLS_ATTR_NAME;
+            }
+            break;
+        case 'P':
+            if (STR_SAME(attr, HLS_STR_PROGRAM_ID)) {
+                return HLS_ATTR_PROGRAM_ID;
+            }
+            break;
+        case 'R':
+            if (STR_SAME(attr, HLS_STR_RESOLUTION)) {
+                return HLS_ATTR_RESOLUTION;
+            }
+            break;
+        case 'S':
+            if (STR_SAME(attr, HLS_STR_SUBTITLES)) {
+                return HLS_ATTR_SUBTITLES;
+            }
+            break;
+        case 'T':
+            if (STR_SAME(attr, HLS_STR_TYPE)) {
+                return HLS_ATTR_TYPE;
+            }
+            break;
+        case 'U':
+            if (STR_SAME(attr, HLS_STR_URI)) {
+                return HLS_ATTR_URI;
+            }
+            break;
+        default:
+            break;
+    }
+    return HLS_ATTR_IGNORE;
+}
+
+static hls_tag_t hls_get_tag(char* tag)
+{
+    if (MEM_SAME(tag, HLS_STR_EXT_X_)) {
+        tag += sizeof(HLS_STR_EXT_X_) - 1;
+    } else if (MEM_SAME(tag, HLS_STR_EXT)) {
+        tag += sizeof(HLS_STR_EXT) -1;
+    } else {
+        return HLS_TAG_IGNORE;
+    }
+    switch (*tag) {
+        case 'B':
+            if (STR_SAME(tag, HLS_STR_BYTERANGE)) {
+                return HLS_TAG_BYTE_RANGE;
+            }
+            break;
+        case 'D':
+            if (STR_SAME(tag, HLS_STR_DISCONTINUITY)) {
+                return HLS_TAG_DISCONTINUITY;
+            }
+            break;
+        case 'E':
+            if (STR_SAME(tag, HLS_STR_ENDLIST)) {
+                return HLS_TAG_ENDLIST;
+            }
+            break;
+        case 'I':
+            if (STR_SAME(tag, HLS_STR_INF)) {
+                return HLS_TAG_INF;
+            }
+            if (STR_SAME(tag, HLS_STR_I_FRAME_STREAM_INF)) {
+                return HLS_TAG_I_FRAME_STREAM_INF;
+            }
+            if (STR_SAME(tag, HLS_STR_INDEPENDENT_SEGMENTS)) {
+                return HLS_TAG_INDEPENDENT_SEGMENTS;
+            }
+            break;
+        case 'K':
+            if (STR_SAME(tag, HLS_STR_KEY)) {
+                return HLS_TAG_KEY;
+            }
+            break;
+        case 'M':
+            if (STR_SAME(tag, HLS_STR_MEDIA)) {
+                return HLS_TAG_MEDIA;
+            }
+            if (STR_SAME(tag, HLS_STR_MEDIA_SEQUENCE)) {
+                return HLS_TAG_MEDIA_SEQUENCE;
+            }
+            if (STR_SAME(tag, HLS_STR_MAP)) {
+                return HLS_TAG_MAP;
+            }
+            break;
+        case 'P':
+            if (STR_SAME(tag, HLS_STR_PLAYLIST_TYPE)) {
+                return HLS_TAG_PLAYLIST_TYPE;
+            }
+            break;
+        case 'S':
+            if (STR_SAME(tag, HLS_STR_STREAM_INF)) {
+                return HLS_TAG_STREAM_INF;
+            }
+            if (STR_SAME(tag, HLS_STR_SESSION_KEY)) {
+                return HLS_TAG_SESSION_KEY;
+            }
+            break;
+        case 'T':
+            if (STR_SAME(tag, HLS_STR_TARGETDURATION)) {
+                return HLS_TAG_TARGET_DURATION;
+            }
+            break;
+        case 'V':
+            if (STR_SAME(tag, HLS_STR_VERSION)) {
+                return HLS_TAG_VERSION;
+            }
+            break;
+        default:
+            break;
+    }
+    return HLS_TAG_IGNORE;
+}
+
+static char* hls_get_tag_sep(char* s)
+{
+    if (*s == '#') {
+        s++;
+        while (*s) {
+            if ((*s >= 'A' && *s <= 'Z') || *s == '-') {
+
+            } else if (*s == ':') {
+                return s;
+            } else {
+                return NULL;
+            }
+            s++;
+        }
+    }
+    return NULL;
+}
+
+static int hls_parse_attr(hls_parse_t* parser, char* s, int attr_num) {
+    bool in_string = false;
+    bool is_slash  = false;
+    while (*s) {
+        if (in_string && *s == '\\') {
+            is_slash = true;
+        } else {
+            if (*s == '"') {
+                if (is_slash == false) {
+                    in_string = !in_string;
+                }
+            } else if (*s == ',') {
+                if (in_string == false) {
+                    if (attr_num < HLS_MAX_ATTR_NUM) {
+                        *(s++) = 0;
+                        if (*s == 0) {
+                            break;
+                        }
+                        parser->attr[attr_num++] = s;
+                    } else {
+                        ESP_LOGE(TAG, "Too many hls attributes try to enlarge HLS_MAX_ATTR_NUM");
+                    }
+                }
+            }
+            if (is_slash) {
+                is_slash = false;
+            }
+        }
+        s++;
+    }
+    return attr_num;
+}
+
+static void hls_parse_key(hls_parse_t* parser, hls_tag_t tag, int attr_num) {
+    for (int i = 0; i < attr_num; i++) {
+        char* k = parser->attr[i];
+        char* sep = strchr(k, '=');
+        if (sep) {
+            *(sep++) = 0;
+            parser->k[i] = hls_get_attr(k);
+            parser->v[i].s = sep;
+        } else {
+            parser->k[i] = HLS_ATTR_IGNORE;
+            if (i == 0) {
+                switch (tag) {
+                    case HLS_TAG_INF:
+                    case HLS_TAG_TARGET_DURATION:
+                        parser->k[i] = HLS_ATTR_DURATION;
+                        break;
+                    case HLS_TAG_MEDIA_SEQUENCE:
+                    case HLS_TAG_VERSION:
+                        parser->k[i] = HLS_ATTR_INT;
+                        break;
+                    case HLS_TAG_PLAYLIST_TYPE:
+                        parser->k[i] = HLS_ATTR_INT;
+                        parser->v[i].v = (uint64_t)hls_get_playlist_type(k);
+                        continue;
+                    default:
+                        break;
+                }
+            }
+            parser->v[i].s = k;
+        }
+    }
+}
+
+static void hls_parse_value(hls_parse_t* parser, int attr_num) {
+    for (int i = 0; i < attr_num; i++) {
+        switch (parser->k[i]) {
+            case HLS_ATTR_DURATION:
+                parser->v[i].f = hls_get_float_value(parser->v[i].s);
+                break;
+            case HLS_ATTR_TYPE:
+                parser->v[i].v = (uint64_t)hls_get_type(parser->v[i].s);
+                break;
+            case HLS_ATTR_BANDWIDTH:
+            case HLS_ATTR_PROGRAM_ID:
+            case HLS_ATTR_INT:
+                parser->v[i].v = hls_get_int_value(parser->v[i].s);
+             break;
+            case HLS_ATTR_DEFAULT:
+            case HLS_ATTR_AUTO_SELECT:
+            case HLS_ATTR_FORCED:
+                parser->v[i].v = hls_get_bool_value(parser->v[i].s);
+                break;
+            case HLS_ATTR_METHOD:
+                parser->v[i].v = (uint64_t)hls_get_method(parser->v[i].s);
+                break;
+            default: {
+                // remove start and end "
+                char* v = parser->v[i].s;
+                if (v[0] == '"') {
+                    int len = strlen(v);
+                    if (v[--len] == '"') {
+                        v[len] = 0;
+                    }
+                    parser->v[i].s = v+1;
+                }
+                break;
+            }
+        }
+    }
+}
+
+int hls_parse_init(hls_parse_t* parser)
+{
+    memset(parser, 0, sizeof(hls_parse_t));
+    parser->reader = line_reader_init(HLS_MAX_LINE_CHAR);
+    if (parser->reader == NULL) {
+        return -1;
+    }
+    return 0;
+}
+
+void hls_parse_deinit(hls_parse_t* parser)
+{
+    if (parser->reader) {
+        line_reader_deinit(parser->reader);
+        parser->reader = NULL;
+    }
+}
+
+bool hls_matched(uint8_t* b, int len)
+{
+    if (STR_SAME(b, HLS_STR_EXTM3U) == 0) {
+        return true;
+    }
+    return false;
+}
+
+hls_file_type_t hls_get_file_type(uint8_t* b, int len)
+{
+    while (len > sizeof(HLS_STR_EXT_X_STREAM_INF)) {
+        if (MEM_SAME(b, HLS_STR_EXT_X_STREAM_INF) || MEM_SAME(b, HLS_STR_EXT_X_MEDIA)) {
+            return HLS_FILE_TYPE_MASTER_PLAYLIST;
+        }
+        if (MEM_SAME(b, HLS_STR_EXTINF)) {
+            return HLS_FILE_TYPE_MEDIA_PLAYLIST;
+        }
+        len--;
+        b++;
+    }
+    return HLS_FILE_TYPE_NONE;
+}
+
+int hls_parse_add_buffer(hls_parse_t* parser, uint8_t* buffer, int size, bool eos)
+{
+    if (parser->reader == NULL) {
+        return -1;
+    }
+    line_reader_add_buffer(parser->reader, buffer, size, eos);
+    return 0;
+}
+
+int hls_parse(hls_parse_t* parser, hls_tag_callback cb, void* ctx)
+{
+    while (1) {
+        char* line = line_reader_get_line(parser->reader);
+        if (line == NULL) {
+            break;
+        }
+        hls_tag_t tag;
+        int attr_num = 0;
+        char* sep = hls_get_tag_sep(line);
+        if (sep == NULL) {
+            tag = hls_get_tag(line);
+            if (tag == HLS_TAG_IGNORE) {
+                // append tag attribute to previous tag
+                if (parser->tag == HLS_TAG_STREAM_INF || parser->tag == HLS_TAG_INF) {
+                    tag = (parser->tag == HLS_TAG_STREAM_INF)? HLS_TAG_STREAM_INF_APPEND : HLS_TAG_INF_APPEND;
+                    parser->k[attr_num] = HLS_ATTR_URI;
+                    parser->v[attr_num++].s = line;
+                }
+                parser->tag = HLS_TAG_IGNORE;
+                if (attr_num == 0) {
+                    continue;
+                }
+            }
+            parser->tag = tag;
+        } else {
+            char* tag_str = line;
+            *(sep++) = 0;
+            char* attr = sep;
+            tag = hls_get_tag(tag_str);
+            // set previous tag
+            parser->tag = tag;
+            if (tag == HLS_TAG_IGNORE) {
+                continue;
+            }
+            parser->attr[attr_num++] = attr;
+            attr_num = hls_parse_attr(parser, sep, attr_num);
+            hls_parse_key(parser, tag, attr_num);
+            hls_parse_value(parser, attr_num);
+        }
+        if (cb) {
+            hls_tag_info_t tag_info = {
+                .tag = tag,
+                .attr_num = attr_num,
+                .k = parser->k,
+                .v = parser->v,
+            };
+            cb(&tag_info, ctx);
+        }
+    }
+    return 0;
+}
+
+const char* hls_tag2str(hls_tag_t tag)
+{
+    switch (tag) {
+        default:
+        case HLS_TAG_IGNORE: return HLS_STR_IGNORE;
+        case HLS_TAG_VERSION: return HLS_STR_VERSION;
+        case HLS_TAG_MEDIA_SEQUENCE: return HLS_STR_MEDIA_SEQUENCE;
+        case HLS_TAG_TARGET_DURATION: return HLS_STR_TARGETDURATION;
+        case HLS_TAG_INF: return HLS_STR_INF;
+        case HLS_TAG_MEDIA: return HLS_STR_MEDIA;
+        case HLS_TAG_STREAM_INF: return HLS_STR_STREAM_INF;
+        case HLS_TAG_INDEPENDENT_SEGMENTS: return HLS_STR_INDEPENDENT_SEGMENTS;
+        case HLS_TAG_I_FRAME_STREAM_INF: return HLS_STR_I_FRAME_STREAM_INF;
+        case HLS_TAG_KEY: return HLS_STR_KEY;
+        case HLS_TAG_SESSION_KEY: return HLS_STR_SESSION_KEY;
+        case HLS_TAG_BYTE_RANGE: return HLS_STR_BYTERANGE;
+        case HLS_TAG_PLAYLIST_TYPE: return HLS_STR_PLAYLIST_TYPE;
+        case HLS_TAG_MAP: return HLS_STR_MAP;
+        case HLS_TAG_DISCONTINUITY: return HLS_STR_DISCONTINUITY;
+        case HLS_TAG_ENDLIST: return HLS_STR_ENDLIST;
+    }
+}
+
+const char* hls_attr2str(hls_attr_t attr)
+{
+    switch (attr) {
+        default:
+        case HLS_ATTR_IGNORE: return HLS_STR_IGNORE;
+        case HLS_ATTR_VERSION: return HLS_STR_VERSION;
+        case HLS_ATTR_DURATION: return HLS_STR_DURATION;
+        case HLS_ATTR_TITLE: return HLS_STR_TITLE;
+        case HLS_ATTR_TYPE: return HLS_STR_TYPE;
+        case HLS_ATTR_GROUP_ID: return HLS_STR_GROUP_ID;
+        case HLS_ATTR_NAME: return HLS_STR_NAME;
+        case HLS_ATTR_LANGUAGE: return HLS_STR_LANGUAGE;
+        case HLS_ATTR_AUTO_SELECT: return HLS_STR_AUTO_SELECT;
+        case HLS_ATTR_URI: return HLS_STR_URI;
+        case HLS_ATTR_BANDWIDTH: return HLS_STR_BANDWIDTH;
+        case HLS_ATTR_CODECS: return HLS_STR_CODECS;
+        case HLS_ATTR_RESOLUTION: return HLS_STR_RESOLUTION;
+        case HLS_ATTR_DEFAULT: return HLS_STR_DEFAULT;
+        case HLS_ATTR_FORCED: return HLS_STR_FORCED;
+        case HLS_ATTR_AUDIO: return HLS_STR_AUDIO;
+        case HLS_ATTR_SUBTITLES: return HLS_STR_SUBTITLES;
+        case HLS_ATTR_PROGRAM_ID: return HLS_STR_PROGRAM_ID;
+        case HLS_ATTR_INT: return HLS_STR_INT;
+        case HLS_ATTR_METHOD: return HLS_STR_METHOD;
+        case HLS_ATTR_IV: return HLS_STR_IV;
+        case HLS_ATTR_KEYFORMAT: return HLS_STR_KEYFORMAT;
+        case HLS_ATTR_KEYFORMAT_VERSION: return HLS_STR_KEYFORMATVERSION;
+    }
+}
diff --git a/components/audio_stream/lib/hls/hls_parse.h b/components/audio_stream/lib/hls/hls_parse.h
index 7f6ec160..d33e54a9 100644
--- a/components/audio_stream/lib/hls/hls_parse.h
+++ b/components/audio_stream/lib/hls/hls_parse.h
@@ -1,293 +1,293 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef HLS_PARSE_H
-#define HLS_PARSE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <stdint.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include "line_reader.h"
-
-#define HLS_MAX_ATTR_NUM             (16)
-#define HLS_MAX_LINE_CHAR            (512)
-
-#define HLS_STR_AES_128              "AES-128"
-#define HLS_STR_AUDIO                "AUDIO"
-#define HLS_STR_AUTOSELECT           "AUTOSELECT"
-#define HLS_STR_AUTO_SELECT          "AUTO-SELECT"
-#define HLS_STR_BANDWIDTH            "BANDWIDTH"
-#define HLS_STR_BYTERANGE            "BYTERANGE"
-#define HLS_STR_CLOSED_CAPTIONS      "CLOSED-CAPTIONS"
-#define HLS_STR_CODECS               "CODECS"
-#define HLS_STR_DEFAULT              "DEFAULT"
-#define HLS_STR_DISCONTINUITY        "DISCONTINUITY"
-#define HLS_STR_DURATION             "DURATION"
-#define HLS_STR_ENDLIST              "ENDLIST"
-#define HLS_STR_EVENT                "EVENT"
-#define HLS_STR_EXT                  "#EXT"
-#define HLS_STR_EXTINF               "#EXTINF:"
-#define HLS_STR_EXTM3U               "#EXTM3U"
-#define HLS_STR_EXT_X_               "#EXT-X-"
-#define HLS_STR_EXT_X_MEDIA          "#EXT-X-MEDIA:"
-#define HLS_STR_EXT_X_STREAM_INF     "#EXT-X-STREAM-INF:"
-#define HLS_STR_FORCED               "FORCED"
-#define HLS_STR_GROUP_ID             "GROUP-ID"
-#define HLS_STR_IGNORE               "IGNORE"
-#define HLS_STR_INDEPENDENT_SEGMENTS "INDEPENDENT-SEGMENTS"
-#define HLS_STR_INF                  "INF"
-#define HLS_STR_INT                  "INT"
-#define HLS_STR_IV                   "IV"
-#define HLS_STR_I_FRAME_STREAM_INF   "I-FRAME-STREAM-INF"
-#define HLS_STR_KEY                  "KEY"
-#define HLS_STR_KEYFORMAT            "KEYFORMAT"
-#define HLS_STR_KEYFORMATVERSION     "KEYFORMATVERSION"
-#define HLS_STR_LANGUAGE             "LANGUAGE"
-#define HLS_STR_MAP                  "MAP"
-#define HLS_STR_MEDIA                "MEDIA"
-#define HLS_STR_MEDIA_SEQUENCE       "MEDIA-SEQUENCE"
-#define HLS_STR_METHOD               "METHOD"
-#define HLS_STR_NAME                 "NAME"
-#define HLS_STR_PLAYLIST_TYPE        "PLAYLIST-TYPE"
-#define HLS_STR_PROGRAM_ID           "PROGRAM-ID"
-#define HLS_STR_RESOLUTION           "RESOLUTION"
-#define HLS_STR_SAMPLE_AES           "SAMPLE-AES"
-#define HLS_STR_SESSION_KEY          "SESSION-KEY"
-#define HLS_STR_STREAM_INF           "STREAM-INF"
-#define HLS_STR_SUBTITLES            "SUBTITLES"
-#define HLS_STR_TARGETDURATION       "TARGETDURATION"
-#define HLS_STR_TITLE                "TITLE"
-#define HLS_STR_TYPE                 "TYPE"
-#define HLS_STR_URI                  "URI"
-#define HLS_STR_VERSION              "VERSION"
-#define HLS_STR_VIDEO                "VIDEO"
-#define HLS_STR_VOD                  "VOD"
-#define HLS_STR_YES                  "YES"
-
-/**
- * @brief HLS tag type
- */
-typedef enum {
-    HLS_TAG_IGNORE,
-    HLS_TAG_VERSION,
-    HLS_TAG_MEDIA_SEQUENCE,
-    HLS_TAG_TARGET_DURATION,
-    HLS_TAG_INF,
-    HLS_TAG_MEDIA,
-    HLS_TAG_STREAM_INF,
-    HLS_TAG_I_FRAME_STREAM_INF,
-    HLS_TAG_KEY,
-    HLS_TAG_SESSION_KEY,
-    HLS_TAG_BYTE_RANGE,
-    HLS_TAG_PLAYLIST_TYPE,
-    HLS_TAG_MAP,
-    HLS_TAG_DISCONTINUITY,
-    HLS_TAG_INDEPENDENT_SEGMENTS,
-    HLS_TAG_INF_APPEND,       // Fake tag to avoid strdup
-    HLS_TAG_STREAM_INF_APPEND,
-    HLS_TAG_ENDLIST,
-} hls_tag_t;
-
-/**
- * @brief Attribute type of HLS tag
- */
-typedef enum {
-    HLS_ATTR_IGNORE,
-    HLS_ATTR_VERSION,
-    HLS_ATTR_DURATION,
-    HLS_ATTR_TITLE,
-    HLS_ATTR_TYPE,
-    HLS_ATTR_GROUP_ID,
-    HLS_ATTR_NAME,
-    HLS_ATTR_LANGUAGE,
-    HLS_ATTR_AUTO_SELECT,
-    HLS_ATTR_URI,
-    HLS_ATTR_BANDWIDTH,
-    HLS_ATTR_CODECS,
-    HLS_ATTR_RESOLUTION,
-    HLS_ATTR_DEFAULT,
-    HLS_ATTR_FORCED,
-    HLS_ATTR_AUDIO,
-    HLS_ATTR_SUBTITLES,
-    HLS_ATTR_PROGRAM_ID,
-    HLS_ATTR_INT,
-    HLS_ATTR_METHOD,
-    HLS_ATTR_IV,
-    HLS_ATTR_KEYFORMAT,
-    HLS_ATTR_KEYFORMAT_VERSION,
-} hls_attr_t;
-
-/**
- * @brief HLS stream type
- */
-typedef enum {
-    HLS_TYPE_AUDIO,          /*!< Contain audio */
-    HLS_TYPE_VIDEO,          /*!< Contain video */
-    HLS_TYPE_SUBTITLES,      /*!< Contain subtitle */
-    HLS_TYPE_CLOSED_CAPTION, /*!< Contain close caption */
-    HLS_TYPE_AV,             /*!< Contain both audio and video in one url */
-} hls_type_t;
-
-/**
- * @brief HLS encrypt type
- */
-typedef enum {
-    HLS_ENCRYPT_METHOD_NONE,
-    HLS_ENCRYPT_METHOD_AES128,
-    HLS_ENCRYPT_METHOD_SAMPLE_AES,
-} hls_encrypt_method_t;
-
-/**
- * @brief File type of HLS playlist
- */
-typedef enum {
-    HLS_FILE_TYPE_NONE,
-    HLS_FILE_TYPE_MASTER_PLAYLIST,
-    HLS_FILE_TYPE_MEDIA_PLAYLIST
-} hls_file_type_t;
-
-/**
- * @brief Type of HLS playlist
- */
-typedef enum {
-   HLS_PLAYLIST_TYPE_EVENT,  /*!< Playlist file is dynamic. Need reload. */
-   HLS_PLAYLIST_TYPE_VOD,    /*!< Playlist file is constant. Need load only once. */
-} hls_playlist_type_t;
-
-/**
- * @brief Attribute union of HLS tag
- */
-typedef union {
-    uint64_t   v;  /*!< Decimal integer */
-    float      f;  /*!< Float */
-    char*      s;  /*!< String */
-} hls_attr_value_t;
-
-/**
- * @brief Struct for HLS parser
- */
-typedef struct {
-    line_reader_t*   reader;                   /*!< Line reader instance */
-    hls_tag_t        tag;                      /*!< Type of HLS tag */
-    int              attr_num;                 /*!< Attribute number of HLS tag */
-    char*            attr[HLS_MAX_ATTR_NUM];   /*!< Attribute string of HLS tag */
-    hls_attr_t       k[HLS_MAX_ATTR_NUM];      /*!< Attribute type of HLS tag */
-    hls_attr_value_t v[HLS_MAX_ATTR_NUM];      /*!< Attribute value of HLS tag */
-} hls_parse_t;
-
-/**
- * @brief HLS tag information
- */
-typedef struct {
-    hls_tag_t         tag;                     /*!< Type of HLS tag */
-    int               attr_num;                /*!< Attribute number of HLS tag */
-    hls_attr_t*       k;                       /*!< Attribute type of HLS tag */
-    hls_attr_value_t* v;                       /*!< Attribute value of HLS tag */
-} hls_tag_info_t;
-
-typedef int (*hls_tag_callback) (hls_tag_info_t* tag_info, void* ctx);
-
-/**
- * @brief       Check whether input buffer match an Extended M3U Playlist file
- *
- * @param       b: Input Data
- * @param       len: Input Data length
- * @return      -true: Matched ok
- *              -false: Not matched
- */
-bool hls_matched(uint8_t* b, int len);
-
-/**
- * @brief       Check HLS file type
- *
- * @param       b: Input Data
- * @param       len: Input Data length
- * @return      Recognize HLS file type media playlist file or master playlist file
- *              -HLS_FILE_TYPE_NONE on fail
- */
-hls_file_type_t hls_get_file_type(uint8_t* b, int len);
-
-/**
- * @brief       Initialize HLS parser
- *
- * @param       parser: HLS parser struct
- * @return      -0: On success otherwise fail
- */
-int hls_parse_init(hls_parse_t* parser);
-
-/**
- * @brief       Add buffer for HLS parser
- *
- * @param       parser: HLS parser instance
- * @param       buffer: Buffer to be parsed
- * @param       size: Buffer size
- * @param       eos: Whether it is last buffer or not
- * @return      -0: On success otherwise parser not initialized
- */
-int hls_parse_add_buffer(hls_parse_t* parser, uint8_t* buffer, int size, bool eos);
-
-/**
- * @brief       Start parsing of input data
- *
- * @param       parser: HLS parser instance
- * @param       cb: HLS tag callback
- * @param       ctx: Input context
- * @return      -0: On success otherwise parse fail
- */
-int hls_parse(hls_parse_t* parser, hls_tag_callback cb, void* ctx);
-
-/**
- * @brief       Deinitialize of HLS parser
- *
- * @param       parser HLS parser instance
- */
-void hls_parse_deinit(hls_parse_t* parser);
-
-/**
- * @brief       Convert HLS tag to string 
- *
- * @param       tag: HLS tag
- * @return      String representation of tag
- */
-const char* hls_tag2str(hls_tag_t tag);
-
-/**
- * @brief       Convert HLS tag attribute to string 
- *
- * @param       attr: HLS tag attribute
- * @return      String representation of tag attribute
- */
-const char* hls_attr2str(hls_attr_t attr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef HLS_PARSE_H
+#define HLS_PARSE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "line_reader.h"
+
+#define HLS_MAX_ATTR_NUM             (16)
+#define HLS_MAX_LINE_CHAR            (512)
+
+#define HLS_STR_AES_128              "AES-128"
+#define HLS_STR_AUDIO                "AUDIO"
+#define HLS_STR_AUTOSELECT           "AUTOSELECT"
+#define HLS_STR_AUTO_SELECT          "AUTO-SELECT"
+#define HLS_STR_BANDWIDTH            "BANDWIDTH"
+#define HLS_STR_BYTERANGE            "BYTERANGE"
+#define HLS_STR_CLOSED_CAPTIONS      "CLOSED-CAPTIONS"
+#define HLS_STR_CODECS               "CODECS"
+#define HLS_STR_DEFAULT              "DEFAULT"
+#define HLS_STR_DISCONTINUITY        "DISCONTINUITY"
+#define HLS_STR_DURATION             "DURATION"
+#define HLS_STR_ENDLIST              "ENDLIST"
+#define HLS_STR_EVENT                "EVENT"
+#define HLS_STR_EXT                  "#EXT"
+#define HLS_STR_EXTINF               "#EXTINF:"
+#define HLS_STR_EXTM3U               "#EXTM3U"
+#define HLS_STR_EXT_X_               "#EXT-X-"
+#define HLS_STR_EXT_X_MEDIA          "#EXT-X-MEDIA:"
+#define HLS_STR_EXT_X_STREAM_INF     "#EXT-X-STREAM-INF:"
+#define HLS_STR_FORCED               "FORCED"
+#define HLS_STR_GROUP_ID             "GROUP-ID"
+#define HLS_STR_IGNORE               "IGNORE"
+#define HLS_STR_INDEPENDENT_SEGMENTS "INDEPENDENT-SEGMENTS"
+#define HLS_STR_INF                  "INF"
+#define HLS_STR_INT                  "INT"
+#define HLS_STR_IV                   "IV"
+#define HLS_STR_I_FRAME_STREAM_INF   "I-FRAME-STREAM-INF"
+#define HLS_STR_KEY                  "KEY"
+#define HLS_STR_KEYFORMAT            "KEYFORMAT"
+#define HLS_STR_KEYFORMATVERSION     "KEYFORMATVERSION"
+#define HLS_STR_LANGUAGE             "LANGUAGE"
+#define HLS_STR_MAP                  "MAP"
+#define HLS_STR_MEDIA                "MEDIA"
+#define HLS_STR_MEDIA_SEQUENCE       "MEDIA-SEQUENCE"
+#define HLS_STR_METHOD               "METHOD"
+#define HLS_STR_NAME                 "NAME"
+#define HLS_STR_PLAYLIST_TYPE        "PLAYLIST-TYPE"
+#define HLS_STR_PROGRAM_ID           "PROGRAM-ID"
+#define HLS_STR_RESOLUTION           "RESOLUTION"
+#define HLS_STR_SAMPLE_AES           "SAMPLE-AES"
+#define HLS_STR_SESSION_KEY          "SESSION-KEY"
+#define HLS_STR_STREAM_INF           "STREAM-INF"
+#define HLS_STR_SUBTITLES            "SUBTITLES"
+#define HLS_STR_TARGETDURATION       "TARGETDURATION"
+#define HLS_STR_TITLE                "TITLE"
+#define HLS_STR_TYPE                 "TYPE"
+#define HLS_STR_URI                  "URI"
+#define HLS_STR_VERSION              "VERSION"
+#define HLS_STR_VIDEO                "VIDEO"
+#define HLS_STR_VOD                  "VOD"
+#define HLS_STR_YES                  "YES"
+
+/**
+ * @brief HLS tag type
+ */
+typedef enum {
+    HLS_TAG_IGNORE,
+    HLS_TAG_VERSION,
+    HLS_TAG_MEDIA_SEQUENCE,
+    HLS_TAG_TARGET_DURATION,
+    HLS_TAG_INF,
+    HLS_TAG_MEDIA,
+    HLS_TAG_STREAM_INF,
+    HLS_TAG_I_FRAME_STREAM_INF,
+    HLS_TAG_KEY,
+    HLS_TAG_SESSION_KEY,
+    HLS_TAG_BYTE_RANGE,
+    HLS_TAG_PLAYLIST_TYPE,
+    HLS_TAG_MAP,
+    HLS_TAG_DISCONTINUITY,
+    HLS_TAG_INDEPENDENT_SEGMENTS,
+    HLS_TAG_INF_APPEND,       // Fake tag to avoid strdup
+    HLS_TAG_STREAM_INF_APPEND,
+    HLS_TAG_ENDLIST,
+} hls_tag_t;
+
+/**
+ * @brief Attribute type of HLS tag
+ */
+typedef enum {
+    HLS_ATTR_IGNORE,
+    HLS_ATTR_VERSION,
+    HLS_ATTR_DURATION,
+    HLS_ATTR_TITLE,
+    HLS_ATTR_TYPE,
+    HLS_ATTR_GROUP_ID,
+    HLS_ATTR_NAME,
+    HLS_ATTR_LANGUAGE,
+    HLS_ATTR_AUTO_SELECT,
+    HLS_ATTR_URI,
+    HLS_ATTR_BANDWIDTH,
+    HLS_ATTR_CODECS,
+    HLS_ATTR_RESOLUTION,
+    HLS_ATTR_DEFAULT,
+    HLS_ATTR_FORCED,
+    HLS_ATTR_AUDIO,
+    HLS_ATTR_SUBTITLES,
+    HLS_ATTR_PROGRAM_ID,
+    HLS_ATTR_INT,
+    HLS_ATTR_METHOD,
+    HLS_ATTR_IV,
+    HLS_ATTR_KEYFORMAT,
+    HLS_ATTR_KEYFORMAT_VERSION,
+} hls_attr_t;
+
+/**
+ * @brief HLS stream type
+ */
+typedef enum {
+    HLS_TYPE_AUDIO,          /*!< Contain audio */
+    HLS_TYPE_VIDEO,          /*!< Contain video */
+    HLS_TYPE_SUBTITLES,      /*!< Contain subtitle */
+    HLS_TYPE_CLOSED_CAPTION, /*!< Contain close caption */
+    HLS_TYPE_AV,             /*!< Contain both audio and video in one url */
+} hls_type_t;
+
+/**
+ * @brief HLS encrypt type
+ */
+typedef enum {
+    HLS_ENCRYPT_METHOD_NONE,
+    HLS_ENCRYPT_METHOD_AES128,
+    HLS_ENCRYPT_METHOD_SAMPLE_AES,
+} hls_encrypt_method_t;
+
+/**
+ * @brief File type of HLS playlist
+ */
+typedef enum {
+    HLS_FILE_TYPE_NONE,
+    HLS_FILE_TYPE_MASTER_PLAYLIST,
+    HLS_FILE_TYPE_MEDIA_PLAYLIST
+} hls_file_type_t;
+
+/**
+ * @brief Type of HLS playlist
+ */
+typedef enum {
+   HLS_PLAYLIST_TYPE_EVENT,  /*!< Playlist file is dynamic. Need reload. */
+   HLS_PLAYLIST_TYPE_VOD,    /*!< Playlist file is constant. Need load only once. */
+} hls_playlist_type_t;
+
+/**
+ * @brief Attribute union of HLS tag
+ */
+typedef union {
+    uint64_t   v;  /*!< Decimal integer */
+    float      f;  /*!< Float */
+    char*      s;  /*!< String */
+} hls_attr_value_t;
+
+/**
+ * @brief Struct for HLS parser
+ */
+typedef struct {
+    line_reader_t*   reader;                   /*!< Line reader instance */
+    hls_tag_t        tag;                      /*!< Type of HLS tag */
+    int              attr_num;                 /*!< Attribute number of HLS tag */
+    char*            attr[HLS_MAX_ATTR_NUM];   /*!< Attribute string of HLS tag */
+    hls_attr_t       k[HLS_MAX_ATTR_NUM];      /*!< Attribute type of HLS tag */
+    hls_attr_value_t v[HLS_MAX_ATTR_NUM];      /*!< Attribute value of HLS tag */
+} hls_parse_t;
+
+/**
+ * @brief HLS tag information
+ */
+typedef struct {
+    hls_tag_t         tag;                     /*!< Type of HLS tag */
+    int               attr_num;                /*!< Attribute number of HLS tag */
+    hls_attr_t*       k;                       /*!< Attribute type of HLS tag */
+    hls_attr_value_t* v;                       /*!< Attribute value of HLS tag */
+} hls_tag_info_t;
+
+typedef int (*hls_tag_callback) (hls_tag_info_t* tag_info, void* ctx);
+
+/**
+ * @brief       Check whether input buffer match an Extended M3U Playlist file
+ *
+ * @param       b: Input Data
+ * @param       len: Input Data length
+ * @return      -true: Matched ok
+ *              -false: Not matched
+ */
+bool hls_matched(uint8_t* b, int len);
+
+/**
+ * @brief       Check HLS file type
+ *
+ * @param       b: Input Data
+ * @param       len: Input Data length
+ * @return      Recognize HLS file type media playlist file or master playlist file
+ *              -HLS_FILE_TYPE_NONE on fail
+ */
+hls_file_type_t hls_get_file_type(uint8_t* b, int len);
+
+/**
+ * @brief       Initialize HLS parser
+ *
+ * @param       parser: HLS parser struct
+ * @return      -0: On success otherwise fail
+ */
+int hls_parse_init(hls_parse_t* parser);
+
+/**
+ * @brief       Add buffer for HLS parser
+ *
+ * @param       parser: HLS parser instance
+ * @param       buffer: Buffer to be parsed
+ * @param       size: Buffer size
+ * @param       eos: Whether it is last buffer or not
+ * @return      -0: On success otherwise parser not initialized
+ */
+int hls_parse_add_buffer(hls_parse_t* parser, uint8_t* buffer, int size, bool eos);
+
+/**
+ * @brief       Start parsing of input data
+ *
+ * @param       parser: HLS parser instance
+ * @param       cb: HLS tag callback
+ * @param       ctx: Input context
+ * @return      -0: On success otherwise parse fail
+ */
+int hls_parse(hls_parse_t* parser, hls_tag_callback cb, void* ctx);
+
+/**
+ * @brief       Deinitialize of HLS parser
+ *
+ * @param       parser HLS parser instance
+ */
+void hls_parse_deinit(hls_parse_t* parser);
+
+/**
+ * @brief       Convert HLS tag to string 
+ *
+ * @param       tag: HLS tag
+ * @return      String representation of tag
+ */
+const char* hls_tag2str(hls_tag_t tag);
+
+/**
+ * @brief       Convert HLS tag attribute to string 
+ *
+ * @param       attr: HLS tag attribute
+ * @return      String representation of tag attribute
+ */
+const char* hls_attr2str(hls_attr_t attr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/lib/hls/hls_playlist.c b/components/audio_stream/lib/hls/hls_playlist.c
index 8281b922..ef13f70b 100644
--- a/components/audio_stream/lib/hls/hls_playlist.c
+++ b/components/audio_stream/lib/hls/hls_playlist.c
@@ -1,655 +1,655 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include <audio_mem.h>
-#include <audio_error.h>
-#include "esp_log.h"
-#include "hls_playlist.h"
-#include "join_path.h"
-#include "hls_parse.h"
-
-#define TAG "HLS_PLAYLIST"
-
-#define MEDIA_FLAG_AUTO_SELECT (1)
-#define MEDIA_FLAG_DEFAULT     (2)
-#define MEDIA_FLAG_FORCED      (4)
-
-#define HLS_MALLOC(type) (type*)audio_calloc(1, sizeof(type))
-#define HLS_FREE(b)      if (b) {audio_free(b); b = NULL;}
-
-/**
- * @brief Url tag information
- */
-typedef struct {
-    float duration;
-    char* uri;
-} hls_url_t;
-
-/**
- * @brief Key tag information
- *        Notes: only support identify KEYFORMAT currently
- */
-typedef struct {
-    hls_encrypt_method_t method;
-    char*                uri;
-    uint8_t              k[16];
-    uint8_t              iv[16];
-    uint16_t             range[2];  /*!< Indicate key applied url range */
-} hls_key_t;
-
-/**
- * @brief HLS media information
- */
-typedef struct {
-    uint8_t    media_flag;
-    hls_type_t type;
-    char*      group_id;
-    char*      name;
-    char*      lang;
-    char*      uri;
-} hls_media_t;
-
-/**
- * @brief HLS stream information
- */
-typedef struct {
-    uint16_t program_id;
-    uint32_t bandwidth;
-    char*    codec;
-    char*    audio;
-    char*    subtitle;
-    char*    resolution;
-    char*    uri;
-} hls_stream_t;
-
-/**
- * @brief HLS master playlist information
- */
-typedef struct {
-    uint8_t       ver;
-    uint16_t      media_num;
-    uint16_t      stream_num;
-    hls_media_t*  media;
-    hls_stream_t* stream;
-    char*         uri;
-} hls_master_playlist_t;
-
-/**
- * @brief HLS media playlist information
- */
-typedef struct {
-    uint8_t              ver;             /*!< Version */
-    hls_stream_t*        variant_stream;  /*!< Stream list of different bitrate */
-    bool                 active;          /*!< Stream is used or not */
-    hls_type_t           stream_type;     /*!< Stream type */
-    hls_playlist_type_t  type;            /*!< Playlist type change over time */
-    uint32_t             target_duration; /*!< Maximum segment duration */
-    uint16_t             url_num;         /*!< Record of url number */
-    uint16_t             url_alloc;       /*!< Allocated number of record */
-    uint16_t             key_num;         /*!< Key number */
-    uint16_t             current_url;     /*!< Current used url index in url_num */
-    float                current_time;    /*!< Current time to determine when to reload playlist file */
-    uint64_t             media_sequence;  /*!< Media sequence */
-    hls_url_t*           url_items;       /*!< Record of url */
-    hls_key_t*           key;             /*!< Record of key */
-    char*                uri;             /*!< Base url of media playlist */
-} hls_media_playlist_t;
-
-/**
- * @brief Struct for HLS instance
- */
-typedef struct {
-    hls_playlist_cfg_t      cfg;              /*!< HLS playlist configuration */
-    hls_parse_t             parser;           /*!< HLS parser */
-    hls_file_type_t         type;             /*!< Master playlist or media playlist */
-    uint8_t                 playlist_num;     /*!< Media playlist number */
-    hls_master_playlist_t*  master_playlist;  /*!< Master playlist information */
-    hls_media_playlist_t*   media_playlist;   /*!< Media playlist information */
-} hls_t;
-
-static int hls_fill_media_attr(hls_media_t* m, hls_tag_info_t* tag_info)
-{
-    for (int i = 0; i < tag_info->attr_num; i++) {
-        switch (tag_info->k[i]) {
-            case HLS_ATTR_AUTO_SELECT:
-                m->media_flag |= tag_info->v[i].v ? MEDIA_FLAG_AUTO_SELECT : 0;
-                break;
-            case HLS_ATTR_DEFAULT:
-                m->media_flag |= tag_info->v[i].v ? MEDIA_FLAG_DEFAULT : 0;
-                break;
-            case HLS_ATTR_FORCED:
-                m->media_flag |= tag_info->v[i].v ? MEDIA_FLAG_FORCED : 0;
-                break;
-            case HLS_ATTR_TYPE:
-                m->type = (hls_type_t)tag_info->v[i].v;
-                break;
-            case HLS_ATTR_GROUP_ID:
-                m->group_id = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_NAME:
-                m->name = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_LANGUAGE:
-                m->lang = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_URI:
-                m->uri = audio_strdup(tag_info->v[i].s);
-                break;
-            default:
-                break;
-        }
-    }
-    return 0;
-}
-
-static int hls_fill_stream_attr(hls_stream_t* s, hls_tag_info_t* tag_info)
-{
-    for (int i = 0; i < tag_info->attr_num; i++) {
-        switch (tag_info->k[i]) {
-            case HLS_ATTR_AUTO_SELECT:
-                s->program_id = (uint16_t)tag_info->v[i].v;
-                break;
-            case HLS_ATTR_BANDWIDTH:
-                s->bandwidth = (uint32_t)tag_info->v[i].v;
-                break;
-            case HLS_ATTR_CODECS:
-                s->codec = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_AUDIO:
-                s->audio = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_SUBTITLES:
-                s->subtitle = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_RESOLUTION:
-                s->resolution = audio_strdup(tag_info->v[i].s);
-                break;
-            case HLS_ATTR_URI:
-                s->uri = audio_strdup(tag_info->v[i].s);
-                break;
-            default:
-                break;
-        }
-    }
-    return 0;
-}
-
-static int hls_main_tag_cb(hls_tag_info_t* tag_info, void* ctx)
-{
-    hls_master_playlist_t* master_playlist = (hls_master_playlist_t*)ctx;
-    switch (tag_info->tag) {
-        case HLS_TAG_VERSION:
-            if (tag_info->attr_num) {
-                master_playlist->ver = (uint8_t)tag_info->v[0].v;
-            }
-            break;
-        case HLS_TAG_MEDIA:
-            if (tag_info->attr_num) {
-                hls_media_t* new_media = audio_realloc(master_playlist->media, sizeof(hls_media_t) * (master_playlist->media_num + 1));
-                AUDIO_MEM_CHECK(TAG, new_media, break);
-                if (new_media) {
-                    master_playlist->media = new_media;
-                    memset(&master_playlist->media[master_playlist->media_num], 0, sizeof(hls_media_t));
-                    hls_fill_media_attr(&master_playlist->media[master_playlist->media_num], tag_info);
-                    master_playlist->media_num++;
-                }
-            }
-            break;
-        case HLS_TAG_STREAM_INF:
-            if (tag_info->attr_num) {
-                hls_stream_t* new_stream = audio_realloc(master_playlist->stream, sizeof(hls_stream_t) * (master_playlist->stream_num + 1));
-                AUDIO_MEM_CHECK(TAG, new_stream, break);
-                if (new_stream) {
-                    master_playlist->stream = new_stream;
-                    memset(&master_playlist->stream[master_playlist->stream_num], 0, sizeof(hls_stream_t));
-                    hls_fill_stream_attr(&master_playlist->stream[master_playlist->stream_num], tag_info);
-                    master_playlist->stream_num++;
-                }
-            }
-            break;
-        case HLS_TAG_STREAM_INF_APPEND:
-            if (master_playlist->stream && master_playlist->stream_num) {
-                hls_fill_stream_attr(&master_playlist->stream[master_playlist->stream_num-1], tag_info);
-            }
-            break;
-        default:
-            break;
-    }
-    return 0;
-}
-
-static uint8_t h_to_i(char c)
-{
-    if (c >= 'a' && c <= 'z') {
-        return c - 'a';
-    }
-    if (c >= 'A' && c <= 'Z') {
-        return c - 'A';
-    }
-    return c - '0';
-}
-
-static void hls_hex_to_bin(uint8_t* v, char* s, int n)
-{
-    int i = 0;
-    while (i < n) {
-        *(v++) = (h_to_i(s[i]) << 4) + h_to_i(s[i+1]);
-        i += 2;
-    }
-}
-
-static int hls_media_tag_cb(hls_tag_info_t* tag_info, void* ctx)
-{
-    hls_t* hls = (hls_t*)ctx;
-    if (hls == NULL || hls->media_playlist == NULL) {
-        return -1;
-    }
-    hls_media_playlist_t* media = hls->media_playlist;
-    switch (tag_info->tag) {
-        case HLS_TAG_ENDLIST:
-            media->type = HLS_PLAYLIST_TYPE_VOD;
-            break;
-        case HLS_TAG_VERSION:
-            if (tag_info->attr_num) {
-                media->ver = (uint8_t)tag_info->v[0].v;
-            }
-            break;
-        case HLS_TAG_PLAYLIST_TYPE:
-            if (tag_info->attr_num) {
-                media->type = (hls_playlist_type_t)tag_info->v[0].v;
-            }
-            break;
-        case HLS_TAG_TARGET_DURATION:
-            if (tag_info->attr_num) {
-                media->target_duration = (uint32_t)tag_info->v[0].v;
-            }
-            break;
-        case HLS_TAG_MEDIA_SEQUENCE:
-            if (tag_info->attr_num) {
-                media->media_sequence = tag_info->v[0].v;
-            }
-            break;
-        case HLS_TAG_KEY:
-            if (tag_info->attr_num) {
-                // Only support one key currently
-                media->key_num = 1;
-                if (media->key == NULL) {
-                    media->key = (hls_key_t*) audio_calloc(1, sizeof(hls_key_t));
-                }
-                if (media->key == NULL) {
-                    ESP_LOGE(TAG, "No memory for key");
-                    break;
-                }
-                for (int i = 0; i < tag_info->attr_num; i++) {
-                    switch (tag_info->k[i]) {
-                        case HLS_ATTR_METHOD:
-                            media->key[0].method = (hls_encrypt_method_t)tag_info->v[i].v;
-                            break;
-                        case HLS_ATTR_IV: {
-                            char* v = tag_info->v[i].s;
-                            // Skip leading 0x
-                            if (strncasecmp(v, "0x", 2) == 0) {
-                                v += 2;
-                            }
-                            hls_hex_to_bin(media->key[0].iv, v, strlen(v));
-                            break;
-                        }
-                        case HLS_ATTR_URI:
-                            HLS_FREE(media->key[0].uri);
-                            media->key[0].uri = join_url(media->uri, tag_info->v[i].s);
-                            break;
-                        default:
-                            break;
-                    }
-                }
-            }
-            break;
-
-        case HLS_TAG_INF_APPEND:
-            for (int i = 0; i < tag_info->attr_num; i++) {
-                switch (tag_info->k[i]) {
-                    case HLS_ATTR_URI: {
-                        char* url = join_url(media->uri, tag_info->v[i].s);
-                        if (url) {
-                            hls->cfg.cb(url, hls->cfg.ctx);
-                            audio_free(url);
-                        }
-                        break;
-                    }
-                    default:
-                        break;
-                }
-            }
-            break;
-
-        default:
-            break;
-    }
-    return 0;
-}
-
-static hls_stream_t* hls_filter_stream(hls_master_playlist_t* main, uint32_t bitrate)
-{
-    if (main->stream_num == 0) {
-        return NULL;
-    }
-    int max_bitrate = 0;
-    hls_stream_t* sel_stream = NULL;
-    for (int i = 0; i < main->stream_num; i++) {
-        hls_stream_t* stream = &main->stream[i];
-        if (stream->bandwidth <= bitrate) {
-            if (stream->bandwidth > max_bitrate) {
-                max_bitrate = stream->bandwidth;
-                sel_stream = stream;
-            }
-        }
-    }
-    if (sel_stream == NULL) {
-        sel_stream = &main->stream[0];
-    }
-    return sel_stream;
-}
-
-static hls_media_t* hls_filter_media(hls_master_playlist_t* main, char* group_id, hls_type_t type)
-{
-    hls_media_t* sel = NULL;
-    if (group_id == NULL) {
-        return NULL;
-    }
-    for (int i = 0; i < main->media_num; i++) {
-        hls_media_t* m = &main->media[i];
-        if (m->uri && strcmp(m->group_id, group_id) == 0 && m->type == type) {
-            if (sel == NULL) {
-                sel = m;
-            }
-            else if ((m->media_flag & MEDIA_FLAG_AUTO_SELECT)) {
-                return m;
-            }
-        }
-    }
-    return sel;
-}
-
-static int hls_close_master_playlist(hls_t* hls, hls_master_playlist_t* m)
-{
-    //TODO add lock to wait parse exit
-    int i;
-    for (i = 0; i < m->media_num; i++) {
-        hls_media_t* media = &m->media[i];
-        HLS_FREE(media->group_id);
-        HLS_FREE(media->name);
-        HLS_FREE(media->lang);
-        HLS_FREE(media->uri);
-    }
-    HLS_FREE(m->media);
-    m->media_num = 0;
-    for (i = 0; i < m->stream_num; i++) {
-        hls_stream_t* stream = &m->stream[i];
-        HLS_FREE(stream->codec);
-        HLS_FREE(stream->audio);
-        HLS_FREE(stream->subtitle);
-        HLS_FREE(stream->resolution);
-        HLS_FREE(stream->uri);
-    }
-    HLS_FREE(m->stream);
-    m->stream_num = 0;
-    HLS_FREE(m->uri);
-    return 0;
-}
-
-static int hls_close_media_playlist(hls_t* hls, hls_media_playlist_t* media)
-{
-    int i;
-    // release key
-    for (i = 0; i < media->key_num; i++) {
-        hls_key_t* key = &media->key[i];
-        HLS_FREE(key->uri);
-    }
-    media->key_num = 0;
-    HLS_FREE(media->key);
-    // release url
-    for (i = 0; i < media->url_num; i++) {
-        hls_url_t* url = &media->url_items[i];
-        HLS_FREE(url->uri);
-    }
-    HLS_FREE(media->url_items);
-    HLS_FREE(media->uri);
-    return 0;
-}
-
-hls_handle_t hls_playlist_open(hls_playlist_cfg_t* cfg)
-{
-    hls_t* hls = HLS_MALLOC(hls_t);
-    if (hls == NULL) {
-        return NULL;
-    }
-    memcpy(&hls->cfg, cfg, sizeof(hls_playlist_cfg_t));
-    if (hls_parse_init(&hls->parser) != 0) {
-        HLS_FREE(hls);
-        return NULL;
-    }
-    hls->cfg.uri = strdup(cfg->uri);
-    return (hls_handle_t)hls;
-}
-
-bool hls_playlist_is_media_end(hls_handle_t h)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls && hls->media_playlist) {
-        return (hls->media_playlist->type == HLS_PLAYLIST_TYPE_VOD);
-    }
-    return false;
-}
-
-char* hls_playlist_get_prefer_url(hls_handle_t h, hls_stream_type_t type)
-{
-    hls_t* hls = (hls_t*) h;
-    if (hls == NULL || hls->master_playlist == NULL) {
-        return NULL;
-    }
-    hls_master_playlist_t* master_playlist = hls->master_playlist;
-    hls_stream_t* stream = hls_filter_stream(master_playlist, hls->cfg.prefer_bitrate);
-    if (stream == NULL || stream->uri == NULL) {
-        return NULL;
-    }
-    hls_media_t* audio = hls_filter_media(master_playlist, stream->audio, HLS_TYPE_AUDIO);
-    bool has_audio = (audio && audio->uri);
-    char* uri = NULL;
-    switch (type) {
-        case HLS_STREAM_TYPE_VIDEO:
-        case HLS_STREAM_TYPE_AV:
-            uri = stream->uri;
-            break;
-        case HLS_STREAM_TYPE_AUDIO:
-            uri = has_audio ? audio->uri : stream->uri;
-        break;
-        case HLS_STREAM_TYPE_SUBTITLE: {
-            hls_media_t* subtitle = hls_filter_media(master_playlist, stream->subtitle, HLS_TYPE_SUBTITLES);
-            if (subtitle) {
-                uri = subtitle->uri;
-            }
-            break;
-        }
-        default:
-            return NULL;
-    }
-    return uri ? join_url(hls->master_playlist->uri, uri) : NULL;
-}
-
-int hls_playlist_parse_data(hls_handle_t h, uint8_t* buffer, int size, bool eos)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL) {
-        return -1;
-    }
-    if (hls->type == HLS_FILE_TYPE_NONE) {
-        hls->type = hls_get_file_type(buffer, size);
-        if (hls->type == HLS_FILE_TYPE_NONE) {
-            return -1;
-        }
-        if (hls->type == HLS_FILE_TYPE_MEDIA_PLAYLIST) {
-            hls->media_playlist = HLS_MALLOC(hls_media_playlist_t);
-            if (hls->media_playlist == NULL) {
-                return -1;
-            }
-            hls->playlist_num = 1;
-            hls->media_playlist->uri = hls->cfg.uri;
-            hls->media_playlist->active = true;
-            hls->media_playlist->stream_type = HLS_TYPE_AV;
-            hls->cfg.uri = NULL;
-        } else if (hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
-            hls->master_playlist = HLS_MALLOC(hls_master_playlist_t);
-            if (hls->master_playlist == NULL) {
-                return -1;
-            }
-            hls->master_playlist->uri = hls->cfg.uri;
-            hls->cfg.uri = NULL;
-        }
-    }
-    hls_parse_add_buffer(&hls->parser, buffer, size, eos);
-    if (hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
-        hls_parse(&hls->parser, hls_main_tag_cb, hls->master_playlist);
-    }
-    if (hls->type == HLS_FILE_TYPE_MEDIA_PLAYLIST && hls->media_playlist) {
-        hls_parse(&hls->parser, hls_media_tag_cb, hls);
-    }
-    return 0;
-}
-
-int hls_playlist_parse_key(hls_handle_t h, uint8_t* buffer, int size)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL) {
-        return -1;
-    }
-    if (hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
-        return 0;
-    }
-    hls_media_playlist_t* media = hls->media_playlist;
-    if (media == NULL || media->key_num == 0) {
-        return 0;
-    }
-    if (media->key[0].method == HLS_ENCRYPT_METHOD_AES128) {
-        if (size == 16) {
-            memcpy(media->key[0].k, buffer, size);
-        } else if (size == 32) {
-            hls_hex_to_bin(media->key[0].k, (char*)buffer, 32);
-        } else {
-            ESP_LOGE(TAG, "Bad AES key size %d", size);
-        }
-        return 0;
-    }
-    return -1;
-}
-
-bool hls_playlist_is_encrypt(hls_handle_t h)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL || hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
-        return false;
-    }
-    hls_media_playlist_t* media = hls->media_playlist;
-    if (media && media->key_num && media->key[0].method != HLS_ENCRYPT_METHOD_NONE) {
-        return true;
-    }
-    return false;
-}
-
-const char* hls_playlist_get_key_uri(hls_handle_t h)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL || hls->media_playlist == NULL) {
-        return NULL;
-    }
-    hls_media_playlist_t* media = hls->media_playlist;
-    if (media->key_num && media->key[0].uri) {
-        return media->key[0].uri;
-    }
-    return NULL;
-}
-
-uint64_t hls_playlist_get_sequence_no(hls_handle_t h)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL || hls->media_playlist == NULL) {
-        return 0;
-    }
-    hls_media_playlist_t* media = hls->media_playlist;
-    return media->media_sequence;
-}
-
-int hls_playlist_get_key(hls_handle_t h, uint64_t sequence_no, hls_stream_key_t* key)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL || hls->media_playlist == NULL) {
-        return -1;
-    }
-    hls_media_playlist_t* media = hls->media_playlist;
-    if (media->key_num) {
-        memcpy(key->key, media->key[0].k, sizeof(key->key));
-        // Check has iv or not
-        if (media->key[0].iv[0]) {
-            memcpy(key->iv, media->key[0].iv, sizeof(key->iv));
-        } else {
-            // Convert sequence_no to iv
-            int idx = sizeof(key->iv)-1;
-            while (sequence_no) {
-                key->iv[idx--] = (sequence_no & 0xFF);
-                sequence_no >>= 8;
-            }
-            while (idx >= 0) {
-                key->iv[idx--] = 0;
-            }
-        }
-        return 0;
-    }
-    return -1;
-}
-
-bool hls_playlist_is_master(hls_handle_t h)
-{
-    hls_t* hls = (hls_t*)h;
-    return (hls && hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST);
-}
-
-int hls_playlist_close(hls_handle_t h)
-{
-    hls_t* hls = (hls_t*)h;
-    if (hls == NULL) {
-        return -1;
-    }
-    if (hls->master_playlist) {
-        hls_close_master_playlist(hls, hls->master_playlist);
-        HLS_FREE(hls->master_playlist);
-    }
-    for (int i = 0; i < hls->playlist_num; i++) {
-        hls_close_media_playlist(hls, &hls->media_playlist[i]);
-    }
-    hls_parse_deinit(&hls->parser);
-    HLS_FREE(hls->media_playlist);
-    HLS_FREE(hls->cfg.uri);
-    HLS_FREE(hls);
-    return 0;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include <audio_mem.h>
+#include <audio_error.h>
+#include "esp_log.h"
+#include "hls_playlist.h"
+#include "join_path.h"
+#include "hls_parse.h"
+
+#define TAG "HLS_PLAYLIST"
+
+#define MEDIA_FLAG_AUTO_SELECT (1)
+#define MEDIA_FLAG_DEFAULT     (2)
+#define MEDIA_FLAG_FORCED      (4)
+
+#define HLS_MALLOC(type) (type*)audio_calloc(1, sizeof(type))
+#define HLS_FREE(b)      if (b) {audio_free(b); b = NULL;}
+
+/**
+ * @brief Url tag information
+ */
+typedef struct {
+    float duration;
+    char* uri;
+} hls_url_t;
+
+/**
+ * @brief Key tag information
+ *        Notes: only support identify KEYFORMAT currently
+ */
+typedef struct {
+    hls_encrypt_method_t method;
+    char*                uri;
+    uint8_t              k[16];
+    uint8_t              iv[16];
+    uint16_t             range[2];  /*!< Indicate key applied url range */
+} hls_key_t;
+
+/**
+ * @brief HLS media information
+ */
+typedef struct {
+    uint8_t    media_flag;
+    hls_type_t type;
+    char*      group_id;
+    char*      name;
+    char*      lang;
+    char*      uri;
+} hls_media_t;
+
+/**
+ * @brief HLS stream information
+ */
+typedef struct {
+    uint16_t program_id;
+    uint32_t bandwidth;
+    char*    codec;
+    char*    audio;
+    char*    subtitle;
+    char*    resolution;
+    char*    uri;
+} hls_stream_t;
+
+/**
+ * @brief HLS master playlist information
+ */
+typedef struct {
+    uint8_t       ver;
+    uint16_t      media_num;
+    uint16_t      stream_num;
+    hls_media_t*  media;
+    hls_stream_t* stream;
+    char*         uri;
+} hls_master_playlist_t;
+
+/**
+ * @brief HLS media playlist information
+ */
+typedef struct {
+    uint8_t              ver;             /*!< Version */
+    hls_stream_t*        variant_stream;  /*!< Stream list of different bitrate */
+    bool                 active;          /*!< Stream is used or not */
+    hls_type_t           stream_type;     /*!< Stream type */
+    hls_playlist_type_t  type;            /*!< Playlist type change over time */
+    uint32_t             target_duration; /*!< Maximum segment duration */
+    uint16_t             url_num;         /*!< Record of url number */
+    uint16_t             url_alloc;       /*!< Allocated number of record */
+    uint16_t             key_num;         /*!< Key number */
+    uint16_t             current_url;     /*!< Current used url index in url_num */
+    float                current_time;    /*!< Current time to determine when to reload playlist file */
+    uint64_t             media_sequence;  /*!< Media sequence */
+    hls_url_t*           url_items;       /*!< Record of url */
+    hls_key_t*           key;             /*!< Record of key */
+    char*                uri;             /*!< Base url of media playlist */
+} hls_media_playlist_t;
+
+/**
+ * @brief Struct for HLS instance
+ */
+typedef struct {
+    hls_playlist_cfg_t      cfg;              /*!< HLS playlist configuration */
+    hls_parse_t             parser;           /*!< HLS parser */
+    hls_file_type_t         type;             /*!< Master playlist or media playlist */
+    uint8_t                 playlist_num;     /*!< Media playlist number */
+    hls_master_playlist_t*  master_playlist;  /*!< Master playlist information */
+    hls_media_playlist_t*   media_playlist;   /*!< Media playlist information */
+} hls_t;
+
+static int hls_fill_media_attr(hls_media_t* m, hls_tag_info_t* tag_info)
+{
+    for (int i = 0; i < tag_info->attr_num; i++) {
+        switch (tag_info->k[i]) {
+            case HLS_ATTR_AUTO_SELECT:
+                m->media_flag |= tag_info->v[i].v ? MEDIA_FLAG_AUTO_SELECT : 0;
+                break;
+            case HLS_ATTR_DEFAULT:
+                m->media_flag |= tag_info->v[i].v ? MEDIA_FLAG_DEFAULT : 0;
+                break;
+            case HLS_ATTR_FORCED:
+                m->media_flag |= tag_info->v[i].v ? MEDIA_FLAG_FORCED : 0;
+                break;
+            case HLS_ATTR_TYPE:
+                m->type = (hls_type_t)tag_info->v[i].v;
+                break;
+            case HLS_ATTR_GROUP_ID:
+                m->group_id = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_NAME:
+                m->name = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_LANGUAGE:
+                m->lang = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_URI:
+                m->uri = audio_strdup(tag_info->v[i].s);
+                break;
+            default:
+                break;
+        }
+    }
+    return 0;
+}
+
+static int hls_fill_stream_attr(hls_stream_t* s, hls_tag_info_t* tag_info)
+{
+    for (int i = 0; i < tag_info->attr_num; i++) {
+        switch (tag_info->k[i]) {
+            case HLS_ATTR_AUTO_SELECT:
+                s->program_id = (uint16_t)tag_info->v[i].v;
+                break;
+            case HLS_ATTR_BANDWIDTH:
+                s->bandwidth = (uint32_t)tag_info->v[i].v;
+                break;
+            case HLS_ATTR_CODECS:
+                s->codec = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_AUDIO:
+                s->audio = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_SUBTITLES:
+                s->subtitle = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_RESOLUTION:
+                s->resolution = audio_strdup(tag_info->v[i].s);
+                break;
+            case HLS_ATTR_URI:
+                s->uri = audio_strdup(tag_info->v[i].s);
+                break;
+            default:
+                break;
+        }
+    }
+    return 0;
+}
+
+static int hls_main_tag_cb(hls_tag_info_t* tag_info, void* ctx)
+{
+    hls_master_playlist_t* master_playlist = (hls_master_playlist_t*)ctx;
+    switch (tag_info->tag) {
+        case HLS_TAG_VERSION:
+            if (tag_info->attr_num) {
+                master_playlist->ver = (uint8_t)tag_info->v[0].v;
+            }
+            break;
+        case HLS_TAG_MEDIA:
+            if (tag_info->attr_num) {
+                hls_media_t* new_media = audio_realloc(master_playlist->media, sizeof(hls_media_t) * (master_playlist->media_num + 1));
+                AUDIO_MEM_CHECK(TAG, new_media, break);
+                if (new_media) {
+                    master_playlist->media = new_media;
+                    memset(&master_playlist->media[master_playlist->media_num], 0, sizeof(hls_media_t));
+                    hls_fill_media_attr(&master_playlist->media[master_playlist->media_num], tag_info);
+                    master_playlist->media_num++;
+                }
+            }
+            break;
+        case HLS_TAG_STREAM_INF:
+            if (tag_info->attr_num) {
+                hls_stream_t* new_stream = audio_realloc(master_playlist->stream, sizeof(hls_stream_t) * (master_playlist->stream_num + 1));
+                AUDIO_MEM_CHECK(TAG, new_stream, break);
+                if (new_stream) {
+                    master_playlist->stream = new_stream;
+                    memset(&master_playlist->stream[master_playlist->stream_num], 0, sizeof(hls_stream_t));
+                    hls_fill_stream_attr(&master_playlist->stream[master_playlist->stream_num], tag_info);
+                    master_playlist->stream_num++;
+                }
+            }
+            break;
+        case HLS_TAG_STREAM_INF_APPEND:
+            if (master_playlist->stream && master_playlist->stream_num) {
+                hls_fill_stream_attr(&master_playlist->stream[master_playlist->stream_num-1], tag_info);
+            }
+            break;
+        default:
+            break;
+    }
+    return 0;
+}
+
+static uint8_t h_to_i(char c)
+{
+    if (c >= 'a' && c <= 'z') {
+        return c - 'a';
+    }
+    if (c >= 'A' && c <= 'Z') {
+        return c - 'A';
+    }
+    return c - '0';
+}
+
+static void hls_hex_to_bin(uint8_t* v, char* s, int n)
+{
+    int i = 0;
+    while (i < n) {
+        *(v++) = (h_to_i(s[i]) << 4) + h_to_i(s[i+1]);
+        i += 2;
+    }
+}
+
+static int hls_media_tag_cb(hls_tag_info_t* tag_info, void* ctx)
+{
+    hls_t* hls = (hls_t*)ctx;
+    if (hls == NULL || hls->media_playlist == NULL) {
+        return -1;
+    }
+    hls_media_playlist_t* media = hls->media_playlist;
+    switch (tag_info->tag) {
+        case HLS_TAG_ENDLIST:
+            media->type = HLS_PLAYLIST_TYPE_VOD;
+            break;
+        case HLS_TAG_VERSION:
+            if (tag_info->attr_num) {
+                media->ver = (uint8_t)tag_info->v[0].v;
+            }
+            break;
+        case HLS_TAG_PLAYLIST_TYPE:
+            if (tag_info->attr_num) {
+                media->type = (hls_playlist_type_t)tag_info->v[0].v;
+            }
+            break;
+        case HLS_TAG_TARGET_DURATION:
+            if (tag_info->attr_num) {
+                media->target_duration = (uint32_t)tag_info->v[0].v;
+            }
+            break;
+        case HLS_TAG_MEDIA_SEQUENCE:
+            if (tag_info->attr_num) {
+                media->media_sequence = tag_info->v[0].v;
+            }
+            break;
+        case HLS_TAG_KEY:
+            if (tag_info->attr_num) {
+                // Only support one key currently
+                media->key_num = 1;
+                if (media->key == NULL) {
+                    media->key = (hls_key_t*) audio_calloc(1, sizeof(hls_key_t));
+                }
+                if (media->key == NULL) {
+                    ESP_LOGE(TAG, "No memory for key");
+                    break;
+                }
+                for (int i = 0; i < tag_info->attr_num; i++) {
+                    switch (tag_info->k[i]) {
+                        case HLS_ATTR_METHOD:
+                            media->key[0].method = (hls_encrypt_method_t)tag_info->v[i].v;
+                            break;
+                        case HLS_ATTR_IV: {
+                            char* v = tag_info->v[i].s;
+                            // Skip leading 0x
+                            if (strncasecmp(v, "0x", 2) == 0) {
+                                v += 2;
+                            }
+                            hls_hex_to_bin(media->key[0].iv, v, strlen(v));
+                            break;
+                        }
+                        case HLS_ATTR_URI:
+                            HLS_FREE(media->key[0].uri);
+                            media->key[0].uri = join_url(media->uri, tag_info->v[i].s);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+            break;
+
+        case HLS_TAG_INF_APPEND:
+            for (int i = 0; i < tag_info->attr_num; i++) {
+                switch (tag_info->k[i]) {
+                    case HLS_ATTR_URI: {
+                        char* url = join_url(media->uri, tag_info->v[i].s);
+                        if (url) {
+                            hls->cfg.cb(url, hls->cfg.ctx);
+                            audio_free(url);
+                        }
+                        break;
+                    }
+                    default:
+                        break;
+                }
+            }
+            break;
+
+        default:
+            break;
+    }
+    return 0;
+}
+
+static hls_stream_t* hls_filter_stream(hls_master_playlist_t* main, uint32_t bitrate)
+{
+    if (main->stream_num == 0) {
+        return NULL;
+    }
+    int max_bitrate = 0;
+    hls_stream_t* sel_stream = NULL;
+    for (int i = 0; i < main->stream_num; i++) {
+        hls_stream_t* stream = &main->stream[i];
+        if (stream->bandwidth <= bitrate) {
+            if (stream->bandwidth > max_bitrate) {
+                max_bitrate = stream->bandwidth;
+                sel_stream = stream;
+            }
+        }
+    }
+    if (sel_stream == NULL) {
+        sel_stream = &main->stream[0];
+    }
+    return sel_stream;
+}
+
+static hls_media_t* hls_filter_media(hls_master_playlist_t* main, char* group_id, hls_type_t type)
+{
+    hls_media_t* sel = NULL;
+    if (group_id == NULL) {
+        return NULL;
+    }
+    for (int i = 0; i < main->media_num; i++) {
+        hls_media_t* m = &main->media[i];
+        if (m->uri && strcmp(m->group_id, group_id) == 0 && m->type == type) {
+            if (sel == NULL) {
+                sel = m;
+            }
+            else if ((m->media_flag & MEDIA_FLAG_AUTO_SELECT)) {
+                return m;
+            }
+        }
+    }
+    return sel;
+}
+
+static int hls_close_master_playlist(hls_t* hls, hls_master_playlist_t* m)
+{
+    //TODO add lock to wait parse exit
+    int i;
+    for (i = 0; i < m->media_num; i++) {
+        hls_media_t* media = &m->media[i];
+        HLS_FREE(media->group_id);
+        HLS_FREE(media->name);
+        HLS_FREE(media->lang);
+        HLS_FREE(media->uri);
+    }
+    HLS_FREE(m->media);
+    m->media_num = 0;
+    for (i = 0; i < m->stream_num; i++) {
+        hls_stream_t* stream = &m->stream[i];
+        HLS_FREE(stream->codec);
+        HLS_FREE(stream->audio);
+        HLS_FREE(stream->subtitle);
+        HLS_FREE(stream->resolution);
+        HLS_FREE(stream->uri);
+    }
+    HLS_FREE(m->stream);
+    m->stream_num = 0;
+    HLS_FREE(m->uri);
+    return 0;
+}
+
+static int hls_close_media_playlist(hls_t* hls, hls_media_playlist_t* media)
+{
+    int i;
+    // release key
+    for (i = 0; i < media->key_num; i++) {
+        hls_key_t* key = &media->key[i];
+        HLS_FREE(key->uri);
+    }
+    media->key_num = 0;
+    HLS_FREE(media->key);
+    // release url
+    for (i = 0; i < media->url_num; i++) {
+        hls_url_t* url = &media->url_items[i];
+        HLS_FREE(url->uri);
+    }
+    HLS_FREE(media->url_items);
+    HLS_FREE(media->uri);
+    return 0;
+}
+
+hls_handle_t hls_playlist_open(hls_playlist_cfg_t* cfg)
+{
+    hls_t* hls = HLS_MALLOC(hls_t);
+    if (hls == NULL) {
+        return NULL;
+    }
+    memcpy(&hls->cfg, cfg, sizeof(hls_playlist_cfg_t));
+    if (hls_parse_init(&hls->parser) != 0) {
+        HLS_FREE(hls);
+        return NULL;
+    }
+    hls->cfg.uri = strdup(cfg->uri);
+    return (hls_handle_t)hls;
+}
+
+bool hls_playlist_is_media_end(hls_handle_t h)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls && hls->media_playlist) {
+        return (hls->media_playlist->type == HLS_PLAYLIST_TYPE_VOD);
+    }
+    return false;
+}
+
+char* hls_playlist_get_prefer_url(hls_handle_t h, hls_stream_type_t type)
+{
+    hls_t* hls = (hls_t*) h;
+    if (hls == NULL || hls->master_playlist == NULL) {
+        return NULL;
+    }
+    hls_master_playlist_t* master_playlist = hls->master_playlist;
+    hls_stream_t* stream = hls_filter_stream(master_playlist, hls->cfg.prefer_bitrate);
+    if (stream == NULL || stream->uri == NULL) {
+        return NULL;
+    }
+    hls_media_t* audio = hls_filter_media(master_playlist, stream->audio, HLS_TYPE_AUDIO);
+    bool has_audio = (audio && audio->uri);
+    char* uri = NULL;
+    switch (type) {
+        case HLS_STREAM_TYPE_VIDEO:
+        case HLS_STREAM_TYPE_AV:
+            uri = stream->uri;
+            break;
+        case HLS_STREAM_TYPE_AUDIO:
+            uri = has_audio ? audio->uri : stream->uri;
+        break;
+        case HLS_STREAM_TYPE_SUBTITLE: {
+            hls_media_t* subtitle = hls_filter_media(master_playlist, stream->subtitle, HLS_TYPE_SUBTITLES);
+            if (subtitle) {
+                uri = subtitle->uri;
+            }
+            break;
+        }
+        default:
+            return NULL;
+    }
+    return uri ? join_url(hls->master_playlist->uri, uri) : NULL;
+}
+
+int hls_playlist_parse_data(hls_handle_t h, uint8_t* buffer, int size, bool eos)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL) {
+        return -1;
+    }
+    if (hls->type == HLS_FILE_TYPE_NONE) {
+        hls->type = hls_get_file_type(buffer, size);
+        if (hls->type == HLS_FILE_TYPE_NONE) {
+            return -1;
+        }
+        if (hls->type == HLS_FILE_TYPE_MEDIA_PLAYLIST) {
+            hls->media_playlist = HLS_MALLOC(hls_media_playlist_t);
+            if (hls->media_playlist == NULL) {
+                return -1;
+            }
+            hls->playlist_num = 1;
+            hls->media_playlist->uri = hls->cfg.uri;
+            hls->media_playlist->active = true;
+            hls->media_playlist->stream_type = HLS_TYPE_AV;
+            hls->cfg.uri = NULL;
+        } else if (hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
+            hls->master_playlist = HLS_MALLOC(hls_master_playlist_t);
+            if (hls->master_playlist == NULL) {
+                return -1;
+            }
+            hls->master_playlist->uri = hls->cfg.uri;
+            hls->cfg.uri = NULL;
+        }
+    }
+    hls_parse_add_buffer(&hls->parser, buffer, size, eos);
+    if (hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
+        hls_parse(&hls->parser, hls_main_tag_cb, hls->master_playlist);
+    }
+    if (hls->type == HLS_FILE_TYPE_MEDIA_PLAYLIST && hls->media_playlist) {
+        hls_parse(&hls->parser, hls_media_tag_cb, hls);
+    }
+    return 0;
+}
+
+int hls_playlist_parse_key(hls_handle_t h, uint8_t* buffer, int size)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL) {
+        return -1;
+    }
+    if (hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
+        return 0;
+    }
+    hls_media_playlist_t* media = hls->media_playlist;
+    if (media == NULL || media->key_num == 0) {
+        return 0;
+    }
+    if (media->key[0].method == HLS_ENCRYPT_METHOD_AES128) {
+        if (size == 16) {
+            memcpy(media->key[0].k, buffer, size);
+        } else if (size == 32) {
+            hls_hex_to_bin(media->key[0].k, (char*)buffer, 32);
+        } else {
+            ESP_LOGE(TAG, "Bad AES key size %d", size);
+        }
+        return 0;
+    }
+    return -1;
+}
+
+bool hls_playlist_is_encrypt(hls_handle_t h)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL || hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST) {
+        return false;
+    }
+    hls_media_playlist_t* media = hls->media_playlist;
+    if (media && media->key_num && media->key[0].method != HLS_ENCRYPT_METHOD_NONE) {
+        return true;
+    }
+    return false;
+}
+
+const char* hls_playlist_get_key_uri(hls_handle_t h)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL || hls->media_playlist == NULL) {
+        return NULL;
+    }
+    hls_media_playlist_t* media = hls->media_playlist;
+    if (media->key_num && media->key[0].uri) {
+        return media->key[0].uri;
+    }
+    return NULL;
+}
+
+uint64_t hls_playlist_get_sequence_no(hls_handle_t h)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL || hls->media_playlist == NULL) {
+        return 0;
+    }
+    hls_media_playlist_t* media = hls->media_playlist;
+    return media->media_sequence;
+}
+
+int hls_playlist_get_key(hls_handle_t h, uint64_t sequence_no, hls_stream_key_t* key)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL || hls->media_playlist == NULL) {
+        return -1;
+    }
+    hls_media_playlist_t* media = hls->media_playlist;
+    if (media->key_num) {
+        memcpy(key->key, media->key[0].k, sizeof(key->key));
+        // Check has iv or not
+        if (media->key[0].iv[0]) {
+            memcpy(key->iv, media->key[0].iv, sizeof(key->iv));
+        } else {
+            // Convert sequence_no to iv
+            int idx = sizeof(key->iv)-1;
+            while (sequence_no) {
+                key->iv[idx--] = (sequence_no & 0xFF);
+                sequence_no >>= 8;
+            }
+            while (idx >= 0) {
+                key->iv[idx--] = 0;
+            }
+        }
+        return 0;
+    }
+    return -1;
+}
+
+bool hls_playlist_is_master(hls_handle_t h)
+{
+    hls_t* hls = (hls_t*)h;
+    return (hls && hls->type == HLS_FILE_TYPE_MASTER_PLAYLIST);
+}
+
+int hls_playlist_close(hls_handle_t h)
+{
+    hls_t* hls = (hls_t*)h;
+    if (hls == NULL) {
+        return -1;
+    }
+    if (hls->master_playlist) {
+        hls_close_master_playlist(hls, hls->master_playlist);
+        HLS_FREE(hls->master_playlist);
+    }
+    for (int i = 0; i < hls->playlist_num; i++) {
+        hls_close_media_playlist(hls, &hls->media_playlist[i]);
+    }
+    hls_parse_deinit(&hls->parser);
+    HLS_FREE(hls->media_playlist);
+    HLS_FREE(hls->cfg.uri);
+    HLS_FREE(hls);
+    return 0;
+}
diff --git a/components/audio_stream/lib/hls/include/hls_playlist.h b/components/audio_stream/lib/hls/include/hls_playlist.h
index c769ec0e..162ba36a 100644
--- a/components/audio_stream/lib/hls/include/hls_playlist.h
+++ b/components/audio_stream/lib/hls/include/hls_playlist.h
@@ -1,173 +1,173 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _HLS_PLAYLIST_H
-#define _HLS_PLAYLIST_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void* hls_handle_t;
-
-/**
- * @brief HLS stream type
- */
-typedef enum {
-   HLS_STREAM_TYPE_AUDIO,    /*!< Audio stream type */
-   HLS_STREAM_TYPE_VIDEO,    /*!< Video stream type */
-   HLS_STREAM_TYPE_AV,       /*!< Audio and Video stream type */
-   HLS_STREAM_TYPE_SUBTITLE, /*!< Subtitle stream type */
-} hls_stream_type_t;
-
-/**
- * @brief HLS AES key information
- */
-typedef struct {
-   char key[16];
-   char iv[16];
-} hls_stream_key_t;
-
-/**
- * @brief Callback for HLS media uri
- */
-typedef int (*hls_uri_callback) (char* uri, void* tag);
-
-/**
- * @brief HLS playlist parser configuration
- */
-typedef struct {
-    uint32_t         prefer_bitrate;   /*!< Prefer bitrate used to filter media playlist */
-    hls_uri_callback cb;               /*!< HLS media stream uri callback */
-    void*            ctx;              /*!< Input context */
-    char*            uri;              /*!< M3U8 host url */
-} hls_playlist_cfg_t;
-
-/**
- * @brief         Open HLS playlist parser
- *
- * @param         cfg: HLS filter configuration
- * @return        HLS parse handle
- */
-hls_handle_t hls_playlist_open(hls_playlist_cfg_t* cfg);
-
-/**
- * @brief         Check whether playlist is master playlist
- *
- * @param         h: HLS handle
- * @return        -true: Master playlist
- *                -false: Not master playlist
- */
-bool hls_playlist_is_master(hls_handle_t h);
-
-/**
- * @brief         Check whether media playlist contain #END-PLAYLIST tag
- *
- * @param         h: HLS handle
- * @return        -true: Contain end tag
- *                -false: Not contain
- */
-bool hls_playlist_is_media_end(hls_handle_t h);
-
-/**
- * @brief         Filter url by stream type and given bitrate
- *
- * @param         h: HLS handle
- * @param         type: HLS stream type
- * @return        Filtered stream url
- */
-char* hls_playlist_get_prefer_url(hls_handle_t h, hls_stream_type_t type);
-
-/**
- * @brief           Parse data of HLS playlist
- *
- * @param           h: HLS handle
- * @param           data: Data of m3u8 playlist
- * @param           size: Input data size
- * @param           eos: Whether input data reach file end or not
- * @return          -0: On sucess
- *                  -Others: Parse fail
- */
-int hls_playlist_parse_data(hls_handle_t h, uint8_t* data, int size, bool eos);
-
-/**
- * @brief         Check whether playlist is encrypt or not
- * @param         h: HLS handle
- * @return        -true: Content is encrypt
- *                -false: Content is clear
- */
-bool hls_playlist_is_encrypt(hls_handle_t h);
-
-/**
- * @brief         Get key URI string
- * @param         h: HLS handle
- * @return        -NULL: URI not existed
- *                -Others: URI string
- */
-const char *hls_playlist_get_key_uri(hls_handle_t h);
-
-/**
- * @brief         Get sequence number
- * @param         h: HLS handle
- * @return        Sequence number of first media url
- */
-uint64_t hls_playlist_get_sequence_no(hls_handle_t h);
-
-/**
- * @brief         Get AES key information
- * @param         h: HLS handle
- * @param         sequence_no: Sequence number
- * @param         key[out]: Key information
- * @return         0: Get key success
- *                -1: Key not existed
- */
-int hls_playlist_get_key(hls_handle_t h, uint64_t sequence_no, hls_stream_key_t* key);
-
-/**
- * @brief           Parse HLS key
- * @param           h: HLS handle
- * @param           buffer: Buffer for key content
- * @param           size: Key size
- * @return          0: On success
- *                  -1: Parse key fail
- */
-int hls_playlist_parse_key(hls_handle_t h, uint8_t* buffer, int size);
-
-/**
- * @brief         Close parse for HLS playlist
- *
- * @param           h: HLS handle
- * @return          -0: On success
- *                  other: Invalid input
- */
-int hls_playlist_close(hls_handle_t h);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _HLS_PLAYLIST_H
+#define _HLS_PLAYLIST_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void* hls_handle_t;
+
+/**
+ * @brief HLS stream type
+ */
+typedef enum {
+   HLS_STREAM_TYPE_AUDIO,    /*!< Audio stream type */
+   HLS_STREAM_TYPE_VIDEO,    /*!< Video stream type */
+   HLS_STREAM_TYPE_AV,       /*!< Audio and Video stream type */
+   HLS_STREAM_TYPE_SUBTITLE, /*!< Subtitle stream type */
+} hls_stream_type_t;
+
+/**
+ * @brief HLS AES key information
+ */
+typedef struct {
+   char key[16];
+   char iv[16];
+} hls_stream_key_t;
+
+/**
+ * @brief Callback for HLS media uri
+ */
+typedef int (*hls_uri_callback) (char* uri, void* tag);
+
+/**
+ * @brief HLS playlist parser configuration
+ */
+typedef struct {
+    uint32_t         prefer_bitrate;   /*!< Prefer bitrate used to filter media playlist */
+    hls_uri_callback cb;               /*!< HLS media stream uri callback */
+    void*            ctx;              /*!< Input context */
+    char*            uri;              /*!< M3U8 host url */
+} hls_playlist_cfg_t;
+
+/**
+ * @brief         Open HLS playlist parser
+ *
+ * @param         cfg: HLS filter configuration
+ * @return        HLS parse handle
+ */
+hls_handle_t hls_playlist_open(hls_playlist_cfg_t* cfg);
+
+/**
+ * @brief         Check whether playlist is master playlist
+ *
+ * @param         h: HLS handle
+ * @return        -true: Master playlist
+ *                -false: Not master playlist
+ */
+bool hls_playlist_is_master(hls_handle_t h);
+
+/**
+ * @brief         Check whether media playlist contain #END-PLAYLIST tag
+ *
+ * @param         h: HLS handle
+ * @return        -true: Contain end tag
+ *                -false: Not contain
+ */
+bool hls_playlist_is_media_end(hls_handle_t h);
+
+/**
+ * @brief         Filter url by stream type and given bitrate
+ *
+ * @param         h: HLS handle
+ * @param         type: HLS stream type
+ * @return        Filtered stream url
+ */
+char* hls_playlist_get_prefer_url(hls_handle_t h, hls_stream_type_t type);
+
+/**
+ * @brief           Parse data of HLS playlist
+ *
+ * @param           h: HLS handle
+ * @param           data: Data of m3u8 playlist
+ * @param           size: Input data size
+ * @param           eos: Whether input data reach file end or not
+ * @return          -0: On sucess
+ *                  -Others: Parse fail
+ */
+int hls_playlist_parse_data(hls_handle_t h, uint8_t* data, int size, bool eos);
+
+/**
+ * @brief         Check whether playlist is encrypt or not
+ * @param         h: HLS handle
+ * @return        -true: Content is encrypt
+ *                -false: Content is clear
+ */
+bool hls_playlist_is_encrypt(hls_handle_t h);
+
+/**
+ * @brief         Get key URI string
+ * @param         h: HLS handle
+ * @return        -NULL: URI not existed
+ *                -Others: URI string
+ */
+const char *hls_playlist_get_key_uri(hls_handle_t h);
+
+/**
+ * @brief         Get sequence number
+ * @param         h: HLS handle
+ * @return        Sequence number of first media url
+ */
+uint64_t hls_playlist_get_sequence_no(hls_handle_t h);
+
+/**
+ * @brief         Get AES key information
+ * @param         h: HLS handle
+ * @param         sequence_no: Sequence number
+ * @param         key[out]: Key information
+ * @return         0: Get key success
+ *                -1: Key not existed
+ */
+int hls_playlist_get_key(hls_handle_t h, uint64_t sequence_no, hls_stream_key_t* key);
+
+/**
+ * @brief           Parse HLS key
+ * @param           h: HLS handle
+ * @param           buffer: Buffer for key content
+ * @param           size: Key size
+ * @return          0: On success
+ *                  -1: Parse key fail
+ */
+int hls_playlist_parse_key(hls_handle_t h, uint8_t* buffer, int size);
+
+/**
+ * @brief         Close parse for HLS playlist
+ *
+ * @param           h: HLS handle
+ * @return          -0: On success
+ *                  other: Invalid input
+ */
+int hls_playlist_close(hls_handle_t h);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/lib/hls/include/join_path.h b/components/audio_stream/lib/hls/include/join_path.h
index 594e0bfa..415d10c8 100644
--- a/components/audio_stream/lib/hls/include/join_path.h
+++ b/components/audio_stream/lib/hls/include/join_path.h
@@ -1,45 +1,45 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef JOIN_PATH_H
-#define JOIN_PATH_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      Join two urls into one
- *
- * @param      host: Host uri address
- * @param      ext: Extension uri address
- *
- * @return     Full uri address
- */
-char* join_url(char* host, char* ext);
-
-#ifdef __cplusplus
-}
-#endif
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef JOIN_PATH_H
+#define JOIN_PATH_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      Join two urls into one
+ *
+ * @param      host: Host uri address
+ * @param      ext: Extension uri address
+ *
+ * @return     Full uri address
+ */
+char* join_url(char* host, char* ext);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif
\ No newline at end of file
diff --git a/components/audio_stream/lib/hls/include/line_reader.h b/components/audio_stream/lib/hls/include/line_reader.h
index 41020c68..ab313cf4 100644
--- a/components/audio_stream/lib/hls/include/line_reader.h
+++ b/components/audio_stream/lib/hls/include/line_reader.h
@@ -1,88 +1,88 @@
-
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef LINE_READER_H
-#define LINE_READER_H
-
-#include <stdint.h>
-#include <stdbool.h>
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Line reader struct
- */
-typedef struct {
-    uint8_t* buffer;           /*!< Input data */
-    int      size;             /*!< Input data size */
-    int      rp;               /*!< Read pointer of cache buffer */
-    bool     eos;              /*!< Input data end of stream */
-    uint8_t* line_buffer;      /*!< Cache buffers for input data */
-    uint16_t line_size;        /*!< Buffer size of cache buffer */
-    uint16_t line_fill;        /*!< Cached size */
-} line_reader_t;
-
-/**
- * @brief      Initialize line reader
- *
- * @param      line_size: Maximum characters in one line
- *
- * @return     Line reader instance
- */
-line_reader_t* line_reader_init(int line_size);
-
-/**
- * @brief      Add buffer to line reader
- *
- * @param      reader: Line reader instance
- * @param      buffer: Buffer to be parsed
- * @param      size: Buffer size to be parsed
- * @param      eos: Whether data to be processed reached end or not
- */
-void line_reader_add_buffer(line_reader_t* reader, uint8_t* buffer, int size, bool eos);
-
-/**
- * @brief      Get one line data from line reader
- *
- * @param      reader: Line reader instance
- * @param      buffer: Buffer to be parsed
- * @param      size: Buffer size
- * @return     Line data
- */
-char* line_reader_get_line(line_reader_t* reader);
-
-/**
- * @brief      Deinitialize line reader
- *
- * @param      reader: Line reader instance
- */
-void line_reader_deinit(line_reader_t* reader);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef LINE_READER_H
+#define LINE_READER_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Line reader struct
+ */
+typedef struct {
+    uint8_t* buffer;           /*!< Input data */
+    int      size;             /*!< Input data size */
+    int      rp;               /*!< Read pointer of cache buffer */
+    bool     eos;              /*!< Input data end of stream */
+    uint8_t* line_buffer;      /*!< Cache buffers for input data */
+    uint16_t line_size;        /*!< Buffer size of cache buffer */
+    uint16_t line_fill;        /*!< Cached size */
+} line_reader_t;
+
+/**
+ * @brief      Initialize line reader
+ *
+ * @param      line_size: Maximum characters in one line
+ *
+ * @return     Line reader instance
+ */
+line_reader_t* line_reader_init(int line_size);
+
+/**
+ * @brief      Add buffer to line reader
+ *
+ * @param      reader: Line reader instance
+ * @param      buffer: Buffer to be parsed
+ * @param      size: Buffer size to be parsed
+ * @param      eos: Whether data to be processed reached end or not
+ */
+void line_reader_add_buffer(line_reader_t* reader, uint8_t* buffer, int size, bool eos);
+
+/**
+ * @brief      Get one line data from line reader
+ *
+ * @param      reader: Line reader instance
+ * @param      buffer: Buffer to be parsed
+ * @param      size: Buffer size
+ * @return     Line data
+ */
+char* line_reader_get_line(line_reader_t* reader);
+
+/**
+ * @brief      Deinitialize line reader
+ *
+ * @param      reader: Line reader instance
+ */
+void line_reader_deinit(line_reader_t* reader);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/audio_stream/lib/hls/join_path.c b/components/audio_stream/lib/hls/join_path.c
index 9017eeff..837dd9c0 100644
--- a/components/audio_stream/lib/hls/join_path.c
+++ b/components/audio_stream/lib/hls/join_path.c
@@ -1,124 +1,124 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "audio_mem.h"
-#include "join_path.h"
-
-static char* get_slash(char* s, int len, int dir)
-{
-    if (len == 0) {
-        return NULL;
-    }
-    if (dir) {
-        while (len-- > 0) {
-           if (s[len] == '/') {
-               return &s[len];
-           }
-        }
-    } else {
-        char* e = s + len;
-        while (s < e) {
-            if (*(s++) == '/') {
-                if (*s == '/') {
-                   s++;
-                   continue;
-                }
-                return s-1;
-            }
-        }
-    }
-    return NULL;
-}
-
-char* join_url(char* base, char* ext)
-{
-    if (memcmp(ext, "http", 4) == 0) {
-        return audio_strdup(ext);
-    }
-    int base_len = strlen(base);
-    int ext_len  = strlen(ext);
-    int ext_skip = 0;
-    char* s;
-    if (memcmp(base, "http", 4)) {
-        // local path
-        char* ask = strchr(ext, '?');
-        if (ask > ext) {
-            ext_len = ask - ext;
-        }
-    }
-    if (*ext == '/') {
-        if (*(ext+1) == '/') {
-            s = strstr(base, "//");
-        } else {
-            s = get_slash(base, base_len, 0);
-        }
-        if (s == NULL) {
-           return NULL;
-        }
-        base_len = s - base;
-    } else if (*ext == '.') {
-        s = get_slash(base, base_len, 1);
-        if (s == NULL) {
-            return NULL;
-        }
-        base_len = s - base;
-        if (ext_len == 1) {
-            ext_skip = 1;
-        } else if (*(ext+1) == '/') {
-           ext_skip = 2;
-        } else {
-            while (memcmp(ext + ext_skip, "../", 3) == 0) {
-                ext_skip += 3;
-                s = get_slash(base, base_len, 1);
-                if (s == NULL) {
-                return NULL;
-                }
-                base_len = s - base;
-            }
-        }
-        base_len++;
-    } else if (*ext == '#') {
-    } else if (*ext == '?') {
-         char* a = strrchr(base, '?');
-         if (a) {
-             base_len = a - base;
-         }
-    } else {
-        s = get_slash(base, base_len, 1);
-        if (s == NULL) {
-            return NULL;
-        }
-        base_len = s - base + 1;
-    }
-    int t = base_len + ext_len - ext_skip + 1;
-    char* dst = (char*) audio_malloc(t);
-    if (dst == NULL) {
-        return dst;
-    }
-    memcpy(dst, base, base_len);
-    memcpy(dst + base_len, ext + ext_skip, ext_len - ext_skip);
-    dst[t-1] = 0;
-    return dst;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "audio_mem.h"
+#include "join_path.h"
+
+static char* get_slash(char* s, int len, int dir)
+{
+    if (len == 0) {
+        return NULL;
+    }
+    if (dir) {
+        while (len-- > 0) {
+           if (s[len] == '/') {
+               return &s[len];
+           }
+        }
+    } else {
+        char* e = s + len;
+        while (s < e) {
+            if (*(s++) == '/') {
+                if (*s == '/') {
+                   s++;
+                   continue;
+                }
+                return s-1;
+            }
+        }
+    }
+    return NULL;
+}
+
+char* join_url(char* base, char* ext)
+{
+    if (memcmp(ext, "http", 4) == 0) {
+        return audio_strdup(ext);
+    }
+    int base_len = strlen(base);
+    int ext_len  = strlen(ext);
+    int ext_skip = 0;
+    char* s;
+    if (memcmp(base, "http", 4)) {
+        // local path
+        char* ask = strchr(ext, '?');
+        if (ask > ext) {
+            ext_len = ask - ext;
+        }
+    }
+    if (*ext == '/') {
+        if (*(ext+1) == '/') {
+            s = strstr(base, "//");
+        } else {
+            s = get_slash(base, base_len, 0);
+        }
+        if (s == NULL) {
+           return NULL;
+        }
+        base_len = s - base;
+    } else if (*ext == '.') {
+        s = get_slash(base, base_len, 1);
+        if (s == NULL) {
+            return NULL;
+        }
+        base_len = s - base;
+        if (ext_len == 1) {
+            ext_skip = 1;
+        } else if (*(ext+1) == '/') {
+           ext_skip = 2;
+        } else {
+            while (memcmp(ext + ext_skip, "../", 3) == 0) {
+                ext_skip += 3;
+                s = get_slash(base, base_len, 1);
+                if (s == NULL) {
+                return NULL;
+                }
+                base_len = s - base;
+            }
+        }
+        base_len++;
+    } else if (*ext == '#') {
+    } else if (*ext == '?') {
+         char* a = strrchr(base, '?');
+         if (a) {
+             base_len = a - base;
+         }
+    } else {
+        s = get_slash(base, base_len, 1);
+        if (s == NULL) {
+            return NULL;
+        }
+        base_len = s - base + 1;
+    }
+    int t = base_len + ext_len - ext_skip + 1;
+    char* dst = (char*) audio_malloc(t);
+    if (dst == NULL) {
+        return dst;
+    }
+    memcpy(dst, base, base_len);
+    memcpy(dst + base_len, ext + ext_skip, ext_len - ext_skip);
+    dst[t-1] = 0;
+    return dst;
+}
diff --git a/components/audio_stream/lib/hls/line_reader.c b/components/audio_stream/lib/hls/line_reader.c
index 5c1b3f32..f1c1afcb 100644
--- a/components/audio_stream/lib/hls/line_reader.c
+++ b/components/audio_stream/lib/hls/line_reader.c
@@ -1,105 +1,105 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include "audio_mem.h"
-#include "esp_log.h"
-#include "line_reader.h"
-
-#define TAG "LINE_READER"
-
-static inline void line_reader_add_char(line_reader_t* b, uint8_t c)
-{
-    if (b->line_fill < b->line_size) {
-        b->line_buffer[b->line_fill++] = c;
-    } else {
-        ESP_LOGE(TAG, "Line too long try to init large than %d", b->line_size);
-    }
-}
-
-line_reader_t* line_reader_init(int line_size)
-{
-    line_reader_t* reader = (line_reader_t*) audio_calloc(1, sizeof(line_reader_t));
-    if (reader == NULL) {
-        return NULL;
-    }
-    reader->line_buffer = (uint8_t*)audio_malloc(line_size);
-    if (reader->line_buffer) {
-        reader->line_size = line_size;
-        return reader;
-    }
-    audio_free(reader);
-    return NULL;
-}
-
-void line_reader_add_buffer(line_reader_t* b, uint8_t* buffer, int size, bool eos)
-{
-    if (b) {
-        b->buffer = buffer;
-        b->size = size;
-        b->eos = eos;
-    }
-}
-
-char* line_reader_get_line(line_reader_t* b)
-{
-    if (b == NULL) {
-        return NULL;
-    }
-    while (b->rp < b->size) {
-        uint8_t c = b->buffer[b->rp];
-        if (c == '\r' || c == '\n') {
-            b->rp++;
-            if (b->line_fill) {
-                line_reader_add_char(b, 0);
-                b->line_fill = 0;
-                return (char*)b->line_buffer;
-            }
-            continue;
-        } else {
-            line_reader_add_char(b, c);
-        }
-        b->rp++;
-    }
-    if (b->eos && b->line_fill) {
-        line_reader_add_char(b, 0);
-        b->line_fill = 0;
-        return (char*)b->line_buffer;
-    }
-    b->rp = 0; // auto reset
-    b->size = 0;
-    return NULL;
-}
-
-void line_reader_deinit(line_reader_t* b)
-{
-    if (b) {
-        if (b->line_buffer) {
-            audio_free(b->line_buffer);
-        }
-        audio_free(b);
-    }
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include "audio_mem.h"
+#include "esp_log.h"
+#include "line_reader.h"
+
+#define TAG "LINE_READER"
+
+static inline void line_reader_add_char(line_reader_t* b, uint8_t c)
+{
+    if (b->line_fill < b->line_size) {
+        b->line_buffer[b->line_fill++] = c;
+    } else {
+        ESP_LOGE(TAG, "Line too long try to init large than %d", b->line_size);
+    }
+}
+
+line_reader_t* line_reader_init(int line_size)
+{
+    line_reader_t* reader = (line_reader_t*) audio_calloc(1, sizeof(line_reader_t));
+    if (reader == NULL) {
+        return NULL;
+    }
+    reader->line_buffer = (uint8_t*)audio_malloc(line_size);
+    if (reader->line_buffer) {
+        reader->line_size = line_size;
+        return reader;
+    }
+    audio_free(reader);
+    return NULL;
+}
+
+void line_reader_add_buffer(line_reader_t* b, uint8_t* buffer, int size, bool eos)
+{
+    if (b) {
+        b->buffer = buffer;
+        b->size = size;
+        b->eos = eos;
+    }
+}
+
+char* line_reader_get_line(line_reader_t* b)
+{
+    if (b == NULL) {
+        return NULL;
+    }
+    while (b->rp < b->size) {
+        uint8_t c = b->buffer[b->rp];
+        if (c == '\r' || c == '\n') {
+            b->rp++;
+            if (b->line_fill) {
+                line_reader_add_char(b, 0);
+                b->line_fill = 0;
+                return (char*)b->line_buffer;
+            }
+            continue;
+        } else {
+            line_reader_add_char(b, c);
+        }
+        b->rp++;
+    }
+    if (b->eos && b->line_fill) {
+        line_reader_add_char(b, 0);
+        b->line_fill = 0;
+        return (char*)b->line_buffer;
+    }
+    b->rp = 0; // auto reset
+    b->size = 0;
+    return NULL;
+}
+
+void line_reader_deinit(line_reader_t* b)
+{
+    if (b) {
+        if (b->line_buffer) {
+            audio_free(b->line_buffer);
+        }
+        audio_free(b);
+    }
+}
diff --git a/components/audio_stream/lib/hls/test/build.pl b/components/audio_stream/lib/hls/test/build.pl
old mode 100755
new mode 100644
index bff8b501..27521cd1
--- a/components/audio_stream/lib/hls/test/build.pl
+++ b/components/audio_stream/lib/hls/test/build.pl
@@ -1,52 +1,52 @@
-#!/usr/bin/perl
-my @f = <../*.c>;
-gen_fake_header();
-`gcc @f test.c -I../include -I../ -g -o ./test`;
-clear_up();
-
-sub clear_up {
-   unlink("../include/audio_mem.h");
-   unlink("../include/audio_error.h");
-   unlink("../include/esp_log.h");
-}
-
-sub gen_fake_header {
-    my $audio_mem =<< 'MEM_H';
-#include <string.h>
-#include <stdlib.h>
-#define audio_malloc  malloc
-#define audio_free    free
-#define audio_strdup  strdup
-#define audio_calloc  calloc
-#define audio_realloc realloc
-MEM_H
-
-    my $audio_error =<< 'ERROR_H';
-#include "esp_log.h"
-#define AUDIO_CHECK(TAG, a, action, msg) if (!(a)) {                                \
-        ESP_LOGE(TAG,"%s:%d (%s): %s", __FILE__, __LINE__, __FUNCTION__, msg);  \
-        action;                                                                     \
-        }
-#define AUDIO_MEM_CHECK(TAG, a, action)  AUDIO_CHECK(TAG, a, action, "Memory exhausted")
-ERROR_H
-
-   my $esp_log = << 'ESP_LOG_H';
-#include <stdarg.h>
-#define LOGOUT(tag, format, ...) printf("%s: "format, tag, ##__VA_ARGS__);
-#define ESP_LOGI LOGOUT
-#define ESP_LOGE LOGOUT
-#define ESP_LOGD LOGOUT
-#define ESP_LOGW LOGOUT
-ESP_LOG_H
-
-    write_file("../include/audio_mem.h", $audio_mem);
-    write_file("../include/audio_error.h", $audio_error);
-    write_file("../include/esp_log.h", $esp_log);
-}
-
-sub write_file {
-    my ($f, $str) = @_;
-    open(my $H, '+>', $f) || die "";
-    print $H $str;
-    close $H;
-}
+#!/usr/bin/perl
+my @f = <../*.c>;
+gen_fake_header();
+`gcc @f test.c -I../include -I../ -g -o ./test`;
+clear_up();
+
+sub clear_up {
+   unlink("../include/audio_mem.h");
+   unlink("../include/audio_error.h");
+   unlink("../include/esp_log.h");
+}
+
+sub gen_fake_header {
+    my $audio_mem =<< 'MEM_H';
+#include <string.h>
+#include <stdlib.h>
+#define audio_malloc  malloc
+#define audio_free    free
+#define audio_strdup  strdup
+#define audio_calloc  calloc
+#define audio_realloc realloc
+MEM_H
+
+    my $audio_error =<< 'ERROR_H';
+#include "esp_log.h"
+#define AUDIO_CHECK(TAG, a, action, msg) if (!(a)) {                                \
+        ESP_LOGE(TAG,"%s:%d (%s): %s", __FILE__, __LINE__, __FUNCTION__, msg);  \
+        action;                                                                     \
+        }
+#define AUDIO_MEM_CHECK(TAG, a, action)  AUDIO_CHECK(TAG, a, action, "Memory exhausted")
+ERROR_H
+
+   my $esp_log = << 'ESP_LOG_H';
+#include <stdarg.h>
+#define LOGOUT(tag, format, ...) printf("%s: "format, tag, ##__VA_ARGS__);
+#define ESP_LOGI LOGOUT
+#define ESP_LOGE LOGOUT
+#define ESP_LOGD LOGOUT
+#define ESP_LOGW LOGOUT
+ESP_LOG_H
+
+    write_file("../include/audio_mem.h", $audio_mem);
+    write_file("../include/audio_error.h", $audio_error);
+    write_file("../include/esp_log.h", $esp_log);
+}
+
+sub write_file {
+    my ($f, $str) = @_;
+    open(my $H, '+>', $f) || die "";
+    print $H $str;
+    close $H;
+}
diff --git a/components/audio_stream/lib/hls/test/hls_download.pl b/components/audio_stream/lib/hls/test/hls_download.pl
old mode 100755
new mode 100644
index eb336a6f..1bd133ae
--- a/components/audio_stream/lib/hls/test/hls_download.pl
+++ b/components/audio_stream/lib/hls/test/hls_download.pl
@@ -1,309 +1,309 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-
-use LWP::UserAgent ();
-use URI        ();
-use HTTP::Date ();
-use Encode;
-use Encode::Locale;
-use Getopt::Long;
-use File::Path qw(make_path);
-use threads;
-
-my $force_download = 0;
-my $m3u8;
-my $bitrate = 0;
-my $top_dir = 'hls';
-my %play_list;
-my %file_list;
-my @files;
-$SIG{INT} = sub { die "Interrupted\n"; };
-$| = 1;         # autoflush
-GetOptions(
-    'force!'  => \$force_download,
-    'url:s' => \$m3u8,
-    'bitrate:i' => \$bitrate,
-    'dir:s' => \$top_dir,
-);
-unless ($m3u8) {
-print  << 'USAGE';
--force force overwrite file when exists
--url set m3u8 path
--dir set download path
--bitrate set accept bitrate
-./hls_download.pl -url https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8 -bitrate 1144430 -dir hls
-USAGE
-
-    exit(0);
-}
-
-my $ua = LWP::UserAgent->new(
-    agent      => "lwp-download/1.0 ",
-    keep_alive => 1,
-    env_proxy  => 1);
-
-my $dir = "$top_dir/" . get_file_name($m3u8);
-print "Got dir $dir $m3u8\n";
-unless (download_url($m3u8, $dir) == 1 || -e $dir) {
-    die "fail to download $m3u8\n";
-}
-get_file_lists($dir);
-
-my $file_num = @files;
-my $seg_num  = int($file_num / 5) + 1;
-my @thread;
-if ($seg_num > 10) {
-    $seg_num = 10;
-}
-
-for (0..$seg_num-1) {
-    push @thread, threads->create(\&download_segments, get_segment($_));
-}
-
-for (@thread) {
-    $_->join();
-}
-
-sub get_segment {
-    my $idx = shift;
-    my $n = int ($file_num / $seg_num);
-    return [$n* $idx, $idx + 1 < $seg_num ? ($idx+1)*$n-1 : $file_num-1];
-}
-
-sub download_segments {
-    my $seg = shift;
-    for my $idx($seg->[0] .. $seg->[1]) {
-        my $remote = $files[$idx];
-        my $local  = $file_list{$remote};
-        print "$idx: download $remote to $local\n";
-        download_url($remote, $local);
-    }
-}
-
-sub get_file_lists {
-    my $dir = shift;
-    my $cont = read_file($dir);
-    if ($cont =~/(EXT-X-STREAM-INF|EXT-X-MEDIA):/ms) {
-        print "This is main playlist\n";
-        parse_main_playlist($cont);
-        for my $p(keys %play_list) {
-            my $remote = get_full_url($m3u8, $p);
-            my $local = get_local_path($top_dir, $p);
-            $play_list{$remote} = check_dir($local);
-            if (download_url($remote, $local) || -e $local) {
-                $cont = read_file($local);
-                parse_playlist($cont, $remote);
-            }
-        }
-    }
-    else {
-        $play_list{$m3u8} = $top_dir;
-        parse_playlist($cont, $m3u8);
-    }
-}
-
-sub parse_main_playlist {
-    my $s = shift;
-    my $stream_inf = 0;
-    my $attr = {};
-    my @media;
-    my @stream;
-    while ($s =~/(.*?)[\r\n]+/msg) {
-        if ($stream_inf) {
-            $attr->{"URI"} = $1;
-            print "Got Stream uri ", $attr->{"URI"}, "\n";
-            $stream_inf = 0;
-            next;
-        }
-        my $l = $1;
-        ##EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="stereo",LANGUAGE="en",NAME="English",DEFAULT=YES,AUTOSELECT=YES,URI="audio/stereo/en/128kbit.m3u8"
-        if ($l =~/#EXT-X-MEDIA:(.*)/) {
-            $attr = get_attr($1);
-            push @media, $attr;
-            print "Got media uri ", $attr->{"URI"}, "\n";
-        }
-        ##EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=520929,CODECS="avc1.4d4015,mp4a.40.2",AUDIO="stereo",RESOLUTION=638x272,SUBTITLES="subs"
-        elsif ($l=~ /#EXT-X-STREAM-INF:(.*)/) {
-            $attr = get_attr($1);
-            push @stream, $attr;
-            $stream_inf = 1;
-        }
-    }
-    
-    #get all playlist which match bitrate
-    @stream = sort {$a->{"BANDWIDTH"} <=> $b->{"BANDWIDTH"}} @stream;
-    my $sel = sub {
-        my $s = shift;
-        my @type = qw /AUDIO SUBTITLES/;
-        if (exists $s->{"URI"}) {
-            print "match...", $s->{"URI"},"\n";
-            $play_list{$s->{"URI"}} = 1;
-        }
-        for my $t(@type) {
-            next unless (exists $s->{$t});
-            my $group_id = $s->{$t};
-            for my $m(@media) {
-                next unless (exists $m->{"URI"});
-                if ($m->{"TYPE"} eq $t &&  $m->{"GROUP-ID"} eq $group_id) {
-                    $play_list{$m->{"URI"}} = 1;
-                    print "match...", $m->{"URI"},"\n";
-                }
-            }
-        }
-    };
-    for my $m(@stream) {
-        if ($m->{"BANDWIDTH"} < $bitrate) {
-            next;
-        }
-        $sel->($m);
-        if ($m->{"BANDWIDTH"} >= $bitrate) {
-            last;
-        }
-    }
-}
-
-sub get_attr {
-    my $s = shift;
-    my $attr = {};
-    while ($s =~/([\w-]+)=["]?([^,"]+)/g) {
-        $attr->{$1} = $2;
-    }
-    return $attr;
-}
-
-sub parse_playlist {
-    my $d = shift;
-    my $remote = shift;
-    my $dir = $play_list{$remote};
-    my @info = split(/#EXTINF:/, $d);
-    for $d(@info) {
-        my @l = split(/[\r\n]+/, $d);
-        my $p;
-        for (1..$#l) {
-           if ($l[$_] =~/\w+/) {
-              unless ($l[$_] =~/^#EXT/) {
-                  $p = $l[$_];
-                  last;
-              }
-           }
-        }
-        if ($p) {
-	    my $r = get_full_url($remote, $p);
-	    my $local = get_local_path($dir, $p);
-	    $file_list{$r} = $local;
-	    push @files, $r;
-	    check_dir($local);
-	    print "Remote $r to $local\n";
-        }
-    }
-}
-
-sub check_dir {
-    my $p = shift;
-    if ($p =~/(.*)\//) {
-        my $dir = $1;
-        unless (-d $dir) {
-            make_path($dir);
-        }
-        return $dir;
-    }
-    return "";
-}
-
-sub get_full_url {
-    my $base = shift;
-    my $ext  = shift;
-    if ($ext =~/http/) {
-        return $ext;
-    }
-    my @base = split('\/', $base);
-    my @ext = split('\/', $ext);
-    pop @base;
-    while ($#ext >= 0) {
-        if ($ext[0] eq '.') {
-            shift @ext;
-            next;
-        }
-        if ($ext[0] eq '..') {
-            shift @ext;
-            pop @base;
-            next;
-        }
-        push @base, @ext;
-        last;
-    }
-    return join('/', @base);
-}
-
-sub get_local_path {
-    my $dir = shift;
-    my $ext = shift;
-    if ($ext =~/http/) {
-        return "$dir/" . get_file_name($ext);
-    }
-    return "$dir/$ext";
-}
-
-sub get_file_name {
-    my $url = shift;
-    if ($url =~/.*\/([\w\.-]+)/) {
-        return $1;
-    }
-    return $url;
-}
-
-sub read_file {
-    my $f = shift;
-    open(my $H, $f) || return "";
-    my $str;
-    do {local $/=undef; $str = <$H>;};
-    close $H;
-    return $str;
-}
-
-sub download_url {
-    my $url = shift;
-    my $dir = shift;
-    my $name = get_file_name($url);
-    if (-e $dir) {
-        if ($force_download == 0) {
-            print "$dir already exists if you still want to overwrite on it using -f option\n";
-            return 0;
-        }
-    }
-  
-    my $H;
-    my $start_time = 0;
-    my $total = 0;
-    my $last_time;
-    my $res = $ua->request(
-        HTTP::Request->new(GET => $url),
-        sub {
-            my $r = $_[1];
-            my $cur = time;
-            unless ($H) {
-                print "Start to download $url to $dir\n";
-                open($H, "+>", $dir) || die "Can't open $dir: $!\n";
-                binmode $H;
-                $start_time = $cur;
-                $last_time = $cur;
-            }
-            print $H $_[0];
-            $total += length($_[0]);
-            if ($cur >= $last_time + 5) {
-                $last_time = $cur;
-                print "$name $total / $r->content_length\n";
-            }
-        }
-    );
-    if ($H) {
-        close($H);
-    }
-    if (!$res->is_success) {
-        print "Fail to download for $res->status_line\n";
-        return 0;
-    }
-    return 1;
-}
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+
+use LWP::UserAgent ();
+use URI        ();
+use HTTP::Date ();
+use Encode;
+use Encode::Locale;
+use Getopt::Long;
+use File::Path qw(make_path);
+use threads;
+
+my $force_download = 0;
+my $m3u8;
+my $bitrate = 0;
+my $top_dir = 'hls';
+my %play_list;
+my %file_list;
+my @files;
+$SIG{INT} = sub { die "Interrupted\n"; };
+$| = 1;         # autoflush
+GetOptions(
+    'force!'  => \$force_download,
+    'url:s' => \$m3u8,
+    'bitrate:i' => \$bitrate,
+    'dir:s' => \$top_dir,
+);
+unless ($m3u8) {
+print  << 'USAGE';
+-force force overwrite file when exists
+-url set m3u8 path
+-dir set download path
+-bitrate set accept bitrate
+./hls_download.pl -url https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8 -bitrate 1144430 -dir hls
+USAGE
+
+    exit(0);
+}
+
+my $ua = LWP::UserAgent->new(
+    agent      => "lwp-download/1.0 ",
+    keep_alive => 1,
+    env_proxy  => 1);
+
+my $dir = "$top_dir/" . get_file_name($m3u8);
+print "Got dir $dir $m3u8\n";
+unless (download_url($m3u8, $dir) == 1 || -e $dir) {
+    die "fail to download $m3u8\n";
+}
+get_file_lists($dir);
+
+my $file_num = @files;
+my $seg_num  = int($file_num / 5) + 1;
+my @thread;
+if ($seg_num > 10) {
+    $seg_num = 10;
+}
+
+for (0..$seg_num-1) {
+    push @thread, threads->create(\&download_segments, get_segment($_));
+}
+
+for (@thread) {
+    $_->join();
+}
+
+sub get_segment {
+    my $idx = shift;
+    my $n = int ($file_num / $seg_num);
+    return [$n* $idx, $idx + 1 < $seg_num ? ($idx+1)*$n-1 : $file_num-1];
+}
+
+sub download_segments {
+    my $seg = shift;
+    for my $idx($seg->[0] .. $seg->[1]) {
+        my $remote = $files[$idx];
+        my $local  = $file_list{$remote};
+        print "$idx: download $remote to $local\n";
+        download_url($remote, $local);
+    }
+}
+
+sub get_file_lists {
+    my $dir = shift;
+    my $cont = read_file($dir);
+    if ($cont =~/(EXT-X-STREAM-INF|EXT-X-MEDIA):/ms) {
+        print "This is main playlist\n";
+        parse_main_playlist($cont);
+        for my $p(keys %play_list) {
+            my $remote = get_full_url($m3u8, $p);
+            my $local = get_local_path($top_dir, $p);
+            $play_list{$remote} = check_dir($local);
+            if (download_url($remote, $local) || -e $local) {
+                $cont = read_file($local);
+                parse_playlist($cont, $remote);
+            }
+        }
+    }
+    else {
+        $play_list{$m3u8} = $top_dir;
+        parse_playlist($cont, $m3u8);
+    }
+}
+
+sub parse_main_playlist {
+    my $s = shift;
+    my $stream_inf = 0;
+    my $attr = {};
+    my @media;
+    my @stream;
+    while ($s =~/(.*?)[\r\n]+/msg) {
+        if ($stream_inf) {
+            $attr->{"URI"} = $1;
+            print "Got Stream uri ", $attr->{"URI"}, "\n";
+            $stream_inf = 0;
+            next;
+        }
+        my $l = $1;
+        ##EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="stereo",LANGUAGE="en",NAME="English",DEFAULT=YES,AUTOSELECT=YES,URI="audio/stereo/en/128kbit.m3u8"
+        if ($l =~/#EXT-X-MEDIA:(.*)/) {
+            $attr = get_attr($1);
+            push @media, $attr;
+            print "Got media uri ", $attr->{"URI"}, "\n";
+        }
+        ##EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=520929,CODECS="avc1.4d4015,mp4a.40.2",AUDIO="stereo",RESOLUTION=638x272,SUBTITLES="subs"
+        elsif ($l=~ /#EXT-X-STREAM-INF:(.*)/) {
+            $attr = get_attr($1);
+            push @stream, $attr;
+            $stream_inf = 1;
+        }
+    }
+    
+    #get all playlist which match bitrate
+    @stream = sort {$a->{"BANDWIDTH"} <=> $b->{"BANDWIDTH"}} @stream;
+    my $sel = sub {
+        my $s = shift;
+        my @type = qw /AUDIO SUBTITLES/;
+        if (exists $s->{"URI"}) {
+            print "match...", $s->{"URI"},"\n";
+            $play_list{$s->{"URI"}} = 1;
+        }
+        for my $t(@type) {
+            next unless (exists $s->{$t});
+            my $group_id = $s->{$t};
+            for my $m(@media) {
+                next unless (exists $m->{"URI"});
+                if ($m->{"TYPE"} eq $t &&  $m->{"GROUP-ID"} eq $group_id) {
+                    $play_list{$m->{"URI"}} = 1;
+                    print "match...", $m->{"URI"},"\n";
+                }
+            }
+        }
+    };
+    for my $m(@stream) {
+        if ($m->{"BANDWIDTH"} < $bitrate) {
+            next;
+        }
+        $sel->($m);
+        if ($m->{"BANDWIDTH"} >= $bitrate) {
+            last;
+        }
+    }
+}
+
+sub get_attr {
+    my $s = shift;
+    my $attr = {};
+    while ($s =~/([\w-]+)=["]?([^,"]+)/g) {
+        $attr->{$1} = $2;
+    }
+    return $attr;
+}
+
+sub parse_playlist {
+    my $d = shift;
+    my $remote = shift;
+    my $dir = $play_list{$remote};
+    my @info = split(/#EXTINF:/, $d);
+    for $d(@info) {
+        my @l = split(/[\r\n]+/, $d);
+        my $p;
+        for (1..$#l) {
+           if ($l[$_] =~/\w+/) {
+              unless ($l[$_] =~/^#EXT/) {
+                  $p = $l[$_];
+                  last;
+              }
+           }
+        }
+        if ($p) {
+	    my $r = get_full_url($remote, $p);
+	    my $local = get_local_path($dir, $p);
+	    $file_list{$r} = $local;
+	    push @files, $r;
+	    check_dir($local);
+	    print "Remote $r to $local\n";
+        }
+    }
+}
+
+sub check_dir {
+    my $p = shift;
+    if ($p =~/(.*)\//) {
+        my $dir = $1;
+        unless (-d $dir) {
+            make_path($dir);
+        }
+        return $dir;
+    }
+    return "";
+}
+
+sub get_full_url {
+    my $base = shift;
+    my $ext  = shift;
+    if ($ext =~/http/) {
+        return $ext;
+    }
+    my @base = split('\/', $base);
+    my @ext = split('\/', $ext);
+    pop @base;
+    while ($#ext >= 0) {
+        if ($ext[0] eq '.') {
+            shift @ext;
+            next;
+        }
+        if ($ext[0] eq '..') {
+            shift @ext;
+            pop @base;
+            next;
+        }
+        push @base, @ext;
+        last;
+    }
+    return join('/', @base);
+}
+
+sub get_local_path {
+    my $dir = shift;
+    my $ext = shift;
+    if ($ext =~/http/) {
+        return "$dir/" . get_file_name($ext);
+    }
+    return "$dir/$ext";
+}
+
+sub get_file_name {
+    my $url = shift;
+    if ($url =~/.*\/([\w\.-]+)/) {
+        return $1;
+    }
+    return $url;
+}
+
+sub read_file {
+    my $f = shift;
+    open(my $H, $f) || return "";
+    my $str;
+    do {local $/=undef; $str = <$H>;};
+    close $H;
+    return $str;
+}
+
+sub download_url {
+    my $url = shift;
+    my $dir = shift;
+    my $name = get_file_name($url);
+    if (-e $dir) {
+        if ($force_download == 0) {
+            print "$dir already exists if you still want to overwrite on it using -f option\n";
+            return 0;
+        }
+    }
+  
+    my $H;
+    my $start_time = 0;
+    my $total = 0;
+    my $last_time;
+    my $res = $ua->request(
+        HTTP::Request->new(GET => $url),
+        sub {
+            my $r = $_[1];
+            my $cur = time;
+            unless ($H) {
+                print "Start to download $url to $dir\n";
+                open($H, "+>", $dir) || die "Can't open $dir: $!\n";
+                binmode $H;
+                $start_time = $cur;
+                $last_time = $cur;
+            }
+            print $H $_[0];
+            $total += length($_[0]);
+            if ($cur >= $last_time + 5) {
+                $last_time = $cur;
+                print "$name $total / $r->content_length\n";
+            }
+        }
+    );
+    if ($H) {
+        close($H);
+    }
+    if (!$res->is_success) {
+        print "Fail to download for $res->status_line\n";
+        return 0;
+    }
+    return 1;
+}
diff --git a/components/audio_stream/lib/hls/test/test.c b/components/audio_stream/lib/hls/test/test.c
index 36765fac..8af6bab5 100644
--- a/components/audio_stream/lib/hls/test/test.c
+++ b/components/audio_stream/lib/hls/test/test.c
@@ -1,225 +1,225 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <stdint.h>
-#include "hls_parse.h"
-#include "hls_playlist.h"
-
-uint8_t* read_file(char* f, int* size)
-{
-    FILE* fp = fopen(f, "r");
-    if (fp) {
-        fseek(fp, 0, SEEK_END);
-        *size = ftell(fp);
-        void* b = malloc(*size);
-        if (b) {
-            fseek(fp, 0, SEEK_SET);
-            fread(b, 1, *size, fp);
-            fclose(fp);
-        }
-        return (uint8_t*) b;
-    }
-    return NULL;
-}
-
-int tag_callback(hls_tag_info_t* tag_info, void* ctx)
-{
-    if (tag_info->tag != HLS_TAG_INF_APPEND && tag_info->tag != HLS_TAG_STREAM_INF_APPEND) {
-        printf("Tag:%s(%d)\n", hls_tag2str(tag_info->tag), tag_info->tag);
-    }
-    for (int i = 0; i < tag_info->attr_num; i++) {
-        printf("    %s(%d) = ", hls_attr2str(tag_info->k[i]), tag_info->k[i]);
-        switch (tag_info->k[i]) {
-            case HLS_ATTR_DURATION:
-                printf("%f\n", tag_info->v[i].f);
-                break;
-            case HLS_ATTR_TYPE:
-            case HLS_ATTR_BANDWIDTH:
-            case HLS_ATTR_PROGRAM_ID:
-            case HLS_ATTR_INT:
-            case HLS_ATTR_DEFAULT:
-            case HLS_ATTR_AUTO_SELECT:
-            case HLS_ATTR_FORCED:
-                printf("%d\n", tag_info->v[i].v);
-                break;
-            default:
-                printf("%s\n", tag_info->v[i].s);
-                break;
-        }
-    }
-    return 0;
-}
-
-int test_parser(char* file_name)
-{
-    int      size = 0;
-    uint8_t* buffer = read_file(file_name, &size);
-    if (buffer == NULL) {
-        printf("File %s not exists\n", file_name);
-        return 0;
-    }
-    hls_parse_t parser;
-    do {
-        if (hls_parse_init(&parser) != 0) {
-            break;
-        }
-        if (hls_matched(buffer, size) == false) {
-            printf("file is not hls\n");
-            break;
-        }
-        hls_file_type_t type = hls_get_file_type(buffer, size);
-        if (type == HLS_FILE_TYPE_NONE) {
-            printf("Not a playlist file\n");
-            break;
-        }
-        printf("filetype:%s playlist\n", type == HLS_FILE_TYPE_MASTER_PLAYLIST ? "master" : "media");
-        uint8_t* t = buffer;
-        while (size > 0) {
-            int  s = size;
-            bool eos = false;
-            if (s > 16) {
-                s = 16;
-            } else {
-                eos = true;
-            }
-            hls_parse_add_buffer(&parser, t, s, eos);
-            hls_parse(&parser, tag_callback, NULL);
-            size -= s;
-            t += s;
-        }
-        hls_parse(&parser, tag_callback, NULL);
-    } while (0);
-    hls_parse_deinit(&parser);
-    free(buffer);
-    return 0;
-}
-
-int read_local(char* uri, uint8_t* data, int size)
-{
-    static FILE* fp = NULL;
-    if (fp == NULL) {
-        fp = fopen(uri, "r");
-        if (fp == NULL) {
-            return -1;
-        }
-    }
-    if (fp) {
-        int s = fread(data, 1, size, fp);
-        printf("Read got size %d\n", s);
-        if (s < 0 || s < size) {
-            if (fp) {
-                fclose(fp);
-                fp = NULL;
-            }
-        }
-        return s;
-    }
-    return -1;
-}
-
-static int hls_file_cb(char* url, void* tag)
-{
-    printf("Got url: %s\n", url);
-    return 0;
-}
-
-int parse_data(hls_handle_t hls, char* url)
-{
-    int     size = 512;
-    uint8_t data[512];
-    while (1) {
-        int s = read_local(url, data, 512);
-        if (s < 0) {
-            break;
-        }
-        int ret = hls_playlist_parse_data(hls, data, s, (s < size));
-        if (s < size) {
-            break;
-        }
-    }
-    return 0;
-}
-
-int test_playlist(char* file)
-{
-    hls_playlist_cfg_t cfg = {
-        .prefer_bitrate = 500 * 1024,
-        .cb = hls_file_cb,
-        .ctx = NULL,
-        .uri = file,
-    };
-    hls_handle_t hls = hls_playlist_open(&cfg);
-    char*        stream_uri = NULL;
-    if (hls) {
-        do {
-            int ret = parse_data(hls, file);
-            if (ret != 0) {
-                break;
-            }
-            if (hls_playlist_is_master(hls)) {
-                stream_uri = hls_playlist_get_prefer_url(hls, HLS_STREAM_TYPE_AUDIO);
-            }
-            hls_playlist_close(hls);
-            hls = NULL;
-            if (stream_uri == NULL) {
-                break;
-            }
-            cfg.uri = stream_uri;
-            hls = hls_playlist_open(&cfg);
-            if (hls == NULL) {
-                break;
-            }
-            ret = parse_data(hls, stream_uri);
-            if (ret != 0) {
-                break;
-            }
-            hls_playlist_close(hls);
-            hls = NULL;
-        } while (0);
-        if (hls) {
-            hls_playlist_close(hls);
-        }
-        if (stream_uri) {
-            free(stream_uri);
-        }
-    }
-    return 0;
-}
-
-int main(int argc, char** argv)
-{
-    char* file_name;
-    if (argc < 2) {
-        printf("Your should set input filename firstly\n");
-        return -1;
-    }
-    file_name = argv[1];
-    if (argc >= 3) {
-        test_parser(file_name);
-    } else {
-        test_playlist(file_name);
-    }
-    return 0;
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2022 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "hls_parse.h"
+#include "hls_playlist.h"
+
+uint8_t* read_file(char* f, int* size)
+{
+    FILE* fp = fopen(f, "r");
+    if (fp) {
+        fseek(fp, 0, SEEK_END);
+        *size = ftell(fp);
+        void* b = malloc(*size);
+        if (b) {
+            fseek(fp, 0, SEEK_SET);
+            fread(b, 1, *size, fp);
+            fclose(fp);
+        }
+        return (uint8_t*) b;
+    }
+    return NULL;
+}
+
+int tag_callback(hls_tag_info_t* tag_info, void* ctx)
+{
+    if (tag_info->tag != HLS_TAG_INF_APPEND && tag_info->tag != HLS_TAG_STREAM_INF_APPEND) {
+        printf("Tag:%s(%d)\n", hls_tag2str(tag_info->tag), tag_info->tag);
+    }
+    for (int i = 0; i < tag_info->attr_num; i++) {
+        printf("    %s(%d) = ", hls_attr2str(tag_info->k[i]), tag_info->k[i]);
+        switch (tag_info->k[i]) {
+            case HLS_ATTR_DURATION:
+                printf("%f\n", tag_info->v[i].f);
+                break;
+            case HLS_ATTR_TYPE:
+            case HLS_ATTR_BANDWIDTH:
+            case HLS_ATTR_PROGRAM_ID:
+            case HLS_ATTR_INT:
+            case HLS_ATTR_DEFAULT:
+            case HLS_ATTR_AUTO_SELECT:
+            case HLS_ATTR_FORCED:
+                printf("%d\n", tag_info->v[i].v);
+                break;
+            default:
+                printf("%s\n", tag_info->v[i].s);
+                break;
+        }
+    }
+    return 0;
+}
+
+int test_parser(char* file_name)
+{
+    int      size = 0;
+    uint8_t* buffer = read_file(file_name, &size);
+    if (buffer == NULL) {
+        printf("File %s not exists\n", file_name);
+        return 0;
+    }
+    hls_parse_t parser;
+    do {
+        if (hls_parse_init(&parser) != 0) {
+            break;
+        }
+        if (hls_matched(buffer, size) == false) {
+            printf("file is not hls\n");
+            break;
+        }
+        hls_file_type_t type = hls_get_file_type(buffer, size);
+        if (type == HLS_FILE_TYPE_NONE) {
+            printf("Not a playlist file\n");
+            break;
+        }
+        printf("filetype:%s playlist\n", type == HLS_FILE_TYPE_MASTER_PLAYLIST ? "master" : "media");
+        uint8_t* t = buffer;
+        while (size > 0) {
+            int  s = size;
+            bool eos = false;
+            if (s > 16) {
+                s = 16;
+            } else {
+                eos = true;
+            }
+            hls_parse_add_buffer(&parser, t, s, eos);
+            hls_parse(&parser, tag_callback, NULL);
+            size -= s;
+            t += s;
+        }
+        hls_parse(&parser, tag_callback, NULL);
+    } while (0);
+    hls_parse_deinit(&parser);
+    free(buffer);
+    return 0;
+}
+
+int read_local(char* uri, uint8_t* data, int size)
+{
+    static FILE* fp = NULL;
+    if (fp == NULL) {
+        fp = fopen(uri, "r");
+        if (fp == NULL) {
+            return -1;
+        }
+    }
+    if (fp) {
+        int s = fread(data, 1, size, fp);
+        printf("Read got size %d\n", s);
+        if (s < 0 || s < size) {
+            if (fp) {
+                fclose(fp);
+                fp = NULL;
+            }
+        }
+        return s;
+    }
+    return -1;
+}
+
+static int hls_file_cb(char* url, void* tag)
+{
+    printf("Got url: %s\n", url);
+    return 0;
+}
+
+int parse_data(hls_handle_t hls, char* url)
+{
+    int     size = 512;
+    uint8_t data[512];
+    while (1) {
+        int s = read_local(url, data, 512);
+        if (s < 0) {
+            break;
+        }
+        int ret = hls_playlist_parse_data(hls, data, s, (s < size));
+        if (s < size) {
+            break;
+        }
+    }
+    return 0;
+}
+
+int test_playlist(char* file)
+{
+    hls_playlist_cfg_t cfg = {
+        .prefer_bitrate = 500 * 1024,
+        .cb = hls_file_cb,
+        .ctx = NULL,
+        .uri = file,
+    };
+    hls_handle_t hls = hls_playlist_open(&cfg);
+    char*        stream_uri = NULL;
+    if (hls) {
+        do {
+            int ret = parse_data(hls, file);
+            if (ret != 0) {
+                break;
+            }
+            if (hls_playlist_is_master(hls)) {
+                stream_uri = hls_playlist_get_prefer_url(hls, HLS_STREAM_TYPE_AUDIO);
+            }
+            hls_playlist_close(hls);
+            hls = NULL;
+            if (stream_uri == NULL) {
+                break;
+            }
+            cfg.uri = stream_uri;
+            hls = hls_playlist_open(&cfg);
+            if (hls == NULL) {
+                break;
+            }
+            ret = parse_data(hls, stream_uri);
+            if (ret != 0) {
+                break;
+            }
+            hls_playlist_close(hls);
+            hls = NULL;
+        } while (0);
+        if (hls) {
+            hls_playlist_close(hls);
+        }
+        if (stream_uri) {
+            free(stream_uri);
+        }
+    }
+    return 0;
+}
+
+int main(int argc, char** argv)
+{
+    char* file_name;
+    if (argc < 2) {
+        printf("Your should set input filename firstly\n");
+        return -1;
+    }
+    file_name = argv[1];
+    if (argc >= 3) {
+        test_parser(file_name);
+    } else {
+        test_playlist(file_name);
+    }
+    return 0;
 }
\ No newline at end of file
diff --git a/components/audio_stream/pwm_stream.c b/components/audio_stream/pwm_stream.c
index c3326f94..1de35691 100644
--- a/components/audio_stream/pwm_stream.c
+++ b/components/audio_stream/pwm_stream.c
@@ -1,754 +1,754 @@
-/*
- *  * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <string.h>
-#include <inttypes.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-
-#include "audio_mem.h"
-#include "audio_sys.h"
-#include "audio_error.h"
-#include "audio_element.h"
-#include "esp_log.h"
-#include "esp_err.h"
-
-#include "soc/ledc_struct.h"
-#include "soc/ledc_reg.h"
-#include "pwm_stream.h"
-#include "audio_idf_version.h"
-#include "soc/timer_group_struct.h"
-
-static const char *TAG = "PWM_STREAM";
-
-#define BUFFER_MIN_SIZE (256UL)
-#define SAMPLE_RATE_MAX (48000)
-#define SAMPLE_RATE_MIN (8000)
-#define CHANNEL_LEFT_INDEX  (0)
-#define CHANNEL_RIGHT_INDEX (1)
-#define CHANNEL_LEFT_MASK   (0x01)
-#define CHANNEL_RIGHT_MASK  (0x02)
-#define AUDIO_PWM_CH_MAX (2)
-
-typedef struct {
-    char *buf;                         /**< Original pointer */
-    uint32_t volatile head;            /**< ending pointer */
-    uint32_t volatile tail;            /**< Read pointer */
-    uint32_t size;                     /**< Buffer size */
-    uint32_t is_give;                  /**< semaphore give flag */
-    SemaphoreHandle_t semaphore;       /**< Semaphore for data */
-} data_list_t;
-typedef data_list_t *pwm_data_handle_t;
-
-typedef enum {
-    AUDIO_PWM_STATUS_UNINIT = 0,    /*!< pwm audio uninitialized */
-    AUDIO_PWM_STATUS_IDLE   = 1,    /*!< pwm audio idle */
-    AUDIO_PWM_STATUS_BUSY   = 2,    /*!< pwm audio busy */
-} audio_pwm_status_t;
-
-typedef struct {
-    audio_pwm_config_t    config;                          /**< pwm audio config struct */
-    ledc_channel_config_t ledc_channel[AUDIO_PWM_CH_MAX];  /**< ledc channel config */
-    ledc_timer_config_t   ledc_timer;                      /**< ledc timer config  */
-    timg_dev_t            *timg_dev;                       /**< timer group register pointer */
-    pwm_data_handle_t     data;                            /**< audio data pointer */
-    uint32_t              channel_mask;                    /**< channel gpio mask */
-    uint32_t              channel_set_num;                 /**< channel audio set number */
-    int32_t               framerate;                       /*!< frame rates in Hz */
-    int32_t               bits_per_sample;                 /*!< bits per sample (16, 32) */
-    audio_pwm_status_t    status;
-} audio_pwm_t;
-typedef audio_pwm_t *audio_pwm_handle_t;
-
-static volatile uint32_t *g_ledc_left_conf0_val  = NULL;
-static volatile uint32_t *g_ledc_left_conf1_val  = NULL;
-static volatile uint32_t *g_ledc_left_duty_val   = NULL;
-static volatile uint32_t *g_ledc_right_conf0_val = NULL;
-static volatile uint32_t *g_ledc_right_conf1_val = NULL;
-static volatile uint32_t *g_ledc_right_duty_val  = NULL;
-static audio_pwm_handle_t g_audio_pwm_handle = NULL;
-
-typedef struct pwm_stream {
-    audio_stream_type_t type;
-    pwm_stream_cfg_t    config;
-    bool                is_open;
-    bool                uninstall_drv;
-} pwm_stream_t;
-
-static esp_err_t pwm_data_list_destroy(pwm_data_handle_t data)
-{
-    if (data == NULL) {
-        return ESP_ERR_INVALID_ARG;
-    }
-    if (data->buf) {
-        audio_free(data->buf);
-    }
-    if (data->semaphore) {
-        vSemaphoreDelete(data->semaphore);
-    }
-    audio_free(data);
-    data = NULL;
-    return ESP_OK;
-}
-
-static pwm_data_handle_t pwm_data_list_create(int size)
-{
-    if (size < (BUFFER_MIN_SIZE << 2)) {
-        ESP_LOGE(TAG, "Invalid buffer size, Minimum = %d", (int)(BUFFER_MIN_SIZE << 2));
-        return NULL;
-    }
-
-    pwm_data_handle_t data = heap_caps_calloc(1, sizeof(data_list_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
-    AUDIO_NULL_CHECK(TAG, data, goto data_error);
-
-    data->buf = heap_caps_calloc(1, size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
-    AUDIO_NULL_CHECK(TAG, data->buf, goto data_error);
-
-    data->semaphore = xSemaphoreCreateBinary();
-    AUDIO_NULL_CHECK(TAG, data->semaphore, goto data_error);
-
-    data->is_give = 0;
-    data->head = data->tail = 0;
-    data->size = size;
-    return data;
-
-data_error:
-    if (data->semaphore != NULL) {
-        vSemaphoreDelete(data->semaphore);
-        data->semaphore = NULL;
-    }
-    if (data->buf) {
-        audio_free(data->buf);
-        data->buf = NULL;
-    }
-    if (data) {
-        audio_free(data);
-        data = NULL;
-    }
-    return NULL;
-}
-
-static uint32_t IRAM_ATTR pwm_data_list_get_count(pwm_data_handle_t data)
-{
-    uint32_t tail = data->tail;
-    if (data->head >= tail) {
-        return (data->head - tail);
-    }
-    return (data->size - (tail - data->head));
-}
-
-static uint32_t IRAM_ATTR pwm_data_list_get_free(pwm_data_handle_t data)
-{
-    return (data->size - pwm_data_list_get_count(data) - 1);
-}
-
-static esp_err_t pwm_data_list_flush(pwm_data_handle_t data)
-{
-    data->tail = data->head = 0;
-    return ESP_OK;
-}
-
-static esp_err_t IRAM_ATTR pwm_data_list_read_byte(pwm_data_handle_t data, uint8_t *outdata)
-{
-    uint32_t tail = data->tail;
-    if ((tail == data->head) || (tail == (data->head + 1))) {
-        return ESP_FAIL;
-    }
-    *outdata = data->buf[tail];
-    tail++;
-    if (tail == data->size) {
-        tail = 0;
-    }
-
-    data->tail = tail;
-    return ESP_OK;
-}
-
-static esp_err_t pwm_data_list_write_byte(pwm_data_handle_t data, const uint8_t indata)
-{
-    uint32_t next_head = data->head + 1;
-    if (next_head == data->size) {
-        next_head = 0;
-    }
-    if (next_head == data->tail) {
-        return ESP_FAIL;
-    }
-    data->buf[data->head] = indata;
-    data->head = next_head;
-    return ESP_OK;
-}
-
-static esp_err_t pwm_data_list_wait_semaphore(pwm_data_handle_t data, TickType_t ticks_to_wait)
-{
-    data->is_give = 0;
-    if (xSemaphoreTake(data->semaphore, ticks_to_wait) == pdTRUE) {
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-static esp_err_t pwm_data_list_wait_flushed(pwm_data_handle_t data, TickType_t ticks_to_wait)
-{
-    data->is_give = 2;
-    if (xSemaphoreTake(data->semaphore, ticks_to_wait) == pdTRUE) {
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-static inline void ledc_set_left_duty_fast(uint32_t duty_val)
-{
-    *g_ledc_left_duty_val = (duty_val) << 4;
-    *g_ledc_left_conf0_val |= 0x00000014;
-    *g_ledc_left_conf1_val |= 0x80000000;
-}
-
-static inline void ledc_set_right_duty_fast(uint32_t duty_val)
-{
-    *g_ledc_right_duty_val = (duty_val) << 4;
-    *g_ledc_right_conf0_val |= 0x00000014;
-    *g_ledc_right_conf1_val |= 0x80000000;
-}
-
-static void IRAM_ATTR timer_group_isr(void *para)
-{
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-
-    if (handle == NULL) {
-        return;
-    }
-
-#ifdef CONFIG_IDF_TARGET_ESP32S2
-#if ((ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)) && (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)))
-    if (handle->timg_dev->int_st.val & BIT(handle->config.timer_num)) {
-        handle->timg_dev->int_clr.val |= (1UL << handle->config.timer_num);
-    }
-    handle->timg_dev->hw_timer[handle->config.timer_num].config.alarm_en = TIMER_ALARM_EN;
-#else
-    if (handle->timg_dev->int_st_timers.val & BIT(handle->config.timer_num)) {
-        handle->timg_dev->int_clr_timers.val |= (1UL << handle->config.timer_num);
-    }
-    handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_alarm_en = TIMER_ALARM_EN;
-#endif
-#elif CONFIG_IDF_TARGET_ESP32
-    if (handle->timg_dev->int_st_timers.val & BIT(handle->config.timer_num)) {
-        handle->timg_dev->int_clr_timers.val |= (1UL << handle->config.timer_num);
-    }
-    #if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-    handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_alarm_en = TIMER_ALARM_EN;
-    #else
-    handle->timg_dev->hw_timer[handle->config.timer_num].config.alarm_en = TIMER_ALARM_EN;
-    #endif
-#elif CONFIG_IDF_TARGET_ESP32S3
-    if (handle->timg_dev->int_st_timers.val & BIT(handle->config.timer_num)) {
-        handle->timg_dev->int_clr_timers.val |= (1UL << handle->config.timer_num);
-    }
-    handle->timg_dev->hw_timer[handle->config.timer_num].config.tn_alarm_en = TIMER_ALARM_EN;
-#endif
-
-    static uint8_t wave_h, wave_l;
-    static uint16_t value;
-
-    if (handle->channel_mask & CHANNEL_LEFT_MASK) {
-        if (handle->config.duty_resolution > 8) {
-            pwm_data_list_read_byte(handle->data, &wave_l);
-            if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
-                value = ((wave_h << 8) | wave_l);
-                ledc_set_left_duty_fast(value);
-            }
-        } else {
-            if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
-                ledc_set_left_duty_fast(wave_h);
-            }
-        }
-    }
-
-    if (handle->channel_mask & CHANNEL_RIGHT_MASK) {
-        if (handle->channel_set_num == 1) {
-            if (handle->config.duty_resolution > 8) {
-                ledc_set_right_duty_fast(value);
-            } else {
-                ledc_set_right_duty_fast(wave_h);
-            }
-        } else {
-            if (handle->config.duty_resolution > 8) {
-                pwm_data_list_read_byte(handle->data, &wave_l);
-                if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
-                    value = ((wave_h << 8) | wave_l);
-                    ledc_set_right_duty_fast(value);
-                }
-            } else {
-                if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
-                    ledc_set_right_duty_fast(wave_h);
-                }
-            }
-        }
-    } else {
-        if (handle->channel_set_num == 2) {
-            if (handle->config.duty_resolution > 8) {
-                pwm_data_list_read_byte(handle->data, &wave_h);
-                pwm_data_list_read_byte(handle->data, &wave_h);
-            } else {
-                pwm_data_list_read_byte(handle->data, &wave_h);
-            }
-            pwm_data_list_read_byte(handle->data, &wave_l);
-        }
-    }
-
-    if ((0 == handle->data->is_give && pwm_data_list_get_free(handle->data) > BUFFER_MIN_SIZE) ||
-        (2 == handle->data->is_give && pwm_data_list_get_count(handle->data) == 0)) {
-        handle->data->is_give = 1;
-        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
-        xSemaphoreGiveFromISR(handle->data->semaphore, &xHigherPriorityTaskWoken);
-        if (pdFALSE != xHigherPriorityTaskWoken) {
-            portYIELD_FROM_ISR();
-        }
-    }
-}
-
-static esp_err_t audio_pwm_init(const audio_pwm_config_t *cfg)
-{
-    esp_err_t res = ESP_OK;
-    AUDIO_NULL_CHECK(TAG, cfg, return ESP_ERR_INVALID_ARG);
-    if (!(cfg->tg_num < TIMER_GROUP_MAX)) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM TIMER GROUP NUMBER IS %d AND SHOULD BE 0 OR 1", __FILENAME__, __LINE__, __FUNCTION__, cfg->tg_num);
-    }
-    if (!(cfg->timer_num < TIMER_MAX)) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM TIMER NUMBER IS %d AND SHOULD BE 0 OR 1", __FILENAME__, __LINE__, __FUNCTION__, cfg->timer_num);
-    }
-
-    if (cfg->duty_resolution < 8 || cfg->duty_resolution > 10) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM RESOLUTION IS %d AND SHOULD BE 8, 9, 10", __FILENAME__, __LINE__, __FUNCTION__, cfg->duty_resolution);
-    }
-
-    audio_pwm_handle_t handle = NULL;
-    handle = heap_caps_calloc(1, sizeof(audio_pwm_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
-    AUDIO_NULL_CHECK(TAG, handle, goto init_error);
-
-    handle->data = pwm_data_list_create(cfg->data_len);
-    AUDIO_NULL_CHECK(TAG, handle->data, goto init_error);
-
-    handle->config = *cfg;
-    g_audio_pwm_handle = handle;
-    if (cfg->tg_num == TIMER_GROUP_0) {
-        handle->timg_dev = &TIMERG0;
-    } else {
-        handle->timg_dev = &TIMERG1;
-    }
-    handle->channel_mask = 0;
-    if (handle->config.gpio_num_left >= 0) {
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].channel = handle->config.ledc_channel_left;
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].duty = 0;
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].gpio_num = handle->config.gpio_num_left;
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].speed_mode = LEDC_LOW_SPEED_MODE;
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].hpoint = 0;
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].timer_sel = handle->config.ledc_timer_sel;
-        handle->ledc_channel[CHANNEL_LEFT_INDEX].intr_type = LEDC_INTR_DISABLE;
-        res = ledc_channel_config(&handle->ledc_channel[CHANNEL_LEFT_INDEX]);
-        AUDIO_CHECK(TAG, ESP_OK == res, goto init_error, "AUDIO PWM LEFT CHANNEL CONFIG ERROR");
-        handle->channel_mask |= CHANNEL_LEFT_MASK;
-    }
-    if (handle->config.gpio_num_right >= 0) {
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel = handle->config.ledc_channel_right;
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].duty = 0;
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].gpio_num = handle->config.gpio_num_right;
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].speed_mode = LEDC_LOW_SPEED_MODE;
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].hpoint = 0;
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].timer_sel = handle->config.ledc_timer_sel;
-        handle->ledc_channel[CHANNEL_RIGHT_INDEX].intr_type = LEDC_INTR_DISABLE;
-        res = ledc_channel_config(&handle->ledc_channel[CHANNEL_RIGHT_INDEX]);
-        AUDIO_CHECK(TAG, ESP_OK == res, goto init_error, "AUDIO PWM RIGHT CHANNEL CONFIG ERROR");
-        handle->channel_mask |= CHANNEL_RIGHT_MASK;
-    }
-    AUDIO_CHECK(TAG, 0 != handle->channel_mask, goto init_error, "AUDIO PWM CHANNEL MASK IS 0");
-
-#ifdef CONFIG_IDF_TARGET_ESP32S2
-    handle->ledc_timer.clk_cfg = LEDC_USE_APB_CLK;
-#endif
-
-    handle->ledc_timer.speed_mode = LEDC_LOW_SPEED_MODE;
-    handle->ledc_timer.duty_resolution = handle->config.duty_resolution;
-    handle->ledc_timer.timer_num = handle->config.ledc_timer_sel;
-    uint32_t freq = (APB_CLK_FREQ / (1 << handle->ledc_timer.duty_resolution));
-    handle->ledc_timer.freq_hz = freq - (freq % 1000);
-    res = ledc_timer_config(&handle->ledc_timer);
-    AUDIO_CHECK(TAG, ESP_OK == res, goto init_error, "AUDIO PWM TIMER ERROR");
-
-#if defined(CONFIG_IDF_TARGET_ESP32P4)
-    g_ledc_left_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].duty_r.val;
-    g_ledc_right_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].duty_r.val;
-#else
-    g_ledc_left_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].duty.val;
-    g_ledc_right_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].duty.val;
-#endif // CONFIG_IDF_TARGET_ESP32P4
-    g_ledc_left_conf0_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].conf0.val;
-    g_ledc_left_conf1_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].conf1.val;
-    g_ledc_right_conf0_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].conf0.val;
-    g_ledc_right_conf1_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].conf1.val;
-
-    handle->status = AUDIO_PWM_STATUS_IDLE;
-    return res;
-
-init_error:
-    if (handle->data) {
-        audio_free(handle->data);
-        handle->data = NULL;
-    }
-    if (handle) {
-        audio_free(handle);
-        handle = NULL;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t audio_pwm_set_param(int rate, ledc_timer_bit_t bits, int ch)
-{
-    esp_err_t res = ESP_OK;
-    AUDIO_CHECK(TAG, g_audio_pwm_handle->status != AUDIO_PWM_STATUS_BUSY, return ESP_FAIL, "AUDIO PWM CAN NOT SET PARAM, WHEN AUDIO PWM STATUS IS BUSY");
-    if (rate > SAMPLE_RATE_MAX || rate < SAMPLE_RATE_MIN) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM SAMPLE IS %d AND SHOULD BE BETWEEN 8000 AND 48000", __FILENAME__, __LINE__, __FUNCTION__, rate);
-    }
-    if (!(bits == 32 || bits == 16 || bits == 8)) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM BITS IS %d AND SHOULD BE 8, 16, 32", __FILENAME__, __LINE__, __FUNCTION__, bits);
-    }
-    if (!(ch == 2 || ch == 1)) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM CH IS %d AND SHOULD BE 1 OR 2", __FILENAME__, __LINE__, __FUNCTION__, ch);
-    }
-
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    handle->framerate = rate;
-    handle->bits_per_sample = bits;
-    handle->channel_set_num = ch;
-    timer_config_t config = {0};
-    config.divider = 16;
-    config.counter_dir = TIMER_COUNT_UP;
-    config.counter_en = TIMER_PAUSE;
-    config.alarm_en = TIMER_ALARM_EN;
-    config.intr_type = TIMER_INTR_LEVEL;
-    config.auto_reload = 1;
-
-#ifdef TIMER_GROUP_SUPPORTS_XTAL_CLOCK
-    config.clk_src = TIMER_SRC_CLK_APB;
-#endif
-
-    timer_init(handle->config.tg_num, handle->config.timer_num, &config);
-    timer_set_counter_value(handle->config.tg_num, handle->config.timer_num, 0x00000000ULL);
-    timer_set_alarm_value(handle->config.tg_num, handle->config.timer_num, (APB_CLK_FREQ / config.divider) / handle->framerate);
-    timer_enable_intr(handle->config.tg_num, handle->config.timer_num);
-    timer_isr_register(handle->config.tg_num, handle->config.timer_num, timer_group_isr, NULL, ESP_INTR_FLAG_IRAM, NULL);
-    return res;
-}
-
-esp_err_t audio_pwm_set_sample_rate(int rate)
-{
-    esp_err_t res;
-    AUDIO_CHECK(TAG, g_audio_pwm_handle->status != AUDIO_PWM_STATUS_BUSY, return ESP_FAIL, "AUDIO PWM CAN NOT SET PARAM, WHEN AUDIO PWM STATUS IS BUSY");
-    if (rate > SAMPLE_RATE_MAX || rate < SAMPLE_RATE_MIN) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM SAMPLE IS %d AND SHOULD BE BETWEEN 8000 AND 48000", __FILENAME__, __LINE__, __FUNCTION__, rate);
-    }
-
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    handle->framerate = rate;
-    uint16_t div = 1;
-#ifdef CONFIG_IDF_TARGET_ESP32S2
-#if ((ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)) && (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)))
-    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.divider;
-#else
-    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_divider;
-#endif
-#elif CONFIG_IDF_TARGET_ESP32
-    #if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_divider;
-    #else
-    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.divider;
-    #endif
-#elif CONFIG_IDF_TARGET_ESP32S3
-    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.tn_divider;
-#endif
-
-    res = timer_set_alarm_value(handle->config.tg_num, handle->config.timer_num, (APB_CLK_FREQ / div) / handle->framerate);
-    return res;
-}
-
-static esp_err_t pwm_data_convert(pwm_data_handle_t data, uint8_t *inbuf, int32_t bits_per, int32_t duty, uint32_t bytes)
-{
-    int8_t shift = bits_per - duty;
-    uint32_t len = bytes;
-
-    if (bits_per == 16) {
-        len >>= 1;
-        uint16_t *buf_16b = (uint16_t *)inbuf;
-        uint16_t value;
-        int16_t temp;
-        if (duty > 8) {
-            for (size_t i = 0; i < len; i++) {
-                temp = buf_16b[i];
-                value = temp + 0x7fff;
-                value >>= shift;
-                pwm_data_list_write_byte(data, value);
-                pwm_data_list_write_byte(data, value >> 8);
-            }
-        } else {
-            for (size_t i = 0; i < len; i++) {
-                temp = buf_16b[i];
-                value = temp + 0x7fff;
-                value >>= shift;
-                pwm_data_list_write_byte(data, value);
-            }
-        }
-    } else if (bits_per == 32) {
-        len >>= 2;
-        uint32_t *buf_32b = (uint32_t *)inbuf;
-        uint32_t value;
-        int32_t temp;
-        if (duty > 8) {
-            for (size_t i = 0; i < len; i++) {
-                temp = buf_32b[i];
-                value = temp + 0x7fffffff;
-                value >>= shift;
-                pwm_data_list_write_byte(data, value);
-                pwm_data_list_write_byte(data, value >> 8);
-            }
-        } else {
-            for (size_t i = 0; i < len; i++) {
-                temp = buf_32b[i];
-                value = temp + 0x7fffffff;
-                value >>= shift;
-                pwm_data_list_write_byte(data, value);
-            }
-        }
-    } else {
-        ESP_LOGE(TAG, "Only support bits (16 or 32), now bits_per is %"PRId32, bits_per);
-    }
-    return ESP_OK;
-}
-
-static uint32_t pwm_get_data_duration(uint32_t data_size)
-{
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    uint32_t sample_bytes = (handle->config.duty_resolution) > 8 ? 2: 1;
-    uint32_t byte_rate = sample_bytes * handle->channel_set_num * handle->framerate;
-    if (byte_rate == 0) {
-        return 0;
-    }
-    // Add extra 20ms
-    return (data_size * 1000 / byte_rate) + 20;
-}
-
-static void pwm_wait_flush(void)
-{
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    uint32_t data_size = pwm_data_list_get_count(handle->data);
-    if (handle->status == AUDIO_PWM_STATUS_BUSY && data_size > 0) {
-        pwm_data_list_wait_flushed(handle->data, pwm_get_data_duration(data_size) / portTICK_RATE_MS);
-    }
-}
-
-esp_err_t audio_pwm_write(uint8_t *inbuf, size_t inbuf_len, size_t *bytes_written, TickType_t ticks_to_wait)
-{
-    esp_err_t res = ESP_OK;
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    AUDIO_NULL_CHECK(TAG, inbuf, return ESP_FAIL);
-
-    *bytes_written = 0;
-    pwm_data_handle_t data = handle->data;
-    while (inbuf_len) {
-        if (ESP_OK == pwm_data_list_wait_semaphore(data, ticks_to_wait)) {
-            uint32_t free = pwm_data_list_get_free(data);
-            uint32_t bytes_can_write = inbuf_len;
-            if (inbuf_len > free) {
-                bytes_can_write = free;
-            }
-            bytes_can_write &= 0xfffffffc;
-            if (0 == bytes_can_write) {
-                *bytes_written += inbuf_len;
-                return ESP_OK;
-            }
-            pwm_data_convert(data, inbuf, handle->bits_per_sample, handle->config.duty_resolution, bytes_can_write);
-            inbuf += bytes_can_write;
-            inbuf_len -= bytes_can_write;
-            *bytes_written += bytes_can_write;
-        } else {
-            res = ESP_FAIL;
-        }
-    }
-    return res;
-}
-
-static esp_err_t audio_pwm_start(void)
-{
-    esp_err_t res;
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-
-    if (handle->status != AUDIO_PWM_STATUS_IDLE) {
-        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM STATE IS %d, AND SHOULD BE IDLE WHEN PWM START", __FILENAME__, __LINE__, __FUNCTION__, handle->status);
-    }
-
-    handle->status = AUDIO_PWM_STATUS_BUSY;
-    timer_enable_intr(handle->config.tg_num, handle->config.timer_num);
-    res = timer_start(handle->config.tg_num, handle->config.timer_num);
-    return res;
-}
-
-static esp_err_t audio_pwm_stop(void)
-{
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    timer_pause(handle->config.tg_num, handle->config.timer_num);
-    timer_disable_intr(handle->config.tg_num, handle->config.timer_num);
-    pwm_data_list_flush(handle->data);
-    handle->status = AUDIO_PWM_STATUS_IDLE;
-    return ESP_OK;
-}
-
-static esp_err_t audio_pwm_deinit(void)
-{
-    audio_pwm_handle_t handle = g_audio_pwm_handle;
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_FAIL);
-    handle->status = AUDIO_PWM_STATUS_UNINIT;
-    audio_pwm_stop();
-    for (size_t i = 0; i < AUDIO_PWM_CH_MAX; i++) {
-        if (handle->ledc_channel[i].gpio_num >= 0) {
-            ledc_stop(handle->ledc_channel[i].speed_mode, handle->ledc_channel[i].channel, 0);
-        }
-    }
-
-    for (size_t i = 0; i < AUDIO_PWM_CH_MAX; i++) {
-        if (handle->ledc_channel[i].gpio_num >= 0) {
-            gpio_set_direction(handle->ledc_channel[i].gpio_num, GPIO_MODE_INPUT);
-        }
-    }
-
-    pwm_data_list_destroy(handle->data);
-    audio_free(handle);
-    return ESP_OK;
-}
-
-static int _pwm_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    size_t bytes_written = 0;
-    audio_pwm_write((uint8_t *)buffer, len, &bytes_written, ticks_to_wait);
-    return bytes_written;
-}
-
-static esp_err_t _pwm_destroy(audio_element_handle_t self)
-{
-    esp_err_t res = ESP_OK;
-    pwm_stream_t *pwm = (pwm_stream_t *)audio_element_getdata(self);
-    if (pwm->uninstall_drv) {
-        res = audio_pwm_deinit();
-    }
-    audio_free(pwm);
-    return res;
-}
-
-static esp_err_t _pwm_open(audio_element_handle_t self)
-{
-    esp_err_t res = ESP_OK;
-    pwm_stream_t *pwm = (pwm_stream_t *)audio_element_getdata(self);
-    if (pwm->is_open) {
-        return ESP_OK;
-    }
-    res = audio_element_set_input_timeout(self, 2000 / portTICK_RATE_MS);
-    pwm->is_open = true;
-    return res;
-}
-
-static esp_err_t _pwm_close(audio_element_handle_t self)
-{
-    esp_err_t res = ESP_OK;
-    pwm_stream_t *pwm = (pwm_stream_t *)audio_element_getdata(self);
-    pwm->is_open = false;
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_report_pos(self);
-        audio_element_set_byte_pos(self, 0);
-        res = audio_pwm_stop();
-    }
-    return res;
-}
-
-static int _pwm_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size == AEL_IO_TIMEOUT) {
-        memset(in_buffer, 0x00, in_len);
-        r_size = in_len;
-    }
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-        audio_element_update_byte_pos(self, w_size);
-    } else {
-        w_size = r_size;
-    }
-    if (w_size == 0 || w_size == AEL_IO_DONE) {
-        pwm_wait_flush();
-    }
-    return w_size;
-}
-
-audio_element_handle_t pwm_stream_init(pwm_stream_cfg_t *config)
-{
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    audio_element_handle_t el;
-
-    audio_pwm_init(&config->pwm_config);
-    cfg.open = _pwm_open;
-    cfg.close = _pwm_close;
-    cfg.process = _pwm_process;
-    cfg.destroy = _pwm_destroy;
-    cfg.tag = "pwm";
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.buffer_len = config->buffer_len;
-    cfg.stack_in_ext = config->ext_stack;
-    if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _pwm_write;
-    } else {
-        ESP_LOGE(TAG, "PWM stream only support AUDIO_STREAM_WRITER mode, not support %d", config->type);
-        return NULL;
-    }
-
-    pwm_stream_t *pwm = audio_calloc(1, sizeof(pwm_stream_t));
-    AUDIO_NULL_CHECK(TAG, pwm, return NULL);
-    memcpy(&pwm->config, config, sizeof(pwm_stream_cfg_t));
-
-    pwm->type = AUDIO_STREAM_WRITER;
-    pwm->uninstall_drv = true;
-
-    el = audio_element_init(&cfg);
-    audio_element_setdata(el, pwm);
-
-    ESP_LOGD(TAG, "stream init,el:%p", el);
-    return el;
-}
-
-esp_err_t pwm_stream_set_clk(audio_element_handle_t pwm_stream, int rate, int bits, int ch)
-{
-    esp_err_t res = ESP_OK;
-    res |= audio_pwm_set_param(rate, bits, ch);
-    res |= audio_pwm_start();
-    return res;
-}
+/*
+ *  * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <string.h>
+#include <inttypes.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+
+#include "audio_mem.h"
+#include "audio_sys.h"
+#include "audio_error.h"
+#include "audio_element.h"
+#include "esp_log.h"
+#include "esp_err.h"
+
+#include "soc/ledc_struct.h"
+#include "soc/ledc_reg.h"
+#include "pwm_stream.h"
+#include "audio_idf_version.h"
+#include "soc/timer_group_struct.h"
+
+static const char *TAG = "PWM_STREAM";
+
+#define BUFFER_MIN_SIZE (256UL)
+#define SAMPLE_RATE_MAX (48000)
+#define SAMPLE_RATE_MIN (8000)
+#define CHANNEL_LEFT_INDEX  (0)
+#define CHANNEL_RIGHT_INDEX (1)
+#define CHANNEL_LEFT_MASK   (0x01)
+#define CHANNEL_RIGHT_MASK  (0x02)
+#define AUDIO_PWM_CH_MAX (2)
+
+typedef struct {
+    char *buf;                         /**< Original pointer */
+    uint32_t volatile head;            /**< ending pointer */
+    uint32_t volatile tail;            /**< Read pointer */
+    uint32_t size;                     /**< Buffer size */
+    uint32_t is_give;                  /**< semaphore give flag */
+    SemaphoreHandle_t semaphore;       /**< Semaphore for data */
+} data_list_t;
+typedef data_list_t *pwm_data_handle_t;
+
+typedef enum {
+    AUDIO_PWM_STATUS_UNINIT = 0,    /*!< pwm audio uninitialized */
+    AUDIO_PWM_STATUS_IDLE   = 1,    /*!< pwm audio idle */
+    AUDIO_PWM_STATUS_BUSY   = 2,    /*!< pwm audio busy */
+} audio_pwm_status_t;
+
+typedef struct {
+    audio_pwm_config_t    config;                          /**< pwm audio config struct */
+    ledc_channel_config_t ledc_channel[AUDIO_PWM_CH_MAX];  /**< ledc channel config */
+    ledc_timer_config_t   ledc_timer;                      /**< ledc timer config  */
+    timg_dev_t            *timg_dev;                       /**< timer group register pointer */
+    pwm_data_handle_t     data;                            /**< audio data pointer */
+    uint32_t              channel_mask;                    /**< channel gpio mask */
+    uint32_t              channel_set_num;                 /**< channel audio set number */
+    int32_t               framerate;                       /*!< frame rates in Hz */
+    int32_t               bits_per_sample;                 /*!< bits per sample (16, 32) */
+    audio_pwm_status_t    status;
+} audio_pwm_t;
+typedef audio_pwm_t *audio_pwm_handle_t;
+
+static volatile uint32_t *g_ledc_left_conf0_val  = NULL;
+static volatile uint32_t *g_ledc_left_conf1_val  = NULL;
+static volatile uint32_t *g_ledc_left_duty_val   = NULL;
+static volatile uint32_t *g_ledc_right_conf0_val = NULL;
+static volatile uint32_t *g_ledc_right_conf1_val = NULL;
+static volatile uint32_t *g_ledc_right_duty_val  = NULL;
+static audio_pwm_handle_t g_audio_pwm_handle = NULL;
+
+typedef struct pwm_stream {
+    audio_stream_type_t type;
+    pwm_stream_cfg_t    config;
+    bool                is_open;
+    bool                uninstall_drv;
+} pwm_stream_t;
+
+static esp_err_t pwm_data_list_destroy(pwm_data_handle_t data)
+{
+    if (data == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+    if (data->buf) {
+        audio_free(data->buf);
+    }
+    if (data->semaphore) {
+        vSemaphoreDelete(data->semaphore);
+    }
+    audio_free(data);
+    data = NULL;
+    return ESP_OK;
+}
+
+static pwm_data_handle_t pwm_data_list_create(int size)
+{
+    if (size < (BUFFER_MIN_SIZE << 2)) {
+        ESP_LOGE(TAG, "Invalid buffer size, Minimum = %d", (int)(BUFFER_MIN_SIZE << 2));
+        return NULL;
+    }
+
+    pwm_data_handle_t data = heap_caps_calloc(1, sizeof(data_list_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
+    AUDIO_NULL_CHECK(TAG, data, goto data_error);
+
+    data->buf = heap_caps_calloc(1, size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
+    AUDIO_NULL_CHECK(TAG, data->buf, goto data_error);
+
+    data->semaphore = xSemaphoreCreateBinary();
+    AUDIO_NULL_CHECK(TAG, data->semaphore, goto data_error);
+
+    data->is_give = 0;
+    data->head = data->tail = 0;
+    data->size = size;
+    return data;
+
+data_error:
+    if (data->semaphore != NULL) {
+        vSemaphoreDelete(data->semaphore);
+        data->semaphore = NULL;
+    }
+    if (data->buf) {
+        audio_free(data->buf);
+        data->buf = NULL;
+    }
+    if (data) {
+        audio_free(data);
+        data = NULL;
+    }
+    return NULL;
+}
+
+static uint32_t IRAM_ATTR pwm_data_list_get_count(pwm_data_handle_t data)
+{
+    uint32_t tail = data->tail;
+    if (data->head >= tail) {
+        return (data->head - tail);
+    }
+    return (data->size - (tail - data->head));
+}
+
+static uint32_t IRAM_ATTR pwm_data_list_get_free(pwm_data_handle_t data)
+{
+    return (data->size - pwm_data_list_get_count(data) - 1);
+}
+
+static esp_err_t pwm_data_list_flush(pwm_data_handle_t data)
+{
+    data->tail = data->head = 0;
+    return ESP_OK;
+}
+
+static esp_err_t IRAM_ATTR pwm_data_list_read_byte(pwm_data_handle_t data, uint8_t *outdata)
+{
+    uint32_t tail = data->tail;
+    if ((tail == data->head) || (tail == (data->head + 1))) {
+        return ESP_FAIL;
+    }
+    *outdata = data->buf[tail];
+    tail++;
+    if (tail == data->size) {
+        tail = 0;
+    }
+
+    data->tail = tail;
+    return ESP_OK;
+}
+
+static esp_err_t pwm_data_list_write_byte(pwm_data_handle_t data, const uint8_t indata)
+{
+    uint32_t next_head = data->head + 1;
+    if (next_head == data->size) {
+        next_head = 0;
+    }
+    if (next_head == data->tail) {
+        return ESP_FAIL;
+    }
+    data->buf[data->head] = indata;
+    data->head = next_head;
+    return ESP_OK;
+}
+
+static esp_err_t pwm_data_list_wait_semaphore(pwm_data_handle_t data, TickType_t ticks_to_wait)
+{
+    data->is_give = 0;
+    if (xSemaphoreTake(data->semaphore, ticks_to_wait) == pdTRUE) {
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+static esp_err_t pwm_data_list_wait_flushed(pwm_data_handle_t data, TickType_t ticks_to_wait)
+{
+    data->is_give = 2;
+    if (xSemaphoreTake(data->semaphore, ticks_to_wait) == pdTRUE) {
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+static inline void ledc_set_left_duty_fast(uint32_t duty_val)
+{
+    *g_ledc_left_duty_val = (duty_val) << 4;
+    *g_ledc_left_conf0_val |= 0x00000014;
+    *g_ledc_left_conf1_val |= 0x80000000;
+}
+
+static inline void ledc_set_right_duty_fast(uint32_t duty_val)
+{
+    *g_ledc_right_duty_val = (duty_val) << 4;
+    *g_ledc_right_conf0_val |= 0x00000014;
+    *g_ledc_right_conf1_val |= 0x80000000;
+}
+
+static void IRAM_ATTR timer_group_isr(void *para)
+{
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+
+    if (handle == NULL) {
+        return;
+    }
+
+#ifdef CONFIG_IDF_TARGET_ESP32S2
+#if ((ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)) && (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)))
+    if (handle->timg_dev->int_st.val & BIT(handle->config.timer_num)) {
+        handle->timg_dev->int_clr.val |= (1UL << handle->config.timer_num);
+    }
+    handle->timg_dev->hw_timer[handle->config.timer_num].config.alarm_en = TIMER_ALARM_EN;
+#else
+    if (handle->timg_dev->int_st_timers.val & BIT(handle->config.timer_num)) {
+        handle->timg_dev->int_clr_timers.val |= (1UL << handle->config.timer_num);
+    }
+    handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_alarm_en = TIMER_ALARM_EN;
+#endif
+#elif CONFIG_IDF_TARGET_ESP32
+    if (handle->timg_dev->int_st_timers.val & BIT(handle->config.timer_num)) {
+        handle->timg_dev->int_clr_timers.val |= (1UL << handle->config.timer_num);
+    }
+    #if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+    handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_alarm_en = TIMER_ALARM_EN;
+    #else
+    handle->timg_dev->hw_timer[handle->config.timer_num].config.alarm_en = TIMER_ALARM_EN;
+    #endif
+#elif CONFIG_IDF_TARGET_ESP32S3
+    if (handle->timg_dev->int_st_timers.val & BIT(handle->config.timer_num)) {
+        handle->timg_dev->int_clr_timers.val |= (1UL << handle->config.timer_num);
+    }
+    handle->timg_dev->hw_timer[handle->config.timer_num].config.tn_alarm_en = TIMER_ALARM_EN;
+#endif
+
+    static uint8_t wave_h, wave_l;
+    static uint16_t value;
+
+    if (handle->channel_mask & CHANNEL_LEFT_MASK) {
+        if (handle->config.duty_resolution > 8) {
+            pwm_data_list_read_byte(handle->data, &wave_l);
+            if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
+                value = ((wave_h << 8) | wave_l);
+                ledc_set_left_duty_fast(value);
+            }
+        } else {
+            if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
+                ledc_set_left_duty_fast(wave_h);
+            }
+        }
+    }
+
+    if (handle->channel_mask & CHANNEL_RIGHT_MASK) {
+        if (handle->channel_set_num == 1) {
+            if (handle->config.duty_resolution > 8) {
+                ledc_set_right_duty_fast(value);
+            } else {
+                ledc_set_right_duty_fast(wave_h);
+            }
+        } else {
+            if (handle->config.duty_resolution > 8) {
+                pwm_data_list_read_byte(handle->data, &wave_l);
+                if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
+                    value = ((wave_h << 8) | wave_l);
+                    ledc_set_right_duty_fast(value);
+                }
+            } else {
+                if (ESP_OK == pwm_data_list_read_byte(handle->data, &wave_h)) {
+                    ledc_set_right_duty_fast(wave_h);
+                }
+            }
+        }
+    } else {
+        if (handle->channel_set_num == 2) {
+            if (handle->config.duty_resolution > 8) {
+                pwm_data_list_read_byte(handle->data, &wave_h);
+                pwm_data_list_read_byte(handle->data, &wave_h);
+            } else {
+                pwm_data_list_read_byte(handle->data, &wave_h);
+            }
+            pwm_data_list_read_byte(handle->data, &wave_l);
+        }
+    }
+
+    if ((0 == handle->data->is_give && pwm_data_list_get_free(handle->data) > BUFFER_MIN_SIZE) ||
+        (2 == handle->data->is_give && pwm_data_list_get_count(handle->data) == 0)) {
+        handle->data->is_give = 1;
+        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+        xSemaphoreGiveFromISR(handle->data->semaphore, &xHigherPriorityTaskWoken);
+        if (pdFALSE != xHigherPriorityTaskWoken) {
+            portYIELD_FROM_ISR();
+        }
+    }
+}
+
+static esp_err_t audio_pwm_init(const audio_pwm_config_t *cfg)
+{
+    esp_err_t res = ESP_OK;
+    AUDIO_NULL_CHECK(TAG, cfg, return ESP_ERR_INVALID_ARG);
+    if (!(cfg->tg_num < TIMER_GROUP_MAX)) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM TIMER GROUP NUMBER IS %d AND SHOULD BE 0 OR 1", __FILENAME__, __LINE__, __FUNCTION__, cfg->tg_num);
+    }
+    if (!(cfg->timer_num < TIMER_MAX)) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM TIMER NUMBER IS %d AND SHOULD BE 0 OR 1", __FILENAME__, __LINE__, __FUNCTION__, cfg->timer_num);
+    }
+
+    if (cfg->duty_resolution < 8 || cfg->duty_resolution > 10) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM RESOLUTION IS %d AND SHOULD BE 8, 9, 10", __FILENAME__, __LINE__, __FUNCTION__, cfg->duty_resolution);
+    }
+
+    audio_pwm_handle_t handle = NULL;
+    handle = heap_caps_calloc(1, sizeof(audio_pwm_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
+    AUDIO_NULL_CHECK(TAG, handle, goto init_error);
+
+    handle->data = pwm_data_list_create(cfg->data_len);
+    AUDIO_NULL_CHECK(TAG, handle->data, goto init_error);
+
+    handle->config = *cfg;
+    g_audio_pwm_handle = handle;
+    if (cfg->tg_num == TIMER_GROUP_0) {
+        handle->timg_dev = &TIMERG0;
+    } else {
+        handle->timg_dev = &TIMERG1;
+    }
+    handle->channel_mask = 0;
+    if (handle->config.gpio_num_left >= 0) {
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].channel = handle->config.ledc_channel_left;
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].duty = 0;
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].gpio_num = handle->config.gpio_num_left;
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].speed_mode = LEDC_LOW_SPEED_MODE;
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].hpoint = 0;
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].timer_sel = handle->config.ledc_timer_sel;
+        handle->ledc_channel[CHANNEL_LEFT_INDEX].intr_type = LEDC_INTR_DISABLE;
+        res = ledc_channel_config(&handle->ledc_channel[CHANNEL_LEFT_INDEX]);
+        AUDIO_CHECK(TAG, ESP_OK == res, goto init_error, "AUDIO PWM LEFT CHANNEL CONFIG ERROR");
+        handle->channel_mask |= CHANNEL_LEFT_MASK;
+    }
+    if (handle->config.gpio_num_right >= 0) {
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel = handle->config.ledc_channel_right;
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].duty = 0;
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].gpio_num = handle->config.gpio_num_right;
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].speed_mode = LEDC_LOW_SPEED_MODE;
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].hpoint = 0;
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].timer_sel = handle->config.ledc_timer_sel;
+        handle->ledc_channel[CHANNEL_RIGHT_INDEX].intr_type = LEDC_INTR_DISABLE;
+        res = ledc_channel_config(&handle->ledc_channel[CHANNEL_RIGHT_INDEX]);
+        AUDIO_CHECK(TAG, ESP_OK == res, goto init_error, "AUDIO PWM RIGHT CHANNEL CONFIG ERROR");
+        handle->channel_mask |= CHANNEL_RIGHT_MASK;
+    }
+    AUDIO_CHECK(TAG, 0 != handle->channel_mask, goto init_error, "AUDIO PWM CHANNEL MASK IS 0");
+
+#ifdef CONFIG_IDF_TARGET_ESP32S2
+    handle->ledc_timer.clk_cfg = LEDC_USE_APB_CLK;
+#endif
+
+    handle->ledc_timer.speed_mode = LEDC_LOW_SPEED_MODE;
+    handle->ledc_timer.duty_resolution = handle->config.duty_resolution;
+    handle->ledc_timer.timer_num = handle->config.ledc_timer_sel;
+    uint32_t freq = (APB_CLK_FREQ / (1 << handle->ledc_timer.duty_resolution));
+    handle->ledc_timer.freq_hz = freq - (freq % 1000);
+    res = ledc_timer_config(&handle->ledc_timer);
+    AUDIO_CHECK(TAG, ESP_OK == res, goto init_error, "AUDIO PWM TIMER ERROR");
+
+#if defined(CONFIG_IDF_TARGET_ESP32P4)
+    g_ledc_left_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].duty_r.val;
+    g_ledc_right_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].duty_r.val;
+#else
+    g_ledc_left_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].duty.val;
+    g_ledc_right_duty_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].duty.val;
+#endif // CONFIG_IDF_TARGET_ESP32P4
+    g_ledc_left_conf0_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].conf0.val;
+    g_ledc_left_conf1_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_LEFT_INDEX].channel].conf1.val;
+    g_ledc_right_conf0_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].conf0.val;
+    g_ledc_right_conf1_val = &LEDC.channel_group[handle->ledc_timer.speed_mode].channel[handle->ledc_channel[CHANNEL_RIGHT_INDEX].channel].conf1.val;
+
+    handle->status = AUDIO_PWM_STATUS_IDLE;
+    return res;
+
+init_error:
+    if (handle->data) {
+        audio_free(handle->data);
+        handle->data = NULL;
+    }
+    if (handle) {
+        audio_free(handle);
+        handle = NULL;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t audio_pwm_set_param(int rate, ledc_timer_bit_t bits, int ch)
+{
+    esp_err_t res = ESP_OK;
+    AUDIO_CHECK(TAG, g_audio_pwm_handle->status != AUDIO_PWM_STATUS_BUSY, return ESP_FAIL, "AUDIO PWM CAN NOT SET PARAM, WHEN AUDIO PWM STATUS IS BUSY");
+    if (rate > SAMPLE_RATE_MAX || rate < SAMPLE_RATE_MIN) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM SAMPLE IS %d AND SHOULD BE BETWEEN 8000 AND 48000", __FILENAME__, __LINE__, __FUNCTION__, rate);
+    }
+    if (!(bits == 32 || bits == 16 || bits == 8)) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM BITS IS %d AND SHOULD BE 8, 16, 32", __FILENAME__, __LINE__, __FUNCTION__, bits);
+    }
+    if (!(ch == 2 || ch == 1)) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM CH IS %d AND SHOULD BE 1 OR 2", __FILENAME__, __LINE__, __FUNCTION__, ch);
+    }
+
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    handle->framerate = rate;
+    handle->bits_per_sample = bits;
+    handle->channel_set_num = ch;
+    timer_config_t config = {0};
+    config.divider = 16;
+    config.counter_dir = TIMER_COUNT_UP;
+    config.counter_en = TIMER_PAUSE;
+    config.alarm_en = TIMER_ALARM_EN;
+    config.intr_type = TIMER_INTR_LEVEL;
+    config.auto_reload = 1;
+
+#ifdef TIMER_GROUP_SUPPORTS_XTAL_CLOCK
+    config.clk_src = TIMER_SRC_CLK_APB;
+#endif
+
+    timer_init(handle->config.tg_num, handle->config.timer_num, &config);
+    timer_set_counter_value(handle->config.tg_num, handle->config.timer_num, 0x00000000ULL);
+    timer_set_alarm_value(handle->config.tg_num, handle->config.timer_num, (APB_CLK_FREQ / config.divider) / handle->framerate);
+    timer_enable_intr(handle->config.tg_num, handle->config.timer_num);
+    timer_isr_register(handle->config.tg_num, handle->config.timer_num, timer_group_isr, NULL, ESP_INTR_FLAG_IRAM, NULL);
+    return res;
+}
+
+esp_err_t audio_pwm_set_sample_rate(int rate)
+{
+    esp_err_t res;
+    AUDIO_CHECK(TAG, g_audio_pwm_handle->status != AUDIO_PWM_STATUS_BUSY, return ESP_FAIL, "AUDIO PWM CAN NOT SET PARAM, WHEN AUDIO PWM STATUS IS BUSY");
+    if (rate > SAMPLE_RATE_MAX || rate < SAMPLE_RATE_MIN) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM SAMPLE IS %d AND SHOULD BE BETWEEN 8000 AND 48000", __FILENAME__, __LINE__, __FUNCTION__, rate);
+    }
+
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    handle->framerate = rate;
+    uint16_t div = 1;
+#ifdef CONFIG_IDF_TARGET_ESP32S2
+#if ((ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 2, 0)) && (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)))
+    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.divider;
+#else
+    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_divider;
+#endif
+#elif CONFIG_IDF_TARGET_ESP32
+    #if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.tx_divider;
+    #else
+    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.divider;
+    #endif
+#elif CONFIG_IDF_TARGET_ESP32S3
+    div = (uint16_t)handle->timg_dev->hw_timer[handle->config.timer_num].config.tn_divider;
+#endif
+
+    res = timer_set_alarm_value(handle->config.tg_num, handle->config.timer_num, (APB_CLK_FREQ / div) / handle->framerate);
+    return res;
+}
+
+static esp_err_t pwm_data_convert(pwm_data_handle_t data, uint8_t *inbuf, int32_t bits_per, int32_t duty, uint32_t bytes)
+{
+    int8_t shift = bits_per - duty;
+    uint32_t len = bytes;
+
+    if (bits_per == 16) {
+        len >>= 1;
+        uint16_t *buf_16b = (uint16_t *)inbuf;
+        uint16_t value;
+        int16_t temp;
+        if (duty > 8) {
+            for (size_t i = 0; i < len; i++) {
+                temp = buf_16b[i];
+                value = temp + 0x7fff;
+                value >>= shift;
+                pwm_data_list_write_byte(data, value);
+                pwm_data_list_write_byte(data, value >> 8);
+            }
+        } else {
+            for (size_t i = 0; i < len; i++) {
+                temp = buf_16b[i];
+                value = temp + 0x7fff;
+                value >>= shift;
+                pwm_data_list_write_byte(data, value);
+            }
+        }
+    } else if (bits_per == 32) {
+        len >>= 2;
+        uint32_t *buf_32b = (uint32_t *)inbuf;
+        uint32_t value;
+        int32_t temp;
+        if (duty > 8) {
+            for (size_t i = 0; i < len; i++) {
+                temp = buf_32b[i];
+                value = temp + 0x7fffffff;
+                value >>= shift;
+                pwm_data_list_write_byte(data, value);
+                pwm_data_list_write_byte(data, value >> 8);
+            }
+        } else {
+            for (size_t i = 0; i < len; i++) {
+                temp = buf_32b[i];
+                value = temp + 0x7fffffff;
+                value >>= shift;
+                pwm_data_list_write_byte(data, value);
+            }
+        }
+    } else {
+        ESP_LOGE(TAG, "Only support bits (16 or 32), now bits_per is %"PRId32, bits_per);
+    }
+    return ESP_OK;
+}
+
+static uint32_t pwm_get_data_duration(uint32_t data_size)
+{
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    uint32_t sample_bytes = (handle->config.duty_resolution) > 8 ? 2: 1;
+    uint32_t byte_rate = sample_bytes * handle->channel_set_num * handle->framerate;
+    if (byte_rate == 0) {
+        return 0;
+    }
+    // Add extra 20ms
+    return (data_size * 1000 / byte_rate) + 20;
+}
+
+static void pwm_wait_flush(void)
+{
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    uint32_t data_size = pwm_data_list_get_count(handle->data);
+    if (handle->status == AUDIO_PWM_STATUS_BUSY && data_size > 0) {
+        pwm_data_list_wait_flushed(handle->data, pwm_get_data_duration(data_size) / portTICK_PERIOD_MS);
+    }
+}
+
+esp_err_t audio_pwm_write(uint8_t *inbuf, size_t inbuf_len, size_t *bytes_written, TickType_t ticks_to_wait)
+{
+    esp_err_t res = ESP_OK;
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    AUDIO_NULL_CHECK(TAG, inbuf, return ESP_FAIL);
+
+    *bytes_written = 0;
+    pwm_data_handle_t data = handle->data;
+    while (inbuf_len) {
+        if (ESP_OK == pwm_data_list_wait_semaphore(data, ticks_to_wait)) {
+            uint32_t free = pwm_data_list_get_free(data);
+            uint32_t bytes_can_write = inbuf_len;
+            if (inbuf_len > free) {
+                bytes_can_write = free;
+            }
+            bytes_can_write &= 0xfffffffc;
+            if (0 == bytes_can_write) {
+                *bytes_written += inbuf_len;
+                return ESP_OK;
+            }
+            pwm_data_convert(data, inbuf, handle->bits_per_sample, handle->config.duty_resolution, bytes_can_write);
+            inbuf += bytes_can_write;
+            inbuf_len -= bytes_can_write;
+            *bytes_written += bytes_can_write;
+        } else {
+            res = ESP_FAIL;
+        }
+    }
+    return res;
+}
+
+static esp_err_t audio_pwm_start(void)
+{
+    esp_err_t res;
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+
+    if (handle->status != AUDIO_PWM_STATUS_IDLE) {
+        ESP_LOGE(TAG, "%s:%d (%s): AUDIO PWM STATE IS %d, AND SHOULD BE IDLE WHEN PWM START", __FILENAME__, __LINE__, __FUNCTION__, handle->status);
+    }
+
+    handle->status = AUDIO_PWM_STATUS_BUSY;
+    timer_enable_intr(handle->config.tg_num, handle->config.timer_num);
+    res = timer_start(handle->config.tg_num, handle->config.timer_num);
+    return res;
+}
+
+static esp_err_t audio_pwm_stop(void)
+{
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    timer_pause(handle->config.tg_num, handle->config.timer_num);
+    timer_disable_intr(handle->config.tg_num, handle->config.timer_num);
+    pwm_data_list_flush(handle->data);
+    handle->status = AUDIO_PWM_STATUS_IDLE;
+    return ESP_OK;
+}
+
+static esp_err_t audio_pwm_deinit(void)
+{
+    audio_pwm_handle_t handle = g_audio_pwm_handle;
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_FAIL);
+    handle->status = AUDIO_PWM_STATUS_UNINIT;
+    audio_pwm_stop();
+    for (size_t i = 0; i < AUDIO_PWM_CH_MAX; i++) {
+        if (handle->ledc_channel[i].gpio_num >= 0) {
+            ledc_stop(handle->ledc_channel[i].speed_mode, handle->ledc_channel[i].channel, 0);
+        }
+    }
+
+    for (size_t i = 0; i < AUDIO_PWM_CH_MAX; i++) {
+        if (handle->ledc_channel[i].gpio_num >= 0) {
+            gpio_set_direction(handle->ledc_channel[i].gpio_num, GPIO_MODE_INPUT);
+        }
+    }
+
+    pwm_data_list_destroy(handle->data);
+    audio_free(handle);
+    return ESP_OK;
+}
+
+static int _pwm_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    size_t bytes_written = 0;
+    audio_pwm_write((uint8_t *)buffer, len, &bytes_written, ticks_to_wait);
+    return bytes_written;
+}
+
+static esp_err_t _pwm_destroy(audio_element_handle_t self)
+{
+    esp_err_t res = ESP_OK;
+    pwm_stream_t *pwm = (pwm_stream_t *)audio_element_getdata(self);
+    if (pwm->uninstall_drv) {
+        res = audio_pwm_deinit();
+    }
+    audio_free(pwm);
+    return res;
+}
+
+static esp_err_t _pwm_open(audio_element_handle_t self)
+{
+    esp_err_t res = ESP_OK;
+    pwm_stream_t *pwm = (pwm_stream_t *)audio_element_getdata(self);
+    if (pwm->is_open) {
+        return ESP_OK;
+    }
+    res = audio_element_set_input_timeout(self, 2000 / portTICK_PERIOD_MS);
+    pwm->is_open = true;
+    return res;
+}
+
+static esp_err_t _pwm_close(audio_element_handle_t self)
+{
+    esp_err_t res = ESP_OK;
+    pwm_stream_t *pwm = (pwm_stream_t *)audio_element_getdata(self);
+    pwm->is_open = false;
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_report_pos(self);
+        audio_element_set_byte_pos(self, 0);
+        res = audio_pwm_stop();
+    }
+    return res;
+}
+
+static int _pwm_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size == AEL_IO_TIMEOUT) {
+        memset(in_buffer, 0x00, in_len);
+        r_size = in_len;
+    }
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+        audio_element_update_byte_pos(self, w_size);
+    } else {
+        w_size = r_size;
+    }
+    if (w_size == 0 || w_size == AEL_IO_DONE) {
+        pwm_wait_flush();
+    }
+    return w_size;
+}
+
+audio_element_handle_t pwm_stream_init(pwm_stream_cfg_t *config)
+{
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    audio_element_handle_t el;
+
+    audio_pwm_init(&config->pwm_config);
+    cfg.open = _pwm_open;
+    cfg.close = _pwm_close;
+    cfg.process = _pwm_process;
+    cfg.destroy = _pwm_destroy;
+    cfg.tag = "pwm";
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.buffer_len = config->buffer_len;
+    cfg.stack_in_ext = config->ext_stack;
+    if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _pwm_write;
+    } else {
+        ESP_LOGE(TAG, "PWM stream only support AUDIO_STREAM_WRITER mode, not support %d", config->type);
+        return NULL;
+    }
+
+    pwm_stream_t *pwm = audio_calloc(1, sizeof(pwm_stream_t));
+    AUDIO_NULL_CHECK(TAG, pwm, return NULL);
+    memcpy(&pwm->config, config, sizeof(pwm_stream_cfg_t));
+
+    pwm->type = AUDIO_STREAM_WRITER;
+    pwm->uninstall_drv = true;
+
+    el = audio_element_init(&cfg);
+    audio_element_setdata(el, pwm);
+
+    ESP_LOGD(TAG, "stream init,el:%p", el);
+    return el;
+}
+
+esp_err_t pwm_stream_set_clk(audio_element_handle_t pwm_stream, int rate, int bits, int ch)
+{
+    esp_err_t res = ESP_OK;
+    res |= audio_pwm_set_param(rate, bits, ch);
+    res |= audio_pwm_start();
+    return res;
+}
diff --git a/components/audio_stream/raw_stream.c b/components/audio_stream/raw_stream.c
index 6e2d0440..a28a3914 100644
--- a/components/audio_stream/raw_stream.c
+++ b/components/audio_stream/raw_stream.c
@@ -1,96 +1,96 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <sys/unistd.h>
-#include <sys/stat.h>
-#include <stdio.h>
-#include <string.h>
-#include "errno.h"
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-
-#include "raw_stream.h"
-#include "audio_common.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "esp_system.h"
-#include "esp_log.h"
-
-static const char *TAG = "RAW_STREAM";
-
-typedef struct raw_stream {
-    audio_stream_type_t type;
-} raw_stream_t;
-
-int raw_stream_read(audio_element_handle_t pipeline, char *buffer, int len)
-{
-    int ret = audio_element_input(pipeline, buffer, len);
-    if (ret == AEL_IO_DONE || ret == AEL_IO_OK) {
-        audio_element_report_status(pipeline, AEL_STATUS_STATE_FINISHED);
-    } else if ((ret < 0) && (ret != AEL_IO_TIMEOUT)) {
-        audio_element_report_status(pipeline, AEL_STATUS_STATE_STOPPED);
-    }
-    return ret;
-
-}
-int raw_stream_write(audio_element_handle_t pipeline, char *buffer, int len)
-{
-    int ret = audio_element_output(pipeline, buffer, len);
-    if (ret == AEL_IO_DONE || ret == AEL_IO_OK) {
-        audio_element_report_status(pipeline, AEL_STATUS_STATE_FINISHED);
-    } else if ((ret < 0) && (ret != AEL_IO_TIMEOUT)) {
-        audio_element_report_status(pipeline, AEL_STATUS_STATE_STOPPED);
-    }
-    return ret;
-}
-
-static esp_err_t _raw_destroy(audio_element_handle_t self)
-{
-    raw_stream_t *raw = (raw_stream_t *)audio_element_getdata(self);
-    audio_free(raw);
-    return ESP_OK;
-}
-
-audio_element_handle_t raw_stream_init(raw_stream_cfg_t *config)
-{
-    raw_stream_t *raw = audio_calloc(1, sizeof(raw_stream_t));
-    AUDIO_MEM_CHECK(TAG, raw, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.task_stack = -1; // No need task
-    cfg.destroy = _raw_destroy;
-    cfg.tag = "raw";
-    cfg.out_rb_size = config->out_rb_size;
-    raw->type = config->type;
-    audio_element_handle_t el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, {
-        audio_free(raw);
-        return NULL;
-    });
-    audio_element_setdata(el, raw);
-    ESP_LOGD(TAG, "stream init,el:%p", el);
-    return el;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <sys/unistd.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include "errno.h"
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+
+#include "raw_stream.h"
+#include "audio_common.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "esp_system.h"
+#include "esp_log.h"
+
+static const char *TAG = "RAW_STREAM";
+
+typedef struct raw_stream {
+    audio_stream_type_t type;
+} raw_stream_t;
+
+int raw_stream_read(audio_element_handle_t pipeline, char *buffer, int len)
+{
+    int ret = audio_element_input(pipeline, buffer, len);
+    if (ret == AEL_IO_DONE || ret == AEL_IO_OK) {
+        audio_element_report_status(pipeline, AEL_STATUS_STATE_FINISHED);
+    } else if ((ret < 0) && (ret != AEL_IO_TIMEOUT)) {
+        audio_element_report_status(pipeline, AEL_STATUS_STATE_STOPPED);
+    }
+    return ret;
+
+}
+int raw_stream_write(audio_element_handle_t pipeline, char *buffer, int len)
+{
+    int ret = audio_element_output(pipeline, buffer, len);
+    if (ret == AEL_IO_DONE || ret == AEL_IO_OK) {
+        audio_element_report_status(pipeline, AEL_STATUS_STATE_FINISHED);
+    } else if ((ret < 0) && (ret != AEL_IO_TIMEOUT)) {
+        audio_element_report_status(pipeline, AEL_STATUS_STATE_STOPPED);
+    }
+    return ret;
+}
+
+static esp_err_t _raw_destroy(audio_element_handle_t self)
+{
+    raw_stream_t *raw = (raw_stream_t *)audio_element_getdata(self);
+    audio_free(raw);
+    return ESP_OK;
+}
+
+audio_element_handle_t raw_stream_init(raw_stream_cfg_t *config)
+{
+    raw_stream_t *raw = audio_calloc(1, sizeof(raw_stream_t));
+    AUDIO_MEM_CHECK(TAG, raw, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.task_stack = -1; // No need task
+    cfg.destroy = _raw_destroy;
+    cfg.tag = "raw";
+    cfg.out_rb_size = config->out_rb_size;
+    raw->type = config->type;
+    audio_element_handle_t el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, {
+        audio_free(raw);
+        return NULL;
+    });
+    audio_element_setdata(el, raw);
+    ESP_LOGD(TAG, "stream init,el:%p", el);
+    return el;
+}
diff --git a/components/audio_stream/spiffs_stream.c b/components/audio_stream/spiffs_stream.c
index d7267056..3be800b3 100644
--- a/components/audio_stream/spiffs_stream.c
+++ b/components/audio_stream/spiffs_stream.c
@@ -1,271 +1,271 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <sys/unistd.h>
-#include <sys/stat.h>
-#include <stdio.h>
-#include <string.h>
-#include "errno.h"
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-
-#include "spiffs_stream.h"
-#include "audio_common.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "wav_head.h"
-#include "esp_log.h"
-
-#define FILE_WAV_SUFFIX_TYPE  "wav"
-#define FILE_OPUS_SUFFIX_TYPE "opus"
-#define FILE_AMR_SUFFIX_TYPE "amr"
-#define FILE_AMRWB_SUFFIX_TYPE "Wamr"
-
-static const char *TAG = "SPIFFS_STREAM";
-
-typedef enum {
-    STREAM_TYPE_UNKNOWN,
-    STREAM_TYPE_WAV,
-    STREAM_TYPE_OPUS,
-    STREAM_TYPE_AMR,
-    STREAM_TYPE_AMRWB,
-} wr_stream_type_t;
-
-typedef struct spiffs_stream {
-    audio_stream_type_t type;
-    int block_size;
-    bool is_open;
-    FILE *file;
-    wr_stream_type_t w_type;
-    bool write_header;
-} spiffs_stream_t;
-
-static wr_stream_type_t get_type(const char *str)
-{
-    char *relt = strrchr(str, '.');
-    if (relt != NULL) {
-        relt ++;
-        ESP_LOGD(TAG, "result = %s", relt);
-        if (strncasecmp(relt, FILE_WAV_SUFFIX_TYPE, 3) == 0) {
-            return STREAM_TYPE_WAV;
-        } else if (strncasecmp(relt, FILE_OPUS_SUFFIX_TYPE, 4) == 0) {
-            return STREAM_TYPE_OPUS;
-        } else if (strncasecmp(relt, FILE_AMR_SUFFIX_TYPE, 3) == 0) {
-            return STREAM_TYPE_AMR;
-        } else if (strncasecmp(relt, FILE_AMRWB_SUFFIX_TYPE, 4) == 0) {
-            return STREAM_TYPE_AMRWB;
-        } else {
-            return STREAM_TYPE_UNKNOWN;
-        }
-    } else {
-        return STREAM_TYPE_UNKNOWN;
-    }
-}
-
-static esp_err_t _spiffs_open(audio_element_handle_t self)
-{
-    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
-
-    audio_element_info_t info;
-    char *uri = audio_element_get_uri(self);
-    ESP_LOGD(TAG, "_spiffs_open,   %s", uri);
-    char *path = strstr(uri, "/spiffs");
-    audio_element_getinfo(self, &info);
-    if (path == NULL) {
-        ESP_LOGE(TAG, "Need file path to open");
-        return ESP_FAIL;
-    }
-    if (spiffs->is_open) {
-        ESP_LOGE(TAG, "Already opened");
-        return ESP_FAIL;
-    }
-    if (spiffs->type == AUDIO_STREAM_READER) {
-        spiffs->file = fopen(path, "r");
-        struct stat siz =  { 0 };
-        stat(path, &siz);
-        info.total_bytes = siz.st_size;
-        ESP_LOGI(TAG, "File size is %d byte, pos:%d", (int)siz.st_size, (int)info.byte_pos);
-        if (spiffs->file && (info.byte_pos > 0)) {
-            if (fseek(spiffs->file, info.byte_pos, SEEK_SET) != 0) {
-                ESP_LOGE(TAG, "Error seek file");
-                return ESP_FAIL;
-            }
-        }
-    } else if (spiffs->type == AUDIO_STREAM_WRITER) {
-        spiffs->file = fopen(path, "w+");
-        spiffs->w_type =  get_type(path);
-        if (spiffs->file && STREAM_TYPE_WAV == spiffs->w_type) {
-            wav_header_t info = {0};
-            fwrite(&info, 1, sizeof(wav_header_t), spiffs->file);
-            fsync(fileno(spiffs->file));
-        } else if (spiffs->file && (STREAM_TYPE_AMR == spiffs->w_type) && (spiffs->write_header == true)) {
-            fwrite("#!AMR\n", 1, 6, spiffs->file);
-            fsync(fileno(spiffs->file));
-        } else if (spiffs->file && (STREAM_TYPE_AMRWB == spiffs->w_type) && (spiffs->write_header == true)) {
-            fwrite("#!AMR-WB\n", 1, 9, spiffs->file);
-            fsync(fileno(spiffs->file));
-        }
-    } else {
-        ESP_LOGE(TAG, "SPIFFS must be Reader or Writer");
-        return ESP_FAIL;
-    }
-    if (spiffs->file == NULL) {
-        ESP_LOGE(TAG, "Failed to open file %s", path);
-        return ESP_FAIL;
-    }
-    spiffs->is_open = true;
-    if (info.byte_pos && fseek(spiffs->file, info.byte_pos, SEEK_SET) != 0) {
-        ESP_LOGE(TAG, "Failed to seek to %d/%d", (int)info.byte_pos, (int)info.total_bytes);
-        return ESP_FAIL;
-    }
-    int ret = audio_element_set_total_bytes(self, info.total_bytes);
-    return ret;
-}
-
-static int _spiffs_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-
-    ESP_LOGD(TAG, "read len=%d, pos=%d/%d", len, (int)info.byte_pos, (int)info.total_bytes);
-    int rlen = fread(buffer, 1, len, spiffs->file);
-    if (rlen <= 0) {
-        ESP_LOGW(TAG, "No more data, ret:%d", rlen);
-    } else {
-        audio_element_update_byte_pos(self, rlen);
-    }
-    return rlen;
-}
-
-static int _spiffs_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
-    audio_element_info_t info;
-    audio_element_getinfo(self, &info);
-    int wlen = fwrite(buffer, 1, len, spiffs->file);
-    fsync(fileno(spiffs->file));
-    ESP_LOGD(TAG, "write:%d, errno:%d, pos:%d", wlen, errno, (int)info.byte_pos);
-    if (wlen > 0) {
-        audio_element_update_byte_pos(self, wlen);
-    }
-    return wlen;
-}
-
-static int _spiffs_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _spiffs_close(audio_element_handle_t self)
-{
-    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
-
-    if (AUDIO_STREAM_WRITER == spiffs->type
-        && spiffs->file
-        && STREAM_TYPE_WAV == spiffs->w_type) {
-        wav_header_t *wav_info = (wav_header_t *) audio_malloc(sizeof(wav_header_t));
-
-        AUDIO_MEM_CHECK(TAG, wav_info, return ESP_ERR_NO_MEM);
-
-        if (fseek(spiffs->file, 0, SEEK_SET) != 0) {
-            ESP_LOGE(TAG, "Error seek file, line=%d", __LINE__);
-        }
-        audio_element_info_t info;
-        audio_element_getinfo(self, &info);
-        wav_head_init(wav_info, info.sample_rates, info.bits, info.channels);
-        wav_head_size(wav_info, (uint32_t)info.byte_pos);
-        fwrite(wav_info, 1, sizeof(wav_header_t), spiffs->file);
-        fsync(fileno(spiffs->file));
-        audio_free(wav_info);
-    }
-
-    if (spiffs->is_open) {
-        fclose(spiffs->file);
-        spiffs->is_open = false;
-    }
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_report_pos(self);
-        audio_element_set_byte_pos(self, 0);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _spiffs_destroy(audio_element_handle_t self)
-{
-    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
-    audio_free(spiffs);
-    return ESP_OK;
-}
-
-audio_element_handle_t spiffs_stream_init(spiffs_stream_cfg_t *config)
-{
-    audio_element_handle_t el;
-
-    spiffs_stream_t *spiffs = audio_calloc(1, sizeof(spiffs_stream_t));
-
-    AUDIO_MEM_CHECK(TAG, spiffs, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _spiffs_open;
-    cfg.close = _spiffs_close;
-    cfg.process = _spiffs_process;
-    cfg.destroy = _spiffs_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.buffer_len = config->buf_sz;
-    if (cfg.buffer_len == 0) {
-        cfg.buffer_len = SPIFFS_STREAM_BUF_SIZE;
-    }
-
-    cfg.tag = "spiffs";
-    spiffs->type = config->type;
-    spiffs->write_header = config->write_header;
-
-    if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _spiffs_write;
-    } else {
-        cfg.read = _spiffs_read;
-    }
-
-    el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, goto _spiffs_init_exit);
-    audio_element_setdata(el, spiffs);
-
-    return el;
-_spiffs_init_exit:
-    audio_free(spiffs);
-    return NULL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <sys/unistd.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include "errno.h"
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+
+#include "spiffs_stream.h"
+#include "audio_common.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "wav_head.h"
+#include "esp_log.h"
+
+#define FILE_WAV_SUFFIX_TYPE  "wav"
+#define FILE_OPUS_SUFFIX_TYPE "opus"
+#define FILE_AMR_SUFFIX_TYPE "amr"
+#define FILE_AMRWB_SUFFIX_TYPE "Wamr"
+
+static const char *TAG = "SPIFFS_STREAM";
+
+typedef enum {
+    STREAM_TYPE_UNKNOWN,
+    STREAM_TYPE_WAV,
+    STREAM_TYPE_OPUS,
+    STREAM_TYPE_AMR,
+    STREAM_TYPE_AMRWB,
+} wr_stream_type_t;
+
+typedef struct spiffs_stream {
+    audio_stream_type_t type;
+    int block_size;
+    bool is_open;
+    FILE *file;
+    wr_stream_type_t w_type;
+    bool write_header;
+} spiffs_stream_t;
+
+static wr_stream_type_t get_type(const char *str)
+{
+    char *relt = strrchr(str, '.');
+    if (relt != NULL) {
+        relt ++;
+        ESP_LOGD(TAG, "result = %s", relt);
+        if (strncasecmp(relt, FILE_WAV_SUFFIX_TYPE, 3) == 0) {
+            return STREAM_TYPE_WAV;
+        } else if (strncasecmp(relt, FILE_OPUS_SUFFIX_TYPE, 4) == 0) {
+            return STREAM_TYPE_OPUS;
+        } else if (strncasecmp(relt, FILE_AMR_SUFFIX_TYPE, 3) == 0) {
+            return STREAM_TYPE_AMR;
+        } else if (strncasecmp(relt, FILE_AMRWB_SUFFIX_TYPE, 4) == 0) {
+            return STREAM_TYPE_AMRWB;
+        } else {
+            return STREAM_TYPE_UNKNOWN;
+        }
+    } else {
+        return STREAM_TYPE_UNKNOWN;
+    }
+}
+
+static esp_err_t _spiffs_open(audio_element_handle_t self)
+{
+    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
+
+    audio_element_info_t info;
+    char *uri = audio_element_get_uri(self);
+    ESP_LOGD(TAG, "_spiffs_open,   %s", uri);
+    char *path = strstr(uri, "/spiffs");
+    audio_element_getinfo(self, &info);
+    if (path == NULL) {
+        ESP_LOGE(TAG, "Need file path to open");
+        return ESP_FAIL;
+    }
+    if (spiffs->is_open) {
+        ESP_LOGE(TAG, "Already opened");
+        return ESP_FAIL;
+    }
+    if (spiffs->type == AUDIO_STREAM_READER) {
+        spiffs->file = fopen(path, "r");
+        struct stat siz =  { 0 };
+        stat(path, &siz);
+        info.total_bytes = siz.st_size;
+        ESP_LOGI(TAG, "File size is %d byte, pos:%d", (int)siz.st_size, (int)info.byte_pos);
+        if (spiffs->file && (info.byte_pos > 0)) {
+            if (fseek(spiffs->file, info.byte_pos, SEEK_SET) != 0) {
+                ESP_LOGE(TAG, "Error seek file");
+                return ESP_FAIL;
+            }
+        }
+    } else if (spiffs->type == AUDIO_STREAM_WRITER) {
+        spiffs->file = fopen(path, "w+");
+        spiffs->w_type =  get_type(path);
+        if (spiffs->file && STREAM_TYPE_WAV == spiffs->w_type) {
+            wav_header_t info = {0};
+            fwrite(&info, 1, sizeof(wav_header_t), spiffs->file);
+            fsync(fileno(spiffs->file));
+        } else if (spiffs->file && (STREAM_TYPE_AMR == spiffs->w_type) && (spiffs->write_header == true)) {
+            fwrite("#!AMR\n", 1, 6, spiffs->file);
+            fsync(fileno(spiffs->file));
+        } else if (spiffs->file && (STREAM_TYPE_AMRWB == spiffs->w_type) && (spiffs->write_header == true)) {
+            fwrite("#!AMR-WB\n", 1, 9, spiffs->file);
+            fsync(fileno(spiffs->file));
+        }
+    } else {
+        ESP_LOGE(TAG, "SPIFFS must be Reader or Writer");
+        return ESP_FAIL;
+    }
+    if (spiffs->file == NULL) {
+        ESP_LOGE(TAG, "Failed to open file %s", path);
+        return ESP_FAIL;
+    }
+    spiffs->is_open = true;
+    if (info.byte_pos && fseek(spiffs->file, info.byte_pos, SEEK_SET) != 0) {
+        ESP_LOGE(TAG, "Failed to seek to %d/%d", (int)info.byte_pos, (int)info.total_bytes);
+        return ESP_FAIL;
+    }
+    int ret = audio_element_set_total_bytes(self, info.total_bytes);
+    return ret;
+}
+
+static int _spiffs_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+
+    ESP_LOGD(TAG, "read len=%d, pos=%d/%d", len, (int)info.byte_pos, (int)info.total_bytes);
+    int rlen = fread(buffer, 1, len, spiffs->file);
+    if (rlen <= 0) {
+        ESP_LOGW(TAG, "No more data, ret:%d", rlen);
+    } else {
+        audio_element_update_byte_pos(self, rlen);
+    }
+    return rlen;
+}
+
+static int _spiffs_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
+    audio_element_info_t info;
+    audio_element_getinfo(self, &info);
+    int wlen = fwrite(buffer, 1, len, spiffs->file);
+    fsync(fileno(spiffs->file));
+    ESP_LOGD(TAG, "write:%d, errno:%d, pos:%d", wlen, errno, (int)info.byte_pos);
+    if (wlen > 0) {
+        audio_element_update_byte_pos(self, wlen);
+    }
+    return wlen;
+}
+
+static int _spiffs_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _spiffs_close(audio_element_handle_t self)
+{
+    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
+
+    if (AUDIO_STREAM_WRITER == spiffs->type
+        && spiffs->file
+        && STREAM_TYPE_WAV == spiffs->w_type) {
+        wav_header_t *wav_info = (wav_header_t *) audio_malloc(sizeof(wav_header_t));
+
+        AUDIO_MEM_CHECK(TAG, wav_info, return ESP_ERR_NO_MEM);
+
+        if (fseek(spiffs->file, 0, SEEK_SET) != 0) {
+            ESP_LOGE(TAG, "Error seek file, line=%d", __LINE__);
+        }
+        audio_element_info_t info;
+        audio_element_getinfo(self, &info);
+        wav_head_init(wav_info, info.sample_rates, info.bits, info.channels);
+        wav_head_size(wav_info, (uint32_t)info.byte_pos);
+        fwrite(wav_info, 1, sizeof(wav_header_t), spiffs->file);
+        fsync(fileno(spiffs->file));
+        audio_free(wav_info);
+    }
+
+    if (spiffs->is_open) {
+        fclose(spiffs->file);
+        spiffs->is_open = false;
+    }
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_report_pos(self);
+        audio_element_set_byte_pos(self, 0);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _spiffs_destroy(audio_element_handle_t self)
+{
+    spiffs_stream_t *spiffs = (spiffs_stream_t *)audio_element_getdata(self);
+    audio_free(spiffs);
+    return ESP_OK;
+}
+
+audio_element_handle_t spiffs_stream_init(spiffs_stream_cfg_t *config)
+{
+    audio_element_handle_t el;
+
+    spiffs_stream_t *spiffs = audio_calloc(1, sizeof(spiffs_stream_t));
+
+    AUDIO_MEM_CHECK(TAG, spiffs, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _spiffs_open;
+    cfg.close = _spiffs_close;
+    cfg.process = _spiffs_process;
+    cfg.destroy = _spiffs_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.buffer_len = config->buf_sz;
+    if (cfg.buffer_len == 0) {
+        cfg.buffer_len = SPIFFS_STREAM_BUF_SIZE;
+    }
+
+    cfg.tag = "spiffs";
+    spiffs->type = config->type;
+    spiffs->write_header = config->write_header;
+
+    if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _spiffs_write;
+    } else {
+        cfg.read = _spiffs_read;
+    }
+
+    el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, goto _spiffs_init_exit);
+    audio_element_setdata(el, spiffs);
+
+    return el;
+_spiffs_init_exit:
+    audio_free(spiffs);
+    return NULL;
+}
diff --git a/components/audio_stream/tcp_client_stream.c b/components/audio_stream/tcp_client_stream.c
index e80a9e95..11a313fc 100644
--- a/components/audio_stream/tcp_client_stream.c
+++ b/components/audio_stream/tcp_client_stream.c
@@ -1,245 +1,245 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-
-#include "lwip/sockets.h"
-#include "esp_transport_tcp.h"
-#include "esp_log.h"
-#include "esp_err.h"
-#include "audio_mem.h"
-#include "tcp_client_stream.h"
-
-static const char *TAG = "TCP_STREAM";
-#define CONNECT_TIMEOUT_MS        100
-
-typedef struct tcp_stream {
-    esp_transport_handle_t        t;
-    audio_stream_type_t           type;
-    int                           sock;
-    int                           port;
-    char                          *host;
-    bool                          is_open;
-    int                           timeout_ms;
-    tcp_stream_event_handle_cb    hook;
-    esp_transport_list_handle_t   transport_list;
-    void                          *ctx;
-} tcp_stream_t;
-
-static int _get_socket_error_code_reason(const char *str, int sockfd)
-{
-    uint32_t optlen = sizeof(int);
-    int result;
-    int err;
-
-    err = getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &result, &optlen);
-    if (err == -1) {
-        ESP_LOGE(TAG, "%s, getsockopt failed (%d)", str, err);
-        return -1;
-    }
-    if (result != 0) {
-        ESP_LOGW(TAG, "%s error, error code: %d, reason: %s", str, err, strerror(result));
-    }
-    return result;
-}
-
-static esp_err_t _dispatch_event(audio_element_handle_t el, tcp_stream_t *tcp, void *data, int len, tcp_stream_status_t state)
-{
-    if (el && tcp && tcp->hook) {
-        tcp_stream_event_msg_t msg = { 0 };
-        msg.data = data;
-        msg.data_len = len;
-        msg.sock_fd = tcp->t;
-        msg.source = el;
-        return tcp->hook(&msg, state, tcp->ctx);
-    }
-    return ESP_FAIL;
-}
-
-static esp_err_t _tcp_open(audio_element_handle_t self)
-{
-    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
-
-    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
-    if (tcp->is_open) {
-        ESP_LOGE(TAG, "Already opened");
-        return ESP_FAIL;
-    }
-    ESP_LOGI(TAG, "Host is %s, port is %d\n", tcp->host, tcp->port);
-    esp_transport_handle_t t = esp_transport_tcp_init();
-    AUDIO_MEM_CHECK(TAG, t, return ESP_FAIL);
-    tcp->transport_list = esp_transport_list_init();
-    AUDIO_MEM_CHECK(TAG, tcp->transport_list, goto _exit);
-    esp_transport_list_add(tcp->transport_list, t, "tcp");
-    tcp->sock = esp_transport_connect(t, tcp->host, tcp->port, CONNECT_TIMEOUT_MS);
-    if (tcp->sock < 0) {
-        _get_socket_error_code_reason(__func__,  tcp->sock);
-        goto _exit;
-    }
-    tcp->is_open = true;
-    tcp->t = t;
-    _dispatch_event(self, tcp, NULL, 0, TCP_STREAM_STATE_CONNECTED);
-    return ESP_OK;
-
-_exit:
-    if (tcp->transport_list) {
-        esp_transport_list_destroy(tcp->transport_list);
-        tcp->transport_list = NULL;
-    } else {
-        esp_transport_destroy(t);
-    }
-
-    return ESP_FAIL;
-}
-
-static esp_err_t _tcp_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
-    int rlen = esp_transport_read(tcp->t, buffer, len, tcp->timeout_ms);
-    if (rlen < 0) {
-        // note: refer transport_ssl.c, the server actively disconnects and returns -1
-        if (rlen == -1) {
-            ESP_LOGW(TAG, "TCP server actively closes the connection");
-            return ESP_OK;
-        } else {
-            ESP_LOGE(TAG, "read data failed");
-            _get_socket_error_code_reason(__func__, tcp->sock);
-            return ESP_FAIL;
-        }
-    }
-    audio_element_update_byte_pos(self, rlen);
-    ESP_LOGD(TAG, "read len=%d, rlen=%d", len, rlen);
-    return rlen;
-}
-
-static esp_err_t _tcp_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
-    int wlen = esp_transport_write(tcp->t, buffer, len, tcp->timeout_ms);
-    if (wlen < 0) {
-        _get_socket_error_code_reason(__func__, tcp->sock);
-        return ESP_FAIL;
-    }
-    ESP_LOGD(TAG, "write len=%d, rlen=%d", len, wlen);
-    return wlen;
-}
-
-static esp_err_t _tcp_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-        if (w_size > 0) {
-            audio_element_update_byte_pos(self, r_size);
-        }
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _tcp_close(audio_element_handle_t self)
-{
-    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
-
-    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
-    AUDIO_NULL_CHECK(TAG, tcp, return ESP_FAIL);
-    if (!tcp->is_open) {
-        ESP_LOGE(TAG, "Already closed");
-        return ESP_FAIL;
-    }
-    if (-1 == esp_transport_close(tcp->t)) {
-        ESP_LOGE(TAG, "TCP stream close failed");
-        return ESP_FAIL;
-    }
-    tcp->is_open = false;
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_set_byte_pos(self, 0);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _tcp_destroy(audio_element_handle_t self)
-{
-    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
-
-    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
-    AUDIO_NULL_CHECK(TAG, tcp, return ESP_FAIL);
-    if (tcp->transport_list) {
-        esp_transport_list_destroy(tcp->transport_list);
-    } 
-    audio_free(tcp);
-    return ESP_OK;
-}
-
-audio_element_handle_t tcp_stream_init(tcp_stream_cfg_t *config)
-{
-    AUDIO_NULL_CHECK(TAG, config, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    audio_element_handle_t el;
-    cfg.open = _tcp_open;
-    cfg.close = _tcp_close;
-    cfg.process = _tcp_process;
-    cfg.destroy = _tcp_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.stack_in_ext = config->ext_stack;
-    cfg.tag = "tcp_client";
-    if (cfg.buffer_len == 0) {
-        cfg.buffer_len = TCP_STREAM_BUF_SIZE;
-    }
-
-    tcp_stream_t *tcp = audio_calloc(1, sizeof(tcp_stream_t));
-    AUDIO_MEM_CHECK(TAG, tcp, return NULL);
-
-    tcp->type = config->type;
-    tcp->port = config->port;
-    tcp->host = config->host;
-    tcp->timeout_ms = config->timeout_ms;
-    if (config->event_handler) {
-        tcp->hook = config->event_handler;
-        if (config->event_ctx) {
-            tcp->ctx = config->event_ctx;
-        }
-    }
-
-    if (config->type == AUDIO_STREAM_WRITER) {
-        cfg.write = _tcp_write;
-    } else {
-        cfg.read = _tcp_read;
-    }
-
-    el = audio_element_init(&cfg);
-    AUDIO_MEM_CHECK(TAG, el, goto _tcp_init_exit);
-    audio_element_setdata(el, tcp);
-
-    return el;
-_tcp_init_exit:
-    audio_free(tcp);
-    return NULL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lwip/sockets.h"
+#include "esp_transport_tcp.h"
+#include "esp_log.h"
+#include "esp_err.h"
+#include "audio_mem.h"
+#include "tcp_client_stream.h"
+
+static const char *TAG = "TCP_STREAM";
+#define CONNECT_TIMEOUT_MS        100
+
+typedef struct tcp_stream {
+    esp_transport_handle_t        t;
+    audio_stream_type_t           type;
+    int                           sock;
+    int                           port;
+    char                          *host;
+    bool                          is_open;
+    int                           timeout_ms;
+    tcp_stream_event_handle_cb    hook;
+    esp_transport_list_handle_t   transport_list;
+    void                          *ctx;
+} tcp_stream_t;
+
+static int _get_socket_error_code_reason(const char *str, int sockfd)
+{
+    uint32_t optlen = sizeof(int);
+    int result;
+    int err;
+
+    err = getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &result, &optlen);
+    if (err == -1) {
+        ESP_LOGE(TAG, "%s, getsockopt failed (%d)", str, err);
+        return -1;
+    }
+    if (result != 0) {
+        ESP_LOGW(TAG, "%s error, error code: %d, reason: %s", str, err, strerror(result));
+    }
+    return result;
+}
+
+static esp_err_t _dispatch_event(audio_element_handle_t el, tcp_stream_t *tcp, void *data, int len, tcp_stream_status_t state)
+{
+    if (el && tcp && tcp->hook) {
+        tcp_stream_event_msg_t msg = { 0 };
+        msg.data = data;
+        msg.data_len = len;
+        msg.sock_fd = tcp->t;
+        msg.source = el;
+        return tcp->hook(&msg, state, tcp->ctx);
+    }
+    return ESP_FAIL;
+}
+
+static esp_err_t _tcp_open(audio_element_handle_t self)
+{
+    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
+
+    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
+    if (tcp->is_open) {
+        ESP_LOGE(TAG, "Already opened");
+        return ESP_FAIL;
+    }
+    ESP_LOGI(TAG, "Host is %s, port is %d\n", tcp->host, tcp->port);
+    esp_transport_handle_t t = esp_transport_tcp_init();
+    AUDIO_MEM_CHECK(TAG, t, return ESP_FAIL);
+    tcp->transport_list = esp_transport_list_init();
+    AUDIO_MEM_CHECK(TAG, tcp->transport_list, goto _exit);
+    esp_transport_list_add(tcp->transport_list, t, "tcp");
+    tcp->sock = esp_transport_connect(t, tcp->host, tcp->port, CONNECT_TIMEOUT_MS);
+    if (tcp->sock < 0) {
+        _get_socket_error_code_reason(__func__,  tcp->sock);
+        goto _exit;
+    }
+    tcp->is_open = true;
+    tcp->t = t;
+    _dispatch_event(self, tcp, NULL, 0, TCP_STREAM_STATE_CONNECTED);
+    return ESP_OK;
+
+_exit:
+    if (tcp->transport_list) {
+        esp_transport_list_destroy(tcp->transport_list);
+        tcp->transport_list = NULL;
+    } else {
+        esp_transport_destroy(t);
+    }
+
+    return ESP_FAIL;
+}
+
+static esp_err_t _tcp_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
+    int rlen = esp_transport_read(tcp->t, buffer, len, tcp->timeout_ms);
+    if (rlen < 0) {
+        // note: refer transport_ssl.c, the server actively disconnects and returns -1
+        if (rlen == -1) {
+            ESP_LOGW(TAG, "TCP server actively closes the connection");
+            return ESP_OK;
+        } else {
+            ESP_LOGE(TAG, "read data failed");
+            _get_socket_error_code_reason(__func__, tcp->sock);
+            return ESP_FAIL;
+        }
+    }
+    audio_element_update_byte_pos(self, rlen);
+    ESP_LOGD(TAG, "read len=%d, rlen=%d", len, rlen);
+    return rlen;
+}
+
+static esp_err_t _tcp_write(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
+    int wlen = esp_transport_write(tcp->t, buffer, len, tcp->timeout_ms);
+    if (wlen < 0) {
+        _get_socket_error_code_reason(__func__, tcp->sock);
+        return ESP_FAIL;
+    }
+    ESP_LOGD(TAG, "write len=%d, rlen=%d", len, wlen);
+    return wlen;
+}
+
+static esp_err_t _tcp_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+        if (w_size > 0) {
+            audio_element_update_byte_pos(self, r_size);
+        }
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _tcp_close(audio_element_handle_t self)
+{
+    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
+
+    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
+    AUDIO_NULL_CHECK(TAG, tcp, return ESP_FAIL);
+    if (!tcp->is_open) {
+        ESP_LOGE(TAG, "Already closed");
+        return ESP_FAIL;
+    }
+    if (-1 == esp_transport_close(tcp->t)) {
+        ESP_LOGE(TAG, "TCP stream close failed");
+        return ESP_FAIL;
+    }
+    tcp->is_open = false;
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_set_byte_pos(self, 0);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _tcp_destroy(audio_element_handle_t self)
+{
+    AUDIO_NULL_CHECK(TAG, self, return ESP_FAIL);
+
+    tcp_stream_t *tcp = (tcp_stream_t *)audio_element_getdata(self);
+    AUDIO_NULL_CHECK(TAG, tcp, return ESP_FAIL);
+    if (tcp->transport_list) {
+        esp_transport_list_destroy(tcp->transport_list);
+    } 
+    audio_free(tcp);
+    return ESP_OK;
+}
+
+audio_element_handle_t tcp_stream_init(tcp_stream_cfg_t *config)
+{
+    AUDIO_NULL_CHECK(TAG, config, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    audio_element_handle_t el;
+    cfg.open = _tcp_open;
+    cfg.close = _tcp_close;
+    cfg.process = _tcp_process;
+    cfg.destroy = _tcp_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.stack_in_ext = config->ext_stack;
+    cfg.tag = "tcp_client";
+    if (cfg.buffer_len == 0) {
+        cfg.buffer_len = TCP_STREAM_BUF_SIZE;
+    }
+
+    tcp_stream_t *tcp = audio_calloc(1, sizeof(tcp_stream_t));
+    AUDIO_MEM_CHECK(TAG, tcp, return NULL);
+
+    tcp->type = config->type;
+    tcp->port = config->port;
+    tcp->host = config->host;
+    tcp->timeout_ms = config->timeout_ms;
+    if (config->event_handler) {
+        tcp->hook = config->event_handler;
+        if (config->event_ctx) {
+            tcp->ctx = config->event_ctx;
+        }
+    }
+
+    if (config->type == AUDIO_STREAM_WRITER) {
+        cfg.write = _tcp_write;
+    } else {
+        cfg.read = _tcp_read;
+    }
+
+    el = audio_element_init(&cfg);
+    AUDIO_MEM_CHECK(TAG, el, goto _tcp_init_exit);
+    audio_element_setdata(el, tcp);
+
+    return el;
+_tcp_init_exit:
+    audio_free(tcp);
+    return NULL;
+}
diff --git a/components/audio_stream/test/component.mk b/components/audio_stream/test/component.mk
index 5dd172bd..5f441ada 100644
--- a/components/audio_stream/test/component.mk
+++ b/components/audio_stream/test/component.mk
@@ -1,5 +1,5 @@
-#
-#Component Makefile
-#
-
-COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
+#
+#Component Makefile
+#
+
+COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
diff --git a/components/audio_stream/test/fatfs_stream_test.c b/components/audio_stream/test/fatfs_stream_test.c
index 6f53dba5..babc8be2 100644
--- a/components/audio_stream/test/fatfs_stream_test.c
+++ b/components/audio_stream/test/fatfs_stream_test.c
@@ -1,161 +1,161 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-
-#include "unity.h"
-#include "esp_err.h"
-#include "esp_log.h"
-
-#include "audio_pipeline.h"
-#include "audio_mem.h"
-#include "fatfs_stream.h"
-
-#include "esp_peripherals.h"
-#include "board.h"
-
-static const char *TAG = "FATFS_STREAM_TEST";
-
-#define TEST_FATFS_READER  "/sdcard/test.mp3"
-#define TEST_FATFS_WRITER  "/sdcard/WRITER.MP3"
-
-
-static uint64_t get_file_size(const char *name)
-{
-    FILE *f;
-    uint64_t size = 0;
-
-    f = fopen(name, "rb");
-    if (f == NULL) {
-        perror("Error open file");
-        return -1;
-    }
-    fseek(f, 0, SEEK_END);
-    size = ftell(f);
-    fclose(f);
-    return size;
-}
-static void file_size_comparison(const char *file1, const char *file2)
-{
-    uint64_t size1 = get_file_size(file1);
-    uint64_t size2 = get_file_size(file2);
-    ESP_LOGI(TAG, "%s size is %llu, %s size is %llu", file1, size1, file2, size2);
-    if (size1 == size2) {
-        ESP_LOGI(TAG, "The two files are the same size");
-    } else {
-        ESP_LOGI(TAG, "The two files are not the same size");
-    }
-}
-
-TEST_CASE("fatfs stream init memory", "[esp-adf-stream]")
-{
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    audio_element_handle_t fatfs_stream_reader;
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_READER;
-    int cnt = 2000;
-    AUDIO_MEM_SHOW("BEFORE FATFS_STREAM_INIT MEMORY TEST");
-    while (cnt--) {
-        fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
-        audio_element_deinit(fatfs_stream_reader);
-    }
-    AUDIO_MEM_SHOW("AFTER FATFS_STREAM_INIT MEMORY TEST");
-}
-
-TEST_CASE("fatfs stream read write loop", "[esp-adf-stream]")
-{
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t fatfs_stream_reader, fatfs_stream_writer;
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    fatfs_stream_cfg_t fatfs_reader_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_reader_cfg.type = AUDIO_STREAM_READER;
-    fatfs_stream_reader = fatfs_stream_init(&fatfs_reader_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
-
-    fatfs_stream_cfg_t fatfs_writer_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_writer_cfg.type = AUDIO_STREAM_WRITER;
-    fatfs_stream_writer = fatfs_stream_init(&fatfs_writer_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file_reader"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer, "file_writer"));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"file_reader", "file_writer"}, 2));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, TEST_FATFS_READER));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, TEST_FATFS_WRITER));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) fatfs_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
-            ESP_LOGW(TAG, "[ * ] Stop event received");
-            break;
-        }
-    }
-
-    file_size_comparison(TEST_FATFS_READER, TEST_FATFS_WRITER);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-
-
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+
+#include "unity.h"
+#include "esp_err.h"
+#include "esp_log.h"
+
+#include "audio_pipeline.h"
+#include "audio_mem.h"
+#include "fatfs_stream.h"
+
+#include "esp_peripherals.h"
+#include "board.h"
+
+static const char *TAG = "FATFS_STREAM_TEST";
+
+#define TEST_FATFS_READER  "/sdcard/test.mp3"
+#define TEST_FATFS_WRITER  "/sdcard/WRITER.MP3"
+
+
+static uint64_t get_file_size(const char *name)
+{
+    FILE *f;
+    uint64_t size = 0;
+
+    f = fopen(name, "rb");
+    if (f == NULL) {
+        perror("Error open file");
+        return -1;
+    }
+    fseek(f, 0, SEEK_END);
+    size = ftell(f);
+    fclose(f);
+    return size;
+}
+static void file_size_comparison(const char *file1, const char *file2)
+{
+    uint64_t size1 = get_file_size(file1);
+    uint64_t size2 = get_file_size(file2);
+    ESP_LOGI(TAG, "%s size is %llu, %s size is %llu", file1, size1, file2, size2);
+    if (size1 == size2) {
+        ESP_LOGI(TAG, "The two files are the same size");
+    } else {
+        ESP_LOGI(TAG, "The two files are not the same size");
+    }
+}
+
+TEST_CASE("fatfs stream init memory", "[esp-adf-stream]")
+{
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    audio_element_handle_t fatfs_stream_reader;
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_READER;
+    int cnt = 2000;
+    AUDIO_MEM_SHOW("BEFORE FATFS_STREAM_INIT MEMORY TEST");
+    while (cnt--) {
+        fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
+        audio_element_deinit(fatfs_stream_reader);
+    }
+    AUDIO_MEM_SHOW("AFTER FATFS_STREAM_INIT MEMORY TEST");
+}
+
+TEST_CASE("fatfs stream read write loop", "[esp-adf-stream]")
+{
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t fatfs_stream_reader, fatfs_stream_writer;
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    fatfs_stream_cfg_t fatfs_reader_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_reader_cfg.type = AUDIO_STREAM_READER;
+    fatfs_stream_reader = fatfs_stream_init(&fatfs_reader_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
+
+    fatfs_stream_cfg_t fatfs_writer_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_writer_cfg.type = AUDIO_STREAM_WRITER;
+    fatfs_stream_writer = fatfs_stream_init(&fatfs_writer_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file_reader"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer, "file_writer"));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"file_reader", "file_writer"}, 2));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, TEST_FATFS_READER));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, TEST_FATFS_WRITER));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) fatfs_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
+            ESP_LOGW(TAG, "[ * ] Stop event received");
+            break;
+        }
+    }
+
+    file_size_comparison(TEST_FATFS_READER, TEST_FATFS_WRITER);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+
+
+}
diff --git a/components/audio_stream/test/howsmyssl_com_root_cert.pem b/components/audio_stream/test/howsmyssl_com_root_cert.pem
index b85c8037..30aa9363 100644
--- a/components/audio_stream/test/howsmyssl_com_root_cert.pem
+++ b/components/audio_stream/test/howsmyssl_com_root_cert.pem
@@ -1,31 +1,31 @@
------BEGIN CERTIFICATE-----
-MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
-TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
-cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
-WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
-ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
-MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
-h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
-0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
-A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
-T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
-B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
-B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
-KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
-OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
-jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
-qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
-rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
-HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
-hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
-ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
-3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
-NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
-ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
-TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
-jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
-oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
-4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
-mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
-emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
+TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
+cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
+WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
+ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
+MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
+h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
+0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
+A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
+T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
+B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
+B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
+KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
+OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
+jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
+qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
+rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
+HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
+hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
+ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
+3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
+NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
+ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
+TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
+jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
+oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
+4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
+mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
+emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
+-----END CERTIFICATE-----
diff --git a/components/audio_stream/test/http_server_read.py b/components/audio_stream/test/http_server_read.py
index a5cf3c8b..c6e7a203 100644
--- a/components/audio_stream/test/http_server_read.py
+++ b/components/audio_stream/test/http_server_read.py
@@ -1,86 +1,86 @@
-#!/user/bin/env python
-
-#  ESPRESSIF MIT License
-#
-#  Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
-#
-#  Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
-#  it is free of charge, to any person obtaining a copy of this software and associated
-#  documentation files (the "Software"), to deal in the Software without restriction, including
-#  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-#  and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-#  to do so, subject to the following conditions:
-#
-#  The above copyright notice and this permission notice shall be included in all copies or
-#  substantial portions of the Software.
-#
-#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-#  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-import os, datetime, sys, urlparse
-import SimpleHTTPServer, BaseHTTPServer
-import wave
-
-PORT = 8000
-HOST = '192.168.199.168'
-
-class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):
-    def _set_headers(self, length):
-        self.send_response(200)
-        if length > 0:
-            self.send_header('Content-length', str(length))
-        self.end_headers()
-
-    def _get_chunk_size(self):
-        data = self.rfile.read(2)
-        while data[-2:] != b"\r\n":
-            data += self.rfile.read(1)
-        return int(data[:-2], 16)
-
-    def _get_chunk_data(self, chunk_size):
-        data = self.rfile.read(chunk_size)
-        self.rfile.read(2)
-        return data
-
-    def _write_file(self, data):
-        t = datetime.datetime.utcnow()
-        time = t.strftime('%Y%m%dT%H%M%SZ')
-        filename = str.format('{}.mp3', time)
-
-        file = open(filename, 'wb')
-        file.write(bytearray(data))
-        file.close()
-        return filename
-
-    def do_POST(self):
-        urlparts = urlparse.urlparse(self.path)
-        request_file_path = urlparts.path.strip('/')
-        total_bytes = 0
-        if (request_file_path == 'upload'):
-            data = []
-            # https://stackoverflow.com/questions/24500752/how-can-i-read-exactly-one-response-chunk-with-pythons-http-client
-            while True:
-                chunk_size = self._get_chunk_size()
-                total_bytes += chunk_size
-                print("Total bytes received: {}".format(total_bytes))
-                sys.stdout.write("\033[F")
-                if (chunk_size == 0):
-                    break
-                else:
-                    chunk_data = self._get_chunk_data(chunk_size)
-                    data += chunk_data
-
-            filename = self._write_file(data)
-            body = 'File {} was written, size {}'.format(filename, total_bytes)
-            self._set_headers(len(body))
-        else:
-            return SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)
-
-httpd = BaseHTTPServer.HTTPServer((HOST, PORT), Handler)
-
-print("Serving HTTP on {} port {}".format(HOST, PORT));
+#!/user/bin/env python
+
+#  ESPRESSIF MIT License
+#
+#  Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+#
+#  Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+#  it is free of charge, to any person obtaining a copy of this software and associated
+#  documentation files (the "Software"), to deal in the Software without restriction, including
+#  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+#  and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+#  to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in all copies or
+#  substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+#  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+import os, datetime, sys, urlparse
+import SimpleHTTPServer, BaseHTTPServer
+import wave
+
+PORT = 8000
+HOST = '192.168.199.168'
+
+class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):
+    def _set_headers(self, length):
+        self.send_response(200)
+        if length > 0:
+            self.send_header('Content-length', str(length))
+        self.end_headers()
+
+    def _get_chunk_size(self):
+        data = self.rfile.read(2)
+        while data[-2:] != b"\r\n":
+            data += self.rfile.read(1)
+        return int(data[:-2], 16)
+
+    def _get_chunk_data(self, chunk_size):
+        data = self.rfile.read(chunk_size)
+        self.rfile.read(2)
+        return data
+
+    def _write_file(self, data):
+        t = datetime.datetime.utcnow()
+        time = t.strftime('%Y%m%dT%H%M%SZ')
+        filename = str.format('{}.mp3', time)
+
+        file = open(filename, 'wb')
+        file.write(bytearray(data))
+        file.close()
+        return filename
+
+    def do_POST(self):
+        urlparts = urlparse.urlparse(self.path)
+        request_file_path = urlparts.path.strip('/')
+        total_bytes = 0
+        if (request_file_path == 'upload'):
+            data = []
+            # https://stackoverflow.com/questions/24500752/how-can-i-read-exactly-one-response-chunk-with-pythons-http-client
+            while True:
+                chunk_size = self._get_chunk_size()
+                total_bytes += chunk_size
+                print("Total bytes received: {}".format(total_bytes))
+                sys.stdout.write("\033[F")
+                if (chunk_size == 0):
+                    break
+                else:
+                    chunk_data = self._get_chunk_data(chunk_size)
+                    data += chunk_data
+
+            filename = self._write_file(data)
+            body = 'File {} was written, size {}'.format(filename, total_bytes)
+            self._set_headers(len(body))
+        else:
+            return SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)
+
+httpd = BaseHTTPServer.HTTPServer((HOST, PORT), Handler)
+
+print("Serving HTTP on {} port {}".format(HOST, PORT));
 httpd.serve_forever()
\ No newline at end of file
diff --git a/components/audio_stream/test/http_stream_test.c b/components/audio_stream/test/http_stream_test.c
index bf011138..dae7ed93 100644
--- a/components/audio_stream/test/http_stream_test.c
+++ b/components/audio_stream/test/http_stream_test.c
@@ -1,569 +1,569 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-
-#include "unity.h"
-#include "esp_wifi.h"
-#include "esp_http_client.h"
-#include "nvs_flash.h"
-#include "esp_log.h"
-#include "audio_pipeline.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "audio_event_iface.h"
-#include "http_stream.h"
-#include "i2s_stream.h"
-#include "fatfs_stream.h"
-#include "aac_decoder.h"
-
-#include "esp_peripherals.h"
-#include "periph_wifi.h"
-#include "board.h"
-
-static const char *TAG = "HTTP STREAM UNITEST";
-
-static const char URL_RANDOM[] = "0123456789abcdefghijklmnopqrstuvwxyuzABCDEFGHIJKLMNOPQRSTUVWXYUZ-_.!@#$&*()=:/,;?+~";
-#define AAC_STREAM_URI "http://open.ls.qingting.fm/live/274/64k.m3u8?format=aac"
-#define UNITEST_HTTP_SERVRE_URI  "http://192.168.199.168:8000/upload"
-
-#define UNITETS_HTTP_STREAM_WIFI_SSID    "ESPRESSIF"
-#define UNITETS_HTTP_STREAM_WIFI_PASSWD    "espressif"
-
-TEST_CASE("http stream init memory", "[esp-adf-stream]")
-{
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    audio_element_handle_t http_stream_reader;
-    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
-    http_cfg.event_handle = NULL;
-    http_cfg.type = AUDIO_STREAM_READER;
-    http_cfg.enable_playlist_parser = true;
-    int cnt = 2000;
-    AUDIO_MEM_SHOW("BEFORE HTTP_STREAM_INIT MEMORY TEST");
-    while (cnt--) {
-        http_stream_reader = http_stream_init(&http_cfg);
-        audio_element_deinit(http_stream_reader);
-    }
-    AUDIO_MEM_SHOW("AFTER HTTP_STREAM_INIT MEMORY TEST");
-}
-
-TEST_CASE("http stream url test", "[esp-adf-stream]")
-{
-    int url_len = 0;
-    int url_real_len = 0;
-    char s[2] = {0};
-    char url_rand[1024];
-    int url_rand_t = strlen(URL_RANDOM);
-    char *url = (char *)malloc(1024 + sizeof("http://"));
-
-    audio_element_handle_t http_stream_reader;
-    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
-    http_cfg.event_handle = NULL;
-    http_cfg.type = AUDIO_STREAM_READER;
-    http_cfg.enable_playlist_parser = true;
-    http_stream_reader = http_stream_init(&http_cfg);
-
-    srand((unsigned int)time((time_t *)NULL));
-    for (int cnt = 0; cnt < 100; cnt++) {
-        memset(url, 0x00, sizeof("http://"));
-        strcpy(url, "http://");
-        url_len = (rand() % 1024);
-        for ( url_real_len = 0; url_real_len < url_len; url_real_len++) {
-            sprintf(s, "%c", URL_RANDOM[rand() % (url_rand_t) ]);
-            strcat(url_rand, s);
-        }
-        strcat(url, url_rand);
-        url[url_len + sizeof("http://") - 1] = '\0';
-        audio_element_set_uri(http_stream_reader, AAC_STREAM_URI);
-    }
-    free(url);
-    url = NULL;
-}
-
-int _http_living_stream_event_handle(http_stream_event_msg_t *msg)
-{
-    if (msg->event_id == HTTP_STREAM_RESOLVE_ALL_TRACKS) {
-        return ESP_OK;
-    }
-
-    if (msg->event_id == HTTP_STREAM_FINISH_TRACK) {
-        return http_stream_next_track(msg->el);
-    }
-    if (msg->event_id == HTTP_STREAM_FINISH_PLAYLIST) {
-        return http_stream_restart(msg->el);
-    }
-    return ESP_OK;
-
-}
-
-static esp_err_t _http_stream_event_handle(http_stream_event_msg_t *msg)
-{
-    esp_http_client_handle_t http = (esp_http_client_handle_t)msg->http_client;
-    char len_buf[16];
-    static int total_write = 0;
-
-    if (msg->event_id == HTTP_STREAM_PRE_REQUEST) {
-        return ESP_OK;
-    }
-
-    if (msg->event_id == HTTP_STREAM_ON_REQUEST) {
-        // write data
-        int wlen = sprintf(len_buf, "%x\r\n", msg->buffer_len);
-        if (esp_http_client_write(http, len_buf, wlen) <= 0) {
-            return ESP_FAIL;
-        }
-        if (esp_http_client_write(http, msg->buffer, msg->buffer_len) <= 0) {
-            return ESP_FAIL;
-        }
-        if (esp_http_client_write(http, "\r\n", 2) <= 0) {
-            return ESP_FAIL;
-        }
-        total_write += msg->buffer_len;
-        printf("\033[A\33[2K\rTotal bytes written: %d\n", total_write);
-        return msg->buffer_len;
-    }
-
-    if (msg->event_id == HTTP_STREAM_POST_REQUEST) {
-        if (esp_http_client_write(http, "0\r\n\r\n", 5) <= 0) {
-            return ESP_FAIL;
-        }
-        return ESP_OK;
-    }
-    if (msg->event_id == HTTP_STREAM_FINISH_REQUEST) {
-        char *buf = calloc(1, 64);
-        assert(buf);
-        int read_len = esp_http_client_read(http, buf, 64);
-        if (read_len <= 0) {
-            free(buf);
-            return ESP_FAIL;
-        }
-        buf[read_len] = 0;
-        free(buf);
-        return ESP_OK;
-    }
-    return ESP_OK;
-}
-
-TEST_CASE("http stream read", "[esp-adf-stream]")
-{
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t http_stream_reader, fatfs_stream_writer;
-
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    esp_err_t err = nvs_flash_init();
-    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
-        ESP_ERROR_CHECK(nvs_flash_erase());
-        err = nvs_flash_init();
-    }
-    tcpip_adapter_init();
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
-        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
-    };
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    TEST_ASSERT_NOT_NULL(wifi_handle);
-
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
-    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
-
-    audio_board_handle_t board_handle = audio_board_init();
-    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_WRITER;
-    fatfs_stream_writer = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, "/sdcard/test.mp3"));
-
-    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
-    http_cfg.type = AUDIO_STREAM_READER;
-    http_stream_reader = http_stream_init(&http_cfg);
-    TEST_ASSERT_NOT_NULL(http_stream_reader);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_reader, "http"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer,  "fatfs"));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) { "http", "fatfs" }, 2));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_reader, "https://dl.espressif.com/dl/audio/ff-16b-2c-44100hz.mp3"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
-            break;
-            continue;
-        }
-    }
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
-
-/*
- * Note : Before run this unitest, please run the http_server_read.py, and Confirm server ip in UNITEST_HTTP_SERVRE_URI
- */
-TEST_CASE("http stream write", "[esp-adf-stream]")
-{
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t http_stream_writer, fatfs_stream_reader;
-
-    esp_err_t err = nvs_flash_init();
-    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
-        ESP_ERROR_CHECK(nvs_flash_erase());
-        err = nvs_flash_init();
-    }
-    tcpip_adapter_init();
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
-        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
-    };
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    TEST_ASSERT_NOT_NULL(wifi_handle);
-
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
-    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
-
-    audio_board_handle_t board_handle = audio_board_init();
-    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_READER;
-    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
-
-    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
-    http_cfg.type = AUDIO_STREAM_WRITER;
-    http_cfg.event_handle = _http_stream_event_handle;
-    http_stream_writer = http_stream_init(&http_cfg);
-    TEST_ASSERT_NOT_NULL(http_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader,  "fatfs"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_writer, "http"));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"fatfs", "http"}, 2));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_writer, UNITEST_HTTP_SERVRE_URI));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_writer
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
-            break;
-            continue;
-        }
-    }
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
-
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
-
-TEST_CASE("http stream living test", "[esp-adf-stream]")
-{
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    esp_err_t err = nvs_flash_init();
-    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
-        TEST_ASSERT_EQUAL(ESP_OK, nvs_flash_erase());
-        err = nvs_flash_init();
-    }
-    tcpip_adapter_init();
-
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t http_stream_reader, i2s_stream_writer, aac_decoder;
-
-    audio_board_handle_t board_handle = audio_board_init();
-    TEST_ASSERT_NOT_NULL(board_handle);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
-    http_cfg.event_handle = _http_living_stream_event_handle;
-    http_cfg.type = AUDIO_STREAM_READER;
-    http_cfg.enable_playlist_parser = true;
-    http_stream_reader = http_stream_init(&http_cfg);
-    TEST_ASSERT_NOT_NULL(http_stream_reader);
-
-    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg.type = AUDIO_STREAM_WRITER;
-    i2s_stream_writer = i2s_stream_init(&i2s_cfg);
-    TEST_ASSERT_NOT_NULL(i2s_stream_writer);
-
-    aac_decoder_cfg_t aac_cfg = DEFAULT_AAC_DECODER_CONFIG();
-    aac_decoder = aac_decoder_init(&aac_cfg);
-    TEST_ASSERT_NOT_NULL(aac_decoder);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_reader, "http"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, aac_decoder, "aac"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_writer,  "i2s"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"http",  "aac", "i2s"}, 3));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_reader, AAC_STREAM_URI));
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
-        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
-    };
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    TEST_ASSERT_NOT_NULL(wifi_handle);
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
-    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT
-            && msg.source == (void *) aac_decoder
-            && msg.cmd == AEL_MSG_CMD_REPORT_MUSIC_INFO) {
-            audio_element_info_t music_info = {0};
-            TEST_ASSERT_EQUAL(ESP_OK, audio_element_getinfo(aac_decoder, &music_info));
-
-            ESP_LOGI(TAG, "[ * ] Receive music info from aac decoder, sample_rates=%d, bits=%d, ch=%d",
-                     music_info.sample_rates, music_info.bits, music_info.channels);
-
-            TEST_ASSERT_EQUAL(ESP_OK, audio_element_setinfo(i2s_stream_writer, &music_info));
-            TEST_ASSERT_EQUAL(ESP_OK, i2s_stream_set_clk(i2s_stream_writer, music_info.sample_rates, music_info.bits, music_info.channels));
-            continue;
-        }
-
-        /* restart stream when the first pipeline element (http_stream_reader in this case) receives stop event (caused by reading errors) */
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
-            ESP_LOGW(TAG, "[ * ] Restart stream");
-            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(aac_decoder));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(i2s_stream_writer));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_ringbuffer(pipeline));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_items_state(pipeline));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-            continue;
-        }
-    }
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, aac_decoder));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(aac_decoder));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
-
-TEST_CASE("https stream test", "[esp-adf-stream]")
-{
-
-    extern const char howsmyssl_com_root_cert_pem_start[] asm("_binary_howsmyssl_com_root_cert_pem_start");
-    extern const char howsmyssl_com_root_cert_pem_end[]   asm("_binary_howsmyssl_com_root_cert_pem_end");
-
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t http_stream_reader, fatfs_stream_writer;
-
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    esp_err_t err = nvs_flash_init();
-    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
-        ESP_ERROR_CHECK(nvs_flash_erase());
-        err = nvs_flash_init();
-    }
-    tcpip_adapter_init();
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
-        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
-    };
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    TEST_ASSERT_NOT_NULL(wifi_handle);
-
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
-    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
-
-    audio_board_handle_t board_handle = audio_board_init();
-    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_WRITER;
-    fatfs_stream_writer = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, "/sdcard/test.txt"));
-
-    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
-    http_cfg.type = AUDIO_STREAM_READER;
-    http_cfg.cert_pem =  howsmyssl_com_root_cert_pem_start;
-    http_stream_reader = http_stream_init(&http_cfg);
-    TEST_ASSERT_NOT_NULL(http_stream_reader);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_reader, "http"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer,  "fatfs"));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) { "http", "fatfs" }, 2));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_reader, "http://httpbin.org/redirect-to?url=https%3A%2F%2Fwww.howsmyssl.com"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
-            break;
-            continue;
-        }
-    }
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+
+#include "unity.h"
+#include "esp_wifi.h"
+#include "esp_http_client.h"
+#include "nvs_flash.h"
+#include "esp_log.h"
+#include "audio_pipeline.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "audio_event_iface.h"
+#include "http_stream.h"
+#include "i2s_stream.h"
+#include "fatfs_stream.h"
+#include "aac_decoder.h"
+
+#include "esp_peripherals.h"
+#include "periph_wifi.h"
+#include "board.h"
+
+static const char *TAG = "HTTP STREAM UNITEST";
+
+static const char URL_RANDOM[] = "0123456789abcdefghijklmnopqrstuvwxyuzABCDEFGHIJKLMNOPQRSTUVWXYUZ-_.!@#$&*()=:/,;?+~";
+#define AAC_STREAM_URI "http://open.ls.qingting.fm/live/274/64k.m3u8?format=aac"
+#define UNITEST_HTTP_SERVRE_URI  "http://192.168.199.168:8000/upload"
+
+#define UNITETS_HTTP_STREAM_WIFI_SSID    "ESPRESSIF"
+#define UNITETS_HTTP_STREAM_WIFI_PASSWD    "espressif"
+
+TEST_CASE("http stream init memory", "[esp-adf-stream]")
+{
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    audio_element_handle_t http_stream_reader;
+    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+    http_cfg.event_handle = NULL;
+    http_cfg.type = AUDIO_STREAM_READER;
+    http_cfg.enable_playlist_parser = true;
+    int cnt = 2000;
+    AUDIO_MEM_SHOW("BEFORE HTTP_STREAM_INIT MEMORY TEST");
+    while (cnt--) {
+        http_stream_reader = http_stream_init(&http_cfg);
+        audio_element_deinit(http_stream_reader);
+    }
+    AUDIO_MEM_SHOW("AFTER HTTP_STREAM_INIT MEMORY TEST");
+}
+
+TEST_CASE("http stream url test", "[esp-adf-stream]")
+{
+    int url_len = 0;
+    int url_real_len = 0;
+    char s[2] = {0};
+    char url_rand[1024];
+    int url_rand_t = strlen(URL_RANDOM);
+    char *url = (char *)malloc(1024 + sizeof("http://"));
+
+    audio_element_handle_t http_stream_reader;
+    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+    http_cfg.event_handle = NULL;
+    http_cfg.type = AUDIO_STREAM_READER;
+    http_cfg.enable_playlist_parser = true;
+    http_stream_reader = http_stream_init(&http_cfg);
+
+    srand((unsigned int)time((time_t *)NULL));
+    for (int cnt = 0; cnt < 100; cnt++) {
+        memset(url, 0x00, sizeof("http://"));
+        strcpy(url, "http://");
+        url_len = (rand() % 1024);
+        for ( url_real_len = 0; url_real_len < url_len; url_real_len++) {
+            sprintf(s, "%c", URL_RANDOM[rand() % (url_rand_t) ]);
+            strcat(url_rand, s);
+        }
+        strcat(url, url_rand);
+        url[url_len + sizeof("http://") - 1] = '\0';
+        audio_element_set_uri(http_stream_reader, AAC_STREAM_URI);
+    }
+    free(url);
+    url = NULL;
+}
+
+int _http_living_stream_event_handle(http_stream_event_msg_t *msg)
+{
+    if (msg->event_id == HTTP_STREAM_RESOLVE_ALL_TRACKS) {
+        return ESP_OK;
+    }
+
+    if (msg->event_id == HTTP_STREAM_FINISH_TRACK) {
+        return http_stream_next_track(msg->el);
+    }
+    if (msg->event_id == HTTP_STREAM_FINISH_PLAYLIST) {
+        return http_stream_restart(msg->el);
+    }
+    return ESP_OK;
+
+}
+
+static esp_err_t _http_stream_event_handle(http_stream_event_msg_t *msg)
+{
+    esp_http_client_handle_t http = (esp_http_client_handle_t)msg->http_client;
+    char len_buf[16];
+    static int total_write = 0;
+
+    if (msg->event_id == HTTP_STREAM_PRE_REQUEST) {
+        return ESP_OK;
+    }
+
+    if (msg->event_id == HTTP_STREAM_ON_REQUEST) {
+        // write data
+        int wlen = sprintf(len_buf, "%x\r\n", msg->buffer_len);
+        if (esp_http_client_write(http, len_buf, wlen) <= 0) {
+            return ESP_FAIL;
+        }
+        if (esp_http_client_write(http, msg->buffer, msg->buffer_len) <= 0) {
+            return ESP_FAIL;
+        }
+        if (esp_http_client_write(http, "\r\n", 2) <= 0) {
+            return ESP_FAIL;
+        }
+        total_write += msg->buffer_len;
+        printf("\033[A\33[2K\rTotal bytes written: %d\n", total_write);
+        return msg->buffer_len;
+    }
+
+    if (msg->event_id == HTTP_STREAM_POST_REQUEST) {
+        if (esp_http_client_write(http, "0\r\n\r\n", 5) <= 0) {
+            return ESP_FAIL;
+        }
+        return ESP_OK;
+    }
+    if (msg->event_id == HTTP_STREAM_FINISH_REQUEST) {
+        char *buf = calloc(1, 64);
+        assert(buf);
+        int read_len = esp_http_client_read(http, buf, 64);
+        if (read_len <= 0) {
+            free(buf);
+            return ESP_FAIL;
+        }
+        buf[read_len] = 0;
+        free(buf);
+        return ESP_OK;
+    }
+    return ESP_OK;
+}
+
+TEST_CASE("http stream read", "[esp-adf-stream]")
+{
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t http_stream_reader, fatfs_stream_writer;
+
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    esp_err_t err = nvs_flash_init();
+    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
+        ESP_ERROR_CHECK(nvs_flash_erase());
+        err = nvs_flash_init();
+    }
+    tcpip_adapter_init();
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
+        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
+    };
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    TEST_ASSERT_NOT_NULL(wifi_handle);
+
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
+    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
+
+    audio_board_handle_t board_handle = audio_board_init();
+    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_WRITER;
+    fatfs_stream_writer = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, "/sdcard/test.mp3"));
+
+    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+    http_cfg.type = AUDIO_STREAM_READER;
+    http_stream_reader = http_stream_init(&http_cfg);
+    TEST_ASSERT_NOT_NULL(http_stream_reader);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_reader, "http"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer,  "fatfs"));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) { "http", "fatfs" }, 2));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_reader, "https://dl.espressif.com/dl/audio/ff-16b-2c-44100hz.mp3"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
+            break;
+            continue;
+        }
+    }
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
+
+/*
+ * Note : Before run this unitest, please run the http_server_read.py, and Confirm server ip in UNITEST_HTTP_SERVRE_URI
+ */
+TEST_CASE("http stream write", "[esp-adf-stream]")
+{
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t http_stream_writer, fatfs_stream_reader;
+
+    esp_err_t err = nvs_flash_init();
+    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
+        ESP_ERROR_CHECK(nvs_flash_erase());
+        err = nvs_flash_init();
+    }
+    tcpip_adapter_init();
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
+        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
+    };
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    TEST_ASSERT_NOT_NULL(wifi_handle);
+
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
+    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
+
+    audio_board_handle_t board_handle = audio_board_init();
+    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_READER;
+    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
+
+    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+    http_cfg.type = AUDIO_STREAM_WRITER;
+    http_cfg.event_handle = _http_stream_event_handle;
+    http_stream_writer = http_stream_init(&http_cfg);
+    TEST_ASSERT_NOT_NULL(http_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader,  "fatfs"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_writer, "http"));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"fatfs", "http"}, 2));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_writer, UNITEST_HTTP_SERVRE_URI));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_writer
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
+            break;
+            continue;
+        }
+    }
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
+
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
+
+TEST_CASE("http stream living test", "[esp-adf-stream]")
+{
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    esp_err_t err = nvs_flash_init();
+    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
+        TEST_ASSERT_EQUAL(ESP_OK, nvs_flash_erase());
+        err = nvs_flash_init();
+    }
+    tcpip_adapter_init();
+
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t http_stream_reader, i2s_stream_writer, aac_decoder;
+
+    audio_board_handle_t board_handle = audio_board_init();
+    TEST_ASSERT_NOT_NULL(board_handle);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+    http_cfg.event_handle = _http_living_stream_event_handle;
+    http_cfg.type = AUDIO_STREAM_READER;
+    http_cfg.enable_playlist_parser = true;
+    http_stream_reader = http_stream_init(&http_cfg);
+    TEST_ASSERT_NOT_NULL(http_stream_reader);
+
+    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg.type = AUDIO_STREAM_WRITER;
+    i2s_stream_writer = i2s_stream_init(&i2s_cfg);
+    TEST_ASSERT_NOT_NULL(i2s_stream_writer);
+
+    aac_decoder_cfg_t aac_cfg = DEFAULT_AAC_DECODER_CONFIG();
+    aac_decoder = aac_decoder_init(&aac_cfg);
+    TEST_ASSERT_NOT_NULL(aac_decoder);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_reader, "http"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, aac_decoder, "aac"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_writer,  "i2s"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"http",  "aac", "i2s"}, 3));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_reader, AAC_STREAM_URI));
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
+        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
+    };
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    TEST_ASSERT_NOT_NULL(wifi_handle);
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
+    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT
+            && msg.source == (void *) aac_decoder
+            && msg.cmd == AEL_MSG_CMD_REPORT_MUSIC_INFO) {
+            audio_element_info_t music_info = {0};
+            TEST_ASSERT_EQUAL(ESP_OK, audio_element_getinfo(aac_decoder, &music_info));
+
+            ESP_LOGI(TAG, "[ * ] Receive music info from aac decoder, sample_rates=%d, bits=%d, ch=%d",
+                     music_info.sample_rates, music_info.bits, music_info.channels);
+
+            TEST_ASSERT_EQUAL(ESP_OK, audio_element_setinfo(i2s_stream_writer, &music_info));
+            TEST_ASSERT_EQUAL(ESP_OK, i2s_stream_set_clk(i2s_stream_writer, music_info.sample_rates, music_info.bits, music_info.channels));
+            continue;
+        }
+
+        /* restart stream when the first pipeline element (http_stream_reader in this case) receives stop event (caused by reading errors) */
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
+            ESP_LOGW(TAG, "[ * ] Restart stream");
+            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(aac_decoder));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(i2s_stream_writer));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_ringbuffer(pipeline));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_items_state(pipeline));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+            continue;
+        }
+    }
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, aac_decoder));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(aac_decoder));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
+
+TEST_CASE("https stream test", "[esp-adf-stream]")
+{
+
+    extern const char howsmyssl_com_root_cert_pem_start[] asm("_binary_howsmyssl_com_root_cert_pem_start");
+    extern const char howsmyssl_com_root_cert_pem_end[]   asm("_binary_howsmyssl_com_root_cert_pem_end");
+
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t http_stream_reader, fatfs_stream_writer;
+
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    esp_err_t err = nvs_flash_init();
+    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
+        ESP_ERROR_CHECK(nvs_flash_erase());
+        err = nvs_flash_init();
+    }
+    tcpip_adapter_init();
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = UNITETS_HTTP_STREAM_WIFI_SSID,
+        .wifi_config.sta.password = UNITETS_HTTP_STREAM_WIFI_PASSWD,
+    };
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    TEST_ASSERT_NOT_NULL(wifi_handle);
+
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
+    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
+
+    audio_board_handle_t board_handle = audio_board_init();
+    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_WRITER;
+    fatfs_stream_writer = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, "/sdcard/test.txt"));
+
+    http_stream_cfg_t http_cfg = HTTP_STREAM_CFG_DEFAULT();
+    http_cfg.type = AUDIO_STREAM_READER;
+    http_cfg.cert_pem =  howsmyssl_com_root_cert_pem_start;
+    http_stream_reader = http_stream_init(&http_cfg);
+    TEST_ASSERT_NOT_NULL(http_stream_reader);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, http_stream_reader, "http"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer,  "fatfs"));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) { "http", "fatfs" }, 2));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(http_stream_reader, "http://httpbin.org/redirect-to?url=https%3A%2F%2Fwww.howsmyssl.com"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) http_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int) msg.data == AEL_STATUS_ERROR_OPEN) {
+            break;
+            continue;
+        }
+    }
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, http_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(http_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
diff --git a/components/audio_stream/test/i2s_stream_test.c b/components/audio_stream/test/i2s_stream_test.c
index cebea5f8..fd8d79cf 100644
--- a/components/audio_stream/test/i2s_stream_test.c
+++ b/components/audio_stream/test/i2s_stream_test.c
@@ -1,255 +1,255 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "unity.h"
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "esp_log.h"
-#include "sdkconfig.h"
-#include "audio_element.h"
-#include "audio_pipeline.h"
-#include "audio_event_iface.h"
-#include "audio_common.h"
-#include "fatfs_stream.h"
-#include "i2s_stream.h"
-#include "mp3_decoder.h"
-#include "esp_peripherals.h"
-#include "periph_sdcard.h"
-#include "audio_alc.h"
-#include "audio_mem.h"
-#include "board.h"
-
-
-static const char *TAG = "USE_ALC_EXAMPLE";
-
-typedef struct {
-    int rate;
-    int bits;
-    int ch;
-} unitest_i2s_clk__t;
-
-static unitest_i2s_clk__t unitest_i2s_clk[] = {
-    {8000, 16, 1},
-    {8000, 32, 1},
-    {8000, 32, 2},
-    {16000, 16, 1},
-    {16000, 32, 1},
-    {16000, 32, 2},
-    {32000, 16, 1},
-    {32000, 32, 1},
-    {32000, 32, 2},
-    {48000, 16, 1},
-    {48000, 16, 2},
-    {48000, 32, 2},
-    {48000, 32, 2},
-};
-
-static void i2s_volume_alc_task(void *pvParamters)
-{
-    int volume_val = -20;
-    int vol = 0;
-    TEST_ASSERT_NOT_NULL(pvParamters);
-    audio_element_handle_t i2s_stream = (audio_element_handle_t)pvParamters;
-    while (1)
-    {
-        volume_val += 1;
-        if (volume_val > 20) {
-            volume_val  = -20;
-        }
-        ESP_LOGI(TAG, "set vol is %d\n", volume_val);
-        TEST_ASSERT_EQUAL(ESP_OK, i2s_alc_volume_set(i2s_stream, volume_val));
-        TEST_ASSERT_EQUAL(ESP_OK, i2s_alc_volume_get(i2s_stream, &vol));
-        ESP_LOGI(TAG, "get vol is %d\n", vol);
-        vTaskDelay(200 / portTICK_PERIOD_MS);
-    }
-    vTaskDelete(NULL);
-}
-
-TEST_CASE("i2s stream init memory test", "[esp-adf-stream]")
-{
-    audio_element_handle_t i2s_stream_writer;
-    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg.type = AUDIO_STREAM_WRITER;
-    int cnt = 2000;
-    AUDIO_MEM_SHOW("BEFORE I2S_STREAM_INIT MEMORY TEST");
-    while (cnt--) {
-        i2s_stream_writer = i2s_stream_init(&i2s_cfg);
-        audio_element_deinit(i2s_stream_writer);
-    }
-    AUDIO_MEM_SHOW("AFTER I2S_STREAM_INIT MEMORY TEST");
-}
-
-TEST_CASE("i2s_stream alc test", "[esp-adf-stream]")
-{
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t fatfs_stream_reader, i2s_stream_writer, mp3_decoder;
-
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    audio_board_handle_t board_handle = audio_board_init();
-    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_READER;
-    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
-
-    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg.type = AUDIO_STREAM_WRITER;
-
-    i2s_cfg.use_alc = true;
-    i2s_stream_writer = i2s_stream_init(&i2s_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
-
-    mp3_decoder_cfg_t mp3_cfg = DEFAULT_MP3_DECODER_CONFIG();
-    mp3_decoder = mp3_decoder_init(&mp3_cfg);
-    TEST_ASSERT_NOT_NULL(mp3_decoder);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, mp3_decoder, "mp3"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_writer, "i2s"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"file", "mp3", "i2s"}, 3));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    xTaskCreate(i2s_volume_alc_task, "i2s_volume_alc_task", 4096, (void *)i2s_stream_writer, 9, NULL);
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *)mp3_decoder
-            && msg.cmd == AEL_MSG_CMD_REPORT_MUSIC_INFO) {
-            audio_element_info_t music_info = {0};
-            TEST_ASSERT_EQUAL(ESP_OK, audio_element_getinfo(mp3_decoder, &music_info));
-            TEST_ASSERT_EQUAL(ESP_OK, audio_element_setinfo(i2s_stream_writer, &music_info));
-
-            TEST_ASSERT_EQUAL(ESP_OK, i2s_stream_set_clk(i2s_stream_writer, music_info.sample_rates, music_info.bits,
-                               music_info.channels));
-            continue;
-        }
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *)i2s_stream_writer
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int)msg.data == AEL_STATUS_STATE_STOPPED) {
-            ESP_LOGW(TAG, "[ * ] Stop event received");
-            break;
-        }
-    }
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, mp3_decoder));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(mp3_decoder));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
-
-TEST_CASE("i2s_stream write_read_loop", "[esp-adf-stream]")
-{
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t i2s_stream_reader, i2s_stream_writer;
-
-    audio_board_handle_t board_handle = audio_board_init();
-    audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START);
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    i2s_stream_cfg_t i2s_cfg_read = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg_read.type = AUDIO_STREAM_READER;
-    i2s_stream_reader = i2s_stream_init(&i2s_cfg_read);
-    TEST_ASSERT_NOT_NULL(i2s_stream_reader);
-
-    i2s_stream_cfg_t i2s_cfg_writer = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg_writer.type = AUDIO_STREAM_WRITER;
-    i2s_stream_writer = i2s_stream_init(&i2s_cfg_writer);
-    TEST_ASSERT_NOT_NULL(i2s_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_reader, "i2s_read"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_writer, "i2s_write"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"i2s_read", "i2s_write"}, 2));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-    
-    for (size_t i = 10; i > 0; i--) {
-        ESP_LOGI(TAG, "test time: %d", i);
-    }
-    
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_writer));
-    ESP_LOGI(TAG, "finished the [i2s read write loop test]");
-}
-
-TEST_CASE("i2s_stream_clk", "[esp-adf-stream]")
-{
-
-    audio_element_handle_t i2s_stream_reader;
-
-    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg.type = AUDIO_STREAM_READER;
-    i2s_stream_reader = i2s_stream_init(&i2s_cfg); 
-    TEST_ASSERT_NOT_NULL(i2s_stream_reader);
-
-    for (size_t i = 0; i < (sizeof(unitest_i2s_clk)/sizeof(unitest_i2s_clk[0])); i++) {
-        ESP_LOGI(TAG, "rate is %d, bits is %d, ch is %d", unitest_i2s_clk[i].rate, unitest_i2s_clk[i].bits, unitest_i2s_clk[i].ch);
-        TEST_ASSERT_EQUAL(ESP_OK, i2s_stream_set_clk(i2s_stream_reader, unitest_i2s_clk[i].rate, unitest_i2s_clk[i].bits, unitest_i2s_clk[i].ch));
-    }
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "unity.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "esp_log.h"
+#include "sdkconfig.h"
+#include "audio_element.h"
+#include "audio_pipeline.h"
+#include "audio_event_iface.h"
+#include "audio_common.h"
+#include "fatfs_stream.h"
+#include "i2s_stream.h"
+#include "mp3_decoder.h"
+#include "esp_peripherals.h"
+#include "periph_sdcard.h"
+#include "audio_alc.h"
+#include "audio_mem.h"
+#include "board.h"
+
+
+static const char *TAG = "USE_ALC_EXAMPLE";
+
+typedef struct {
+    int rate;
+    int bits;
+    int ch;
+} unitest_i2s_clk__t;
+
+static unitest_i2s_clk__t unitest_i2s_clk[] = {
+    {8000, 16, 1},
+    {8000, 32, 1},
+    {8000, 32, 2},
+    {16000, 16, 1},
+    {16000, 32, 1},
+    {16000, 32, 2},
+    {32000, 16, 1},
+    {32000, 32, 1},
+    {32000, 32, 2},
+    {48000, 16, 1},
+    {48000, 16, 2},
+    {48000, 32, 2},
+    {48000, 32, 2},
+};
+
+static void i2s_volume_alc_task(void *pvParamters)
+{
+    int volume_val = -20;
+    int vol = 0;
+    TEST_ASSERT_NOT_NULL(pvParamters);
+    audio_element_handle_t i2s_stream = (audio_element_handle_t)pvParamters;
+    while (1)
+    {
+        volume_val += 1;
+        if (volume_val > 20) {
+            volume_val  = -20;
+        }
+        ESP_LOGI(TAG, "set vol is %d\n", volume_val);
+        TEST_ASSERT_EQUAL(ESP_OK, i2s_alc_volume_set(i2s_stream, volume_val));
+        TEST_ASSERT_EQUAL(ESP_OK, i2s_alc_volume_get(i2s_stream, &vol));
+        ESP_LOGI(TAG, "get vol is %d\n", vol);
+        vTaskDelay(200 / portTICK_PERIOD_MS);
+    }
+    vTaskDelete(NULL);
+}
+
+TEST_CASE("i2s stream init memory test", "[esp-adf-stream]")
+{
+    audio_element_handle_t i2s_stream_writer;
+    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg.type = AUDIO_STREAM_WRITER;
+    int cnt = 2000;
+    AUDIO_MEM_SHOW("BEFORE I2S_STREAM_INIT MEMORY TEST");
+    while (cnt--) {
+        i2s_stream_writer = i2s_stream_init(&i2s_cfg);
+        audio_element_deinit(i2s_stream_writer);
+    }
+    AUDIO_MEM_SHOW("AFTER I2S_STREAM_INIT MEMORY TEST");
+}
+
+TEST_CASE("i2s_stream alc test", "[esp-adf-stream]")
+{
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t fatfs_stream_reader, i2s_stream_writer, mp3_decoder;
+
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    audio_board_handle_t board_handle = audio_board_init();
+    TEST_ASSERT_EQUAL(ESP_OK, audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_READER;
+    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
+
+    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg.type = AUDIO_STREAM_WRITER;
+
+    i2s_cfg.use_alc = true;
+    i2s_stream_writer = i2s_stream_init(&i2s_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
+
+    mp3_decoder_cfg_t mp3_cfg = DEFAULT_MP3_DECODER_CONFIG();
+    mp3_decoder = mp3_decoder_init(&mp3_cfg);
+    TEST_ASSERT_NOT_NULL(mp3_decoder);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, mp3_decoder, "mp3"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_writer, "i2s"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"file", "mp3", "i2s"}, 3));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    xTaskCreate(i2s_volume_alc_task, "i2s_volume_alc_task", 4096, (void *)i2s_stream_writer, 9, NULL);
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *)mp3_decoder
+            && msg.cmd == AEL_MSG_CMD_REPORT_MUSIC_INFO) {
+            audio_element_info_t music_info = {0};
+            TEST_ASSERT_EQUAL(ESP_OK, audio_element_getinfo(mp3_decoder, &music_info));
+            TEST_ASSERT_EQUAL(ESP_OK, audio_element_setinfo(i2s_stream_writer, &music_info));
+
+            TEST_ASSERT_EQUAL(ESP_OK, i2s_stream_set_clk(i2s_stream_writer, music_info.sample_rates, music_info.bits,
+                               music_info.channels));
+            continue;
+        }
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *)i2s_stream_writer
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS && (int)msg.data == AEL_STATUS_STATE_STOPPED) {
+            ESP_LOGW(TAG, "[ * ] Stop event received");
+            break;
+        }
+    }
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, mp3_decoder));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(mp3_decoder));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
+
+TEST_CASE("i2s_stream write_read_loop", "[esp-adf-stream]")
+{
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t i2s_stream_reader, i2s_stream_writer;
+
+    audio_board_handle_t board_handle = audio_board_init();
+    audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_ENCODE, AUDIO_HAL_CTRL_START);
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    i2s_stream_cfg_t i2s_cfg_read = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg_read.type = AUDIO_STREAM_READER;
+    i2s_stream_reader = i2s_stream_init(&i2s_cfg_read);
+    TEST_ASSERT_NOT_NULL(i2s_stream_reader);
+
+    i2s_stream_cfg_t i2s_cfg_writer = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg_writer.type = AUDIO_STREAM_WRITER;
+    i2s_stream_writer = i2s_stream_init(&i2s_cfg_writer);
+    TEST_ASSERT_NOT_NULL(i2s_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_reader, "i2s_read"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, i2s_stream_writer, "i2s_write"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"i2s_read", "i2s_write"}, 2));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+    
+    for (size_t i = 10; i > 0; i--) {
+        ESP_LOGI(TAG, "test time: %d", i);
+    }
+    
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(i2s_stream_writer));
+    ESP_LOGI(TAG, "finished the [i2s read write loop test]");
+}
+
+TEST_CASE("i2s_stream_clk", "[esp-adf-stream]")
+{
+
+    audio_element_handle_t i2s_stream_reader;
+
+    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg.type = AUDIO_STREAM_READER;
+    i2s_stream_reader = i2s_stream_init(&i2s_cfg); 
+    TEST_ASSERT_NOT_NULL(i2s_stream_reader);
+
+    for (size_t i = 0; i < (sizeof(unitest_i2s_clk)/sizeof(unitest_i2s_clk[0])); i++) {
+        ESP_LOGI(TAG, "rate is %d, bits is %d, ch is %d", unitest_i2s_clk[i].rate, unitest_i2s_clk[i].bits, unitest_i2s_clk[i].ch);
+        TEST_ASSERT_EQUAL(ESP_OK, i2s_stream_set_clk(i2s_stream_reader, unitest_i2s_clk[i].rate, unitest_i2s_clk[i].bits, unitest_i2s_clk[i].ch));
+    }
 }
\ No newline at end of file
diff --git a/components/audio_stream/test/partitions_test_tts_stream.csv b/components/audio_stream/test/partitions_test_tts_stream.csv
index 199e557f..5500c9ab 100644
--- a/components/audio_stream/test/partitions_test_tts_stream.csv
+++ b/components/audio_stream/test/partitions_test_tts_stream.csv
@@ -1,18 +1,18 @@
-
-# Special partition table for unit test app
-#
-# Name,     Type, SubType, Offset,   Size, Flags
-# Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild
-nvs,        data, nvs,      0x9000,  0x6000
-phy_init,   data, phy,      0xf000,  0x1000
-
-# these OTA partitions are used for tests, but can't fit real OTA apps in them
-# (done this way to reduce total flash usage.)
-ota_0,      0,    ota_0,    0x10000, 0x80000
-
-# flash_test partition used for SPI flash tests, WL FAT tests, and SPIFFS tests
-flash_test, data, fat,      ,        0x90000
-
-# Note: still 1MB of a 4MB flash left free for some other purpose
-voice_data, data,  fat,     0x500000, 3M
-
+
+# Special partition table for unit test app
+#
+# Name,     Type, SubType, Offset,   Size, Flags
+# Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild
+nvs,        data, nvs,      0x9000,  0x6000
+phy_init,   data, phy,      0xf000,  0x1000
+
+# these OTA partitions are used for tests, but can't fit real OTA apps in them
+# (done this way to reduce total flash usage.)
+ota_0,      0,    ota_0,    0x10000, 0x80000
+
+# flash_test partition used for SPI flash tests, WL FAT tests, and SPIFFS tests
+flash_test, data, fat,      ,        0x90000
+
+# Note: still 1MB of a 4MB flash left free for some other purpose
+voice_data, data,  fat,     0x500000, 3M
+
diff --git a/components/audio_stream/test/spiffs_stream_test.c b/components/audio_stream/test/spiffs_stream_test.c
index 0346a697..f5721fb7 100644
--- a/components/audio_stream/test/spiffs_stream_test.c
+++ b/components/audio_stream/test/spiffs_stream_test.c
@@ -1,178 +1,178 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-
-#include "unity.h"
-#include "esp_log.h"
-#include "esp_err.h"
-
-#include "audio_mem.h"
-#include "audio_pipeline.h"
-#include "esp_peripherals.h"
-#include "spiffs_stream.h"
-#include "periph_spiffs.h"
-
-static const char *TAG = "SPIFFS_STREAM_TEST";
-
-
-static uint64_t get_file_size(const char *name)
-{
-    FILE *f;
-    int size = 0;
-    f = fopen(name, "rb");
-    if (f == NULL) {
-        return -1;
-    }
-    fseek(f, 0, SEEK_END);
-    size = ftell(f);
-    fclose(f);
-    return size;
-}
-
-static void comparison_file_size(const char *file1, const char *file2)
-{
-    uint64_t size1 = get_file_size(file1);
-    TEST_ASSERT_TRUE(size1 >= 0);
-    uint64_t size2 = get_file_size(file2);
-    TEST_ASSERT_TRUE(size2 >= 0);
-    if (size1 == size2) {
-        ESP_LOGI(TAG, "spiffs test successful");
-    } else {
-        ESP_LOGI(TAG, "spiffs test failed");
-    }
-}
-
-TEST_CASE("spiffs stream init memory test", "esp-adf-stream")
-{
-    audio_element_handle_t spiffs_stream_reader;
-    periph_spiffs_cfg_t spiffs_cfg = {
-        .root = "/spiffs",
-        .partition_label = NULL,
-        .max_files = 5,
-        .format_if_mount_failed = true
-    };
-    AUDIO_MEM_SHOW("BEFORE SPIFFS_STREAM_INIT MEMORY TEST");
-    spiffs_stream_cfg_t spiffs_reader_cfg = SPIFFS_STREAM_CFG_DEFAULT();
-    spiffs_reader_cfg.type = AUDIO_STREAM_READER;
-    int cnt = 2000;
-    while (cnt--) {
-        spiffs_stream_reader = spiffs_stream_init(&spiffs_reader_cfg);
-        audio_element_deinit(spiffs_stream_reader);
-    }
-    AUDIO_MEM_SHOW("BEFORE SPIFFS_STREAM_INIT MEMORY TEST");
-}
-
-/* 
- * Note Before run this unitest, please prepare the following two steps
- * step1 mofify you partition table, For example add "storage,  data, spiffs,  0x110000,1M" in partition table
- * step2 download esp-audio.bin in flash, the download address is 0x110000
- */
-TEST_CASE("Spiffs stream read and write loop test", "[esp-adf-stream]")
-{
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t spiffs_stream_reader, spiffs_stream_writer;
-
-    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    periph_spiffs_cfg_t spiffs_cfg = {
-        .root = "/spiffs",
-        .partition_label = NULL,
-        .max_files = 5,
-        .format_if_mount_failed = true
-    };
-    esp_periph_handle_t spiffs_handle = periph_spiffs_init(&spiffs_cfg);
-    TEST_ASSERT_NOT_NULL(spiffs_handle);
-
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, spiffs_handle));
-
-    while (!periph_spiffs_is_mounted(spiffs_handle)) {
-        vTaskDelay(500 / portTICK_PERIOD_MS);
-    }
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    spiffs_stream_cfg_t spiffs_reader_cfg = SPIFFS_STREAM_CFG_DEFAULT();
-    spiffs_reader_cfg.type = AUDIO_STREAM_READER;
-    spiffs_stream_reader = spiffs_stream_init(&spiffs_reader_cfg);
-    TEST_ASSERT_NOT_NULL(spiffs_stream_reader);
-
-    spiffs_stream_cfg_t fatfs_writer_cfg = SPIFFS_STREAM_CFG_DEFAULT();
-    fatfs_writer_cfg.type = AUDIO_STREAM_WRITER;
-    spiffs_stream_writer = spiffs_stream_init(&fatfs_writer_cfg);
-    TEST_ASSERT_NOT_NULL(spiffs_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, spiffs_stream_reader, "spiffs_reader"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, spiffs_stream_writer, "spiffs_writer"));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"spiffs_reader", "spiffs_writer"}, 2));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(spiffs_stream_reader, "/spiffs/adf_music.mp3"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(spiffs_stream_writer, "/spiffs/adf_music_writer.mp3"));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg = { 0 };
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) spiffs_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
-            ESP_LOGW(TAG, "[ * ] Stop event received");
-            break;
-        }
-    }
-
-    comparison_file_size("/spiffs/adf_music.mp3", "/spiffs/adf_music_writer.mp3");
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, spiffs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, spiffs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(spiffs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(spiffs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+
+#include "unity.h"
+#include "esp_log.h"
+#include "esp_err.h"
+
+#include "audio_mem.h"
+#include "audio_pipeline.h"
+#include "esp_peripherals.h"
+#include "spiffs_stream.h"
+#include "periph_spiffs.h"
+
+static const char *TAG = "SPIFFS_STREAM_TEST";
+
+
+static uint64_t get_file_size(const char *name)
+{
+    FILE *f;
+    int size = 0;
+    f = fopen(name, "rb");
+    if (f == NULL) {
+        return -1;
+    }
+    fseek(f, 0, SEEK_END);
+    size = ftell(f);
+    fclose(f);
+    return size;
+}
+
+static void comparison_file_size(const char *file1, const char *file2)
+{
+    uint64_t size1 = get_file_size(file1);
+    TEST_ASSERT_TRUE(size1 >= 0);
+    uint64_t size2 = get_file_size(file2);
+    TEST_ASSERT_TRUE(size2 >= 0);
+    if (size1 == size2) {
+        ESP_LOGI(TAG, "spiffs test successful");
+    } else {
+        ESP_LOGI(TAG, "spiffs test failed");
+    }
+}
+
+TEST_CASE("spiffs stream init memory test", "esp-adf-stream")
+{
+    audio_element_handle_t spiffs_stream_reader;
+    periph_spiffs_cfg_t spiffs_cfg = {
+        .root = "/spiffs",
+        .partition_label = NULL,
+        .max_files = 5,
+        .format_if_mount_failed = true
+    };
+    AUDIO_MEM_SHOW("BEFORE SPIFFS_STREAM_INIT MEMORY TEST");
+    spiffs_stream_cfg_t spiffs_reader_cfg = SPIFFS_STREAM_CFG_DEFAULT();
+    spiffs_reader_cfg.type = AUDIO_STREAM_READER;
+    int cnt = 2000;
+    while (cnt--) {
+        spiffs_stream_reader = spiffs_stream_init(&spiffs_reader_cfg);
+        audio_element_deinit(spiffs_stream_reader);
+    }
+    AUDIO_MEM_SHOW("BEFORE SPIFFS_STREAM_INIT MEMORY TEST");
+}
+
+/* 
+ * Note Before run this unitest, please prepare the following two steps
+ * step1 mofify you partition table, For example add "storage,  data, spiffs,  0x110000,1M" in partition table
+ * step2 download esp-audio.bin in flash, the download address is 0x110000
+ */
+TEST_CASE("Spiffs stream read and write loop test", "[esp-adf-stream]")
+{
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t spiffs_stream_reader, spiffs_stream_writer;
+
+    esp_log_level_set("AUDIO_PIPELINE", ESP_LOG_DEBUG);
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    periph_spiffs_cfg_t spiffs_cfg = {
+        .root = "/spiffs",
+        .partition_label = NULL,
+        .max_files = 5,
+        .format_if_mount_failed = true
+    };
+    esp_periph_handle_t spiffs_handle = periph_spiffs_init(&spiffs_cfg);
+    TEST_ASSERT_NOT_NULL(spiffs_handle);
+
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, spiffs_handle));
+
+    while (!periph_spiffs_is_mounted(spiffs_handle)) {
+        vTaskDelay(500 / portTICK_PERIOD_MS);
+    }
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    spiffs_stream_cfg_t spiffs_reader_cfg = SPIFFS_STREAM_CFG_DEFAULT();
+    spiffs_reader_cfg.type = AUDIO_STREAM_READER;
+    spiffs_stream_reader = spiffs_stream_init(&spiffs_reader_cfg);
+    TEST_ASSERT_NOT_NULL(spiffs_stream_reader);
+
+    spiffs_stream_cfg_t fatfs_writer_cfg = SPIFFS_STREAM_CFG_DEFAULT();
+    fatfs_writer_cfg.type = AUDIO_STREAM_WRITER;
+    spiffs_stream_writer = spiffs_stream_init(&fatfs_writer_cfg);
+    TEST_ASSERT_NOT_NULL(spiffs_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, spiffs_stream_reader, "spiffs_reader"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, spiffs_stream_writer, "spiffs_writer"));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"spiffs_reader", "spiffs_writer"}, 2));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(spiffs_stream_reader, "/spiffs/adf_music.mp3"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(spiffs_stream_writer, "/spiffs/adf_music_writer.mp3"));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg = { 0 };
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) spiffs_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
+            ESP_LOGW(TAG, "[ * ] Stop event received");
+            break;
+        }
+    }
+
+    comparison_file_size("/spiffs/adf_music.mp3", "/spiffs/adf_music_writer.mp3");
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, spiffs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, spiffs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(spiffs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(spiffs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
diff --git a/components/audio_stream/test/tcp_client_stream_server_read.py b/components/audio_stream/test/tcp_client_stream_server_read.py
index fcbd3fab..a2e6760f 100644
--- a/components/audio_stream/test/tcp_client_stream_server_read.py
+++ b/components/audio_stream/test/tcp_client_stream_server_read.py
@@ -1,67 +1,67 @@
-#!/user/bin/env python
-
-#  ESPRESSIF MIT License
-#
-#  Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
-#
-#  Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
-#  it is free of charge, to any person obtaining a copy of this software and associated
-#  documentation files (the "Software"), to deal in the Software without restriction, including
-#  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-#  and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-#  to do so, subject to the following conditions:
-#
-#  The above copyright notice and this permission notice shall be included in all copies or
-#  substantial portions of the Software.
-#
-#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-#  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-import socket
-import sys
-
-SERVER_PORT  = 8000
-SND_BUF_SIZE = 8194
-
-def start_tcp_server(ip, port):
-
-    fo = open("esp32.mp3", "r")
-
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    server_address = (ip, port)
-
-    print("starting listen on ip %s, port %s" % server_address)
-    sock.bind(server_address)
- 
-    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SND_BUF_SIZE)
-    
-    try:
-        sock.listen(1)
-    except socket.error:
-        print("fail to listen on port %s" % e)
-        sys.exit(1)
-    while True:
-        print("waiting for client to connect")
-        client, addr = sock.accept()
-        break
-    msg = client.recv(1024)
-    if not (msg == "hello test"):
-        exit
-
-    msg = fo.read()
-    if len(msg) <= 0:
-        print "server read data error"
-        exit
-    client .send(msg)
- 
-    fo.close()
-    client.close()
-    sock.close() 
-    print(" close client connect ")
- 
-if __name__=='__main__':
-    start_tcp_server(socket.gethostbyname(socket.getfqdn(socket.gethostname())), SERVER_PORT)
+#!/user/bin/env python
+
+#  ESPRESSIF MIT License
+#
+#  Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+#
+#  Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+#  it is free of charge, to any person obtaining a copy of this software and associated
+#  documentation files (the "Software"), to deal in the Software without restriction, including
+#  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+#  and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+#  to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in all copies or
+#  substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+#  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+import socket
+import sys
+
+SERVER_PORT  = 8000
+SND_BUF_SIZE = 8194
+
+def start_tcp_server(ip, port):
+
+    fo = open("esp32.mp3", "r")
+
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    server_address = (ip, port)
+
+    print("starting listen on ip %s, port %s" % server_address)
+    sock.bind(server_address)
+ 
+    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SND_BUF_SIZE)
+    
+    try:
+        sock.listen(1)
+    except socket.error:
+        print("fail to listen on port %s" % e)
+        sys.exit(1)
+    while True:
+        print("waiting for client to connect")
+        client, addr = sock.accept()
+        break
+    msg = client.recv(1024)
+    if not (msg == "hello test"):
+        exit
+
+    msg = fo.read()
+    if len(msg) <= 0:
+        print "server read data error"
+        exit
+    client .send(msg)
+ 
+    fo.close()
+    client.close()
+    sock.close() 
+    print(" close client connect ")
+ 
+if __name__=='__main__':
+    start_tcp_server(socket.gethostbyname(socket.getfqdn(socket.gethostname())), SERVER_PORT)
diff --git a/components/audio_stream/test/tcp_client_stream_server_write.py b/components/audio_stream/test/tcp_client_stream_server_write.py
index c2cf45f2..cf73d8c7 100644
--- a/components/audio_stream/test/tcp_client_stream_server_write.py
+++ b/components/audio_stream/test/tcp_client_stream_server_write.py
@@ -1,67 +1,67 @@
-#!/user/bin/env python
-
-#  ESPRESSIF MIT License
-#
-#  Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
-#
-#  Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
-#  it is free of charge, to any person obtaining a copy of this software and associated
-#  documentation files (the "Software"), to deal in the Software without restriction, including
-#  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-#  and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-#  to do so, subject to the following conditions:
-#
-#  The above copyright notice and this permission notice shall be included in all copies or
-#  substantial portions of the Software.
-#
-#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-#  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-import socket
-import sys
-
-SERVER_PORT   = 8000
-RECV_BUF_SIZE = 8194
- 
-def start_tcp_server(ip, port):
-
-    fo = open("esp32.mp3", "w+")
-    print ("create a file named esp32.p3")
-
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    server_address = (ip, port)
-
-    print("starting listen on ip %s, port %s" % server_address)
-    sock.bind(server_address)
- 
-    sock.settimeout(1000)
-    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, RECV_BUF_SIZE)
- 
-    try:
-        sock.listen(1)
-    except socket.error:
-        print("fail to listen on port %s" % e)
-        sys.exit(1)
-    while True:
-        print("waiting for client to connect")
-        client, addr = sock.accept()
-        break
-
-    while True:
-        msg = client.recv(8194)
-        print('recv data len ', len(msg));
-        if len(msg) <= 0:
-            break
-        fo.write(msg)
- 
-    fo.close()
-    client.close()
-    sock.close() 
-    print(" close client connect ")
- 
-if __name__=='__main__':
-    start_tcp_server(socket.gethostbyname(socket.getfqdn(socket.gethostname())), SERVER_PORT)
+#!/user/bin/env python
+
+#  ESPRESSIF MIT License
+#
+#  Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+#
+#  Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+#  it is free of charge, to any person obtaining a copy of this software and associated
+#  documentation files (the "Software"), to deal in the Software without restriction, including
+#  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+#  and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+#  to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in all copies or
+#  substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+#  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+#  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+import socket
+import sys
+
+SERVER_PORT   = 8000
+RECV_BUF_SIZE = 8194
+ 
+def start_tcp_server(ip, port):
+
+    fo = open("esp32.mp3", "w+")
+    print ("create a file named esp32.p3")
+
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    server_address = (ip, port)
+
+    print("starting listen on ip %s, port %s" % server_address)
+    sock.bind(server_address)
+ 
+    sock.settimeout(1000)
+    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, RECV_BUF_SIZE)
+ 
+    try:
+        sock.listen(1)
+    except socket.error:
+        print("fail to listen on port %s" % e)
+        sys.exit(1)
+    while True:
+        print("waiting for client to connect")
+        client, addr = sock.accept()
+        break
+
+    while True:
+        msg = client.recv(8194)
+        print('recv data len ', len(msg));
+        if len(msg) <= 0:
+            break
+        fo.write(msg)
+ 
+    fo.close()
+    client.close()
+    sock.close() 
+    print(" close client connect ")
+ 
+if __name__=='__main__':
+    start_tcp_server(socket.gethostbyname(socket.getfqdn(socket.gethostname())), SERVER_PORT)
diff --git a/components/audio_stream/test/tcp_client_stream_test.c b/components/audio_stream/test/tcp_client_stream_test.c
index 89ed89db..811c492b 100644
--- a/components/audio_stream/test/tcp_client_stream_test.c
+++ b/components/audio_stream/test/tcp_client_stream_test.c
@@ -1,242 +1,242 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-
-#include "unity.h"
-#include "esp_wifi.h"
-#include "esp_http_client.h"
-#include "nvs_flash.h"
-#include "esp_log.h"
-#include "audio_pipeline.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "audio_event_iface.h"
-
-#include "tcp_client_stream.h"
-#include "fatfs_stream.h"
-
-#include "esp_peripherals.h"
-#include "periph_wifi.h"
-
-#define CONFIG_TCP_URL   "192.168.199.118"
-#define CONFIG_TCP_PORT  8080
-
-static const char *TAG =  "TCP_CLIENT_STREAM_TEST";
-
-TEST_CASE("tcp client stream init memory", "[esp-adf-stream]")
-{
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    audio_element_handle_t tcp_stream_writer
-    tcp_stream_cfg_t tcp_cfg = TCP_STREAM_CFG_DEFAULT();
-    tcp_cfg.type = AUDIO_STREAM_WRITER;
-    int cnt = 2000;
-    AUDIO_MEM_SHOW("BEFORE TCP_CLIENT_STREAM_INIT MEMORY TEST");
-    while (cnt--) {
-        tcp_stream_writer = tcp_stream_init(&tcp_cfg);
-        TEST_ASSERT_NOT_NULL(tcp_stream_writer);
-        TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tcp_stream_writer));
-    }
-    AUDIO_MEM_SHOW("AFTER TCP_CLIENT_STREAM_INIT MEMORY TEST");
-}
-
-TEST_CASE("tcp client stream write", "[esp-adf-stream]")
-{
-    esp_err_t err = nvs_flash_init();
-    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
-        ESP_ERROR_CHECK(nvs_flash_erase());
-        err = nvs_flash_init();
-    }
-    tcpip_adapter_init();
-
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t tcp_stream_writer, fatfs_stream_reader;
-
-    esp_log_level_set("*", ESP_LOG_WARN);
-    esp_log_level_set(TAG, ESP_LOG_DEBUG);
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_READER;
-    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
-
-    tcp_stream_cfg_t tcp_cfg = TCP_STREAM_CFG_DEFAULT();
-    tcp_cfg.type = AUDIO_STREAM_WRITER;
-    tcp_cfg.port = CONFIG_TCP_PORT;
-    tcp_cfg.host = CONFIG_TCP_URL;
-    tcp_stream_writer = tcp_stream_init(&tcp_cfg);
-    TEST_ASSERT_NOT_NULL(tcp_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, tcp_stream_writer, "tcp"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"file", "tcp"}, 2));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
-
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = CONFIG_WIFI_SSID,
-        .wifi_config.sta.password = CONFIG_WIFI_PASSWORD,
-    };
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
-    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        /* Stop when the last pipeline element (fatfs_stream_reader in this case) read stop event */
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) fatfs_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
-            ESP_LOGW(TAG, "[ * ] Stop event received");
-            break;
-        }
-    }
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, tcp_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tcp_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
-}
-
-TEST_CASE("tcp client stream read", "[esp-adf-stream]")
-{
-    esp_err_t err = nvs_flash_init();
-    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
-        ESP_ERROR_CHECK(nvs_flash_erase());
-        err = nvs_flash_init();
-    }
-    tcpip_adapter_init();
-
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t tcp_stream_writer, fatfs_stream_reader;
-
-    esp_log_level_set("*", ESP_LOG_WARN);
-    esp_log_level_set(TAG, ESP_LOG_DEBUG);
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_WRITER;
-    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
-
-    tcp_stream_cfg_t tcp_cfg = TCP_STREAM_CFG_DEFAULT();
-    tcp_cfg.type = AUDIO_STREAM_READER;
-    tcp_cfg.port = CONFIG_TCP_PORT;
-    tcp_cfg.host = CONFIG_TCP_URL;
-    tcp_stream_writer = tcp_stream_init(&tcp_cfg);
-    TEST_ASSERT_NOT_NULL(tcp_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, tcp_stream_writer, "tcp"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"tcp", "file"}, 2));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
-
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = CONFIG_WIFI_SSID,
-        .wifi_config.sta.password = CONFIG_WIFI_PASSWORD,
-    };
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
-    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
-            continue;
-        }
-
-        /* Stop when the last pipeline element (tcp_stream_reader in this case) read stop event */
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) tcp_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
-            ESP_LOGW(TAG, "[ * ] Stop event received");
-            break;
-        }
-    }
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, tcp_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tcp_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+
+#include "unity.h"
+#include "esp_wifi.h"
+#include "esp_http_client.h"
+#include "nvs_flash.h"
+#include "esp_log.h"
+#include "audio_pipeline.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "audio_event_iface.h"
+
+#include "tcp_client_stream.h"
+#include "fatfs_stream.h"
+
+#include "esp_peripherals.h"
+#include "periph_wifi.h"
+
+#define CONFIG_TCP_URL   "192.168.199.118"
+#define CONFIG_TCP_PORT  8080
+
+static const char *TAG =  "TCP_CLIENT_STREAM_TEST";
+
+TEST_CASE("tcp client stream init memory", "[esp-adf-stream]")
+{
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    audio_element_handle_t tcp_stream_writer
+    tcp_stream_cfg_t tcp_cfg = TCP_STREAM_CFG_DEFAULT();
+    tcp_cfg.type = AUDIO_STREAM_WRITER;
+    int cnt = 2000;
+    AUDIO_MEM_SHOW("BEFORE TCP_CLIENT_STREAM_INIT MEMORY TEST");
+    while (cnt--) {
+        tcp_stream_writer = tcp_stream_init(&tcp_cfg);
+        TEST_ASSERT_NOT_NULL(tcp_stream_writer);
+        TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tcp_stream_writer));
+    }
+    AUDIO_MEM_SHOW("AFTER TCP_CLIENT_STREAM_INIT MEMORY TEST");
+}
+
+TEST_CASE("tcp client stream write", "[esp-adf-stream]")
+{
+    esp_err_t err = nvs_flash_init();
+    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
+        ESP_ERROR_CHECK(nvs_flash_erase());
+        err = nvs_flash_init();
+    }
+    tcpip_adapter_init();
+
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t tcp_stream_writer, fatfs_stream_reader;
+
+    esp_log_level_set("*", ESP_LOG_WARN);
+    esp_log_level_set(TAG, ESP_LOG_DEBUG);
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_READER;
+    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
+
+    tcp_stream_cfg_t tcp_cfg = TCP_STREAM_CFG_DEFAULT();
+    tcp_cfg.type = AUDIO_STREAM_WRITER;
+    tcp_cfg.port = CONFIG_TCP_PORT;
+    tcp_cfg.host = CONFIG_TCP_URL;
+    tcp_stream_writer = tcp_stream_init(&tcp_cfg);
+    TEST_ASSERT_NOT_NULL(tcp_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, tcp_stream_writer, "tcp"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"file", "tcp"}, 2));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
+
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = CONFIG_WIFI_SSID,
+        .wifi_config.sta.password = CONFIG_WIFI_PASSWORD,
+    };
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
+    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        /* Stop when the last pipeline element (fatfs_stream_reader in this case) read stop event */
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) fatfs_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
+            ESP_LOGW(TAG, "[ * ] Stop event received");
+            break;
+        }
+    }
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, tcp_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tcp_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
+}
+
+TEST_CASE("tcp client stream read", "[esp-adf-stream]")
+{
+    esp_err_t err = nvs_flash_init();
+    if (err == ESP_ERR_NVS_NO_FREE_PAGES) {
+        ESP_ERROR_CHECK(nvs_flash_erase());
+        err = nvs_flash_init();
+    }
+    tcpip_adapter_init();
+
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t tcp_stream_writer, fatfs_stream_reader;
+
+    esp_log_level_set("*", ESP_LOG_WARN);
+    esp_log_level_set(TAG, ESP_LOG_DEBUG);
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_WRITER;
+    fatfs_stream_reader = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_reader);
+
+    tcp_stream_cfg_t tcp_cfg = TCP_STREAM_CFG_DEFAULT();
+    tcp_cfg.type = AUDIO_STREAM_READER;
+    tcp_cfg.port = CONFIG_TCP_PORT;
+    tcp_cfg.host = CONFIG_TCP_URL;
+    tcp_stream_writer = tcp_stream_init(&tcp_cfg);
+    TEST_ASSERT_NOT_NULL(tcp_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, tcp_stream_writer, "tcp"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_reader, "file"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"tcp", "file"}, 2));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_reader, "/sdcard/test.mp3"));
+
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = CONFIG_WIFI_SSID,
+        .wifi_config.sta.password = CONFIG_WIFI_PASSWORD,
+    };
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_start(set, wifi_handle));
+    TEST_ASSERT_EQUAL(ESP_OK, periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "[ * ] Event interface error : %d", ret);
+            continue;
+        }
+
+        /* Stop when the last pipeline element (tcp_stream_reader in this case) read stop event */
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) tcp_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
+            ESP_LOGW(TAG, "[ * ] Stop event received");
+            break;
+        }
+    }
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, tcp_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_stop_all(set));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tcp_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, esp_periph_set_destroy(set));
 }
\ No newline at end of file
diff --git a/components/audio_stream/test/tone_stream_test.c b/components/audio_stream/test/tone_stream_test.c
index 0a51e5e5..1facdcbf 100644
--- a/components/audio_stream/test/tone_stream_test.c
+++ b/components/audio_stream/test/tone_stream_test.c
@@ -1,146 +1,146 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-
-#include "unity.h"
-#include "esp_log.h"
-
-#include "audio_pipeline.h"
-#include "audio_mem.h"
-#include "audio_element.h"
-#include "audio_event_iface.h"
-#include "tone_stream.h"
-#include "fatfs_stream.h"
-
-#include "esp_peripherals.h"
-#include "board.h"
-
-const char* tone_uri[] = {
-   "flash://tone/0_Bt_Reconnect.mp3",
-   "flash://tone/1_Wechat.mp3",
-   "flash://tone/2_Welcome_To_Wifi.mp3",
-   "flash://tone/3_New_Version_Available.mp3",
-   "flash://tone/4_Bt_Success.mp3",
-   "flash://tone/5_Freetalk.mp3",
-   "flash://tone/6_Upgrade_Done.mp3",
-   "flash://tone/7_shutdown.mp3",
-   "flash://tone/8_Alarm.mp3",
-   "flash://tone/9_Wifi_Success.mp3",
-   "flash://tone/10_Under_Smartconfig.mp3",
-   "flash://tone/11_Out_Of_Power.mp3",
-   "flash://tone/12_server_connect.mp3",
-   "flash://tone/13_hello.mp3",
-   "flash://tone/14_new_message.mp3",
-   "flash://tone/15_Please_Retry_Wifi.mp3",
-   "flash://tone/16_please_setting_wifi.mp3",
-   "flash://tone/17_Welcome_To_Bt.mp3",
-   "flash://tone/18_Wifi_Time_Out.mp3",
-   "flash://tone/19_Wifi_Reconnect.mp3",
-   "flash://tone/20_server_disconnect.mp3",
-};
-
-#define TONE_URL_MAX		21
-
-TEST_CASE("tone stream init memory", "esp-adf-stream")
-{
-    audio_element_handle_t tone_stream_reader;
-    tone_stream_cfg_t tone_cfg = TONE_STREAM_CFG_DEFAULT();
-    tone_cfg.type = AUDIO_STREAM_READER;
-    
-    int cnt = 2000;
-    AUDIO_MEM_SHOW("BEFORE HTTP_STREAM_INIT MEMORY TEST");
-    while (cnt--) {
-        tone_stream_reader = tone_stream_init(&tone_cfg);
-        audio_element_deinit(tone_stream_reader);
-    }
-    AUDIO_MEM_SHOW("AFTER TONE_STREAM_INIT MEMORY TEST");
-}
-
-TEST_CASE("tone stream read test", "esp-adf-stream")
-{
-    audio_pipeline_handle_t pipeline;
-    audio_element_handle_t tone_stream_reader, fatfs_stream_writer;
-
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(pipeline);
-
-    tone_stream_cfg_t tone_cfg = TONE_STREAM_CFG_DEFAULT();
-    tone_cfg.type = AUDIO_STREAM_READER;
-    tone_stream_reader = tone_stream_init(&tone_cfg);
-    TEST_ASSERT_NOT_NULL(tone_stream_reader);
-
-    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
-    fatfs_cfg.type = AUDIO_STREAM_WRITER;
-    fatfs_stream_writer = fatfs_stream_init(&fatfs_cfg);
-    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, tone_stream_reader, "tone"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer, "fatfs"));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"tone", "fatfs"}, 2));
-
-    uint32_t tone_type = esp_random() % TONE_URL_MAX;
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(tone_stream_reader, tone_uri[tone_type]));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, "/sdcard/test.mp3"));
-
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-
-    while (1) {
-        audio_event_iface_msg_t msg = { 0 };
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            continue;
-        }
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) tone_stream_reader
-            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
-            break;
-        }
-    }
-
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, tone_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tone_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+
+#include "unity.h"
+#include "esp_log.h"
+
+#include "audio_pipeline.h"
+#include "audio_mem.h"
+#include "audio_element.h"
+#include "audio_event_iface.h"
+#include "tone_stream.h"
+#include "fatfs_stream.h"
+
+#include "esp_peripherals.h"
+#include "board.h"
+
+const char* tone_uri[] = {
+   "flash://tone/0_Bt_Reconnect.mp3",
+   "flash://tone/1_Wechat.mp3",
+   "flash://tone/2_Welcome_To_Wifi.mp3",
+   "flash://tone/3_New_Version_Available.mp3",
+   "flash://tone/4_Bt_Success.mp3",
+   "flash://tone/5_Freetalk.mp3",
+   "flash://tone/6_Upgrade_Done.mp3",
+   "flash://tone/7_shutdown.mp3",
+   "flash://tone/8_Alarm.mp3",
+   "flash://tone/9_Wifi_Success.mp3",
+   "flash://tone/10_Under_Smartconfig.mp3",
+   "flash://tone/11_Out_Of_Power.mp3",
+   "flash://tone/12_server_connect.mp3",
+   "flash://tone/13_hello.mp3",
+   "flash://tone/14_new_message.mp3",
+   "flash://tone/15_Please_Retry_Wifi.mp3",
+   "flash://tone/16_please_setting_wifi.mp3",
+   "flash://tone/17_Welcome_To_Bt.mp3",
+   "flash://tone/18_Wifi_Time_Out.mp3",
+   "flash://tone/19_Wifi_Reconnect.mp3",
+   "flash://tone/20_server_disconnect.mp3",
+};
+
+#define TONE_URL_MAX		21
+
+TEST_CASE("tone stream init memory", "esp-adf-stream")
+{
+    audio_element_handle_t tone_stream_reader;
+    tone_stream_cfg_t tone_cfg = TONE_STREAM_CFG_DEFAULT();
+    tone_cfg.type = AUDIO_STREAM_READER;
+    
+    int cnt = 2000;
+    AUDIO_MEM_SHOW("BEFORE HTTP_STREAM_INIT MEMORY TEST");
+    while (cnt--) {
+        tone_stream_reader = tone_stream_init(&tone_cfg);
+        audio_element_deinit(tone_stream_reader);
+    }
+    AUDIO_MEM_SHOW("AFTER TONE_STREAM_INIT MEMORY TEST");
+}
+
+TEST_CASE("tone stream read test", "esp-adf-stream")
+{
+    audio_pipeline_handle_t pipeline;
+    audio_element_handle_t tone_stream_reader, fatfs_stream_writer;
+
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_board_sdcard_init(set, SD_MODE_1_LINE));
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(pipeline);
+
+    tone_stream_cfg_t tone_cfg = TONE_STREAM_CFG_DEFAULT();
+    tone_cfg.type = AUDIO_STREAM_READER;
+    tone_stream_reader = tone_stream_init(&tone_cfg);
+    TEST_ASSERT_NOT_NULL(tone_stream_reader);
+
+    fatfs_stream_cfg_t fatfs_cfg = FATFS_STREAM_CFG_DEFAULT();
+    fatfs_cfg.type = AUDIO_STREAM_WRITER;
+    fatfs_stream_writer = fatfs_stream_init(&fatfs_cfg);
+    TEST_ASSERT_NOT_NULL(fatfs_stream_writer);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, tone_stream_reader, "tone"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_register(pipeline, fatfs_stream_writer, "fatfs"));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_link(pipeline, (const char *[]) {"tone", "fatfs"}, 2));
+
+    uint32_t tone_type = esp_random() % TONE_URL_MAX;
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(tone_stream_reader, tone_uri[tone_type]));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_set_uri(fatfs_stream_writer, "/sdcard/test.mp3"));
+
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_set_listener(pipeline, evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+
+    while (1) {
+        audio_event_iface_msg_t msg = { 0 };
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            continue;
+        }
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) tone_stream_reader
+            && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+            && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
+            break;
+        }
+    }
+
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_terminate(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, tone_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_unregister(pipeline, fatfs_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_remove_listener(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_event_iface_destroy(evt));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_deinit(pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(tone_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK, audio_element_deinit(fatfs_stream_writer));
 }
\ No newline at end of file
diff --git a/components/audio_stream/test/tts_stream_test.c b/components/audio_stream/test/tts_stream_test.c
index e7da20df..ff30dcdd 100644
--- a/components/audio_stream/test/tts_stream_test.c
+++ b/components/audio_stream/test/tts_stream_test.c
@@ -1,282 +1,282 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "unity.h"
-#include "esp_err.h"
-#include "esp_log.h"
-
-#include "audio_pipeline.h"
-#include "audio_mem.h"
-#include "tts_stream.h"
-#include "i2s_stream.h"
-
-#include "esp_peripherals.h"
-#include "board.h"
-
-static void init_tts_stream_test(audio_pipeline_handle_t *pipeline,
-                                    audio_element_handle_t *tts_stream_reader,
-                                    audio_element_handle_t *i2s_stream_writer,
-                                    esp_periph_set_handle_t *set)
-{
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    *set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(*set);
-
-    audio_board_handle_t board_handle = audio_board_init();
-    audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START);
-
-    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
-    *pipeline = audio_pipeline_init(&pipeline_cfg);
-    TEST_ASSERT_NOT_NULL(*pipeline);
-
-    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
-    tts_cfg.type = AUDIO_STREAM_READER;
-    *tts_stream_reader = tts_stream_init(&tts_cfg);
-    TEST_ASSERT_NOT_NULL(*tts_stream_reader);
-
-    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
-    i2s_cfg.type = AUDIO_STREAM_WRITER;
-    i2s_cfg.i2s_config.sample_rate = 16000;
-    i2s_cfg.i2s_config.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;
-    *i2s_stream_writer = i2s_stream_init(&i2s_cfg);
-    TEST_ASSERT_NOT_NULL(*i2s_stream_writer);
-
-    audio_pipeline_register(*pipeline, *tts_stream_reader, "tts");
-    audio_pipeline_register(*pipeline, *i2s_stream_writer, "i2s");
-    const char *link_tag[2] = {"tts", "i2s"};
-    audio_pipeline_link(*pipeline, &link_tag[0], 2);
-}
-
-static void init_audio_event_test(audio_pipeline_handle_t *pipeline,
-                                    esp_periph_set_handle_t *set,
-                                    audio_event_iface_handle_t *evt)
-{
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    *evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_set_listener(*pipeline, *evt));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_event_iface_set_listener(esp_periph_set_get_event_iface(*set), *evt));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_run(*pipeline));
-}
-
-static void deinit_tts_stream_test(audio_pipeline_handle_t *pipeline,
-                                    audio_element_handle_t *tts_stream_reader,
-                                    audio_element_handle_t *i2s_stream_writer,
-                                    esp_periph_set_handle_t *set,
-                                    audio_event_iface_handle_t *evt)
-{
-    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(*pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_terminate(*pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_unregister(*pipeline, *tts_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_unregister(*pipeline, *i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_remove_listener(*pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK,esp_periph_set_stop_all(*set));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_event_iface_remove_listener(esp_periph_set_get_event_iface(*set), *evt));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_event_iface_destroy(*evt));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_deinit(*pipeline));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_element_deinit(*tts_stream_reader));
-    TEST_ASSERT_EQUAL(ESP_OK,audio_element_deinit(*i2s_stream_writer));
-    TEST_ASSERT_EQUAL(ESP_OK,esp_periph_set_destroy(*set));
-}
-
-TEST_CASE("tts stream init and deinit memory", "[esp-adf-stream]")
-{
-    AUDIO_MEM_SHOW("TTS STREAM INIT AND DEINIT MEMORY");
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    audio_element_handle_t tts_stream_reader;
-    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
-    tts_cfg.type = AUDIO_STREAM_READER;
-    int cnt = 20;
-    AUDIO_MEM_SHOW("BEFORE TTS_STREAM_INIT MEMORY TEST");
-    while (cnt--) {
-        tts_stream_reader = tts_stream_init(&tts_cfg);
-
-        audio_element_deinit(tts_stream_reader);
-    }
-    AUDIO_MEM_SHOW("AFTER TTS_STREAM_INIT MEMORY TEST");
-}
-
-TEST_CASE("tts stream set and read strings", "[esp-adf-stream]")
-{
-    AUDIO_MEM_SHOW("TTS STREAM SET AND READ STRINGS");
-    static const char *STRINGS = "Σ╣ÉΘæ½Φ»¡Θƒ│σ╝Çµ║Éµíåµ₧╢τ«Çτº░ADF";
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    audio_element_handle_t tts_stream_reader;
-    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
-    tts_cfg.type = AUDIO_STREAM_READER;
-    tts_stream_reader = tts_stream_init(&tts_cfg);
-    tts_stream_set_strings(tts_stream_reader, STRINGS);
-    char *uri = audio_element_get_uri(tts_stream_reader);
-    TEST_ASSERT_EQUAL_STRING(STRINGS, uri);
-    audio_element_deinit(tts_stream_reader);
-}
-
-TEST_CASE("tts stream speed write and read test", "[esp-adf-stream]")
-{
-    AUDIO_MEM_SHOW("TTS STREAM SPEED WRITE AND READ TEST");
-    audio_element_handle_t tts_stream_reader;
-    tts_voice_speed_t speed;
-    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
-    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
-    tts_cfg.type = AUDIO_STREAM_READER;
-    tts_stream_reader = tts_stream_init(&tts_cfg);
-    TEST_ASSERT_NOT_NULL(tts_stream_reader);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_0));
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
-    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_0, speed);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_1));
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
-    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_1, speed);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_2));
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
-    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_2, speed);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_3));
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
-    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_3, speed);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_4));
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
-    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_4, speed);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_5));
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
-    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_5, speed);
-    audio_element_deinit(tts_stream_reader);
-}
-
-TEST_CASE("tts stream play a chinese string", "[esp-adf-stream]")
-{
-    AUDIO_MEM_SHOW("START PLAY A CHINESE STRING TEST");
-    audio_pipeline_handle_t pipeline = NULL;
-    audio_element_handle_t tts_stream_reader = NULL, i2s_stream_writer = NULL;
-    esp_periph_set_handle_t set = NULL;
-    audio_event_iface_handle_t evt = NULL;
-
-    init_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, "Σ╣ÉΘæ½µÅÉΣ╛¢σ«ëσà¿πÇüτ¿│σ«ÜπÇüΦèéΦâ╜τÜä AIoT Φºúσå│µû╣µíê"));
-    init_audio_event_test(&pipeline, &set, &evt);
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            continue;
-        }
-        /* Stop when the last pipeline element (i2s_stream_writer in this case) receives stop event */
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) i2s_stream_writer
-                && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-                && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
-                    break;
-        }
-    }
-    deinit_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set, &evt);
-}
-
-TEST_CASE("tts stream play multiple strings", "[esp-adf-stream]")
-{
-    AUDIO_MEM_SHOW("TTS STREAM PLAY MULTIPLE STRINGS");
-    static const char STRINGS[][80] = {
-        {"Σ╣ÉΘæ½τºæµèÇµÿ»Σ╕Çσ«╢σà¿τÉâσîûτÜäµùáµÖ╢σ£åσÄéσìèσ»╝Σ╜ôσà¼σÅ╕"},
-        {"σ£¿Σ╕¡σ¢╜πÇüµì╖σàïπÇüσì░σ║ªπÇüµû░σèáσ¥íσÆîσ╖┤ΦÑ┐σ¥çΦ«╛µ£ëσè₧σà¼σ£░"},
-        {"σ¢óΘÿƒµêÉσæÿµ¥ÑΦç¬σà¿Σ╕ûτòîτÜä 20 σñÜΣ╕¬σ¢╜σ«╢σÆîσ£░σî║"},
-    } ;
-
-    audio_pipeline_handle_t pipeline = NULL;
-    audio_element_handle_t tts_stream_reader = NULL, i2s_stream_writer = NULL;
-    esp_periph_set_handle_t set = NULL;
-    audio_event_iface_handle_t evt = NULL;
-
-    init_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, STRINGS));
-    init_audio_event_test(&pipeline, &set, &evt);
-
-    int cnt = 0;
-    while (1){
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            continue;
-        }
-        /* Stop when the last pipeline element (i2s_stream_writer in this case) receives stop event */
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) i2s_stream_writer
-                && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
-                && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))){
-                cnt ++;
-                if(cnt < (sizeof(STRINGS)/sizeof(STRINGS[0]))){
-                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_ringbuffer(pipeline));
-                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_elements(pipeline));
-                    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, (STRINGS + cnt)));
-                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_change_state(pipeline, AEL_STATE_INIT));
-                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-                }else{
-                    AUDIO_MEM_SHOW("ALL PLAY FINISHED");
-                    break;
-                }
-        }
-    }
-    deinit_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set, &evt);
-}
-
-TEST_CASE("tts stream play-stop and start new chainese string", "[esp-adf-stream]")
-{
-    AUDIO_MEM_SHOW("TTS STREAM PLAY-STOP AND START NEW CHAINESE STRING");
-    audio_pipeline_handle_t pipeline = NULL;
-    audio_element_handle_t tts_stream_reader = NULL, i2s_stream_writer = NULL;
-    esp_periph_set_handle_t set = NULL;
-    audio_event_iface_handle_t evt = NULL;
-
-    init_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set);
-    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, "τ¼¼Σ╕ÇΣ╕¬µ╡ïΦ»òτÜä tts Θƒ│Θóæµ╡ü"));
-    init_audio_event_test(&pipeline, &set, &evt);
-
-    bool play_once_flag = true;
-    while (1) {
-        audio_event_iface_msg_t msg;
-        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
-        if (ret != ESP_OK) {
-            continue;
-        }
-
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) tts_stream_reader){
-            if(((int)msg.data == AEL_STATUS_STATE_RUNNING) && (play_once_flag)){
-                play_once_flag = false;
-                vTaskDelay(1000);
-                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
-                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
-                TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(tts_stream_reader));
-                TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(i2s_stream_writer));
-                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_ringbuffer(pipeline));
-                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_items_state(pipeline));
-                TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, "σü£µ¡óτ¼¼Σ╕ÇΣ╕¬µÆ¡µö╛∩╝îσ╝Çσºïτ¼¼Σ║îΣ╕¬µ╡ïΦ»òτÜä tts Θƒ│ΘóæµÆ¡µö╛"));
-                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
-            }
-        }
-        /* Stop when the last pipeline element (i2s_stream_writer in this case) receives stop event */
-        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) i2s_stream_writer
-                && msg.cmd == AEL_MSG_CMD_REPORT_STATUS){
-                if(((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED)){
-                    AUDIO_MEM_SHOW("AEL_STATUS_STATE_FINISHED");
-                    break;
-                }
-        }
-    }
-    deinit_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set, &evt);
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "unity.h"
+#include "esp_err.h"
+#include "esp_log.h"
+
+#include "audio_pipeline.h"
+#include "audio_mem.h"
+#include "tts_stream.h"
+#include "i2s_stream.h"
+
+#include "esp_peripherals.h"
+#include "board.h"
+
+static void init_tts_stream_test(audio_pipeline_handle_t *pipeline,
+                                    audio_element_handle_t *tts_stream_reader,
+                                    audio_element_handle_t *i2s_stream_writer,
+                                    esp_periph_set_handle_t *set)
+{
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    *set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(*set);
+
+    audio_board_handle_t board_handle = audio_board_init();
+    audio_hal_ctrl_codec(board_handle->audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START);
+
+    audio_pipeline_cfg_t pipeline_cfg = DEFAULT_AUDIO_PIPELINE_CONFIG();
+    *pipeline = audio_pipeline_init(&pipeline_cfg);
+    TEST_ASSERT_NOT_NULL(*pipeline);
+
+    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
+    tts_cfg.type = AUDIO_STREAM_READER;
+    *tts_stream_reader = tts_stream_init(&tts_cfg);
+    TEST_ASSERT_NOT_NULL(*tts_stream_reader);
+
+    i2s_stream_cfg_t i2s_cfg = I2S_STREAM_CFG_DEFAULT();
+    i2s_cfg.type = AUDIO_STREAM_WRITER;
+    i2s_cfg.i2s_config.sample_rate = 16000;
+    i2s_cfg.i2s_config.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;
+    *i2s_stream_writer = i2s_stream_init(&i2s_cfg);
+    TEST_ASSERT_NOT_NULL(*i2s_stream_writer);
+
+    audio_pipeline_register(*pipeline, *tts_stream_reader, "tts");
+    audio_pipeline_register(*pipeline, *i2s_stream_writer, "i2s");
+    const char *link_tag[2] = {"tts", "i2s"};
+    audio_pipeline_link(*pipeline, &link_tag[0], 2);
+}
+
+static void init_audio_event_test(audio_pipeline_handle_t *pipeline,
+                                    esp_periph_set_handle_t *set,
+                                    audio_event_iface_handle_t *evt)
+{
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    *evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_set_listener(*pipeline, *evt));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_event_iface_set_listener(esp_periph_set_get_event_iface(*set), *evt));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_run(*pipeline));
+}
+
+static void deinit_tts_stream_test(audio_pipeline_handle_t *pipeline,
+                                    audio_element_handle_t *tts_stream_reader,
+                                    audio_element_handle_t *i2s_stream_writer,
+                                    esp_periph_set_handle_t *set,
+                                    audio_event_iface_handle_t *evt)
+{
+    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(*pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_terminate(*pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_unregister(*pipeline, *tts_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_unregister(*pipeline, *i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_remove_listener(*pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK,esp_periph_set_stop_all(*set));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_event_iface_remove_listener(esp_periph_set_get_event_iface(*set), *evt));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_event_iface_destroy(*evt));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_pipeline_deinit(*pipeline));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_element_deinit(*tts_stream_reader));
+    TEST_ASSERT_EQUAL(ESP_OK,audio_element_deinit(*i2s_stream_writer));
+    TEST_ASSERT_EQUAL(ESP_OK,esp_periph_set_destroy(*set));
+}
+
+TEST_CASE("tts stream init and deinit memory", "[esp-adf-stream]")
+{
+    AUDIO_MEM_SHOW("TTS STREAM INIT AND DEINIT MEMORY");
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    audio_element_handle_t tts_stream_reader;
+    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
+    tts_cfg.type = AUDIO_STREAM_READER;
+    int cnt = 20;
+    AUDIO_MEM_SHOW("BEFORE TTS_STREAM_INIT MEMORY TEST");
+    while (cnt--) {
+        tts_stream_reader = tts_stream_init(&tts_cfg);
+
+        audio_element_deinit(tts_stream_reader);
+    }
+    AUDIO_MEM_SHOW("AFTER TTS_STREAM_INIT MEMORY TEST");
+}
+
+TEST_CASE("tts stream set and read strings", "[esp-adf-stream]")
+{
+    AUDIO_MEM_SHOW("TTS STREAM SET AND READ STRINGS");
+    static const char *STRINGS = "Σ╣ÉΘæ½Φ»¡Θƒ│σ╝Çµ║Éµíåµ₧╢τ«Çτº░ADF";
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    audio_element_handle_t tts_stream_reader;
+    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
+    tts_cfg.type = AUDIO_STREAM_READER;
+    tts_stream_reader = tts_stream_init(&tts_cfg);
+    tts_stream_set_strings(tts_stream_reader, STRINGS);
+    char *uri = audio_element_get_uri(tts_stream_reader);
+    TEST_ASSERT_EQUAL_STRING(STRINGS, uri);
+    audio_element_deinit(tts_stream_reader);
+}
+
+TEST_CASE("tts stream speed write and read test", "[esp-adf-stream]")
+{
+    AUDIO_MEM_SHOW("TTS STREAM SPEED WRITE AND READ TEST");
+    audio_element_handle_t tts_stream_reader;
+    tts_voice_speed_t speed;
+    esp_log_level_set("AUDIO_ELEMENT", ESP_LOG_DEBUG);
+    tts_stream_cfg_t tts_cfg = TTS_STREAM_CFG_DEFAULT();
+    tts_cfg.type = AUDIO_STREAM_READER;
+    tts_stream_reader = tts_stream_init(&tts_cfg);
+    TEST_ASSERT_NOT_NULL(tts_stream_reader);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_0));
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
+    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_0, speed);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_1));
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
+    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_1, speed);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_2));
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
+    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_2, speed);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_3));
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
+    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_3, speed);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_4));
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
+    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_4, speed);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_speed(tts_stream_reader, TTS_VOICE_SPEED_5));
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_get_speed(tts_stream_reader, &speed));
+    TEST_ASSERT_EQUAL(TTS_VOICE_SPEED_5, speed);
+    audio_element_deinit(tts_stream_reader);
+}
+
+TEST_CASE("tts stream play a chinese string", "[esp-adf-stream]")
+{
+    AUDIO_MEM_SHOW("START PLAY A CHINESE STRING TEST");
+    audio_pipeline_handle_t pipeline = NULL;
+    audio_element_handle_t tts_stream_reader = NULL, i2s_stream_writer = NULL;
+    esp_periph_set_handle_t set = NULL;
+    audio_event_iface_handle_t evt = NULL;
+
+    init_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, "Σ╣ÉΘæ½µÅÉΣ╛¢σ«ëσà¿πÇüτ¿│σ«ÜπÇüΦèéΦâ╜τÜä AIoT Φºúσå│µû╣µíê"));
+    init_audio_event_test(&pipeline, &set, &evt);
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            continue;
+        }
+        /* Stop when the last pipeline element (i2s_stream_writer in this case) receives stop event */
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) i2s_stream_writer
+                && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+                && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))) {
+                    break;
+        }
+    }
+    deinit_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set, &evt);
+}
+
+TEST_CASE("tts stream play multiple strings", "[esp-adf-stream]")
+{
+    AUDIO_MEM_SHOW("TTS STREAM PLAY MULTIPLE STRINGS");
+    static const char STRINGS[][80] = {
+        {"Σ╣ÉΘæ½τºæµèÇµÿ»Σ╕Çσ«╢σà¿τÉâσîûτÜäµùáµÖ╢σ£åσÄéσìèσ»╝Σ╜ôσà¼σÅ╕"},
+        {"σ£¿Σ╕¡σ¢╜πÇüµì╖σàïπÇüσì░σ║ªπÇüµû░σèáσ¥íσÆîσ╖┤ΦÑ┐σ¥çΦ«╛µ£ëσè₧σà¼σ£░"},
+        {"σ¢óΘÿƒµêÉσæÿµ¥ÑΦç¬σà¿Σ╕ûτòîτÜä 20 σñÜΣ╕¬σ¢╜σ«╢σÆîσ£░σî║"},
+    } ;
+
+    audio_pipeline_handle_t pipeline = NULL;
+    audio_element_handle_t tts_stream_reader = NULL, i2s_stream_writer = NULL;
+    esp_periph_set_handle_t set = NULL;
+    audio_event_iface_handle_t evt = NULL;
+
+    init_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, STRINGS));
+    init_audio_event_test(&pipeline, &set, &evt);
+
+    int cnt = 0;
+    while (1){
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            continue;
+        }
+        /* Stop when the last pipeline element (i2s_stream_writer in this case) receives stop event */
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) i2s_stream_writer
+                && msg.cmd == AEL_MSG_CMD_REPORT_STATUS
+                && (((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED))){
+                cnt ++;
+                if(cnt < (sizeof(STRINGS)/sizeof(STRINGS[0]))){
+                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_ringbuffer(pipeline));
+                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_elements(pipeline));
+                    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, (STRINGS + cnt)));
+                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_change_state(pipeline, AEL_STATE_INIT));
+                    TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+                }else{
+                    AUDIO_MEM_SHOW("ALL PLAY FINISHED");
+                    break;
+                }
+        }
+    }
+    deinit_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set, &evt);
+}
+
+TEST_CASE("tts stream play-stop and start new chainese string", "[esp-adf-stream]")
+{
+    AUDIO_MEM_SHOW("TTS STREAM PLAY-STOP AND START NEW CHAINESE STRING");
+    audio_pipeline_handle_t pipeline = NULL;
+    audio_element_handle_t tts_stream_reader = NULL, i2s_stream_writer = NULL;
+    esp_periph_set_handle_t set = NULL;
+    audio_event_iface_handle_t evt = NULL;
+
+    init_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set);
+    TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, "τ¼¼Σ╕ÇΣ╕¬µ╡ïΦ»òτÜä tts Θƒ│Θóæµ╡ü"));
+    init_audio_event_test(&pipeline, &set, &evt);
+
+    bool play_once_flag = true;
+    while (1) {
+        audio_event_iface_msg_t msg;
+        esp_err_t ret = audio_event_iface_listen(evt, &msg, portMAX_DELAY);
+        if (ret != ESP_OK) {
+            continue;
+        }
+
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) tts_stream_reader){
+            if(((int)msg.data == AEL_STATUS_STATE_RUNNING) && (play_once_flag)){
+                play_once_flag = false;
+                vTaskDelay(1000);
+                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_stop(pipeline));
+                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_wait_for_stop(pipeline));
+                TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(tts_stream_reader));
+                TEST_ASSERT_EQUAL(ESP_OK, audio_element_reset_state(i2s_stream_writer));
+                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_ringbuffer(pipeline));
+                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_reset_items_state(pipeline));
+                TEST_ASSERT_EQUAL(ESP_OK, tts_stream_set_strings(tts_stream_reader, "σü£µ¡óτ¼¼Σ╕ÇΣ╕¬µÆ¡µö╛∩╝îσ╝Çσºïτ¼¼Σ║îΣ╕¬µ╡ïΦ»òτÜä tts Θƒ│ΘóæµÆ¡µö╛"));
+                TEST_ASSERT_EQUAL(ESP_OK, audio_pipeline_run(pipeline));
+            }
+        }
+        /* Stop when the last pipeline element (i2s_stream_writer in this case) receives stop event */
+        if (msg.source_type == AUDIO_ELEMENT_TYPE_ELEMENT && msg.source == (void *) i2s_stream_writer
+                && msg.cmd == AEL_MSG_CMD_REPORT_STATUS){
+                if(((int)msg.data == AEL_STATUS_STATE_STOPPED) || ((int)msg.data == AEL_STATUS_STATE_FINISHED)){
+                    AUDIO_MEM_SHOW("AEL_STATUS_STATE_FINISHED");
+                    break;
+                }
+        }
+    }
+    deinit_tts_stream_test(&pipeline, &tts_stream_reader, &i2s_stream_writer, &set, &evt);
+}
diff --git a/components/audio_stream/tone_stream.c b/components/audio_stream/tone_stream.c
index 157412fe..ab677521 100644
--- a/components/audio_stream/tone_stream.c
+++ b/components/audio_stream/tone_stream.c
@@ -1,200 +1,200 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-
-#include "esp_log.h"
-
-#include "audio_element.h"
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "tone_partition.h"
-#include "tone_stream.h"
-#include <inttypes.h>
-
-static const char *TAG = "TONE_STREAM";
-
-/**
- * @brief  Parameters of each tone
- */
-typedef struct tone_stream {
-    audio_stream_type_t type;            /*!< File operation type */
-    bool is_open;                        /*!< Tone stream status */
-    bool use_delegate;                   /*!< Tone read with delegate*/
-    tone_partition_handle_t tone_handle; /*!< Tone partition's operation handle*/
-    tone_file_info_t cur_file;           /*!< Address to read tone file */
-    const char *partition_label;         /*!< Label of tone stored in flash */
-} tone_stream_t;
-
-static esp_err_t _tone_open(audio_element_handle_t self)
-{
-    tone_stream_t *stream = (tone_stream_t *)audio_element_getdata(self);
-    if (stream->is_open) {
-        ESP_LOGE(TAG, "already opened");
-        return ESP_FAIL;
-    }
-    stream->tone_handle = tone_partition_init(stream->partition_label, stream->use_delegate);
-    if (stream->tone_handle == NULL) {
-        return ESP_FAIL;
-    }
-
-    char *flash_url = audio_element_get_uri(self);
-
-    flash_url += strlen("flash://tone/");
-    char *temp = strchr(flash_url, '_');
-    char find_num[2] = { 0 };
-    int file_index = 0;
-    if (temp != NULL) {
-        strncpy(find_num, flash_url, temp - flash_url);
-        file_index = strtoul(find_num, 0, 10);
-        ESP_LOGD(TAG, "Wanted read flash tone index is %d", file_index);
-    } else {
-        ESP_LOGE(TAG, "Tone file name is not correct!");
-        return ESP_FAIL;
-    }
-
-    tone_partition_get_file_info(stream->tone_handle, file_index, &stream->cur_file);
-    ESP_LOGI(TAG, "Tone offset:%08"PRIX32", Tone length:%"PRIu32", pos:%d\n", stream->cur_file.song_adr, stream->cur_file.song_len, file_index);
-    if (stream->cur_file.song_len <= 0) {
-        ESP_LOGE(TAG, "Mayebe the flash tone is empty, please ensure the flash's contex");
-        return ESP_FAIL;
-    }
-
-    audio_element_info_t info = { 0 };
-    info.total_bytes = stream->cur_file.song_len;
-    audio_element_setdata(self, stream);
-    audio_element_set_total_bytes(self, info.total_bytes);
-
-    stream->is_open = true;
-    return ESP_OK;
-}
-
-static int _tone_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    audio_element_info_t info = { 0 };
-    tone_stream_t *stream = NULL;
-
-    stream = (tone_stream_t *)audio_element_getdata(self);
-    audio_element_getinfo(self, &info);
-
-    if (info.byte_pos + len > info.total_bytes) {
-        len = info.total_bytes - info.byte_pos;
-    }
-    if (ESP_OK != tone_partition_file_read(stream->tone_handle, &stream->cur_file, info.byte_pos, buffer, len)) {
-        ESP_LOGE(TAG, "get tone data error, line:%d", __LINE__);
-        return ESP_FAIL;
-    }
-    if (len <= 0) {
-        ESP_LOGW(TAG, "No more data,ret:%d ,info.byte_pos:%llu", len, info.byte_pos);
-        return ESP_OK;
-    }
-    audio_element_update_byte_pos(self, len);
-
-    return len;
-}
-
-static int _tone_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _tone_close(audio_element_handle_t self)
-{
-    tone_stream_t *stream = (tone_stream_t *)audio_element_getdata(self);
-    if (stream->is_open) {
-        stream->is_open = false;
-    }
-    tone_partition_deinit(stream->tone_handle);
-    stream->tone_handle = NULL;
-    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
-        audio_element_set_byte_pos(self, 0);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _tone_destroy(audio_element_handle_t self)
-{
-    tone_stream_t *stream = (tone_stream_t *)audio_element_getdata(self);
-    audio_free(stream);
-    return ESP_OK;
-}
-
-audio_element_handle_t tone_stream_init(tone_stream_cfg_t *config)
-{
-    audio_element_handle_t el;
-    tone_stream_t *stream = audio_calloc(1, sizeof(tone_stream_t));
-
-    AUDIO_MEM_CHECK(TAG, stream, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _tone_open;
-    cfg.close = _tone_close;
-    cfg.process = _tone_process;
-    cfg.destroy = _tone_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.buffer_len = config->buf_sz;
-    cfg.stack_in_ext = config->extern_stack;
-    if (cfg.stack_in_ext == true && config->use_delegate == false) {
-        ESP_LOGE(TAG, "Tone stream must read flash with delegate when stack is allocate in external ram");
-        goto _tone_init_exit;
-    }
-    if (cfg.buffer_len == 0) {
-        cfg.buffer_len = TONE_STREAM_BUF_SIZE;
-    }
-    cfg.tag = "flash";
-    stream->type = config->type;
-    stream->use_delegate = config->use_delegate;
-
-    if (config->label == NULL) {
-        ESP_LOGE(TAG, "Please set your tone label");
-        return NULL;
-    } else {
-        stream->partition_label = config->label;
-    }
-    if (config->type == AUDIO_STREAM_READER) {
-        cfg.read = _tone_read;
-    } else if (config->type == AUDIO_STREAM_WRITER) {
-        ESP_LOGE(TAG, "No writer for tone stream");
-        goto _tone_init_exit;
-    }
-    el = audio_element_init(&cfg);
-
-    AUDIO_MEM_CHECK(TAG, el, goto _tone_init_exit);
-    audio_element_setdata(el, stream);
-    return el;
-_tone_init_exit:
-    audio_free(stream);
-    return NULL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "esp_log.h"
+
+#include "audio_element.h"
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "tone_partition.h"
+#include "tone_stream.h"
+#include <inttypes.h>
+
+static const char *TAG = "TONE_STREAM";
+
+/**
+ * @brief  Parameters of each tone
+ */
+typedef struct tone_stream {
+    audio_stream_type_t type;            /*!< File operation type */
+    bool is_open;                        /*!< Tone stream status */
+    bool use_delegate;                   /*!< Tone read with delegate*/
+    tone_partition_handle_t tone_handle; /*!< Tone partition's operation handle*/
+    tone_file_info_t cur_file;           /*!< Address to read tone file */
+    const char *partition_label;         /*!< Label of tone stored in flash */
+} tone_stream_t;
+
+static esp_err_t _tone_open(audio_element_handle_t self)
+{
+    tone_stream_t *stream = (tone_stream_t *)audio_element_getdata(self);
+    if (stream->is_open) {
+        ESP_LOGE(TAG, "already opened");
+        return ESP_FAIL;
+    }
+    stream->tone_handle = tone_partition_init(stream->partition_label, stream->use_delegate);
+    if (stream->tone_handle == NULL) {
+        return ESP_FAIL;
+    }
+
+    char *flash_url = audio_element_get_uri(self);
+
+    flash_url += strlen("flash://tone/");
+    char *temp = strchr(flash_url, '_');
+    char find_num[2] = { 0 };
+    int file_index = 0;
+    if (temp != NULL) {
+        strncpy(find_num, flash_url, temp - flash_url);
+        file_index = strtoul(find_num, 0, 10);
+        ESP_LOGD(TAG, "Wanted read flash tone index is %d", file_index);
+    } else {
+        ESP_LOGE(TAG, "Tone file name is not correct!");
+        return ESP_FAIL;
+    }
+
+    tone_partition_get_file_info(stream->tone_handle, file_index, &stream->cur_file);
+    ESP_LOGI(TAG, "Tone offset:%08"PRIX32", Tone length:%"PRIu32", pos:%d\n", stream->cur_file.song_adr, stream->cur_file.song_len, file_index);
+    if (stream->cur_file.song_len <= 0) {
+        ESP_LOGE(TAG, "Mayebe the flash tone is empty, please ensure the flash's contex");
+        return ESP_FAIL;
+    }
+
+    audio_element_info_t info = { 0 };
+    info.total_bytes = stream->cur_file.song_len;
+    audio_element_setdata(self, stream);
+    audio_element_set_total_bytes(self, info.total_bytes);
+
+    stream->is_open = true;
+    return ESP_OK;
+}
+
+static int _tone_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    audio_element_info_t info = { 0 };
+    tone_stream_t *stream = NULL;
+
+    stream = (tone_stream_t *)audio_element_getdata(self);
+    audio_element_getinfo(self, &info);
+
+    if (info.byte_pos + len > info.total_bytes) {
+        len = info.total_bytes - info.byte_pos;
+    }
+    if (ESP_OK != tone_partition_file_read(stream->tone_handle, &stream->cur_file, info.byte_pos, buffer, len)) {
+        ESP_LOGE(TAG, "get tone data error, line:%d", __LINE__);
+        return ESP_FAIL;
+    }
+    if (len <= 0) {
+        ESP_LOGW(TAG, "No more data,ret:%d ,info.byte_pos:%llu", len, info.byte_pos);
+        return ESP_OK;
+    }
+    audio_element_update_byte_pos(self, len);
+
+    return len;
+}
+
+static int _tone_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _tone_close(audio_element_handle_t self)
+{
+    tone_stream_t *stream = (tone_stream_t *)audio_element_getdata(self);
+    if (stream->is_open) {
+        stream->is_open = false;
+    }
+    tone_partition_deinit(stream->tone_handle);
+    stream->tone_handle = NULL;
+    if (AEL_STATE_PAUSED != audio_element_get_state(self)) {
+        audio_element_set_byte_pos(self, 0);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _tone_destroy(audio_element_handle_t self)
+{
+    tone_stream_t *stream = (tone_stream_t *)audio_element_getdata(self);
+    audio_free(stream);
+    return ESP_OK;
+}
+
+audio_element_handle_t tone_stream_init(tone_stream_cfg_t *config)
+{
+    audio_element_handle_t el;
+    tone_stream_t *stream = audio_calloc(1, sizeof(tone_stream_t));
+
+    AUDIO_MEM_CHECK(TAG, stream, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _tone_open;
+    cfg.close = _tone_close;
+    cfg.process = _tone_process;
+    cfg.destroy = _tone_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.buffer_len = config->buf_sz;
+    cfg.stack_in_ext = config->extern_stack;
+    if (cfg.stack_in_ext == true && config->use_delegate == false) {
+        ESP_LOGE(TAG, "Tone stream must read flash with delegate when stack is allocate in external ram");
+        goto _tone_init_exit;
+    }
+    if (cfg.buffer_len == 0) {
+        cfg.buffer_len = TONE_STREAM_BUF_SIZE;
+    }
+    cfg.tag = "flash";
+    stream->type = config->type;
+    stream->use_delegate = config->use_delegate;
+
+    if (config->label == NULL) {
+        ESP_LOGE(TAG, "Please set your tone label");
+        return NULL;
+    } else {
+        stream->partition_label = config->label;
+    }
+    if (config->type == AUDIO_STREAM_READER) {
+        cfg.read = _tone_read;
+    } else if (config->type == AUDIO_STREAM_WRITER) {
+        ESP_LOGE(TAG, "No writer for tone stream");
+        goto _tone_init_exit;
+    }
+    el = audio_element_init(&cfg);
+
+    AUDIO_MEM_CHECK(TAG, el, goto _tone_init_exit);
+    audio_element_setdata(el, stream);
+    return el;
+_tone_init_exit:
+    audio_free(stream);
+    return NULL;
+}
diff --git a/components/audio_stream/tts_stream.c b/components/audio_stream/tts_stream.c
index 4937de6e..89ef23d6 100644
--- a/components/audio_stream/tts_stream.c
+++ b/components/audio_stream/tts_stream.c
@@ -1,219 +1,219 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "tts_stream.h"
-#include "audio_mem.h"
-#include "esp_log.h"
-#include "esp_partition.h"
-#include "esp_tts_voice_template.h"
-#include "esp_idf_version.h"
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-#include "spi_flash_mmap.h"
-#endif
-
-static const char *TAG = "TTS_STREAM";
-
-#define TTS_MEM_CHECK(x, action) do { \
-    if (x) {                          \
-        action;                       \
-    }                                 \
-}while (0)
-
-/*  */
-typedef struct tts_stream {
-    audio_stream_type_t     type;
-    esp_tts_voice_t         *voice;
-    esp_tts_handle_t        *tts_handle;
-    char                    *prompt;
-    unsigned int            speed;
-    spi_flash_mmap_handle_t mmap;
-    bool is_open;
-} tts_stream_t;
-
-static esp_err_t _tts_stream_open(audio_element_handle_t self)
-{
-    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
-
-    tts_stream->is_open = false;
-    char *uri = audio_element_get_uri(self);
-    if (uri == NULL) {
-        ESP_LOGE(TAG, "The TTS string is not set");
-        return ESP_FAIL;
-    }
-
-    if (esp_tts_parse_chinese(tts_stream->tts_handle, uri)) {
-        tts_stream->is_open = true;
-        ESP_LOGW(TAG, "%s", uri);
-        return ESP_OK;
-    } else {
-        ESP_LOGE(TAG, "The Chinese string parse failed");
-    }
-    return ESP_FAIL;
-}
-
-static int _tts_stream_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
-{
-    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
-    int rlen = 0;
-    uint8_t *pcm_data = (uint8_t *)esp_tts_stream_play(tts_stream->tts_handle, &rlen, tts_stream->speed);
-    if (rlen <= 0) {
-        ESP_LOGW(TAG, "No more data,ret:%d", rlen);
-    } else {
-        memcpy(buffer, pcm_data, rlen << 1);
-        audio_element_update_byte_pos(self, rlen << 1);
-    }
-    return rlen << 1 ;
-}
-
-static int _tts_stream_process(audio_element_handle_t self, char *in_buffer, int in_len)
-{
-    int r_size = audio_element_input(self, in_buffer, in_len);
-    int w_size = 0;
-    if (r_size > 0) {
-        w_size = audio_element_output(self, in_buffer, r_size);
-    } else {
-        w_size = r_size;
-    }
-    return w_size;
-}
-
-static esp_err_t _tts_stream_close(audio_element_handle_t self)
-{
-    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
-    if (tts_stream->is_open) {
-        esp_tts_stream_reset(tts_stream->tts_handle);
-        tts_stream->is_open = false;
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _tts_stream_destroy(audio_element_handle_t self)
-{
-    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
-    spi_flash_munmap(tts_stream->mmap);
-    esp_tts_voice_set_free(tts_stream->voice);
-    esp_tts_destroy(tts_stream->tts_handle);
-    audio_free(tts_stream);
-    return ESP_OK;
-}
-
-esp_err_t tts_stream_set_strings(audio_element_handle_t el, const char *strings)
-{
-    return audio_element_set_uri(el, strings);
-}
-
-esp_err_t tts_stream_set_speed(audio_element_handle_t el, tts_voice_speed_t speed)
-{
-    if (speed > TTS_VOICE_SPEED_MAX) {
-        ESP_LOGE(TAG, "Invalid parameter, voice speed range is [0 - 5]");
-        return ESP_FAIL;
-    }
-    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(el);
-    tts_stream->speed = speed;
-    return ESP_OK;
-}
-
-esp_err_t tts_stream_get_speed(audio_element_handle_t el, tts_voice_speed_t *speed)
-{
-    if (speed == NULL) {
-        ESP_LOGE(TAG, "The speed parameter is NULL");
-        return ESP_FAIL;
-    }
-
-    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(el);
-    *speed = tts_stream->speed;
-    return ESP_OK;
-}
-
-audio_element_handle_t tts_stream_init(tts_stream_cfg_t *config)
-{
-    audio_element_handle_t el;
-    tts_stream_t *tts_stream = audio_calloc(1, sizeof(tts_stream_t));
-
-    AUDIO_MEM_CHECK(TAG, tts_stream, return NULL);
-
-    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
-    cfg.open = _tts_stream_open;
-    cfg.close = _tts_stream_close;
-    cfg.process = _tts_stream_process;
-    cfg.destroy = _tts_stream_destroy;
-    cfg.task_stack = config->task_stack;
-    cfg.task_prio = config->task_prio;
-    cfg.task_core = config->task_core;
-    cfg.out_rb_size = config->out_rb_size;
-    cfg.buffer_len = config->buf_sz;
-    cfg.stack_in_ext = config->ext_stack;
-    if (cfg.buffer_len == 0) {
-        cfg.buffer_len = TTS_STREAM_BUF_SIZE;
-    }
-
-    cfg.tag = "tts";
-    tts_stream->type = config->type;
-
-    const esp_partition_t *part = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, "voice_data");
-    AUDIO_MEM_CHECK(TAG, part, {
-        ESP_LOGE(TAG, "Couldn't find voice data partition!");
-        goto _tts_stream_init_exit;
-    });
-
-    void *voicedata = NULL;
-    esp_err_t err = ESP_OK;
-#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)
-    ESP_ERROR_CHECK(esp_partition_mmap(part, 0, part->size, ESP_PARTITION_MMAP_DATA, (const void **)&voicedata, &tts_stream->mmap));
-#else
-    ESP_ERROR_CHECK(esp_partition_mmap(part, 0, part->size, SPI_FLASH_MMAP_DATA, (const void **)&voicedata, &tts_stream->mmap));
-#endif
-    if (err != ESP_OK) {
-        ESP_LOGE(TAG, "Couldn't map voice data partition!");
-        goto _tts_stream_init_exit;
-    }
-
-    tts_stream->voice = esp_tts_voice_set_init(&esp_tts_voice_template, voicedata);
-    AUDIO_MEM_CHECK(TAG, tts_stream->voice, {
-        ESP_LOGE(TAG, "Couldn't init tts voice set!");
-        goto _tts_stream_init_exit;
-    });
-
-    tts_stream->tts_handle = esp_tts_create(tts_stream->voice);
-    AUDIO_MEM_CHECK(TAG, tts_stream->tts_handle, {
-        ESP_LOGE(TAG, "Couldn't create tts voice handle!");
-        goto _tts_stream_init_exit;
-    });
-
-    tts_stream->speed = TTS_VOICE_SPEED_3;
-    cfg.read = _tts_stream_read;
-    el = audio_element_init(&cfg);
-
-    AUDIO_MEM_CHECK(TAG, el, goto _tts_stream_init_exit);
-    audio_element_setdata(el, tts_stream);
-    return el;
-
-_tts_stream_init_exit:
-    TTS_MEM_CHECK(tts_stream->mmap, spi_flash_munmap(tts_stream->mmap));
-    TTS_MEM_CHECK(tts_stream->voice, esp_tts_voice_set_free(tts_stream->voice));
-    TTS_MEM_CHECK(tts_stream->tts_handle, esp_tts_destroy(tts_stream->tts_handle));
-    audio_free(tts_stream);
-    return NULL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "tts_stream.h"
+#include "audio_mem.h"
+#include "esp_log.h"
+#include "esp_partition.h"
+#include "esp_tts_voice_template.h"
+#include "esp_idf_version.h"
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+#include "spi_flash_mmap.h"
+#endif
+
+static const char *TAG = "TTS_STREAM";
+
+#define TTS_MEM_CHECK(x, action) do { \
+    if (x) {                          \
+        action;                       \
+    }                                 \
+}while (0)
+
+/*  */
+typedef struct tts_stream {
+    audio_stream_type_t     type;
+    esp_tts_voice_t         *voice;
+    esp_tts_handle_t        *tts_handle;
+    char                    *prompt;
+    unsigned int            speed;
+    spi_flash_mmap_handle_t mmap;
+    bool is_open;
+} tts_stream_t;
+
+static esp_err_t _tts_stream_open(audio_element_handle_t self)
+{
+    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
+
+    tts_stream->is_open = false;
+    char *uri = audio_element_get_uri(self);
+    if (uri == NULL) {
+        ESP_LOGE(TAG, "The TTS string is not set");
+        return ESP_FAIL;
+    }
+
+    if (esp_tts_parse_chinese(tts_stream->tts_handle, uri)) {
+        tts_stream->is_open = true;
+        ESP_LOGW(TAG, "%s", uri);
+        return ESP_OK;
+    } else {
+        ESP_LOGE(TAG, "The Chinese string parse failed");
+    }
+    return ESP_FAIL;
+}
+
+static int _tts_stream_read(audio_element_handle_t self, char *buffer, int len, TickType_t ticks_to_wait, void *context)
+{
+    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
+    int rlen = 0;
+    uint8_t *pcm_data = (uint8_t *)esp_tts_stream_play(tts_stream->tts_handle, &rlen, tts_stream->speed);
+    if (rlen <= 0) {
+        ESP_LOGW(TAG, "No more data,ret:%d", rlen);
+    } else {
+        memcpy(buffer, pcm_data, rlen << 1);
+        audio_element_update_byte_pos(self, rlen << 1);
+    }
+    return rlen << 1 ;
+}
+
+static int _tts_stream_process(audio_element_handle_t self, char *in_buffer, int in_len)
+{
+    int r_size = audio_element_input(self, in_buffer, in_len);
+    int w_size = 0;
+    if (r_size > 0) {
+        w_size = audio_element_output(self, in_buffer, r_size);
+    } else {
+        w_size = r_size;
+    }
+    return w_size;
+}
+
+static esp_err_t _tts_stream_close(audio_element_handle_t self)
+{
+    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
+    if (tts_stream->is_open) {
+        esp_tts_stream_reset(tts_stream->tts_handle);
+        tts_stream->is_open = false;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _tts_stream_destroy(audio_element_handle_t self)
+{
+    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(self);
+    spi_flash_munmap(tts_stream->mmap);
+    esp_tts_voice_set_free(tts_stream->voice);
+    esp_tts_destroy(tts_stream->tts_handle);
+    audio_free(tts_stream);
+    return ESP_OK;
+}
+
+esp_err_t tts_stream_set_strings(audio_element_handle_t el, const char *strings)
+{
+    return audio_element_set_uri(el, strings);
+}
+
+esp_err_t tts_stream_set_speed(audio_element_handle_t el, tts_voice_speed_t speed)
+{
+    if (speed > TTS_VOICE_SPEED_MAX) {
+        ESP_LOGE(TAG, "Invalid parameter, voice speed range is [0 - 5]");
+        return ESP_FAIL;
+    }
+    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(el);
+    tts_stream->speed = speed;
+    return ESP_OK;
+}
+
+esp_err_t tts_stream_get_speed(audio_element_handle_t el, tts_voice_speed_t *speed)
+{
+    if (speed == NULL) {
+        ESP_LOGE(TAG, "The speed parameter is NULL");
+        return ESP_FAIL;
+    }
+
+    tts_stream_t *tts_stream = (tts_stream_t *)audio_element_getdata(el);
+    *speed = tts_stream->speed;
+    return ESP_OK;
+}
+
+audio_element_handle_t tts_stream_init(tts_stream_cfg_t *config)
+{
+    audio_element_handle_t el;
+    tts_stream_t *tts_stream = audio_calloc(1, sizeof(tts_stream_t));
+
+    AUDIO_MEM_CHECK(TAG, tts_stream, return NULL);
+
+    audio_element_cfg_t cfg = DEFAULT_AUDIO_ELEMENT_CONFIG();
+    cfg.open = _tts_stream_open;
+    cfg.close = _tts_stream_close;
+    cfg.process = _tts_stream_process;
+    cfg.destroy = _tts_stream_destroy;
+    cfg.task_stack = config->task_stack;
+    cfg.task_prio = config->task_prio;
+    cfg.task_core = config->task_core;
+    cfg.out_rb_size = config->out_rb_size;
+    cfg.buffer_len = config->buf_sz;
+    cfg.stack_in_ext = config->ext_stack;
+    if (cfg.buffer_len == 0) {
+        cfg.buffer_len = TTS_STREAM_BUF_SIZE;
+    }
+
+    cfg.tag = "tts";
+    tts_stream->type = config->type;
+
+    const esp_partition_t *part = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, "voice_data");
+    AUDIO_MEM_CHECK(TAG, part, {
+        ESP_LOGE(TAG, "Couldn't find voice data partition!");
+        goto _tts_stream_init_exit;
+    });
+
+    void *voicedata = NULL;
+    esp_err_t err = ESP_OK;
+#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)
+    ESP_ERROR_CHECK(esp_partition_mmap(part, 0, part->size, ESP_PARTITION_MMAP_DATA, (const void **)&voicedata, &tts_stream->mmap));
+#else
+    ESP_ERROR_CHECK(esp_partition_mmap(part, 0, part->size, SPI_FLASH_MMAP_DATA, (const void **)&voicedata, &tts_stream->mmap));
+#endif
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG, "Couldn't map voice data partition!");
+        goto _tts_stream_init_exit;
+    }
+
+    tts_stream->voice = esp_tts_voice_set_init(&esp_tts_voice_template, voicedata);
+    AUDIO_MEM_CHECK(TAG, tts_stream->voice, {
+        ESP_LOGE(TAG, "Couldn't init tts voice set!");
+        goto _tts_stream_init_exit;
+    });
+
+    tts_stream->tts_handle = esp_tts_create(tts_stream->voice);
+    AUDIO_MEM_CHECK(TAG, tts_stream->tts_handle, {
+        ESP_LOGE(TAG, "Couldn't create tts voice handle!");
+        goto _tts_stream_init_exit;
+    });
+
+    tts_stream->speed = TTS_VOICE_SPEED_3;
+    cfg.read = _tts_stream_read;
+    el = audio_element_init(&cfg);
+
+    AUDIO_MEM_CHECK(TAG, el, goto _tts_stream_init_exit);
+    audio_element_setdata(el, tts_stream);
+    return el;
+
+_tts_stream_init_exit:
+    TTS_MEM_CHECK(tts_stream->mmap, spi_flash_munmap(tts_stream->mmap));
+    TTS_MEM_CHECK(tts_stream->voice, esp_tts_voice_set_free(tts_stream->voice));
+    TTS_MEM_CHECK(tts_stream->tts_handle, esp_tts_destroy(tts_stream->tts_handle));
+    audio_free(tts_stream);
+    return NULL;
+}
diff --git a/components/battery_service/CMakeLists.txt b/components/battery_service/CMakeLists.txt
index b9c2ca1c..6b3aae24 100644
--- a/components/battery_service/CMakeLists.txt
+++ b/components/battery_service/CMakeLists.txt
@@ -1,18 +1,18 @@
-set(idf_version "${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}")
-
-set(COMPONENT_SRCS "battery_service.c"
-                    "./monitors/voltage_monitor.c")
-
-set(COMPONENT_ADD_INCLUDEDIRS "include"
-                                "./monitors/include")
-
-set(COMPONENT_REQUIRES  audio_sal esp_peripherals)
-
-if (idf_version VERSION_GREATER_EQUAL "5.0")
-list(APPEND COMPONENT_PRIV_REQUIRES esp_adc)
-list(APPEND COMPONENT_REQUIRES esp_timer)
-else()
-list(APPEND COMPONENT_PRIV_REQUIRES esp_adc_cal)
-endif()
-
-register_component()
+set(idf_version "${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}")
+
+set(COMPONENT_SRCS "battery_service.c"
+                    "./monitors/voltage_monitor.c")
+
+set(COMPONENT_ADD_INCLUDEDIRS "include"
+                                "./monitors/include")
+
+set(COMPONENT_REQUIRES  audio_sal esp_peripherals)
+
+if (idf_version VERSION_GREATER_EQUAL "5.0")
+list(APPEND COMPONENT_PRIV_REQUIRES esp_adc)
+list(APPEND COMPONENT_REQUIRES esp_timer)
+else()
+list(APPEND COMPONENT_PRIV_REQUIRES esp_adc_cal)
+endif()
+
+register_component()
diff --git a/components/battery_service/battery_service.c b/components/battery_service/battery_service.c
index 222433ae..03c5f96c 100644
--- a/components/battery_service/battery_service.c
+++ b/components/battery_service/battery_service.c
@@ -1,315 +1,315 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/semphr.h"
-#include "freertos/queue.h"
-#include "freertos/event_groups.h"
-
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "audio_sys.h"
-#include "battery_service.h"
-
-typedef struct battery_service {
-    xQueueHandle serv_q;
-    EventGroupHandle_t sync_events;
-
-    vol_monitor_handle_t vol_monitor;
-
-    bool running;
-} battery_service_t;
-
-typedef struct battery_cmd {
-    enum battery_service_msg {
-        /* battery service ctrl */
-        BATTERY_SERVICE_START,
-        BATTERY_SERVICE_STOP,
-        BATTERY_SERVICE_DESTROY,
-
-        /* battery voltage monitor ctrl */
-        BATTERY_VOL_SET_REPORT_FREQ,
-        BATTERY_VOL_REPORT_START,
-        BATTERY_VOL_REPORT_STOP,
-        BATTERY_VOL_REPORT_FREQ,
-        BATTERY_VOL_REPORT_FULL,
-        BATTERY_VOL_REPORT_LOW,
-
-        /* battery charger monitor ctrl - todo*/
-    } msg_id;
-    void *pdata;
-} battery_msg_t;
-
-#define BATTERY_SERV_SYNC_STARTED   (BIT0)
-#define BATTERY_SERV_SYNC_STOPPED   (BIT1)
-#define BATTERY_SERV_SYNC_DESTROYED (BIT2)
-
-static const char *TAG = "BATTERY_SERVICE";
-
-static esp_err_t battery_service_msg_send(void *queue, int msg_id, void *pdata)
-{
-    battery_msg_t msg = { 0 };
-    msg.msg_id = msg_id;
-    msg.pdata = pdata;
-
-    if (xQueueSend(queue, &msg, 0) != pdPASS) {
-        ESP_LOGE(TAG, "msg send failed %d", msg.msg_id);
-        return ESP_FAIL;
-    }
-
-    return ESP_OK;
-}
-
-static void battery_vol_monitor_cb(int msg, void *msg_data, void *user_ctx)
-{
-    switch (msg) {
-        case VOL_MONITOR_EVENT_FREQ_REPORT:
-            battery_service_msg_send(user_ctx, BATTERY_VOL_REPORT_FREQ, msg_data);
-            break;
-        case VOL_MONITOR_EVENT_BAT_FULL:
-            battery_service_msg_send(user_ctx, BATTERY_VOL_REPORT_FULL, msg_data);
-            break;
-        case VOL_MONITOR_EVENT_BAT_LOW:
-            battery_service_msg_send(user_ctx, BATTERY_VOL_REPORT_LOW, msg_data);
-            break;
-        default:
-            break;
-    }
-}
-
-static void battery_task(void *pvParameters)
-{
-    periph_service_handle_t serv_handle = (periph_service_handle_t)pvParameters;
-    battery_service_t *service = periph_service_get_data(serv_handle);
-    periph_service_event_t evt = { 0 };
-    battery_msg_t msg = { 0 };
-
-    service->running = true;
-    while (service->running) {
-        if (xQueueReceive(service->serv_q, &msg, portMAX_DELAY) == pdTRUE) {
-            switch (msg.msg_id) {
-                case BATTERY_SERVICE_START: {
-                    if (service->vol_monitor != NULL && vol_monitor_set_event_cb(service->vol_monitor, battery_vol_monitor_cb, service->serv_q) == ESP_OK) {
-                        xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_STARTED);
-                    } else {
-                        xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_STOPPED);
-                    }
-                    break;
-                }
-                case BATTERY_SERVICE_DESTROY:
-                    service->running = false;
-                    FALL_THROUGH;
-                    // No break, to share the actions of case `BATTERY_SERVICE_STOP`, clear all the monitors.
-                case BATTERY_SERVICE_STOP: {
-                    if (service->vol_monitor != NULL) {
-                        vol_monitor_set_event_cb(service->vol_monitor, NULL, NULL);
-                    }
-                    xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_STOPPED);
-                    break;
-                }
-                /* battery voltage monitor ctrl begin */
-                case BATTERY_VOL_SET_REPORT_FREQ: {
-                    if (service->vol_monitor != NULL) {
-                        vol_monitor_set_report_freq(service->vol_monitor, (int)msg.pdata);
-                    }
-                    break;
-                }
-                case BATTERY_VOL_REPORT_START:
-                    if (service->vol_monitor != NULL) {
-                        vol_monitor_start_freq_report(service->vol_monitor);
-                    }
-                    break;
-                case BATTERY_VOL_REPORT_STOP:
-                    if (service->vol_monitor != NULL) {
-                        vol_monitor_stop_freq_report(service->vol_monitor);
-                    }
-                    break;
-                case BATTERY_VOL_REPORT_FREQ: {
-                    evt.type = BAT_SERV_EVENT_VOL_REPORT;
-                    evt.data = msg.pdata;
-                    periph_service_callback(serv_handle, &evt);
-                    break;
-                }
-                case BATTERY_VOL_REPORT_FULL: {
-                    evt.type = BAT_SERV_EVENT_BAT_FULL;
-                    evt.data = msg.pdata;
-                    periph_service_callback(serv_handle, &evt);
-                    break;
-                }
-                case BATTERY_VOL_REPORT_LOW: {
-                    evt.type = BAT_SERV_EVENT_BAT_LOW;
-                    evt.data = msg.pdata;
-                    periph_service_callback(serv_handle, &evt);
-                    break;
-                }
-                /* battery voltage monitor ctrl end */
-                default:
-                    break;
-            }
-        }
-    }
-
-    xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_DESTROYED);
-    ESP_LOGI(TAG, "battery service destroyed");
-    vTaskDelete(NULL);
-}
-
-static esp_err_t _battery_destroy(periph_service_handle_t handle)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    battery_service_t *service = periph_service_get_data(handle);
-    battery_service_msg_send(service->serv_q, BATTERY_SERVICE_DESTROY, NULL);
-
-    EventBits_t bits = xEventGroupWaitBits(service->sync_events,
-        BATTERY_SERV_SYNC_DESTROYED,
-        true,
-        true,
-        pdMS_TO_TICKS(10000));
-    if (bits & BATTERY_SERV_SYNC_DESTROYED) {
-        if (service->serv_q) {
-            vQueueDelete(service->serv_q);
-        }
-        if (service->sync_events) {
-            vEventGroupDelete(service->sync_events);
-        }
-        free(service);
-
-        return ESP_OK;
-    } else {
-        return ESP_FAIL;
-    }
-}
-
-static esp_err_t _battery_start(periph_service_handle_t handle)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    battery_service_t *service = periph_service_get_data(handle);
-    battery_service_msg_send(service->serv_q, BATTERY_SERVICE_START, NULL);
-
-    EventBits_t bits = xEventGroupWaitBits(service->sync_events,
-        BATTERY_SERV_SYNC_STARTED | BATTERY_SERV_SYNC_STOPPED,
-        true,
-        false,
-        portMAX_DELAY);
-    if (bits & BATTERY_SERV_SYNC_STARTED) {
-        return ESP_OK;
-    } else {
-        return ESP_FAIL;
-    }
-}
-
-static esp_err_t _battery_stop(periph_service_handle_t handle)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    battery_service_t *service = periph_service_get_data(handle);
-    battery_service_msg_send(service->serv_q, BATTERY_SERVICE_STOP, NULL);
-
-    EventBits_t bits = xEventGroupWaitBits(service->sync_events,
-        BATTERY_SERV_SYNC_STOPPED,
-        true,
-        true,
-        portMAX_DELAY);
-    if (bits & BATTERY_SERV_SYNC_STOPPED) {
-        return ESP_OK;
-    } else {
-        return ESP_FAIL;
-    }
-}
-
-periph_service_handle_t battery_service_create(battery_service_config_t *config)
-{
-    AUDIO_NULL_CHECK(TAG, config, return NULL);
-    AUDIO_CHECK(TAG, config->task_stack > 0, return NULL, "battery service should set the task_stack");
-
-    battery_service_t *battery_service = audio_calloc(1, sizeof(battery_service_t));
-    AUDIO_MEM_CHECK(TAG, battery_service, return NULL);
-
-    battery_service->serv_q = xQueueCreate(3, sizeof(battery_msg_t));
-    AUDIO_MEM_CHECK(TAG, battery_service->serv_q, {
-        goto err;
-    });
-    battery_service->sync_events = xEventGroupCreate();
-    AUDIO_MEM_CHECK(TAG, battery_service->sync_events, {
-        goto err;
-    });
-
-    battery_service->vol_monitor = config->vol_monitor;
-
-    periph_service_config_t cfg = {
-        .task_stack = config->task_stack,
-        .task_prio = config->task_prio,
-        .task_core = config->task_core,
-        .extern_stack = config->extern_stack,
-        .task_func = battery_task,
-        .service_start = _battery_start,
-        .service_stop = _battery_stop,
-        .service_ioctl = NULL,
-        .service_destroy = _battery_destroy,
-        .service_name = "battery_serv",
-        .user_data = (void *)battery_service,
-    };
-
-    periph_service_handle_t battery = periph_service_create(&cfg);
-    AUDIO_MEM_CHECK(TAG, battery, {
-        goto err;
-    });
-    periph_service_set_callback(battery, config->evt_cb, config->cb_ctx);
-
-    return battery;
-
-err:
-    if (battery_service && battery_service->serv_q) {
-        vQueueDelete(battery_service->serv_q);
-    }
-    if (battery_service && battery_service->sync_events) {
-        vEventGroupDelete(battery_service->sync_events);
-    }
-    if (battery_service) {
-        free(battery_service);
-    }
-    return NULL;
-}
-
-esp_err_t battery_service_vol_report_switch(periph_service_handle_t handle, bool on_off)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    battery_service_t *service = periph_service_get_data(handle);
-    if (on_off) {
-        battery_service_msg_send(service->serv_q, BATTERY_VOL_REPORT_START, NULL);
-    } else {
-        battery_service_msg_send(service->serv_q, BATTERY_VOL_REPORT_STOP, NULL);
-    }
-    return ESP_OK;
-}
-
-esp_err_t battery_service_set_vol_report_freq(periph_service_handle_t handle, int freq)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    battery_service_t *service = periph_service_get_data(handle);
-
-    battery_service_msg_send(service->serv_q, BATTERY_VOL_SET_REPORT_FREQ, (void *)freq);
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/semphr.h"
+#include "freertos/queue.h"
+#include "freertos/event_groups.h"
+
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "audio_sys.h"
+#include "battery_service.h"
+
+typedef struct battery_service {
+    QueueHandle_t serv_q;
+    EventGroupHandle_t sync_events;
+
+    vol_monitor_handle_t vol_monitor;
+
+    bool running;
+} battery_service_t;
+
+typedef struct battery_cmd {
+    enum battery_service_msg {
+        /* battery service ctrl */
+        BATTERY_SERVICE_START,
+        BATTERY_SERVICE_STOP,
+        BATTERY_SERVICE_DESTROY,
+
+        /* battery voltage monitor ctrl */
+        BATTERY_VOL_SET_REPORT_FREQ,
+        BATTERY_VOL_REPORT_START,
+        BATTERY_VOL_REPORT_STOP,
+        BATTERY_VOL_REPORT_FREQ,
+        BATTERY_VOL_REPORT_FULL,
+        BATTERY_VOL_REPORT_LOW,
+
+        /* battery charger monitor ctrl - todo*/
+    } msg_id;
+    void *pdata;
+} battery_msg_t;
+
+#define BATTERY_SERV_SYNC_STARTED   (BIT0)
+#define BATTERY_SERV_SYNC_STOPPED   (BIT1)
+#define BATTERY_SERV_SYNC_DESTROYED (BIT2)
+
+static const char *TAG = "BATTERY_SERVICE";
+
+static esp_err_t battery_service_msg_send(void *queue, int msg_id, void *pdata)
+{
+    battery_msg_t msg = { 0 };
+    msg.msg_id = msg_id;
+    msg.pdata = pdata;
+
+    if (xQueueSend(queue, &msg, 0) != pdPASS) {
+        ESP_LOGE(TAG, "msg send failed %d", msg.msg_id);
+        return ESP_FAIL;
+    }
+
+    return ESP_OK;
+}
+
+static void battery_vol_monitor_cb(int msg, void *msg_data, void *user_ctx)
+{
+    switch (msg) {
+        case VOL_MONITOR_EVENT_FREQ_REPORT:
+            battery_service_msg_send(user_ctx, BATTERY_VOL_REPORT_FREQ, msg_data);
+            break;
+        case VOL_MONITOR_EVENT_BAT_FULL:
+            battery_service_msg_send(user_ctx, BATTERY_VOL_REPORT_FULL, msg_data);
+            break;
+        case VOL_MONITOR_EVENT_BAT_LOW:
+            battery_service_msg_send(user_ctx, BATTERY_VOL_REPORT_LOW, msg_data);
+            break;
+        default:
+            break;
+    }
+}
+
+static void battery_task(void *pvParameters)
+{
+    periph_service_handle_t serv_handle = (periph_service_handle_t)pvParameters;
+    battery_service_t *service = periph_service_get_data(serv_handle);
+    periph_service_event_t evt = { 0 };
+    battery_msg_t msg = { 0 };
+
+    service->running = true;
+    while (service->running) {
+        if (xQueueReceive(service->serv_q, &msg, portMAX_DELAY) == pdTRUE) {
+            switch (msg.msg_id) {
+                case BATTERY_SERVICE_START: {
+                    if (service->vol_monitor != NULL && vol_monitor_set_event_cb(service->vol_monitor, battery_vol_monitor_cb, service->serv_q) == ESP_OK) {
+                        xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_STARTED);
+                    } else {
+                        xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_STOPPED);
+                    }
+                    break;
+                }
+                case BATTERY_SERVICE_DESTROY:
+                    service->running = false;
+                    FALL_THROUGH;
+                    // No break, to share the actions of case `BATTERY_SERVICE_STOP`, clear all the monitors.
+                case BATTERY_SERVICE_STOP: {
+                    if (service->vol_monitor != NULL) {
+                        vol_monitor_set_event_cb(service->vol_monitor, NULL, NULL);
+                    }
+                    xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_STOPPED);
+                    break;
+                }
+                /* battery voltage monitor ctrl begin */
+                case BATTERY_VOL_SET_REPORT_FREQ: {
+                    if (service->vol_monitor != NULL) {
+                        vol_monitor_set_report_freq(service->vol_monitor, (int)msg.pdata);
+                    }
+                    break;
+                }
+                case BATTERY_VOL_REPORT_START:
+                    if (service->vol_monitor != NULL) {
+                        vol_monitor_start_freq_report(service->vol_monitor);
+                    }
+                    break;
+                case BATTERY_VOL_REPORT_STOP:
+                    if (service->vol_monitor != NULL) {
+                        vol_monitor_stop_freq_report(service->vol_monitor);
+                    }
+                    break;
+                case BATTERY_VOL_REPORT_FREQ: {
+                    evt.type = BAT_SERV_EVENT_VOL_REPORT;
+                    evt.data = msg.pdata;
+                    periph_service_callback(serv_handle, &evt);
+                    break;
+                }
+                case BATTERY_VOL_REPORT_FULL: {
+                    evt.type = BAT_SERV_EVENT_BAT_FULL;
+                    evt.data = msg.pdata;
+                    periph_service_callback(serv_handle, &evt);
+                    break;
+                }
+                case BATTERY_VOL_REPORT_LOW: {
+                    evt.type = BAT_SERV_EVENT_BAT_LOW;
+                    evt.data = msg.pdata;
+                    periph_service_callback(serv_handle, &evt);
+                    break;
+                }
+                /* battery voltage monitor ctrl end */
+                default:
+                    break;
+            }
+        }
+    }
+
+    xEventGroupSetBits(service->sync_events, BATTERY_SERV_SYNC_DESTROYED);
+    ESP_LOGI(TAG, "battery service destroyed");
+    vTaskDelete(NULL);
+}
+
+static esp_err_t _battery_destroy(periph_service_handle_t handle)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    battery_service_t *service = periph_service_get_data(handle);
+    battery_service_msg_send(service->serv_q, BATTERY_SERVICE_DESTROY, NULL);
+
+    EventBits_t bits = xEventGroupWaitBits(service->sync_events,
+        BATTERY_SERV_SYNC_DESTROYED,
+        true,
+        true,
+        pdMS_TO_TICKS(10000));
+    if (bits & BATTERY_SERV_SYNC_DESTROYED) {
+        if (service->serv_q) {
+            vQueueDelete(service->serv_q);
+        }
+        if (service->sync_events) {
+            vEventGroupDelete(service->sync_events);
+        }
+        free(service);
+
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
+
+static esp_err_t _battery_start(periph_service_handle_t handle)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    battery_service_t *service = periph_service_get_data(handle);
+    battery_service_msg_send(service->serv_q, BATTERY_SERVICE_START, NULL);
+
+    EventBits_t bits = xEventGroupWaitBits(service->sync_events,
+        BATTERY_SERV_SYNC_STARTED | BATTERY_SERV_SYNC_STOPPED,
+        true,
+        false,
+        portMAX_DELAY);
+    if (bits & BATTERY_SERV_SYNC_STARTED) {
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
+
+static esp_err_t _battery_stop(periph_service_handle_t handle)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    battery_service_t *service = periph_service_get_data(handle);
+    battery_service_msg_send(service->serv_q, BATTERY_SERVICE_STOP, NULL);
+
+    EventBits_t bits = xEventGroupWaitBits(service->sync_events,
+        BATTERY_SERV_SYNC_STOPPED,
+        true,
+        true,
+        portMAX_DELAY);
+    if (bits & BATTERY_SERV_SYNC_STOPPED) {
+        return ESP_OK;
+    } else {
+        return ESP_FAIL;
+    }
+}
+
+periph_service_handle_t battery_service_create(battery_service_config_t *config)
+{
+    AUDIO_NULL_CHECK(TAG, config, return NULL);
+    AUDIO_CHECK(TAG, config->task_stack > 0, return NULL, "battery service should set the task_stack");
+
+    battery_service_t *battery_service = audio_calloc(1, sizeof(battery_service_t));
+    AUDIO_MEM_CHECK(TAG, battery_service, return NULL);
+
+    battery_service->serv_q = xQueueCreate(3, sizeof(battery_msg_t));
+    AUDIO_MEM_CHECK(TAG, battery_service->serv_q, {
+        goto err;
+    });
+    battery_service->sync_events = xEventGroupCreate();
+    AUDIO_MEM_CHECK(TAG, battery_service->sync_events, {
+        goto err;
+    });
+
+    battery_service->vol_monitor = config->vol_monitor;
+
+    periph_service_config_t cfg = {
+        .task_stack = config->task_stack,
+        .task_prio = config->task_prio,
+        .task_core = config->task_core,
+        .extern_stack = config->extern_stack,
+        .task_func = battery_task,
+        .service_start = _battery_start,
+        .service_stop = _battery_stop,
+        .service_ioctl = NULL,
+        .service_destroy = _battery_destroy,
+        .service_name = "battery_serv",
+        .user_data = (void *)battery_service,
+    };
+
+    periph_service_handle_t battery = periph_service_create(&cfg);
+    AUDIO_MEM_CHECK(TAG, battery, {
+        goto err;
+    });
+    periph_service_set_callback(battery, config->evt_cb, config->cb_ctx);
+
+    return battery;
+
+err:
+    if (battery_service && battery_service->serv_q) {
+        vQueueDelete(battery_service->serv_q);
+    }
+    if (battery_service && battery_service->sync_events) {
+        vEventGroupDelete(battery_service->sync_events);
+    }
+    if (battery_service) {
+        free(battery_service);
+    }
+    return NULL;
+}
+
+esp_err_t battery_service_vol_report_switch(periph_service_handle_t handle, bool on_off)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    battery_service_t *service = periph_service_get_data(handle);
+    if (on_off) {
+        battery_service_msg_send(service->serv_q, BATTERY_VOL_REPORT_START, NULL);
+    } else {
+        battery_service_msg_send(service->serv_q, BATTERY_VOL_REPORT_STOP, NULL);
+    }
+    return ESP_OK;
+}
+
+esp_err_t battery_service_set_vol_report_freq(periph_service_handle_t handle, int freq)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    battery_service_t *service = periph_service_get_data(handle);
+
+    battery_service_msg_send(service->serv_q, BATTERY_VOL_SET_REPORT_FREQ, (void *)freq);
+    return ESP_OK;
+}
diff --git a/components/battery_service/component.mk b/components/battery_service/component.mk
index ce57ebbc..f8cbe60c 100644
--- a/components/battery_service/component.mk
+++ b/components/battery_service/component.mk
@@ -1,8 +1,8 @@
-#
-# "main" pseudo-component makefile.
-#
-# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
-
-
-COMPONENT_ADD_INCLUDEDIRS := ./include ./monitors/include
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
+
+
+COMPONENT_ADD_INCLUDEDIRS := ./include ./monitors/include
 COMPONENT_SRCDIRS := . ./monitors
\ No newline at end of file
diff --git a/components/battery_service/include/battery_service.h b/components/battery_service/include/battery_service.h
index 28b164d4..69b722e1 100644
--- a/components/battery_service/include/battery_service.h
+++ b/components/battery_service/include/battery_service.h
@@ -1,116 +1,116 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef __BATTERY_SERVICE_H__
-#define __BATTERY_SERVICE_H__
-
-#include "periph_service.h"
-#include "voltage_monitor.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Battery service event
- */
-typedef enum {
-    BAT_SERV_EVENT_UNKNOWN,
-
-    /* Battery monitor's events */
-    BAT_SERV_EVENT_VOL_REPORT = 1,
-    BAT_SERV_EVENT_BAT_FULL,
-    BAT_SERV_EVENT_BAT_LOW,
-
-    /* Charger monitor's events */
-    BAT_SERV_EVENT_CHARGING_BEGIN = 100,
-    BAT_SERV_EVENT_CHARGING_STOP,
-} battery_service_event_t;
-
-/**
- * @brief Battery service configure
- */
-typedef struct {
-    /* Service Basic */
-    int task_stack;           /*!< >0 Service task stack; =0 with out task created */
-    int task_prio;            /*!< Service task priority (based on freeRTOS priority) */
-    int task_core;            /*!< Service task running in core (0 or 1) */
-    bool extern_stack;        /*!< Task stack allocate on the extern ram */
-    periph_service_cb evt_cb; /*!< Service callback function */
-    void *cb_ctx;             /*!< Callback context */
-
-    vol_monitor_handle_t vol_monitor;   /*!< Battery monitor */
-
-    void *charger_monitor; /*!< Charger monitor. Not supported yet */
-} battery_service_config_t;
-
-#define BATTERY_SERVICE_DEFAULT_CONFIG() {  \
-    .task_stack   = 3 * 1024,               \
-    .task_prio    = 6,                      \
-    .task_core    = 0,                      \
-    .extern_stack = true,                   \
-    .evt_cb       = NULL,                   \
-    .cb_ctx       = NULL,                   \
-    .vol_monitor  = NULL,                   \
-}
-
-/**
-  * @brief     Create the battery service instance
-  *
-  * @param     config  configuration of the battery service
-  *
-  * @return
-  *    - NULL:  Failed
-  *    - Others: Success
-  */
-periph_service_handle_t battery_service_create(battery_service_config_t *config);
-
-/**
-  * @brief     Start or stop the battery voltage report
-  *
-  * @param[in]   handle     pointer to 'periph_service_handle_t' structure
-  * @param[in]  on_off      'true' to start, 'false' to stop
-  *
-  * @return
-  *    - ESP_OK: Success
-  *    - ESP_ERR_INVALID_ARG∩╝Ü handle is NULL
-  */
-esp_err_t battery_service_vol_report_switch(periph_service_handle_t handle, bool on_off);
-
-/**
-  * @brief     Set voltage report freqency
-  *
-  * @param[in]   handle     pointer to 'periph_service_handle_t' structure
-  * @param[in]   freq       voltage report freqency
-  *
-  * @return
-  *    - ESP_OK: Success
-  *    - ESP_ERR_INVALID_ARG∩╝Ü handle is NULL
-  */
-esp_err_t battery_service_set_vol_report_freq(periph_service_handle_t handle, int freq);
-
-#ifdef __cplusplus
-}
-#endif
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef __BATTERY_SERVICE_H__
+#define __BATTERY_SERVICE_H__
+
+#include "periph_service.h"
+#include "voltage_monitor.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Battery service event
+ */
+typedef enum {
+    BAT_SERV_EVENT_UNKNOWN,
+
+    /* Battery monitor's events */
+    BAT_SERV_EVENT_VOL_REPORT = 1,
+    BAT_SERV_EVENT_BAT_FULL,
+    BAT_SERV_EVENT_BAT_LOW,
+
+    /* Charger monitor's events */
+    BAT_SERV_EVENT_CHARGING_BEGIN = 100,
+    BAT_SERV_EVENT_CHARGING_STOP,
+} battery_service_event_t;
+
+/**
+ * @brief Battery service configure
+ */
+typedef struct {
+    /* Service Basic */
+    int task_stack;           /*!< >0 Service task stack; =0 with out task created */
+    int task_prio;            /*!< Service task priority (based on freeRTOS priority) */
+    int task_core;            /*!< Service task running in core (0 or 1) */
+    bool extern_stack;        /*!< Task stack allocate on the extern ram */
+    periph_service_cb evt_cb; /*!< Service callback function */
+    void *cb_ctx;             /*!< Callback context */
+
+    vol_monitor_handle_t vol_monitor;   /*!< Battery monitor */
+
+    void *charger_monitor; /*!< Charger monitor. Not supported yet */
+} battery_service_config_t;
+
+#define BATTERY_SERVICE_DEFAULT_CONFIG() {  \
+    .task_stack   = 3 * 1024,               \
+    .task_prio    = 6,                      \
+    .task_core    = 0,                      \
+    .extern_stack = true,                   \
+    .evt_cb       = NULL,                   \
+    .cb_ctx       = NULL,                   \
+    .vol_monitor  = NULL,                   \
+}
+
+/**
+  * @brief     Create the battery service instance
+  *
+  * @param     config  configuration of the battery service
+  *
+  * @return
+  *    - NULL:  Failed
+  *    - Others: Success
+  */
+periph_service_handle_t battery_service_create(battery_service_config_t *config);
+
+/**
+  * @brief     Start or stop the battery voltage report
+  *
+  * @param[in]   handle     pointer to 'periph_service_handle_t' structure
+  * @param[in]  on_off      'true' to start, 'false' to stop
+  *
+  * @return
+  *    - ESP_OK: Success
+  *    - ESP_ERR_INVALID_ARG∩╝Ü handle is NULL
+  */
+esp_err_t battery_service_vol_report_switch(periph_service_handle_t handle, bool on_off);
+
+/**
+  * @brief     Set voltage report freqency
+  *
+  * @param[in]   handle     pointer to 'periph_service_handle_t' structure
+  * @param[in]   freq       voltage report freqency
+  *
+  * @return
+  *    - ESP_OK: Success
+  *    - ESP_ERR_INVALID_ARG∩╝Ü handle is NULL
+  */
+esp_err_t battery_service_set_vol_report_freq(periph_service_handle_t handle, int freq);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __BATTERY_SERVICE_H__ */
\ No newline at end of file
diff --git a/components/battery_service/monitors/include/voltage_monitor.h b/components/battery_service/monitors/include/voltage_monitor.h
index 69719493..49a85898 100644
--- a/components/battery_service/monitors/include/voltage_monitor.h
+++ b/components/battery_service/monitors/include/voltage_monitor.h
@@ -1,140 +1,140 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __VOL_MONITOR_H__
-#define __VOL_MONITOR_H__
-
-#include "esp_err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Battery adc configure
- */
-typedef enum {
-    VOL_MONITOR_EVENT_FREQ_REPORT,
-    VOL_MONITOR_EVENT_BAT_FULL,
-    VOL_MONITOR_EVENT_BAT_LOW,
-} vol_monitor_event_t;
-
-/**
- * @brief Battery adc configure
- */
-typedef struct {
-    bool (*init)(void *);   /*!< Voltage read init */
-    bool (*deinit)(void *); /*!< Voltage read deinit */
-    int (*vol_get)(void *); /*!< Voltage read interface */
-    void *user_data;        /*!< Parameters for callbacks */
-    int read_freq;          /*!< Voltage read frequency, unit: s*/
-    int report_freq;        /*!< Voltage report frequency, voltage will be report with a interval calculate by ∩╝ê`read_freq` * `report_freq`∩╝ë */
-    int vol_full_threshold; /*!< Voltage threshold to report, unit: mV */
-    int vol_low_threshold;  /*!< Voltage threshold to report, unit: mV */
-} vol_monitor_param_t;
-
-/**
- * @brief voltage monitor handle
- */
-typedef void *vol_monitor_handle_t;
-
-/**
- * @brief callback define
- */
-typedef void (*vol_monitor_event_cb)(int msg_id, void *data, void *user_ctx);
-
-/**
-  * @brief     Create the voltage monitor instance
-  *
-  * @param[in]  config      pointer to 'vol_monitor_param_t' structure
-  *
-  * @return
-  *    - NULL:  Failed
-  *    - Others: Success
-  */
-vol_monitor_handle_t vol_monitor_create(vol_monitor_param_t *config);
-
-/**
-  * @brief     Destroy the voltage monitor
-  *
-  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
-  *
-  * @return
-  *    - ESP_OK:  Success
-  *    - Others: Failed
-  */
-esp_err_t vol_monitor_destroy(vol_monitor_handle_t handle);
-
-/**
-  * @brief     Set the event callback
-  *
-  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
-  * @param[in]  event_cb    callback used to handle the events of voltage monitor
-  * @param[in]  user_ctx    user's data
-  *
-  * @return
-  *    - ESP_OK:  Success
-  *    - Others: Failed
-  */
-esp_err_t vol_monitor_set_event_cb(vol_monitor_handle_t handle, vol_monitor_event_cb event_cb, void *user_ctx);
-
-/**
-  * @brief     Start the voltage report with the configured frequency
-  *
-  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
-  *
-  * @return
-  *    - ESP_OK:  Success
-  *    - Others: Failed
-  */
-esp_err_t vol_monitor_start_freq_report(vol_monitor_handle_t handle);
-
-/**
-  * @brief     Stop the voltage frequency report
-  *
-  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
-  *
-  * @return
-  *    - ESP_OK:  Success
-  *    - Others: Failed
-  */
-esp_err_t vol_monitor_stop_freq_report(vol_monitor_handle_t handle);
-
-/**
-  * @brief     Set the voltage report frequency
-  *
-  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
-  * @param[in]  freq        voltage report freqency
-  *
-  * @return
-  *    - ESP_OK:  Success
-  *    - Others: Failed
-  */
-esp_err_t vol_monitor_set_report_freq(vol_monitor_handle_t handle, int freq);
-
-#ifdef __cplusplus
-}
-#endif
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __VOL_MONITOR_H__
+#define __VOL_MONITOR_H__
+
+#include "esp_err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Battery adc configure
+ */
+typedef enum {
+    VOL_MONITOR_EVENT_FREQ_REPORT,
+    VOL_MONITOR_EVENT_BAT_FULL,
+    VOL_MONITOR_EVENT_BAT_LOW,
+} vol_monitor_event_t;
+
+/**
+ * @brief Battery adc configure
+ */
+typedef struct {
+    bool (*init)(void *);   /*!< Voltage read init */
+    bool (*deinit)(void *); /*!< Voltage read deinit */
+    int (*vol_get)(void *); /*!< Voltage read interface */
+    void *user_data;        /*!< Parameters for callbacks */
+    int read_freq;          /*!< Voltage read frequency, unit: s*/
+    int report_freq;        /*!< Voltage report frequency, voltage will be report with a interval calculate by ∩╝ê`read_freq` * `report_freq`∩╝ë */
+    int vol_full_threshold; /*!< Voltage threshold to report, unit: mV */
+    int vol_low_threshold;  /*!< Voltage threshold to report, unit: mV */
+} vol_monitor_param_t;
+
+/**
+ * @brief voltage monitor handle
+ */
+typedef void *vol_monitor_handle_t;
+
+/**
+ * @brief callback define
+ */
+typedef void (*vol_monitor_event_cb)(int msg_id, void *data, void *user_ctx);
+
+/**
+  * @brief     Create the voltage monitor instance
+  *
+  * @param[in]  config      pointer to 'vol_monitor_param_t' structure
+  *
+  * @return
+  *    - NULL:  Failed
+  *    - Others: Success
+  */
+vol_monitor_handle_t vol_monitor_create(vol_monitor_param_t *config);
+
+/**
+  * @brief     Destroy the voltage monitor
+  *
+  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others: Failed
+  */
+esp_err_t vol_monitor_destroy(vol_monitor_handle_t handle);
+
+/**
+  * @brief     Set the event callback
+  *
+  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
+  * @param[in]  event_cb    callback used to handle the events of voltage monitor
+  * @param[in]  user_ctx    user's data
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others: Failed
+  */
+esp_err_t vol_monitor_set_event_cb(vol_monitor_handle_t handle, vol_monitor_event_cb event_cb, void *user_ctx);
+
+/**
+  * @brief     Start the voltage report with the configured frequency
+  *
+  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others: Failed
+  */
+esp_err_t vol_monitor_start_freq_report(vol_monitor_handle_t handle);
+
+/**
+  * @brief     Stop the voltage frequency report
+  *
+  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others: Failed
+  */
+esp_err_t vol_monitor_stop_freq_report(vol_monitor_handle_t handle);
+
+/**
+  * @brief     Set the voltage report frequency
+  *
+  * @param[in]  handle      pointer to 'vol_monitor_handle_t' structure
+  * @param[in]  freq        voltage report freqency
+  *
+  * @return
+  *    - ESP_OK:  Success
+  *    - Others: Failed
+  */
+esp_err_t vol_monitor_set_report_freq(vol_monitor_handle_t handle, int freq);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __BATTERY_SERVICE_H__ */
\ No newline at end of file
diff --git a/components/battery_service/monitors/voltage_monitor.c b/components/battery_service/monitors/voltage_monitor.c
index 722b6736..4be8c782 100644
--- a/components/battery_service/monitors/voltage_monitor.c
+++ b/components/battery_service/monitors/voltage_monitor.c
@@ -1,244 +1,244 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/queue.h"
-#include "freertos/event_groups.h"
-#include "freertos/semphr.h"
-
-#include "esp_log.h"
-
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "audio_mutex.h"
-#include "esp_timer.h"
-
-#include "voltage_monitor.h"
-
-typedef struct {
-    SemaphoreHandle_t mutex;
-    vol_monitor_param_t *config;
-    vol_monitor_event_cb event_cb;
-    void *user_ctx;
-
-    esp_timer_handle_t check_timer;
-    int read_cnt;
-    int report_start;
-    bool full_reported;
-    bool low_reported;
-} vol_monitor_ctx_t;
-
-static const char *TAG = "VOL_MONITOR";
-
-static void vol_check_timer_hdlr(void *arg)
-{
-    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)arg;
-
-    if (vol_monitor == NULL || vol_monitor->event_cb == NULL || vol_monitor->config->user_data == NULL) {
-        return;
-    }
-
-    mutex_lock(vol_monitor->mutex);
-
-    int voltage = vol_monitor->config->vol_get(vol_monitor->config->user_data);;
-
-    if (vol_monitor->report_start != 0 && ++vol_monitor->read_cnt % vol_monitor->report_start == 0) {
-        vol_monitor->read_cnt = 0;
-        vol_monitor->event_cb(VOL_MONITOR_EVENT_FREQ_REPORT, (void *)voltage, vol_monitor->user_ctx);
-    }
-
-    if (vol_monitor->config->vol_low_threshold != 0) {
-        if (vol_monitor->low_reported == false && voltage <= vol_monitor->config->vol_low_threshold) {
-            vol_monitor->event_cb(VOL_MONITOR_EVENT_BAT_LOW, (void *)voltage, vol_monitor->user_ctx);
-            vol_monitor->low_reported = true;
-        } else if (voltage > vol_monitor->config->vol_low_threshold) {
-            vol_monitor->low_reported = false;
-        }
-    }
-
-    if (vol_monitor->config->vol_full_threshold != 0) {
-        if (vol_monitor->full_reported == false && voltage >= vol_monitor->config->vol_full_threshold) {
-            vol_monitor->event_cb(VOL_MONITOR_EVENT_BAT_FULL, (void *)voltage, vol_monitor->user_ctx);
-            vol_monitor->full_reported = true;
-        } else if (voltage < vol_monitor->config->vol_full_threshold) {
-            vol_monitor->full_reported = false;
-        }
-    }
-    mutex_unlock(vol_monitor->mutex);
-}
-
-static bool vol_monitor_param_check(vol_monitor_param_t *config)
-{
-    if (config->init == NULL) {
-        ESP_LOGE(TAG, "init NULL");
-        return false;
-    }
-    if (config->deinit == NULL) {
-        ESP_LOGE(TAG, "deinit NULL");
-        return false;
-    }
-    if (config->vol_get == NULL) {
-        ESP_LOGE(TAG, "vol_get NULL");
-        return false;
-    }
-    if (config->read_freq <= 0) {
-        ESP_LOGE(TAG, "Read freq <= 0");
-        return false;
-    }
-    if (config->report_freq < 0) {
-        ESP_LOGE(TAG, "report freq < 0");
-        return false;
-    }
-    if (config->vol_full_threshold < 0 ) {
-        ESP_LOGE(TAG, "vol_full_threshold < 0");
-        return false;
-    }
-    if (config->vol_low_threshold < 0 ) {
-        ESP_LOGE(TAG, "vol_low_threshold < 0");
-        return false;
-    }
-    if (config->vol_full_threshold != 0 && config->vol_low_threshold >= config->vol_full_threshold) {
-        ESP_LOGE(TAG, "vol_low_threshold >= vol_full_threshold");
-        return false;
-    }
-    return true;
-}
-
-vol_monitor_handle_t vol_monitor_create(vol_monitor_param_t *config)
-{
-    AUDIO_NULL_CHECK(TAG, config, return NULL);
-
-    vol_monitor_ctx_t *vol_monitor = audio_calloc(1, sizeof(vol_monitor_ctx_t));
-    AUDIO_MEM_CHECK(TAG, vol_monitor, return NULL);
-    if (!vol_monitor_param_check(config)) {
-        goto error;
-    }
-    vol_monitor->config = config;
-    vol_monitor->config->init(vol_monitor->config->user_data);
-    vol_monitor->mutex = mutex_create();
-    /* init timer */
-    if (vol_monitor->config->read_freq > 0) {
-        const esp_timer_create_args_t timer_args = {
-            .callback = vol_check_timer_hdlr,
-            .arg = vol_monitor,
-            .dispatch_method = ESP_TIMER_TASK,
-            .name = "report",
-        };
-        if (esp_timer_create(&timer_args, &vol_monitor->check_timer) != ESP_OK
-            || esp_timer_start_periodic(vol_monitor->check_timer, vol_monitor->config->read_freq * 1000 * 1000) != ESP_OK) {
-            goto error;
-        }
-    }
-
-    return vol_monitor;
-
-error:
-    ESP_LOGE(TAG, "vol_monitor_create failed");
-    if (vol_monitor->check_timer != NULL) {
-        esp_timer_delete(vol_monitor->check_timer);
-    }
-    if (vol_monitor->mutex) {
-        mutex_destroy(vol_monitor->mutex);
-    }
-    if (vol_monitor) {
-        free(vol_monitor);
-    }
-    return NULL;
-}
-
-esp_err_t vol_monitor_destroy(vol_monitor_handle_t handle)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
-    if (vol_monitor->check_timer != NULL) {
-        esp_timer_stop(vol_monitor->check_timer);
-        esp_timer_delete(vol_monitor->check_timer);
-        vol_monitor->check_timer = NULL;
-    }
-    vol_monitor->config->deinit(vol_monitor->config->user_data);
-    if (vol_monitor->mutex) {
-        mutex_destroy(vol_monitor->mutex);
-    }
-    if (vol_monitor) {
-        free(vol_monitor);
-    }
-    ESP_LOGI(TAG, "vol monitor destroyed");
-    return ESP_OK;
-}
-
-esp_err_t vol_monitor_set_event_cb(vol_monitor_handle_t handle, vol_monitor_event_cb event_cb, void *user_ctx)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_FAIL);
-
-    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
-    mutex_lock(vol_monitor->mutex);
-    vol_monitor->event_cb = event_cb;
-    vol_monitor->user_ctx = user_ctx;
-    mutex_unlock(vol_monitor->mutex);
-    return ESP_OK;
-}
-
-esp_err_t vol_monitor_start_freq_report(vol_monitor_handle_t handle)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
-    esp_err_t ret = ESP_OK;
-    mutex_lock(vol_monitor->mutex);
-    if (vol_monitor->config->report_freq > 0) {
-        vol_monitor->report_start = vol_monitor->config->report_freq;
-        ret = ESP_OK;
-    } else {
-        ESP_LOGW(TAG, "report freq <= 0");
-        ret = ESP_FAIL;
-    }
-    mutex_unlock(vol_monitor->mutex);
-    return ret;
-}
-
-esp_err_t vol_monitor_stop_freq_report(vol_monitor_handle_t handle)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
-    mutex_lock(vol_monitor->mutex);
-    vol_monitor->report_start = 0;
-    mutex_unlock(vol_monitor->mutex);
-    return ESP_OK;
-}
-
-esp_err_t vol_monitor_set_report_freq(vol_monitor_handle_t handle, int freq)
-{
-    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
-    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
-    mutex_lock(vol_monitor->mutex);
-    vol_monitor->config->report_freq = freq;
-    if (vol_monitor->config->report_freq > 0 && vol_monitor->report_start > 0) {
-        vol_monitor->read_cnt = 0;
-        vol_monitor->report_start = vol_monitor->config->report_freq;
-    } else if (vol_monitor->config->report_freq == 0) {
-        vol_monitor->read_cnt = 0;
-        vol_monitor->report_start = 0;
-    }
-    mutex_unlock(vol_monitor->mutex);
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/queue.h"
+#include "freertos/event_groups.h"
+#include "freertos/semphr.h"
+
+#include "esp_log.h"
+
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "audio_mutex.h"
+#include "esp_timer.h"
+
+#include "voltage_monitor.h"
+
+typedef struct {
+    SemaphoreHandle_t mutex;
+    vol_monitor_param_t *config;
+    vol_monitor_event_cb event_cb;
+    void *user_ctx;
+
+    esp_timer_handle_t check_timer;
+    int read_cnt;
+    int report_start;
+    bool full_reported;
+    bool low_reported;
+} vol_monitor_ctx_t;
+
+static const char *TAG = "VOL_MONITOR";
+
+static void vol_check_timer_hdlr(void *arg)
+{
+    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)arg;
+
+    if (vol_monitor == NULL || vol_monitor->event_cb == NULL || vol_monitor->config->user_data == NULL) {
+        return;
+    }
+
+    mutex_lock(vol_monitor->mutex);
+
+    int voltage = vol_monitor->config->vol_get(vol_monitor->config->user_data);;
+
+    if (vol_monitor->report_start != 0 && ++vol_monitor->read_cnt % vol_monitor->report_start == 0) {
+        vol_monitor->read_cnt = 0;
+        vol_monitor->event_cb(VOL_MONITOR_EVENT_FREQ_REPORT, (void *)voltage, vol_monitor->user_ctx);
+    }
+
+    if (vol_monitor->config->vol_low_threshold != 0) {
+        if (vol_monitor->low_reported == false && voltage <= vol_monitor->config->vol_low_threshold) {
+            vol_monitor->event_cb(VOL_MONITOR_EVENT_BAT_LOW, (void *)voltage, vol_monitor->user_ctx);
+            vol_monitor->low_reported = true;
+        } else if (voltage > vol_monitor->config->vol_low_threshold) {
+            vol_monitor->low_reported = false;
+        }
+    }
+
+    if (vol_monitor->config->vol_full_threshold != 0) {
+        if (vol_monitor->full_reported == false && voltage >= vol_monitor->config->vol_full_threshold) {
+            vol_monitor->event_cb(VOL_MONITOR_EVENT_BAT_FULL, (void *)voltage, vol_monitor->user_ctx);
+            vol_monitor->full_reported = true;
+        } else if (voltage < vol_monitor->config->vol_full_threshold) {
+            vol_monitor->full_reported = false;
+        }
+    }
+    mutex_unlock(vol_monitor->mutex);
+}
+
+static bool vol_monitor_param_check(vol_monitor_param_t *config)
+{
+    if (config->init == NULL) {
+        ESP_LOGE(TAG, "init NULL");
+        return false;
+    }
+    if (config->deinit == NULL) {
+        ESP_LOGE(TAG, "deinit NULL");
+        return false;
+    }
+    if (config->vol_get == NULL) {
+        ESP_LOGE(TAG, "vol_get NULL");
+        return false;
+    }
+    if (config->read_freq <= 0) {
+        ESP_LOGE(TAG, "Read freq <= 0");
+        return false;
+    }
+    if (config->report_freq < 0) {
+        ESP_LOGE(TAG, "report freq < 0");
+        return false;
+    }
+    if (config->vol_full_threshold < 0 ) {
+        ESP_LOGE(TAG, "vol_full_threshold < 0");
+        return false;
+    }
+    if (config->vol_low_threshold < 0 ) {
+        ESP_LOGE(TAG, "vol_low_threshold < 0");
+        return false;
+    }
+    if (config->vol_full_threshold != 0 && config->vol_low_threshold >= config->vol_full_threshold) {
+        ESP_LOGE(TAG, "vol_low_threshold >= vol_full_threshold");
+        return false;
+    }
+    return true;
+}
+
+vol_monitor_handle_t vol_monitor_create(vol_monitor_param_t *config)
+{
+    AUDIO_NULL_CHECK(TAG, config, return NULL);
+
+    vol_monitor_ctx_t *vol_monitor = audio_calloc(1, sizeof(vol_monitor_ctx_t));
+    AUDIO_MEM_CHECK(TAG, vol_monitor, return NULL);
+    if (!vol_monitor_param_check(config)) {
+        goto error;
+    }
+    vol_monitor->config = config;
+    vol_monitor->config->init(vol_monitor->config->user_data);
+    vol_monitor->mutex = mutex_create();
+    /* init timer */
+    if (vol_monitor->config->read_freq > 0) {
+        const esp_timer_create_args_t timer_args = {
+            .callback = vol_check_timer_hdlr,
+            .arg = vol_monitor,
+            .dispatch_method = ESP_TIMER_TASK,
+            .name = "report",
+        };
+        if (esp_timer_create(&timer_args, &vol_monitor->check_timer) != ESP_OK
+            || esp_timer_start_periodic(vol_monitor->check_timer, vol_monitor->config->read_freq * 1000 * 1000) != ESP_OK) {
+            goto error;
+        }
+    }
+
+    return vol_monitor;
+
+error:
+    ESP_LOGE(TAG, "vol_monitor_create failed");
+    if (vol_monitor->check_timer != NULL) {
+        esp_timer_delete(vol_monitor->check_timer);
+    }
+    if (vol_monitor->mutex) {
+        mutex_destroy(vol_monitor->mutex);
+    }
+    if (vol_monitor) {
+        free(vol_monitor);
+    }
+    return NULL;
+}
+
+esp_err_t vol_monitor_destroy(vol_monitor_handle_t handle)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
+    if (vol_monitor->check_timer != NULL) {
+        esp_timer_stop(vol_monitor->check_timer);
+        esp_timer_delete(vol_monitor->check_timer);
+        vol_monitor->check_timer = NULL;
+    }
+    vol_monitor->config->deinit(vol_monitor->config->user_data);
+    if (vol_monitor->mutex) {
+        mutex_destroy(vol_monitor->mutex);
+    }
+    if (vol_monitor) {
+        free(vol_monitor);
+    }
+    ESP_LOGI(TAG, "vol monitor destroyed");
+    return ESP_OK;
+}
+
+esp_err_t vol_monitor_set_event_cb(vol_monitor_handle_t handle, vol_monitor_event_cb event_cb, void *user_ctx)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_FAIL);
+
+    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
+    mutex_lock(vol_monitor->mutex);
+    vol_monitor->event_cb = event_cb;
+    vol_monitor->user_ctx = user_ctx;
+    mutex_unlock(vol_monitor->mutex);
+    return ESP_OK;
+}
+
+esp_err_t vol_monitor_start_freq_report(vol_monitor_handle_t handle)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
+    esp_err_t ret = ESP_OK;
+    mutex_lock(vol_monitor->mutex);
+    if (vol_monitor->config->report_freq > 0) {
+        vol_monitor->report_start = vol_monitor->config->report_freq;
+        ret = ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "report freq <= 0");
+        ret = ESP_FAIL;
+    }
+    mutex_unlock(vol_monitor->mutex);
+    return ret;
+}
+
+esp_err_t vol_monitor_stop_freq_report(vol_monitor_handle_t handle)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
+    mutex_lock(vol_monitor->mutex);
+    vol_monitor->report_start = 0;
+    mutex_unlock(vol_monitor->mutex);
+    return ESP_OK;
+}
+
+esp_err_t vol_monitor_set_report_freq(vol_monitor_handle_t handle, int freq)
+{
+    AUDIO_NULL_CHECK(TAG, handle, return ESP_ERR_INVALID_ARG);
+    vol_monitor_ctx_t *vol_monitor = (vol_monitor_ctx_t *)handle;
+    mutex_lock(vol_monitor->mutex);
+    vol_monitor->config->report_freq = freq;
+    if (vol_monitor->config->report_freq > 0 && vol_monitor->report_start > 0) {
+        vol_monitor->read_cnt = 0;
+        vol_monitor->report_start = vol_monitor->config->report_freq;
+    } else if (vol_monitor->config->report_freq == 0) {
+        vol_monitor->read_cnt = 0;
+        vol_monitor->report_start = 0;
+    }
+    mutex_unlock(vol_monitor->mutex);
+    return ESP_OK;
+}
diff --git a/components/battery_service/test/component.mk b/components/battery_service/test/component.mk
index 5dd172bd..5f441ada 100644
--- a/components/battery_service/test/component.mk
+++ b/components/battery_service/test/component.mk
@@ -1,5 +1,5 @@
-#
-#Component Makefile
-#
-
-COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
+#
+#Component Makefile
+#
+
+COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
diff --git a/components/battery_service/test/test_battery_service.c b/components/battery_service/test/test_battery_service.c
index aae51b99..d16415cc 100644
--- a/components/battery_service/test/test_battery_service.c
+++ b/components/battery_service/test/test_battery_service.c
@@ -1,463 +1,463 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "board.h"
-#include "audio_hal.h"
-#include "unity.h"
-#include "test_utils.h"
-#include "driver/adc.h"
-#include "esp_adc_cal.h"
-#include "battery_service.h"
-
-static const char *TAG = "battery_test";
-
-TEST_CASE("create without configuration", "[battery_service]")
-{
-    esp_log_level_set("BATTERY_SERVICE", ESP_LOG_NONE);
-    AUDIO_MEM_SHOW("MEMORY BEFORE");
-    int cnt = 10000;
-    while (cnt--) {
-        periph_service_handle_t battery_service = battery_service_create(NULL);
-        TEST_ASSERT_NULL(battery_service);
-    }
-    AUDIO_MEM_SHOW("MEMORY AFTER");
-}
-
-TEST_CASE("create with configuration all zero", "[battery_service]")
-{
-    battery_service_config_t battery_config = { 0 };
-    AUDIO_MEM_SHOW("MEMORY BEFORE");
-    int cnt = 10000;
-    while (cnt--) {
-        periph_service_handle_t battery_service = battery_service_create(&battery_config);
-        TEST_ASSERT_NULL(battery_service);
-    }
-    AUDIO_MEM_SHOW("MEMORY AFTER");
-}
-
-TEST_CASE("create with configration default", "[battery_service]")
-{
-    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
-
-    esp_log_level_set("BATTERY_SERVICE", ESP_LOG_NONE);
-    AUDIO_MEM_SHOW("MEMORY BEFORE");
-    int cnt = 10000;
-    while (cnt--) {
-        periph_service_handle_t battery_service = battery_service_create(&battery_config);
-        TEST_ASSERT_NOT_NULL(battery_service);
-        TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-        vTaskDelay(1);
-    }
-    AUDIO_MEM_SHOW("MEMORY AFTER");
-}
-
-typedef struct {
-    int unit;  /*!< ADC unit, see `adc_unit_t` */
-    int chan;  /*!< ADC channel, see `adc_channel_t` */
-    int width; /*!< ADC width, see `adc_channel_t` */
-    int atten; /*!< ADC atten, see `adc_atten_t` */
-    int v_ref; /*!< default vref` */
-} vol_adc_param_t;
-
-static bool adc_init(void *user_data)
-{
-    vol_adc_param_t *adc_cfg = (vol_adc_param_t *)user_data;
-    adc1_config_width(adc_cfg->width);
-    adc1_config_channel_atten(adc_cfg->chan, adc_cfg->atten);
-    return true;
-}
-
-static bool adc_deinit(void *user_data)
-{
-    return true;
-}
-
-static int vol_read(void *user_data)
-{
-#define ADC_SAMPLES_NUM (10)
-
-    vol_adc_param_t *adc_cfg = (vol_adc_param_t *)user_data;
-
-    uint32_t data[ADC_SAMPLES_NUM] = { 0 };
-    uint32_t sum = 0;
-    int tmp = 0;
-
-#if CONFIG_IDF_TARGET_ESP32
-    esp_adc_cal_characteristics_t characteristics;
-    esp_adc_cal_characterize(adc_cfg->unit, adc_cfg->atten, adc_cfg->width, adc_cfg->v_ref, &characteristics);
-    for (int i = 0; i < ADC_SAMPLES_NUM; ++i) {
-        esp_adc_cal_get_voltage(adc_cfg->chan, &characteristics, &data[i]);
-    }
-#elif CONFIG_IDF_TARGET_ESP32S2
-    for (int i = 0; i < ADC_SAMPLES_NUM; i++) {
-        data[i] = adc1_get_raw((adc1_channel_t)channel);
-    }
-#endif
-
-    for (int j = 0; j < ADC_SAMPLES_NUM - 1; j++) {
-        for (int i = 0; i < ADC_SAMPLES_NUM - j - 1; i++) {
-            if (data[i] > data[i + 1]) {
-                tmp = data[i];
-                data[i] = data[i + 1];
-                data[i + 1] = tmp;
-            }
-        }
-    }
-    for (int num = 1; num < ADC_SAMPLES_NUM - 1; num++)
-        sum += data[num];
-    return (sum / (ADC_SAMPLES_NUM - 2));
-}
-
-
-TEST_CASE("voltage monitor configure test", "[battery_service]")
-{
-    vol_adc_param_t adc_cfg = {
-        .unit = ADC_UNIT_1,
-        .chan = ADC_CHANNEL_1,
-        .width = ADC_WIDTH_BIT_12,
-        .atten = ADC_ATTEN_11db,
-        .v_ref = 1100,
-    };
-
-    vol_monitor_param_t vol_monitor_cfg = {
-        .init = adc_init,
-        .deinit = adc_deinit,
-        .vol_get = vol_read,
-        .read_freq = 2,
-        .report_freq = 2,
-        .vol_full_threshold = 0,
-        .vol_low_threshold = 0,
-    };
-    periph_service_handle_t battery_service = NULL;
-
-    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
-    vol_monitor_handle_t vol_monitor = NULL;
-
-    vol_monitor_cfg.init = NULL;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    vol_monitor_cfg.init = adc_init;
-    printf("\r\n");
-
-    vol_monitor_cfg.deinit = NULL;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    vol_monitor_cfg.deinit = adc_deinit;
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_get = NULL;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    vol_monitor_cfg.vol_get = vol_read;
-    printf("\r\n");
-
-    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
-    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
-    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
-
-    // read_freq
-    vol_monitor_cfg.read_freq = -1;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    vol_monitor_cfg.read_freq = 0;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    vol_monitor_cfg.read_freq = 100;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-    printf("\r\n");
-
-    // report_freq
-    vol_monitor_cfg.report_freq = -1;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    vol_monitor_cfg.report_freq = 0;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-    printf("\r\n");
-
-    vol_monitor_cfg.report_freq = 100;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-    printf("\r\n");
-
-    // full
-    vol_monitor_cfg.vol_full_threshold = -1;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_full_threshold = 0;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_full_threshold = 100;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-    printf("\r\n");
-
-    // low
-    vol_monitor_cfg.vol_low_threshold = -1;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_low_threshold = 0;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_low_threshold = 50;
-    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_low_threshold = 100;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    vol_monitor_cfg.vol_low_threshold = 200;
-    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
-    printf("\r\n");
-
-    free(vol_monitor_cfg.user_data);
-}
-
-#define BATTERY_FREQ_REPORT (BIT0)
-#define BATTERY_FULL_REPORT (BIT1)
-#define BATTERY_LOW_REPORT  (BIT2)
-
-EventGroupHandle_t sync_events;
-
-static esp_err_t battery_service_cb(periph_service_handle_t handle, periph_service_event_t *evt, void *ctx)
-{
-    if (evt->type == BAT_SERV_EVENT_VOL_REPORT) {
-        ESP_LOGI(TAG, "GOT VOL REPORT");
-        xEventGroupSetBits(sync_events, BATTERY_FREQ_REPORT);
-    } else if (evt->type == BAT_SERV_EVENT_BAT_FULL) {
-        ESP_LOGI(TAG, "GOT FULL REPORT");
-        xEventGroupSetBits(sync_events, BATTERY_FULL_REPORT);
-    } else if (evt->type == BAT_SERV_EVENT_BAT_LOW) {
-        ESP_LOGI(TAG, "GOT LOW REPORT");
-        xEventGroupSetBits(sync_events, BATTERY_LOW_REPORT);
-    } else {
-        ESP_LOGE(TAG, "error message");
-    }
-    return ESP_OK;
-}
-
-TEST_CASE("voltage monitor freq report", "[battery_service]")
-{
-    sync_events = xEventGroupCreate();
-    TEST_ASSERT_NOT_NULL(sync_events);
-
-    vol_adc_param_t adc_cfg = {
-        .unit = ADC_UNIT_1,
-        .chan = ADC_CHANNEL_1,
-        .width = ADC_WIDTH_BIT_12,
-        .atten = ADC_ATTEN_11db,
-        .v_ref = 1100,
-    };
-
-    vol_monitor_param_t vol_monitor_cfg = {
-        .init = adc_init,
-        .deinit = adc_deinit,
-        .vol_get = vol_read,
-        .read_freq = 1,
-        .report_freq = 1,
-        .vol_full_threshold = 0,
-        .vol_low_threshold = 0,
-    };
-    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
-    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
-    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
-
-    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
-    vol_monitor_handle_t vol_monitor = vol_monitor_create(&vol_monitor_cfg);
-    TEST_ASSERT_NOT_NULL(vol_monitor);
-    battery_config.vol_monitor = vol_monitor;
-    battery_config.evt_cb = battery_service_cb;
-
-    periph_service_handle_t battery_service = battery_service_create(&battery_config);
-    TEST_ASSERT_NOT_NULL(battery_service);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, battery_service_vol_report_switch(battery_service, true));
-    EventBits_t bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_EQUAL(BATTERY_FREQ_REPORT, bits & BATTERY_FREQ_REPORT);
-
-    TEST_ASSERT_EQUAL(ESP_OK, battery_service_set_vol_report_freq(battery_service, 2));
-    xEventGroupClearBits(sync_events, BATTERY_FREQ_REPORT);
-    bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_EQUAL(BATTERY_FREQ_REPORT, bits & BATTERY_FREQ_REPORT);
-
-    TEST_ASSERT_EQUAL(ESP_OK, battery_service_vol_report_switch(battery_service, false));
-    bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_NOT_EQUAL(BATTERY_FREQ_REPORT, bits & BATTERY_FREQ_REPORT);
-
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-
-    vol_monitor_cfg.report_freq = 0;
-    vol_monitor = vol_monitor_create(&vol_monitor_cfg);
-    TEST_ASSERT_NOT_NULL(vol_monitor);
-    battery_config.vol_monitor = vol_monitor;
-    battery_service = battery_service_create(&battery_config);
-    TEST_ASSERT_NOT_NULL(battery_service);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, battery_service_vol_report_switch(battery_service, true));
-    bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_EQUAL(0x00000000, bits & BATTERY_FREQ_REPORT);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-
-    vEventGroupDelete(sync_events);
-    free(vol_monitor_cfg.user_data);
-}
-
-TEST_CASE("voltage monitor battery full message", "[battery_service]")
-{
-    sync_events = xEventGroupCreate();
-    TEST_ASSERT_NOT_NULL(sync_events);
-
-    vol_adc_param_t adc_cfg = {
-        .unit = ADC_UNIT_1,
-        .chan = ADC_CHANNEL_1,
-        .width = ADC_WIDTH_BIT_12,
-        .atten = ADC_ATTEN_11db,
-        .v_ref = 1100,
-    };
-
-    vol_monitor_param_t vol_monitor_cfg = {
-        .init = adc_init,
-        .deinit = adc_deinit,
-        .vol_get = vol_read,
-        .read_freq = 1,
-        .report_freq = 0,
-        .vol_full_threshold = 0,
-        .vol_low_threshold = 0,
-    };
-    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
-    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
-    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
-
-    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
-    vol_monitor_handle_t vol_monitor = vol_monitor_create(&vol_monitor_cfg);
-    TEST_ASSERT_NOT_NULL(vol_monitor);
-    battery_config.vol_monitor = vol_monitor;
-    battery_config.evt_cb = battery_service_cb;
-
-    periph_service_handle_t battery_service = battery_service_create(&battery_config);
-    TEST_ASSERT_NOT_NULL(battery_service);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
-    EventBits_t bits = xEventGroupWaitBits(sync_events, BATTERY_FULL_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_NOT_EQUAL(BATTERY_FULL_REPORT, bits & BATTERY_FULL_REPORT);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-
-    vol_monitor_cfg.vol_full_threshold = 100;
-    vol_monitor = vol_monitor_create(&vol_monitor_cfg);
-    TEST_ASSERT_NOT_NULL(vol_monitor);
-    battery_config.vol_monitor = vol_monitor;
-    battery_service = battery_service_create(&battery_config);
-    TEST_ASSERT_NOT_NULL(battery_service);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
-    bits = xEventGroupWaitBits(sync_events, BATTERY_FULL_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_EQUAL(BATTERY_FULL_REPORT, bits & BATTERY_FULL_REPORT);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-
-    vEventGroupDelete(sync_events);
-    free(vol_monitor_cfg.user_data);
-}
-
-TEST_CASE("voltage monitor battery low message", "[battery_service]")
-{
-    sync_events = xEventGroupCreate();
-    TEST_ASSERT_NOT_NULL(sync_events);
-
-    vol_adc_param_t adc_cfg = {
-        .unit = ADC_UNIT_1,
-        .chan = ADC_CHANNEL_1,
-        .width = ADC_WIDTH_BIT_12,
-        .atten = ADC_ATTEN_11db,
-        .v_ref = 1100,
-    };
-
-    vol_monitor_param_t vol_monitor_cfg = {
-        .init = adc_init,
-        .deinit = adc_deinit,
-        .vol_get = vol_read,
-        .read_freq = 1,
-        .report_freq = 0,
-        .vol_full_threshold = 0,
-        .vol_low_threshold = 0,
-    };
-    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
-    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
-    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
-
-    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
-    vol_monitor_handle_t vol_monitor = vol_monitor_create(&vol_monitor_cfg);
-    TEST_ASSERT_NOT_NULL(vol_monitor);
-    battery_config.vol_monitor = vol_monitor;
-    battery_config.evt_cb = battery_service_cb;
-
-    periph_service_handle_t battery_service = battery_service_create(&battery_config);
-    TEST_ASSERT_NOT_NULL(battery_service);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
-    EventBits_t bits = xEventGroupWaitBits(sync_events, BATTERY_LOW_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_NOT_EQUAL(BATTERY_LOW_REPORT, bits & BATTERY_LOW_REPORT);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-
-    vol_monitor_cfg.vol_low_threshold = 10000;
-    vol_monitor = vol_monitor_create(&vol_monitor_cfg);
-    TEST_ASSERT_NOT_NULL(vol_monitor);
-    battery_config.vol_monitor = vol_monitor;
-    battery_service = battery_service_create(&battery_config);
-    TEST_ASSERT_NOT_NULL(battery_service);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
-    bits = xEventGroupWaitBits(sync_events, BATTERY_LOW_REPORT, true, true, pdMS_TO_TICKS(4000));
-    TEST_ASSERT_EQUAL(BATTERY_LOW_REPORT, bits & BATTERY_LOW_REPORT);
-    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
-    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
-    vol_monitor = NULL;
-
-    vEventGroupDelete(sync_events);
-    free(vol_monitor_cfg.user_data);
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "board.h"
+#include "audio_hal.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "driver/adc.h"
+#include "esp_adc_cal.h"
+#include "battery_service.h"
+
+static const char *TAG = "battery_test";
+
+TEST_CASE("create without configuration", "[battery_service]")
+{
+    esp_log_level_set("BATTERY_SERVICE", ESP_LOG_NONE);
+    AUDIO_MEM_SHOW("MEMORY BEFORE");
+    int cnt = 10000;
+    while (cnt--) {
+        periph_service_handle_t battery_service = battery_service_create(NULL);
+        TEST_ASSERT_NULL(battery_service);
+    }
+    AUDIO_MEM_SHOW("MEMORY AFTER");
+}
+
+TEST_CASE("create with configuration all zero", "[battery_service]")
+{
+    battery_service_config_t battery_config = { 0 };
+    AUDIO_MEM_SHOW("MEMORY BEFORE");
+    int cnt = 10000;
+    while (cnt--) {
+        periph_service_handle_t battery_service = battery_service_create(&battery_config);
+        TEST_ASSERT_NULL(battery_service);
+    }
+    AUDIO_MEM_SHOW("MEMORY AFTER");
+}
+
+TEST_CASE("create with configration default", "[battery_service]")
+{
+    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
+
+    esp_log_level_set("BATTERY_SERVICE", ESP_LOG_NONE);
+    AUDIO_MEM_SHOW("MEMORY BEFORE");
+    int cnt = 10000;
+    while (cnt--) {
+        periph_service_handle_t battery_service = battery_service_create(&battery_config);
+        TEST_ASSERT_NOT_NULL(battery_service);
+        TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+        vTaskDelay(1);
+    }
+    AUDIO_MEM_SHOW("MEMORY AFTER");
+}
+
+typedef struct {
+    int unit;  /*!< ADC unit, see `adc_unit_t` */
+    int chan;  /*!< ADC channel, see `adc_channel_t` */
+    int width; /*!< ADC width, see `adc_channel_t` */
+    int atten; /*!< ADC atten, see `adc_atten_t` */
+    int v_ref; /*!< default vref` */
+} vol_adc_param_t;
+
+static bool adc_init(void *user_data)
+{
+    vol_adc_param_t *adc_cfg = (vol_adc_param_t *)user_data;
+    adc1_config_width(adc_cfg->width);
+    adc1_config_channel_atten(adc_cfg->chan, adc_cfg->atten);
+    return true;
+}
+
+static bool adc_deinit(void *user_data)
+{
+    return true;
+}
+
+static int vol_read(void *user_data)
+{
+#define ADC_SAMPLES_NUM (10)
+
+    vol_adc_param_t *adc_cfg = (vol_adc_param_t *)user_data;
+
+    uint32_t data[ADC_SAMPLES_NUM] = { 0 };
+    uint32_t sum = 0;
+    int tmp = 0;
+
+#if CONFIG_IDF_TARGET_ESP32
+    esp_adc_cal_characteristics_t characteristics;
+    esp_adc_cal_characterize(adc_cfg->unit, adc_cfg->atten, adc_cfg->width, adc_cfg->v_ref, &characteristics);
+    for (int i = 0; i < ADC_SAMPLES_NUM; ++i) {
+        esp_adc_cal_get_voltage(adc_cfg->chan, &characteristics, &data[i]);
+    }
+#elif CONFIG_IDF_TARGET_ESP32S2
+    for (int i = 0; i < ADC_SAMPLES_NUM; i++) {
+        data[i] = adc1_get_raw((adc1_channel_t)channel);
+    }
+#endif
+
+    for (int j = 0; j < ADC_SAMPLES_NUM - 1; j++) {
+        for (int i = 0; i < ADC_SAMPLES_NUM - j - 1; i++) {
+            if (data[i] > data[i + 1]) {
+                tmp = data[i];
+                data[i] = data[i + 1];
+                data[i + 1] = tmp;
+            }
+        }
+    }
+    for (int num = 1; num < ADC_SAMPLES_NUM - 1; num++)
+        sum += data[num];
+    return (sum / (ADC_SAMPLES_NUM - 2));
+}
+
+
+TEST_CASE("voltage monitor configure test", "[battery_service]")
+{
+    vol_adc_param_t adc_cfg = {
+        .unit = ADC_UNIT_1,
+        .chan = ADC_CHANNEL_1,
+        .width = ADC_WIDTH_BIT_12,
+        .atten = ADC_ATTEN_11db,
+        .v_ref = 1100,
+    };
+
+    vol_monitor_param_t vol_monitor_cfg = {
+        .init = adc_init,
+        .deinit = adc_deinit,
+        .vol_get = vol_read,
+        .read_freq = 2,
+        .report_freq = 2,
+        .vol_full_threshold = 0,
+        .vol_low_threshold = 0,
+    };
+    periph_service_handle_t battery_service = NULL;
+
+    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
+    vol_monitor_handle_t vol_monitor = NULL;
+
+    vol_monitor_cfg.init = NULL;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    vol_monitor_cfg.init = adc_init;
+    printf("\r\n");
+
+    vol_monitor_cfg.deinit = NULL;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    vol_monitor_cfg.deinit = adc_deinit;
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_get = NULL;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    vol_monitor_cfg.vol_get = vol_read;
+    printf("\r\n");
+
+    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
+    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
+    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
+
+    // read_freq
+    vol_monitor_cfg.read_freq = -1;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    vol_monitor_cfg.read_freq = 0;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    vol_monitor_cfg.read_freq = 100;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+    printf("\r\n");
+
+    // report_freq
+    vol_monitor_cfg.report_freq = -1;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    vol_monitor_cfg.report_freq = 0;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+    printf("\r\n");
+
+    vol_monitor_cfg.report_freq = 100;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+    printf("\r\n");
+
+    // full
+    vol_monitor_cfg.vol_full_threshold = -1;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_full_threshold = 0;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_full_threshold = 100;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+    printf("\r\n");
+
+    // low
+    vol_monitor_cfg.vol_low_threshold = -1;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_low_threshold = 0;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_low_threshold = 50;
+    TEST_ASSERT_NOT_NULL((vol_monitor = vol_monitor_create(&vol_monitor_cfg)));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_low_threshold = 100;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    vol_monitor_cfg.vol_low_threshold = 200;
+    TEST_ASSERT_NULL(vol_monitor_create(&vol_monitor_cfg));
+    printf("\r\n");
+
+    free(vol_monitor_cfg.user_data);
+}
+
+#define BATTERY_FREQ_REPORT (BIT0)
+#define BATTERY_FULL_REPORT (BIT1)
+#define BATTERY_LOW_REPORT  (BIT2)
+
+EventGroupHandle_t sync_events;
+
+static esp_err_t battery_service_cb(periph_service_handle_t handle, periph_service_event_t *evt, void *ctx)
+{
+    if (evt->type == BAT_SERV_EVENT_VOL_REPORT) {
+        ESP_LOGI(TAG, "GOT VOL REPORT");
+        xEventGroupSetBits(sync_events, BATTERY_FREQ_REPORT);
+    } else if (evt->type == BAT_SERV_EVENT_BAT_FULL) {
+        ESP_LOGI(TAG, "GOT FULL REPORT");
+        xEventGroupSetBits(sync_events, BATTERY_FULL_REPORT);
+    } else if (evt->type == BAT_SERV_EVENT_BAT_LOW) {
+        ESP_LOGI(TAG, "GOT LOW REPORT");
+        xEventGroupSetBits(sync_events, BATTERY_LOW_REPORT);
+    } else {
+        ESP_LOGE(TAG, "error message");
+    }
+    return ESP_OK;
+}
+
+TEST_CASE("voltage monitor freq report", "[battery_service]")
+{
+    sync_events = xEventGroupCreate();
+    TEST_ASSERT_NOT_NULL(sync_events);
+
+    vol_adc_param_t adc_cfg = {
+        .unit = ADC_UNIT_1,
+        .chan = ADC_CHANNEL_1,
+        .width = ADC_WIDTH_BIT_12,
+        .atten = ADC_ATTEN_11db,
+        .v_ref = 1100,
+    };
+
+    vol_monitor_param_t vol_monitor_cfg = {
+        .init = adc_init,
+        .deinit = adc_deinit,
+        .vol_get = vol_read,
+        .read_freq = 1,
+        .report_freq = 1,
+        .vol_full_threshold = 0,
+        .vol_low_threshold = 0,
+    };
+    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
+    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
+    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
+
+    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
+    vol_monitor_handle_t vol_monitor = vol_monitor_create(&vol_monitor_cfg);
+    TEST_ASSERT_NOT_NULL(vol_monitor);
+    battery_config.vol_monitor = vol_monitor;
+    battery_config.evt_cb = battery_service_cb;
+
+    periph_service_handle_t battery_service = battery_service_create(&battery_config);
+    TEST_ASSERT_NOT_NULL(battery_service);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, battery_service_vol_report_switch(battery_service, true));
+    EventBits_t bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_EQUAL(BATTERY_FREQ_REPORT, bits & BATTERY_FREQ_REPORT);
+
+    TEST_ASSERT_EQUAL(ESP_OK, battery_service_set_vol_report_freq(battery_service, 2));
+    xEventGroupClearBits(sync_events, BATTERY_FREQ_REPORT);
+    bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_EQUAL(BATTERY_FREQ_REPORT, bits & BATTERY_FREQ_REPORT);
+
+    TEST_ASSERT_EQUAL(ESP_OK, battery_service_vol_report_switch(battery_service, false));
+    bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_NOT_EQUAL(BATTERY_FREQ_REPORT, bits & BATTERY_FREQ_REPORT);
+
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+
+    vol_monitor_cfg.report_freq = 0;
+    vol_monitor = vol_monitor_create(&vol_monitor_cfg);
+    TEST_ASSERT_NOT_NULL(vol_monitor);
+    battery_config.vol_monitor = vol_monitor;
+    battery_service = battery_service_create(&battery_config);
+    TEST_ASSERT_NOT_NULL(battery_service);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, battery_service_vol_report_switch(battery_service, true));
+    bits = xEventGroupWaitBits(sync_events, BATTERY_FREQ_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_EQUAL(0x00000000, bits & BATTERY_FREQ_REPORT);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+
+    vEventGroupDelete(sync_events);
+    free(vol_monitor_cfg.user_data);
+}
+
+TEST_CASE("voltage monitor battery full message", "[battery_service]")
+{
+    sync_events = xEventGroupCreate();
+    TEST_ASSERT_NOT_NULL(sync_events);
+
+    vol_adc_param_t adc_cfg = {
+        .unit = ADC_UNIT_1,
+        .chan = ADC_CHANNEL_1,
+        .width = ADC_WIDTH_BIT_12,
+        .atten = ADC_ATTEN_11db,
+        .v_ref = 1100,
+    };
+
+    vol_monitor_param_t vol_monitor_cfg = {
+        .init = adc_init,
+        .deinit = adc_deinit,
+        .vol_get = vol_read,
+        .read_freq = 1,
+        .report_freq = 0,
+        .vol_full_threshold = 0,
+        .vol_low_threshold = 0,
+    };
+    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
+    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
+    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
+
+    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
+    vol_monitor_handle_t vol_monitor = vol_monitor_create(&vol_monitor_cfg);
+    TEST_ASSERT_NOT_NULL(vol_monitor);
+    battery_config.vol_monitor = vol_monitor;
+    battery_config.evt_cb = battery_service_cb;
+
+    periph_service_handle_t battery_service = battery_service_create(&battery_config);
+    TEST_ASSERT_NOT_NULL(battery_service);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
+    EventBits_t bits = xEventGroupWaitBits(sync_events, BATTERY_FULL_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_NOT_EQUAL(BATTERY_FULL_REPORT, bits & BATTERY_FULL_REPORT);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+
+    vol_monitor_cfg.vol_full_threshold = 100;
+    vol_monitor = vol_monitor_create(&vol_monitor_cfg);
+    TEST_ASSERT_NOT_NULL(vol_monitor);
+    battery_config.vol_monitor = vol_monitor;
+    battery_service = battery_service_create(&battery_config);
+    TEST_ASSERT_NOT_NULL(battery_service);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
+    bits = xEventGroupWaitBits(sync_events, BATTERY_FULL_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_EQUAL(BATTERY_FULL_REPORT, bits & BATTERY_FULL_REPORT);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+
+    vEventGroupDelete(sync_events);
+    free(vol_monitor_cfg.user_data);
+}
+
+TEST_CASE("voltage monitor battery low message", "[battery_service]")
+{
+    sync_events = xEventGroupCreate();
+    TEST_ASSERT_NOT_NULL(sync_events);
+
+    vol_adc_param_t adc_cfg = {
+        .unit = ADC_UNIT_1,
+        .chan = ADC_CHANNEL_1,
+        .width = ADC_WIDTH_BIT_12,
+        .atten = ADC_ATTEN_11db,
+        .v_ref = 1100,
+    };
+
+    vol_monitor_param_t vol_monitor_cfg = {
+        .init = adc_init,
+        .deinit = adc_deinit,
+        .vol_get = vol_read,
+        .read_freq = 1,
+        .report_freq = 0,
+        .vol_full_threshold = 0,
+        .vol_low_threshold = 0,
+    };
+    vol_monitor_cfg.user_data = audio_calloc(1, sizeof(vol_adc_param_t));
+    AUDIO_MEM_CHECK(TAG, vol_monitor_cfg.user_data, return);
+    memcpy(vol_monitor_cfg.user_data, &adc_cfg, sizeof(vol_adc_param_t));
+
+    battery_service_config_t battery_config = BATTERY_SERVICE_DEFAULT_CONFIG();
+    vol_monitor_handle_t vol_monitor = vol_monitor_create(&vol_monitor_cfg);
+    TEST_ASSERT_NOT_NULL(vol_monitor);
+    battery_config.vol_monitor = vol_monitor;
+    battery_config.evt_cb = battery_service_cb;
+
+    periph_service_handle_t battery_service = battery_service_create(&battery_config);
+    TEST_ASSERT_NOT_NULL(battery_service);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
+    EventBits_t bits = xEventGroupWaitBits(sync_events, BATTERY_LOW_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_NOT_EQUAL(BATTERY_LOW_REPORT, bits & BATTERY_LOW_REPORT);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+
+    vol_monitor_cfg.vol_low_threshold = 10000;
+    vol_monitor = vol_monitor_create(&vol_monitor_cfg);
+    TEST_ASSERT_NOT_NULL(vol_monitor);
+    battery_config.vol_monitor = vol_monitor;
+    battery_service = battery_service_create(&battery_config);
+    TEST_ASSERT_NOT_NULL(battery_service);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_start(battery_service));
+    bits = xEventGroupWaitBits(sync_events, BATTERY_LOW_REPORT, true, true, pdMS_TO_TICKS(4000));
+    TEST_ASSERT_EQUAL(BATTERY_LOW_REPORT, bits & BATTERY_LOW_REPORT);
+    TEST_ASSERT_EQUAL(ESP_OK, periph_service_destroy(battery_service));
+    TEST_ASSERT_EQUAL(ESP_OK, vol_monitor_destroy(vol_monitor));
+    vol_monitor = NULL;
+
+    vEventGroupDelete(sync_events);
+    free(vol_monitor_cfg.user_data);
 }
\ No newline at end of file
diff --git a/components/coredump_upload_service/CMakeLists.txt b/components/coredump_upload_service/CMakeLists.txt
index ca35c149..681c5a94 100644
--- a/components/coredump_upload_service/CMakeLists.txt
+++ b/components/coredump_upload_service/CMakeLists.txt
@@ -1,9 +1,9 @@
-set(COMPONENT_ADD_INCLUDEDIRS include)
-
-# Edit following two lines to set component requirements (see docs)
-set(COMPONENT_REQUIRES esp_http_client espcoredump spi_flash esp_rom)
-set(COMPONENT_PRIV_REQUIRES audio_sal esp_dispatcher)
-
-set(COMPONENT_SRCS ./coredump_upload_service.c)
-
-register_component()
+set(COMPONENT_ADD_INCLUDEDIRS include)
+
+# Edit following two lines to set component requirements (see docs)
+set(COMPONENT_REQUIRES esp_http_client espcoredump spi_flash esp_rom)
+set(COMPONENT_PRIV_REQUIRES audio_sal esp_dispatcher)
+
+set(COMPONENT_SRCS ./coredump_upload_service.c)
+
+register_component()
diff --git a/components/coredump_upload_service/component.mk b/components/coredump_upload_service/component.mk
index a60a09eb..e6741b8b 100644
--- a/components/coredump_upload_service/component.mk
+++ b/components/coredump_upload_service/component.mk
@@ -1,7 +1,7 @@
-#
-# "main" pseudo-component makefile.
-#
-# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
-COMPONENT_ADD_INCLUDEDIRS := include
-COMPONENT_SRCDIRS := .
-
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
+COMPONENT_ADD_INCLUDEDIRS := include
+COMPONENT_SRCDIRS := .
+
diff --git a/components/coredump_upload_service/coredump_upload_service.c b/components/coredump_upload_service/coredump_upload_service.c
index e6c6fb43..b9972701 100644
--- a/components/coredump_upload_service/coredump_upload_service.c
+++ b/components/coredump_upload_service/coredump_upload_service.c
@@ -1,260 +1,260 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/event_groups.h"
-#include "freertos/queue.h"
-#include "freertos/task.h"
-
-#include "esp_core_dump.h"
-#include "esp_http_client.h"
-#include "esp_log.h"
-
-#include "esp_system.h"
-
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "coredump_upload_service.h"
-
-#include "audio_idf_version.h"
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-#include "esp_rom_spiflash.h"
-#define SPI_READ esp_rom_spiflash_read
-#else
-#include "esp_spi_flash.h"
-#define SPI_READ spi_flash_read
-#endif
-
-typedef struct {
-    xQueueHandle cmd_q;
-    EventGroupHandle_t sync_evt;
-    bool (*do_post)(char *url, uint32_t *data, size_t len);
-} coredump_upload_t;
-
-typedef struct {
-    enum {
-        MSG_UPLOAD,
-        MSG_DESTROY,
-    } msg_id;
-    void *pdata;
-} coredump_msg_t;
-
-#define COREDUMP_UPLOAD_SUCCESS (BIT0)
-#define COREDUMP_UPLOAD_FAIL    (BIT1)
-#define COREDUMP_UPLOAD_DESTROY (BIT2)
-
-static char *TAG = "COREDUMP_UPLOAD";
-
-static bool coredump_read(uint32_t **des, size_t *len)
-{
-    size_t addr = 0;
-
-    if (esp_core_dump_image_get(&addr, len) != ESP_OK) {
-        ESP_LOGW(TAG, "No dump info to upload");
-        return false;
-    }
-    if (*len == 0) {
-        return false;
-    }
-    *des = audio_calloc(1, *len);
-    AUDIO_MEM_CHECK(TAG, *des, return false);
-    if (SPI_READ(addr, *des, *len) != ESP_OK) {
-        ESP_LOGE(TAG, "Core dump read ERROR");
-        free(*des);
-        *des = NULL;
-        *len = 0;
-        return false;
-    }
-
-    return true;
-}
-
-static bool coredump_do_http_post(char *url, uint32_t *data, size_t len)
-{
-    esp_http_client_config_t config = {
-        .url = url,
-        .method = HTTP_METHOD_POST,
-    };
-    esp_http_client_handle_t http_client = esp_http_client_init(&config);
-    esp_http_client_set_header(http_client, "Content-Type", "application/octet-stream");
-    esp_http_client_set_post_field(http_client, (const char *)data, (int)len);
-    int response = 0;
-    if (esp_http_client_perform(http_client) == ESP_OK) {
-        response = esp_http_client_get_status_code(http_client);
-        ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %lld", response, (int64_t)esp_http_client_get_content_length(http_client));
-    } else {
-        ESP_LOGE(TAG, "Post failed");
-    }
-    esp_http_client_cleanup(http_client);
-
-    return response == 200 ? true : false;
-}
-
-static bool coredump_upload_partition(coredump_upload_t *uploader, char *url)
-{
-    uint32_t *buf = NULL;
-    size_t len = 0;
-    bool ret = false;
-    if (coredump_read(&buf, &len) == true) {
-        if (uploader->do_post(url, buf, len) == true) {
-            ESP_LOGI(TAG, "core dump upload success");
-            ret = true;
-        } else {
-            ESP_LOGE(TAG, "core dump upload failed");
-        }
-    }
-    if (buf != NULL) {
-        free(buf);
-    }
-    return ret;
-}
-
-static void coredump_upload_task(void *args)
-{
-    coredump_upload_t *uploader = periph_service_get_data((periph_service_handle_t)args);
-    bool task_run = true;
-    coredump_msg_t msg = { 0 };
-
-    while (task_run) {
-        if (xQueueReceive(uploader->cmd_q, &msg, portMAX_DELAY)) {
-            switch (msg.msg_id) {
-                case MSG_UPLOAD: {
-                    bool result = coredump_upload_partition(uploader, msg.pdata);
-                    xEventGroupSetBits(uploader->sync_evt, result == true ? COREDUMP_UPLOAD_SUCCESS : COREDUMP_UPLOAD_FAIL);
-                    break;
-                }
-                case MSG_DESTROY:
-                    task_run = false;
-                    break;
-                default:
-                    break;
-            }
-            if (msg.pdata) {
-                free(msg.pdata);
-            }
-        }
-    }
-    xEventGroupSetBits(uploader->sync_evt, COREDUMP_UPLOAD_DESTROY);
-    vTaskDelete(NULL);
-}
-
-bool coredump_need_upload()
-{
-    bool ret = false;
-    esp_reset_reason_t reset_reason = esp_reset_reason();
-    ESP_LOGI(TAG, "reset reason is %d", reset_reason);
-    switch (reset_reason) {
-        case ESP_RST_UNKNOWN:
-        case ESP_RST_PANIC:
-        case ESP_RST_INT_WDT:
-        case ESP_RST_TASK_WDT:
-            // case ESP_RST_WDT:
-            ret = true;
-            break;
-        default:
-            ret = false;
-    }
-    return ret;
-}
-
-esp_err_t coredump_upload(periph_service_handle_t handle, char *url)
-{
-    AUDIO_MEM_CHECK(TAG, handle, return ESP_FAIL);
-    coredump_upload_t *uploader = periph_service_get_data(handle);
-    coredump_msg_t msg = {
-        .msg_id = MSG_UPLOAD,
-    };
-    msg.pdata = audio_calloc(1, strlen(url) + 1);
-    AUDIO_MEM_CHECK(TAG, msg.pdata, return ESP_FAIL);
-    memcpy(msg.pdata, url, strlen(url));
-    xQueueSend(uploader->cmd_q, &msg, portMAX_DELAY);
-    EventBits_t bits = xEventGroupWaitBits(uploader->sync_evt, COREDUMP_UPLOAD_FAIL | COREDUMP_UPLOAD_SUCCESS, true, false, portMAX_DELAY);
-    return (bits & COREDUMP_UPLOAD_SUCCESS) ? ESP_OK : ESP_FAIL;
-}
-
-esp_err_t coredump_upload_deinit(periph_service_handle_t handle)
-{
-    AUDIO_MEM_CHECK(TAG, handle, return ESP_FAIL);
-    coredump_upload_t *uploader = periph_service_get_data(handle);
-    coredump_msg_t msg = {
-        .msg_id = MSG_DESTROY,
-    };
-    xQueueSend(uploader->cmd_q, &msg, portMAX_DELAY);
-    xEventGroupWaitBits(uploader->sync_evt, COREDUMP_UPLOAD_DESTROY, true, true, portMAX_DELAY);
-    if (uploader) {
-        if (uploader->cmd_q) {
-            vQueueDelete(uploader->cmd_q);
-        }
-        if (uploader->sync_evt) {
-            vEventGroupDelete(uploader->sync_evt);
-        }
-        free(uploader);
-    }
-    ESP_LOGW(TAG, "coredump uploader destroyed");
-    return ESP_OK;
-}
-
-periph_service_handle_t coredump_upload_service_create(coredump_upload_service_config_t *config)
-{
-    coredump_upload_t *uploader = audio_calloc(1, sizeof(coredump_upload_t));
-    AUDIO_MEM_CHECK(TAG, uploader, return NULL);
-    uploader->cmd_q = xQueueCreate(2, sizeof(coredump_msg_t));
-    AUDIO_MEM_CHECK(TAG, uploader->cmd_q, {
-        free(uploader);
-        return NULL;
-    });
-    uploader->sync_evt = xEventGroupCreate();
-    AUDIO_MEM_CHECK(TAG, uploader->sync_evt, {
-        vQueueDelete(uploader->cmd_q);
-        free(uploader);
-        return NULL;
-    });
-    uploader->do_post = config->do_post != NULL ? config->do_post : coredump_do_http_post;
-    periph_service_config_t cfg = {
-        .task_stack = config->task_stack,
-        .task_prio = config->task_prio,
-        .task_core = config->task_core,
-        .task_func = coredump_upload_task,
-        .extern_stack = false, /* Need flash read operation */
-        .service_start = NULL,
-        .service_stop = NULL,
-        .service_ioctl = NULL,
-        .service_destroy = coredump_upload_deinit,
-        .service_name = "CoreDumpUpload",
-        .user_data = (void *)uploader,
-    };
-
-    periph_service_handle_t periph_coredump = periph_service_create(&cfg);
-    AUDIO_MEM_CHECK(TAG, periph_coredump, {
-        vQueueDelete(uploader->cmd_q);
-        vEventGroupDelete(uploader->sync_evt);
-        free(uploader);
-        return NULL;
-    });
-    periph_service_set_callback(periph_coredump, config->evt_cb, config->cb_ctx);
-
-    return periph_coredump;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/event_groups.h"
+#include "freertos/queue.h"
+#include "freertos/task.h"
+
+#include "esp_core_dump.h"
+#include "esp_http_client.h"
+#include "esp_log.h"
+
+#include "esp_system.h"
+
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "coredump_upload_service.h"
+
+#include "audio_idf_version.h"
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+#include "esp_rom_spiflash.h"
+#define SPI_READ esp_rom_spiflash_read
+#else
+#include "esp_spi_flash.h"
+#define SPI_READ spi_flash_read
+#endif
+
+typedef struct {
+    QueueHandle_t cmd_q;
+    EventGroupHandle_t sync_evt;
+    bool (*do_post)(char *url, uint32_t *data, size_t len);
+} coredump_upload_t;
+
+typedef struct {
+    enum {
+        MSG_UPLOAD,
+        MSG_DESTROY,
+    } msg_id;
+    void *pdata;
+} coredump_msg_t;
+
+#define COREDUMP_UPLOAD_SUCCESS (BIT0)
+#define COREDUMP_UPLOAD_FAIL    (BIT1)
+#define COREDUMP_UPLOAD_DESTROY (BIT2)
+
+static char *TAG = "COREDUMP_UPLOAD";
+
+static bool coredump_read(uint32_t **des, size_t *len)
+{
+    size_t addr = 0;
+
+    if (esp_core_dump_image_get(&addr, len) != ESP_OK) {
+        ESP_LOGW(TAG, "No dump info to upload");
+        return false;
+    }
+    if (*len == 0) {
+        return false;
+    }
+    *des = audio_calloc(1, *len);
+    AUDIO_MEM_CHECK(TAG, *des, return false);
+    if (SPI_READ(addr, *des, *len) != ESP_OK) {
+        ESP_LOGE(TAG, "Core dump read ERROR");
+        free(*des);
+        *des = NULL;
+        *len = 0;
+        return false;
+    }
+
+    return true;
+}
+
+static bool coredump_do_http_post(char *url, uint32_t *data, size_t len)
+{
+    esp_http_client_config_t config = {
+        .url = url,
+        .method = HTTP_METHOD_POST,
+    };
+    esp_http_client_handle_t http_client = esp_http_client_init(&config);
+    esp_http_client_set_header(http_client, "Content-Type", "application/octet-stream");
+    esp_http_client_set_post_field(http_client, (const char *)data, (int)len);
+    int response = 0;
+    if (esp_http_client_perform(http_client) == ESP_OK) {
+        response = esp_http_client_get_status_code(http_client);
+        ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %lld", response, (int64_t)esp_http_client_get_content_length(http_client));
+    } else {
+        ESP_LOGE(TAG, "Post failed");
+    }
+    esp_http_client_cleanup(http_client);
+
+    return response == 200 ? true : false;
+}
+
+static bool coredump_upload_partition(coredump_upload_t *uploader, char *url)
+{
+    uint32_t *buf = NULL;
+    size_t len = 0;
+    bool ret = false;
+    if (coredump_read(&buf, &len) == true) {
+        if (uploader->do_post(url, buf, len) == true) {
+            ESP_LOGI(TAG, "core dump upload success");
+            ret = true;
+        } else {
+            ESP_LOGE(TAG, "core dump upload failed");
+        }
+    }
+    if (buf != NULL) {
+        free(buf);
+    }
+    return ret;
+}
+
+static void coredump_upload_task(void *args)
+{
+    coredump_upload_t *uploader = periph_service_get_data((periph_service_handle_t)args);
+    bool task_run = true;
+    coredump_msg_t msg = { 0 };
+
+    while (task_run) {
+        if (xQueueReceive(uploader->cmd_q, &msg, portMAX_DELAY)) {
+            switch (msg.msg_id) {
+                case MSG_UPLOAD: {
+                    bool result = coredump_upload_partition(uploader, msg.pdata);
+                    xEventGroupSetBits(uploader->sync_evt, result == true ? COREDUMP_UPLOAD_SUCCESS : COREDUMP_UPLOAD_FAIL);
+                    break;
+                }
+                case MSG_DESTROY:
+                    task_run = false;
+                    break;
+                default:
+                    break;
+            }
+            if (msg.pdata) {
+                free(msg.pdata);
+            }
+        }
+    }
+    xEventGroupSetBits(uploader->sync_evt, COREDUMP_UPLOAD_DESTROY);
+    vTaskDelete(NULL);
+}
+
+bool coredump_need_upload()
+{
+    bool ret = false;
+    esp_reset_reason_t reset_reason = esp_reset_reason();
+    ESP_LOGI(TAG, "reset reason is %d", reset_reason);
+    switch (reset_reason) {
+        case ESP_RST_UNKNOWN:
+        case ESP_RST_PANIC:
+        case ESP_RST_INT_WDT:
+        case ESP_RST_TASK_WDT:
+            // case ESP_RST_WDT:
+            ret = true;
+            break;
+        default:
+            ret = false;
+    }
+    return ret;
+}
+
+esp_err_t coredump_upload(periph_service_handle_t handle, char *url)
+{
+    AUDIO_MEM_CHECK(TAG, handle, return ESP_FAIL);
+    coredump_upload_t *uploader = periph_service_get_data(handle);
+    coredump_msg_t msg = {
+        .msg_id = MSG_UPLOAD,
+    };
+    msg.pdata = audio_calloc(1, strlen(url) + 1);
+    AUDIO_MEM_CHECK(TAG, msg.pdata, return ESP_FAIL);
+    memcpy(msg.pdata, url, strlen(url));
+    xQueueSend(uploader->cmd_q, &msg, portMAX_DELAY);
+    EventBits_t bits = xEventGroupWaitBits(uploader->sync_evt, COREDUMP_UPLOAD_FAIL | COREDUMP_UPLOAD_SUCCESS, true, false, portMAX_DELAY);
+    return (bits & COREDUMP_UPLOAD_SUCCESS) ? ESP_OK : ESP_FAIL;
+}
+
+esp_err_t coredump_upload_deinit(periph_service_handle_t handle)
+{
+    AUDIO_MEM_CHECK(TAG, handle, return ESP_FAIL);
+    coredump_upload_t *uploader = periph_service_get_data(handle);
+    coredump_msg_t msg = {
+        .msg_id = MSG_DESTROY,
+    };
+    xQueueSend(uploader->cmd_q, &msg, portMAX_DELAY);
+    xEventGroupWaitBits(uploader->sync_evt, COREDUMP_UPLOAD_DESTROY, true, true, portMAX_DELAY);
+    if (uploader) {
+        if (uploader->cmd_q) {
+            vQueueDelete(uploader->cmd_q);
+        }
+        if (uploader->sync_evt) {
+            vEventGroupDelete(uploader->sync_evt);
+        }
+        free(uploader);
+    }
+    ESP_LOGW(TAG, "coredump uploader destroyed");
+    return ESP_OK;
+}
+
+periph_service_handle_t coredump_upload_service_create(coredump_upload_service_config_t *config)
+{
+    coredump_upload_t *uploader = audio_calloc(1, sizeof(coredump_upload_t));
+    AUDIO_MEM_CHECK(TAG, uploader, return NULL);
+    uploader->cmd_q = xQueueCreate(2, sizeof(coredump_msg_t));
+    AUDIO_MEM_CHECK(TAG, uploader->cmd_q, {
+        free(uploader);
+        return NULL;
+    });
+    uploader->sync_evt = xEventGroupCreate();
+    AUDIO_MEM_CHECK(TAG, uploader->sync_evt, {
+        vQueueDelete(uploader->cmd_q);
+        free(uploader);
+        return NULL;
+    });
+    uploader->do_post = config->do_post != NULL ? config->do_post : coredump_do_http_post;
+    periph_service_config_t cfg = {
+        .task_stack = config->task_stack,
+        .task_prio = config->task_prio,
+        .task_core = config->task_core,
+        .task_func = coredump_upload_task,
+        .extern_stack = false, /* Need flash read operation */
+        .service_start = NULL,
+        .service_stop = NULL,
+        .service_ioctl = NULL,
+        .service_destroy = coredump_upload_deinit,
+        .service_name = "CoreDumpUpload",
+        .user_data = (void *)uploader,
+    };
+
+    periph_service_handle_t periph_coredump = periph_service_create(&cfg);
+    AUDIO_MEM_CHECK(TAG, periph_coredump, {
+        vQueueDelete(uploader->cmd_q);
+        vEventGroupDelete(uploader->sync_evt);
+        free(uploader);
+        return NULL;
+    });
+    periph_service_set_callback(periph_coredump, config->evt_cb, config->cb_ctx);
+
+    return periph_coredump;
+}
diff --git a/components/coredump_upload_service/include/coredump_upload_service.h b/components/coredump_upload_service/include/coredump_upload_service.h
index 93328e5b..266ad79d 100644
--- a/components/coredump_upload_service/include/coredump_upload_service.h
+++ b/components/coredump_upload_service/include/coredump_upload_service.h
@@ -1,95 +1,95 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __COREDUMP_UPLOAD_H__
-#define __COREDUMP_UPLOAD_H__
-
-#include <stdbool.h>
-#include "esp_err.h"
-#include "periph_service.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief coredump service configuration parameters
- */
-typedef struct {
-    int task_stack;           /*!< >0 Service task stack; =0 with out task created */
-    int task_prio;            /*!< Service task priority (based on freeRTOS priority) */
-    int task_core;            /*!< Service task running in core (0 or 1) */
-    periph_service_cb evt_cb; /*!< Service callback function */
-    void *cb_ctx;             /*!< Callback context */
-    bool (*do_post)(char *url, uint32_t *data, size_t len); /*!< POST interface, users can override this to customize the http client.
-                                                                if left NULL, the service will use the default one */
-} coredump_upload_service_config_t;
-
-#define COREDUMP_UPLOAD_SERVICE_DEFAULT_CONFIG() \
-    {                                \
-        .task_stack = 4096,          \
-        .task_prio = 5,              \
-        .task_core = 1,              \
-        .evt_cb = NULL,              \
-        .cb_ctx = NULL,              \
-        .do_post = NULL,             \
-    }
-
-/**
- * @brief      This function will check the reset code and determine whether to upload the coredump
- * @return
- *     - true: last reboot is a abnormal reset.
- *     - false
- */
-bool coredump_need_upload();
-
-/**
- * @brief      Upload the core dump image to the url.
- *             This function will block the current task until the upload process finished.
- *
- * @param[in]  handle   the 'periph_service_handle_t'
- * @param[in]  url      server addr
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t coredump_upload(periph_service_handle_t handle, char *url);
-
-/**
- * @brief     Create the core dump upload service instance
- *
- * @param     config  configuration of the OTA service
- *
- * @return
- *    - NULL:  Failed
- *    - Others: Success
- */
-periph_service_handle_t coredump_upload_service_create(coredump_upload_service_config_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __COREDUMP_UPLOAD_H__ */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __COREDUMP_UPLOAD_H__
+#define __COREDUMP_UPLOAD_H__
+
+#include <stdbool.h>
+#include "esp_err.h"
+#include "periph_service.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief coredump service configuration parameters
+ */
+typedef struct {
+    int task_stack;           /*!< >0 Service task stack; =0 with out task created */
+    int task_prio;            /*!< Service task priority (based on freeRTOS priority) */
+    int task_core;            /*!< Service task running in core (0 or 1) */
+    periph_service_cb evt_cb; /*!< Service callback function */
+    void *cb_ctx;             /*!< Callback context */
+    bool (*do_post)(char *url, uint32_t *data, size_t len); /*!< POST interface, users can override this to customize the http client.
+                                                                if left NULL, the service will use the default one */
+} coredump_upload_service_config_t;
+
+#define COREDUMP_UPLOAD_SERVICE_DEFAULT_CONFIG() \
+    {                                \
+        .task_stack = 4096,          \
+        .task_prio = 5,              \
+        .task_core = 1,              \
+        .evt_cb = NULL,              \
+        .cb_ctx = NULL,              \
+        .do_post = NULL,             \
+    }
+
+/**
+ * @brief      This function will check the reset code and determine whether to upload the coredump
+ * @return
+ *     - true: last reboot is a abnormal reset.
+ *     - false
+ */
+bool coredump_need_upload();
+
+/**
+ * @brief      Upload the core dump image to the url.
+ *             This function will block the current task until the upload process finished.
+ *
+ * @param[in]  handle   the 'periph_service_handle_t'
+ * @param[in]  url      server addr
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t coredump_upload(periph_service_handle_t handle, char *url);
+
+/**
+ * @brief     Create the core dump upload service instance
+ *
+ * @param     config  configuration of the OTA service
+ *
+ * @return
+ *    - NULL:  Failed
+ *    - Others: Success
+ */
+periph_service_handle_t coredump_upload_service_create(coredump_upload_service_config_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __COREDUMP_UPLOAD_H__ */
diff --git a/components/dueros_service/CMakeLists.txt b/components/dueros_service/CMakeLists.txt
index fcf5b701..02d2cf77 100644
--- a/components/dueros_service/CMakeLists.txt
+++ b/components/dueros_service/CMakeLists.txt
@@ -1,51 +1,51 @@
-set(COMPONENT_ADD_INCLUDEDIRS include)
-
-# Edit following two lines to set component requirements (see docs)
-set(COMPONENT_REQUIRES )
-set(COMPONENT_PRIV_REQUIRES clouds mbedtls audio_board audio_hal esp-adf-libs audio_sal esp_peripherals audio_recorder wifi_service)
-
-set (duer_srcs
-    "dueros_service.c"
-    "esp_audio_device_info.c"
-    "dueros_esp_flash.c"
-    "duer_profile.c"
-    "duer_wifi_cfg.c"
-)
-
-if (CONFIG_BT_BLE_ENABLED)
-    list(APPEND duer_srcs "duer_wifi_cfg_bluedroid.c")
-else()
-    list(APPEND duer_srcs "duer_wifi_cfg_dummy.c")
-endif()
-
-set(COMPONENT_SRCS ${duer_srcs})
-
-register_component()
-
-target_link_libraries(${COMPONENT_LIB} INTERFACE "-u duer_flash_erase")
-target_link_libraries(${COMPONENT_LIB} INTERFACE "-u duer_flash_read")
-target_link_libraries(${COMPONENT_LIB} INTERFACE "-u duer_flash_write")
-
-partition_table_get_partition_info(NVS_PARTITION_SIZE "--partition-name nvs" "size")
-
-if ("${NVS_PARTITION_SIZE}" AND CONFIG_DUEROS_GEN_PROFILE)
-
-    set(NVS_GEN_PY $ENV{IDF_PATH}/components/nvs_flash/nvs_partition_generator/nvs_partition_gen.py)
-    set(NVS_IMAGE  ${CMAKE_BINARY_DIR}/duer_profile.bin)
-    set(NVS_TABLE  ${COMPONENT_DIR}/nvs.csv)
-
-    add_custom_target(duer_profile_bin ALL
-        COMMAND ${PYTHON} ${NVS_GEN_PY} generate ${NVS_TABLE} ${NVS_IMAGE} ${NVS_PARTITION_SIZE}
-        WORKING_DIRECTORY ${COMPONENT_DIR}
-        DEPENDS ${COMPONENT_DIR}/duer_profile ${NVS_TABLE}
-    )
-
-    set_property(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}" APPEND PROPERTY
-            ADDITIONAL_MAKE_CLEAN_FILES
-            ${NVS_IMAGE})
-
-    if (CONFIG_DUEROS_FLASH_PROFILE)
-        add_dependencies(flash duer_profile_bin)
-        esptool_py_flash_to_partition(flash "nvs" "${NVS_IMAGE}")
-    endif()
-endif()
+set(COMPONENT_ADD_INCLUDEDIRS include)
+
+# Edit following two lines to set component requirements (see docs)
+set(COMPONENT_REQUIRES )
+set(COMPONENT_PRIV_REQUIRES clouds mbedtls audio_board audio_hal esp-adf-libs audio_sal esp_peripherals audio_recorder wifi_service)
+
+set (duer_srcs
+    "dueros_service.c"
+    "esp_audio_device_info.c"
+    "dueros_esp_flash.c"
+    "duer_profile.c"
+    "duer_wifi_cfg.c"
+)
+
+if (CONFIG_BT_BLE_ENABLED)
+    list(APPEND duer_srcs "duer_wifi_cfg_bluedroid.c")
+else()
+    list(APPEND duer_srcs "duer_wifi_cfg_dummy.c")
+endif()
+
+set(COMPONENT_SRCS ${duer_srcs})
+
+register_component()
+
+target_link_libraries(${COMPONENT_LIB} INTERFACE "-u duer_flash_erase")
+target_link_libraries(${COMPONENT_LIB} INTERFACE "-u duer_flash_read")
+target_link_libraries(${COMPONENT_LIB} INTERFACE "-u duer_flash_write")
+
+partition_table_get_partition_info(NVS_PARTITION_SIZE "--partition-name nvs" "size")
+
+if ("${NVS_PARTITION_SIZE}" AND CONFIG_DUEROS_GEN_PROFILE)
+
+    set(NVS_GEN_PY $ENV{IDF_PATH}/components/nvs_flash/nvs_partition_generator/nvs_partition_gen.py)
+    set(NVS_IMAGE  ${CMAKE_BINARY_DIR}/duer_profile.bin)
+    set(NVS_TABLE  ${COMPONENT_DIR}/nvs.csv)
+
+    add_custom_target(duer_profile_bin ALL
+        COMMAND ${PYTHON} ${NVS_GEN_PY} generate ${NVS_TABLE} ${NVS_IMAGE} ${NVS_PARTITION_SIZE}
+        WORKING_DIRECTORY ${COMPONENT_DIR}
+        DEPENDS ${COMPONENT_DIR}/duer_profile ${NVS_TABLE}
+    )
+
+    set_property(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}" APPEND PROPERTY
+            ADDITIONAL_MAKE_CLEAN_FILES
+            ${NVS_IMAGE})
+
+    if (CONFIG_DUEROS_FLASH_PROFILE)
+        add_dependencies(flash duer_profile_bin)
+        esptool_py_flash_to_partition(flash "nvs" "${NVS_IMAGE}")
+    endif()
+endif()
diff --git a/components/dueros_service/Kconfig b/components/dueros_service/Kconfig
index 3753383b..1f9755dd 100644
--- a/components/dueros_service/Kconfig
+++ b/components/dueros_service/Kconfig
@@ -1,16 +1,16 @@
-menu "DuerOS Service"
-
-    config DUEROS_GEN_PROFILE
-        bool "Generate the nvs partition which include the profile of dueros"
-        default n
-
-    config DUEROS_FLASH_PROFILE
-        depends on DUEROS_GEN_PROFILE
-        bool "Flash the generated nvs partition"
-        default n
-
-    config DUEROS_DEVICE_NAME
-        string "Duer device name"
-        default "Duer Name"
-
+menu "DuerOS Service"
+
+    config DUEROS_GEN_PROFILE
+        bool "Generate the nvs partition which include the profile of dueros"
+        default n
+
+    config DUEROS_FLASH_PROFILE
+        depends on DUEROS_GEN_PROFILE
+        bool "Flash the generated nvs partition"
+        default n
+
+    config DUEROS_DEVICE_NAME
+        string "Duer device name"
+        default "Duer Name"
+
 endmenu
\ No newline at end of file
diff --git a/components/dueros_service/component.mk b/components/dueros_service/component.mk
index 146e6060..760ad000 100644
--- a/components/dueros_service/component.mk
+++ b/components/dueros_service/component.mk
@@ -1,6 +1,6 @@
-#
-# Main Makefile. This is basically the same as a component makefile.
-
-COMPONENT_ADD_INCLUDEDIRS := include
-COMPONENT_SRCDIRS := .
+#
+# Main Makefile. This is basically the same as a component makefile.
+
+COMPONENT_ADD_INCLUDEDIRS := include
+COMPONENT_SRCDIRS := .
 COMPONENT_EMBED_TXTFILES := duer_profile
\ No newline at end of file
diff --git a/components/dueros_service/duer_profile.c b/components/dueros_service/duer_profile.c
index 7effd16a..71f11c07 100644
--- a/components/dueros_service/duer_profile.c
+++ b/components/dueros_service/duer_profile.c
@@ -1,173 +1,173 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <string.h>
-
-#include "duer_profile.h"
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "baidu_json.h"
-#include "esp_types.h"
-#include "esp_log.h"
-#include "nvs.h"
-
-#define DUER_USER_AGENT_VER ("app/3.0.0.1 DcsSdk/3.3 didp/1 version/1")
-
-static char *TAG = "DUER_PROFILE";
-
-const char *duer_profile_load(void)
-{
-    nvs_handle_t handle = 0;
-    size_t len = 0;
-    esp_err_t ret = ESP_FAIL;
-    char *profile = NULL;
-
-    ret = nvs_open("duer", NVS_READWRITE, &handle);
-    AUDIO_CHECK(TAG, ret == ESP_OK, return NULL, "The duer profile nvs open failed");
-
-    ret = nvs_get_str(handle, "profile", NULL, &len);
-    AUDIO_CHECK(TAG, ret == ESP_OK, goto error, "The duer profile nvs get str len failed");
-
-    profile = audio_calloc(1, len + 1);
-    AUDIO_NULL_CHECK(TAG, profile, goto error);
-
-    ret = nvs_get_str(handle, "profile", profile, &len);
-    AUDIO_CHECK(TAG, ret == ESP_OK, goto error, "The duer profile nvs get str failed");
-    ESP_LOGI(TAG, "profile %s", profile);
-
-    nvs_close(handle);
-    return profile;
-
-error:
-    nvs_close(handle);
-    if (profile) {
-        free(profile);
-    }
-    return NULL;
-}
-
-void duer_profile_release(const char *profile)
-{
-    free((void *)profile);
-}
-
-esp_err_t duer_profile_update(const char *bduss, const char *client_id)
-{
-    esp_err_t ret = ESP_FAIL;
-    baidu_json *root = NULL;
-    char *result = NULL;
-    nvs_handle_t handle = 0;
-
-    const char *profile = duer_profile_load();
-    AUDIO_NULL_CHECK(TAG, profile, { ret = ESP_FAIL; goto exit; });
-
-    root = baidu_json_Parse(profile);
-    AUDIO_NULL_CHECK(TAG, root, { ret = ESP_FAIL; goto exit; });
-
-    baidu_json *bduss_json = baidu_json_CreateString(bduss, 0);
-    if (baidu_json_HasObjectItem(root, "bduss")) {
-        baidu_json_ReplaceItemInObject(root, "bduss", bduss_json);
-    } else {
-        baidu_json_AddItemToObject(root, "bduss", bduss_json);
-    }
-
-    baidu_json *client_json = baidu_json_CreateString(client_id, 0);
-    if (baidu_json_HasObjectItem(root, "clientId")) {
-        baidu_json_ReplaceItemInObject(root, "clientId", client_json);
-    } else {
-        baidu_json_AddItemToObject(root, "clientId", client_json);
-    }
-
-    baidu_json *user_agent_json = baidu_json_CreateString(DUER_USER_AGENT_VER, 0);
-    if (baidu_json_HasObjectItem(root, "userAgent")) {
-        baidu_json_ReplaceItemInObject(root, "userAgent", user_agent_json);
-    } else {
-        baidu_json_AddItemToObject(root, "userAgent", user_agent_json);
-    }
-
-    result = baidu_json_Print(root);
-    AUDIO_NULL_CHECK(TAG, result, { ret = ESP_ERR_NO_MEM; goto exit; });
-    ESP_LOGV(TAG, "profile final %s", result);
-
-    ret = nvs_open("duer", NVS_READWRITE, &handle);
-    AUDIO_CHECK(TAG, ret == ESP_OK, goto exit, "The duer profile nvs open failed");
-
-    ret = nvs_set_str(handle, "profile", result);
-    AUDIO_CHECK(TAG, ret == ESP_OK, , "The duer profile nvs set string failed");
-
-exit:
-    if (handle) {
-        nvs_close(handle);
-    }
-    if (root) {
-        baidu_json_Delete(root);
-    }
-    if (result) {
-        baidu_json_release(result);
-    }
-    if (profile) {
-        duer_profile_release(profile);
-    }
-    return ret;
-}
-
-int32_t duer_profile_certified()
-{
-    const char *profile = duer_profile_load();
-    AUDIO_NULL_CHECK(TAG, profile, return 1);
-
-    baidu_json *root = baidu_json_Parse(profile);
-    AUDIO_NULL_CHECK(TAG, root, return 2);
-
-    int32_t ret = -3;
-    if (baidu_json_HasObjectItem(root, "bduss") &&
-        baidu_json_HasObjectItem(root, "clientid") &&
-        baidu_json_HasObjectItem(root, "userAgent")) {
-        ret = 0;
-    } else {
-        ret = 3;
-    }
-    baidu_json_Delete(root);
-    duer_profile_release(profile);
-    return ret;
-}
-
-int32_t duer_profile_get_uuid(char *buf, size_t blen)
-{
-    const char *profile = duer_profile_load();
-    AUDIO_NULL_CHECK(TAG, profile, return 1);
-
-    baidu_json *root = baidu_json_Parse(profile);
-    AUDIO_NULL_CHECK(TAG, root, return 2);
-
-    int32_t ret = 3;
-    baidu_json *uuid = baidu_json_GetObjectItem(root, "uuid");
-    if (uuid) {
-        ret = 0;
-        snprintf(buf, blen, "%s", uuid->valuestring);
-        ESP_LOGI(TAG, "got uuid form profile: %s", buf);
-    }
-    baidu_json_Delete(root);
-    duer_profile_release(profile);
-    return ret;
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <string.h>
+
+#include "duer_profile.h"
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "baidu_json.h"
+#include "esp_types.h"
+#include "esp_log.h"
+#include "nvs.h"
+
+#define DUER_USER_AGENT_VER ("app/3.0.0.1 DcsSdk/3.3 didp/1 version/1")
+
+static char *TAG = "DUER_PROFILE";
+
+const char *duer_profile_load(void)
+{
+    nvs_handle_t handle = 0;
+    size_t len = 0;
+    esp_err_t ret = ESP_FAIL;
+    char *profile = NULL;
+
+    ret = nvs_open("duer", NVS_READWRITE, &handle);
+    AUDIO_CHECK(TAG, ret == ESP_OK, return NULL, "The duer profile nvs open failed");
+
+    ret = nvs_get_str(handle, "profile", NULL, &len);
+    AUDIO_CHECK(TAG, ret == ESP_OK, goto error, "The duer profile nvs get str len failed");
+
+    profile = audio_calloc(1, len + 1);
+    AUDIO_NULL_CHECK(TAG, profile, goto error);
+
+    ret = nvs_get_str(handle, "profile", profile, &len);
+    AUDIO_CHECK(TAG, ret == ESP_OK, goto error, "The duer profile nvs get str failed");
+    ESP_LOGI(TAG, "profile %s", profile);
+
+    nvs_close(handle);
+    return profile;
+
+error:
+    nvs_close(handle);
+    if (profile) {
+        free(profile);
+    }
+    return NULL;
+}
+
+void duer_profile_release(const char *profile)
+{
+    free((void *)profile);
+}
+
+esp_err_t duer_profile_update(const char *bduss, const char *client_id)
+{
+    esp_err_t ret = ESP_FAIL;
+    baidu_json *root = NULL;
+    char *result = NULL;
+    nvs_handle_t handle = 0;
+
+    const char *profile = duer_profile_load();
+    AUDIO_NULL_CHECK(TAG, profile, { ret = ESP_FAIL; goto exit; });
+
+    root = baidu_json_Parse(profile);
+    AUDIO_NULL_CHECK(TAG, root, { ret = ESP_FAIL; goto exit; });
+
+    baidu_json *bduss_json = baidu_json_CreateString(bduss, 0);
+    if (baidu_json_HasObjectItem(root, "bduss")) {
+        baidu_json_ReplaceItemInObject(root, "bduss", bduss_json);
+    } else {
+        baidu_json_AddItemToObject(root, "bduss", bduss_json);
+    }
+
+    baidu_json *client_json = baidu_json_CreateString(client_id, 0);
+    if (baidu_json_HasObjectItem(root, "clientId")) {
+        baidu_json_ReplaceItemInObject(root, "clientId", client_json);
+    } else {
+        baidu_json_AddItemToObject(root, "clientId", client_json);
+    }
+
+    baidu_json *user_agent_json = baidu_json_CreateString(DUER_USER_AGENT_VER, 0);
+    if (baidu_json_HasObjectItem(root, "userAgent")) {
+        baidu_json_ReplaceItemInObject(root, "userAgent", user_agent_json);
+    } else {
+        baidu_json_AddItemToObject(root, "userAgent", user_agent_json);
+    }
+
+    result = baidu_json_Print(root);
+    AUDIO_NULL_CHECK(TAG, result, { ret = ESP_ERR_NO_MEM; goto exit; });
+    ESP_LOGV(TAG, "profile final %s", result);
+
+    ret = nvs_open("duer", NVS_READWRITE, &handle);
+    AUDIO_CHECK(TAG, ret == ESP_OK, goto exit, "The duer profile nvs open failed");
+
+    ret = nvs_set_str(handle, "profile", result);
+    AUDIO_CHECK(TAG, ret == ESP_OK, , "The duer profile nvs set string failed");
+
+exit:
+    if (handle) {
+        nvs_close(handle);
+    }
+    if (root) {
+        baidu_json_Delete(root);
+    }
+    if (result) {
+        baidu_json_release(result);
+    }
+    if (profile) {
+        duer_profile_release(profile);
+    }
+    return ret;
+}
+
+int32_t duer_profile_certified()
+{
+    const char *profile = duer_profile_load();
+    AUDIO_NULL_CHECK(TAG, profile, return 1);
+
+    baidu_json *root = baidu_json_Parse(profile);
+    AUDIO_NULL_CHECK(TAG, root, return 2);
+
+    int32_t ret = -3;
+    if (baidu_json_HasObjectItem(root, "bduss") &&
+        baidu_json_HasObjectItem(root, "clientid") &&
+        baidu_json_HasObjectItem(root, "userAgent")) {
+        ret = 0;
+    } else {
+        ret = 3;
+    }
+    baidu_json_Delete(root);
+    duer_profile_release(profile);
+    return ret;
+}
+
+int32_t duer_profile_get_uuid(char *buf, size_t blen)
+{
+    const char *profile = duer_profile_load();
+    AUDIO_NULL_CHECK(TAG, profile, return 1);
+
+    baidu_json *root = baidu_json_Parse(profile);
+    AUDIO_NULL_CHECK(TAG, root, return 2);
+
+    int32_t ret = 3;
+    baidu_json *uuid = baidu_json_GetObjectItem(root, "uuid");
+    if (uuid) {
+        ret = 0;
+        snprintf(buf, blen, "%s", uuid->valuestring);
+        ESP_LOGI(TAG, "got uuid form profile: %s", buf);
+    }
+    baidu_json_Delete(root);
+    duer_profile_release(profile);
+    return ret;
 }
\ No newline at end of file
diff --git a/components/dueros_service/duer_wifi_cfg.c b/components/dueros_service/duer_wifi_cfg.c
index a1017cec..26d43f8a 100644
--- a/components/dueros_service/duer_wifi_cfg.c
+++ b/components/dueros_service/duer_wifi_cfg.c
@@ -1,169 +1,169 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_err.h"
-#include "esp_log.h"
-#include "esp_wifi.h"
-
-#include "audio_mem.h"
-#include "audio_error.h"
-#include "esp_err.h"
-#include "rom/ets_sys.h"
-
-#include "duer_wifi_cfg.h"
-#include "duer_wifi_cfg_if.h"
-#include "duer_profile.h"
-#include "lightduer_dipb_data_handler.h"
-#include "lightduer_types.h"
-
-#define DUER_DEV_ID_LEN (32)
-
-static duer_wifi_cfg_t *duer_wifi_cfg;
-static char duer_device_id[DUER_DEV_ID_LEN];
-static const char *TAG = "DUER_WIFI_CFG";
-
-static void duer_on_ble_recv_data(void *data, size_t len, uint16_t handle)
-{
-    duer_dipb_data_handler_recv_data(data, len, handle);
-}
-
-static void duer_on_ble_connect_status(bool status)
-{
-    if (status == false) {
-        duer_wifi_cfg->user_cb(DUER_WIFI_CFG_BLE_DISC, NULL);
-    } else {
-        duer_wifi_cfg->user_cb(DUER_WIFI_CFG_BLE_CONN, NULL);
-    }
-}
-
-static duer_ap_t *scan_wifi(int *list_num)
-{
-    uint16_t ap_num = 0;
-    wifi_ap_record_t *ap_record = NULL;
-    duer_ap_t *duer_record = NULL;
-
-    *list_num = 0;
-
-    wifi_scan_config_t scan_config = { 0 };
-    scan_config.show_hidden = true;
-    esp_wifi_scan_start(&scan_config, true);
-    esp_wifi_scan_get_ap_num(&ap_num);
-    if (ap_num) {
-        ap_record = audio_calloc(1, ap_num * sizeof(wifi_ap_record_t));
-        AUDIO_NULL_CHECK(TAG, ap_record, return NULL);
-        duer_record = audio_calloc(1, ap_num * sizeof(duer_ap_t));
-        AUDIO_NULL_CHECK(TAG, duer_record, { audio_free(ap_record); return NULL; });
-        esp_wifi_scan_get_ap_records(&ap_num, ap_record);
-        for (int i = 0; i < ap_num; i++) {
-            ESP_LOGI(TAG, "scan ap: %s, "MACSTR", %u, %u, %d, %d", ap_record[i].ssid,
-                         MAC2STR(ap_record[i].bssid), ap_record[i].primary,
-                         ap_record[i].second, ap_record[i].rssi, ap_record[i].authmode);
-            memcpy(duer_record[i].ssid, ap_record[i].ssid, 33);
-            duer_record[i].mode = ap_record[i].authmode == WIFI_AUTH_OPEN ? 0 : 1;
-        }
-        audio_free(ap_record);
-    }
-    *list_num = ap_num;
-
-    // `duer_record` will be freed in `dipb`
-    return duer_record;
-}
-
-static int wifi_info(const char *ssid, const char *pwd,
-    const char *bduss, const char *device_bduss)
-{
-    if (duer_wifi_cfg->user_cb) {
-        duer_wifi_ssid_get_t wifi_info = {
-            .ssid = (char *)ssid,
-            .pwd = (char *)pwd,
-            .bduss = (char *)bduss,
-            .device_bduss = (char *)device_bduss,
-        };
-        duer_wifi_cfg->user_cb(DUER_WIFI_CFG_SSID_GET, &wifi_info);
-    }
-    return 0;
-}
-
-static const char *get_profile_value(int key)
-{
-    switch (key) {
-        case PROFILE_KEY_CLIENT_ID:
-            return duer_wifi_cfg->client_id;
-        case PROFILE_KEY_DEVICE_ID:
-            return duer_device_id;
-        case PROFILE_KEY_DEVICE_ECC_PUB_KEY:
-            return duer_wifi_cfg->pub_key;
-        default:
-            return NULL;
-    }
-}
-
-static void set_device_id(const char *device_id)
-{
-    ESP_LOGW(TAG, "set_device_id %s", device_id);
-}
-
-static duer_ble_wifi_cfg_callbacks_t host_cb = {
-    .on_ble_recv_data = duer_on_ble_recv_data,
-    .on_ble_connect_status = duer_on_ble_connect_status,
-};
-
-static duer_dipb_data_handler_callbacks_t dipb_cbs = {
-    .ble_send_data = duer_ble_send_data,
-    .scan_wifi = scan_wifi,
-    .handle_wifi_info = wifi_info,
-    .get_profile_value = get_profile_value,
-    .set_device_id = set_device_id,
-};
-
-int duer_wifi_cfg_init(duer_wifi_cfg_t *cfg)
-{
-    if (duer_wifi_cfg) {
-        ESP_LOGW(TAG, "Duer wifi configuration already in process");
-        return -1;
-    }
-    duer_wifi_cfg = audio_calloc(1, sizeof(duer_wifi_cfg_t));
-    AUDIO_NULL_CHECK(TAG, duer_wifi_cfg, return ESP_ERR_NO_MEM);
-    memcpy(duer_wifi_cfg, cfg, sizeof(duer_wifi_cfg_t));
-
-    ESP_ERROR_CHECK(duer_profile_get_uuid(duer_device_id, DUER_DEV_ID_LEN - 1));
-    ESP_ERROR_CHECK(duer_wifi_cfg_ble_host_init(&host_cb));
-    ESP_ERROR_CHECK(duer_dipb_data_handler_init(&dipb_cbs));
-
-    return 0;
-}
-
-int duer_wifi_cfg_deinit(void)
-{
-    if (!duer_wifi_cfg) {
-        ESP_LOGW(TAG, "Duer wifi configuration not init");
-        return -1;
-    }
-    ESP_ERROR_CHECK(duer_wifi_cfg_ble_host_deinit());
-    ESP_ERROR_CHECK(duer_dipb_data_handler_deinit());
-    audio_free(duer_wifi_cfg);
-    duer_wifi_cfg = NULL;
-    memset(duer_device_id, 0x00, DUER_DEV_ID_LEN);
-    return 0;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_err.h"
+#include "esp_log.h"
+#include "esp_wifi.h"
+
+#include "audio_mem.h"
+#include "audio_error.h"
+#include "esp_err.h"
+#include "rom/ets_sys.h"
+
+#include "duer_wifi_cfg.h"
+#include "duer_wifi_cfg_if.h"
+#include "duer_profile.h"
+#include "lightduer_dipb_data_handler.h"
+#include "lightduer_types.h"
+
+#define DUER_DEV_ID_LEN (32)
+
+static duer_wifi_cfg_t *duer_wifi_cfg;
+static char duer_device_id[DUER_DEV_ID_LEN];
+static const char *TAG = "DUER_WIFI_CFG";
+
+static void duer_on_ble_recv_data(void *data, size_t len, uint16_t handle)
+{
+    duer_dipb_data_handler_recv_data(data, len, handle);
+}
+
+static void duer_on_ble_connect_status(bool status)
+{
+    if (status == false) {
+        duer_wifi_cfg->user_cb(DUER_WIFI_CFG_BLE_DISC, NULL);
+    } else {
+        duer_wifi_cfg->user_cb(DUER_WIFI_CFG_BLE_CONN, NULL);
+    }
+}
+
+static duer_ap_t *scan_wifi(int *list_num)
+{
+    uint16_t ap_num = 0;
+    wifi_ap_record_t *ap_record = NULL;
+    duer_ap_t *duer_record = NULL;
+
+    *list_num = 0;
+
+    wifi_scan_config_t scan_config = { 0 };
+    scan_config.show_hidden = true;
+    esp_wifi_scan_start(&scan_config, true);
+    esp_wifi_scan_get_ap_num(&ap_num);
+    if (ap_num) {
+        ap_record = audio_calloc(1, ap_num * sizeof(wifi_ap_record_t));
+        AUDIO_NULL_CHECK(TAG, ap_record, return NULL);
+        duer_record = audio_calloc(1, ap_num * sizeof(duer_ap_t));
+        AUDIO_NULL_CHECK(TAG, duer_record, { audio_free(ap_record); return NULL; });
+        esp_wifi_scan_get_ap_records(&ap_num, ap_record);
+        for (int i = 0; i < ap_num; i++) {
+            ESP_LOGI(TAG, "scan ap: %s, "MACSTR", %u, %u, %d, %d", ap_record[i].ssid,
+                         MAC2STR(ap_record[i].bssid), ap_record[i].primary,
+                         ap_record[i].second, ap_record[i].rssi, ap_record[i].authmode);
+            memcpy(duer_record[i].ssid, ap_record[i].ssid, 33);
+            duer_record[i].mode = ap_record[i].authmode == WIFI_AUTH_OPEN ? 0 : 1;
+        }
+        audio_free(ap_record);
+    }
+    *list_num = ap_num;
+
+    // `duer_record` will be freed in `dipb`
+    return duer_record;
+}
+
+static int wifi_info(const char *ssid, const char *pwd,
+    const char *bduss, const char *device_bduss)
+{
+    if (duer_wifi_cfg->user_cb) {
+        duer_wifi_ssid_get_t wifi_info = {
+            .ssid = (char *)ssid,
+            .pwd = (char *)pwd,
+            .bduss = (char *)bduss,
+            .device_bduss = (char *)device_bduss,
+        };
+        duer_wifi_cfg->user_cb(DUER_WIFI_CFG_SSID_GET, &wifi_info);
+    }
+    return 0;
+}
+
+static const char *get_profile_value(int key)
+{
+    switch (key) {
+        case PROFILE_KEY_CLIENT_ID:
+            return duer_wifi_cfg->client_id;
+        case PROFILE_KEY_DEVICE_ID:
+            return duer_device_id;
+        case PROFILE_KEY_DEVICE_ECC_PUB_KEY:
+            return duer_wifi_cfg->pub_key;
+        default:
+            return NULL;
+    }
+}
+
+static void set_device_id(const char *device_id)
+{
+    ESP_LOGW(TAG, "set_device_id %s", device_id);
+}
+
+static duer_ble_wifi_cfg_callbacks_t host_cb = {
+    .on_ble_recv_data = duer_on_ble_recv_data,
+    .on_ble_connect_status = duer_on_ble_connect_status,
+};
+
+static duer_dipb_data_handler_callbacks_t dipb_cbs = {
+    .ble_send_data = duer_ble_send_data,
+    .scan_wifi = scan_wifi,
+    .handle_wifi_info = wifi_info,
+    .get_profile_value = get_profile_value,
+    .set_device_id = set_device_id,
+};
+
+int duer_wifi_cfg_init(duer_wifi_cfg_t *cfg)
+{
+    if (duer_wifi_cfg) {
+        ESP_LOGW(TAG, "Duer wifi configuration already in process");
+        return -1;
+    }
+    duer_wifi_cfg = audio_calloc(1, sizeof(duer_wifi_cfg_t));
+    AUDIO_NULL_CHECK(TAG, duer_wifi_cfg, return ESP_ERR_NO_MEM);
+    memcpy(duer_wifi_cfg, cfg, sizeof(duer_wifi_cfg_t));
+
+    ESP_ERROR_CHECK(duer_profile_get_uuid(duer_device_id, DUER_DEV_ID_LEN - 1));
+    ESP_ERROR_CHECK(duer_wifi_cfg_ble_host_init(&host_cb));
+    ESP_ERROR_CHECK(duer_dipb_data_handler_init(&dipb_cbs));
+
+    return 0;
+}
+
+int duer_wifi_cfg_deinit(void)
+{
+    if (!duer_wifi_cfg) {
+        ESP_LOGW(TAG, "Duer wifi configuration not init");
+        return -1;
+    }
+    ESP_ERROR_CHECK(duer_wifi_cfg_ble_host_deinit());
+    ESP_ERROR_CHECK(duer_dipb_data_handler_deinit());
+    audio_free(duer_wifi_cfg);
+    duer_wifi_cfg = NULL;
+    memset(duer_device_id, 0x00, DUER_DEV_ID_LEN);
+    return 0;
+}
diff --git a/components/dueros_service/duer_wifi_cfg_bluedroid.c b/components/dueros_service/duer_wifi_cfg_bluedroid.c
index bcbcc989..5032b87d 100644
--- a/components/dueros_service/duer_wifi_cfg_bluedroid.c
+++ b/components/dueros_service/duer_wifi_cfg_bluedroid.c
@@ -1,604 +1,604 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <assert.h>
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/event_groups.h"
-#include "freertos/queue.h"
-#include "freertos/task.h"
-
-#include "esp_err.h"
-#include "esp_log.h"
-
-#include "lightduer_lib.h"
-#include "lightduer_log.h"
-#include "lightduer_memory.h"
-
-#include "audio_mem.h"
-#include "duer_wifi_cfg.h"
-#include "duer_wifi_cfg_if.h"
-
-#ifdef CONFIG_BT_BLE_ENABLED
-#include "esp_gap_ble_api.h"
-#include "esp_gatt_common_api.h"
-#include "esp_gatts_api.h"
-
-enum {
-    BLE_IDX_SVC,
-    BLE_IDX_TX_CHAR,
-    BLE_IDX_TX_VAL,
-    BLE_IDX_TX_NOTIFY_CFG,
-    BLE_IDX_RX_CHAR,
-    BLE_IDX_RX_VAL,
-    BLE_IDX_RX_NOTIFY_CFG,
-    BLE_IDX_NB,
-};
-
-enum {
-    DUER_BLE_MSG_DATA,
-    DUER_BLE_MSG_CONNECT,
-    DUER_BLE_MSG_DISCONNECT,
-    DUER_BLE_MSG_EXIT
-};
-
-typedef struct {
-    uint8_t msg_id;
-    uint8_t *data;
-    uint16_t data_len;
-    uint16_t handle;
-} duer_ble_msg_t;
-
-#define BLE_WIFI_CFG_GATTC_MTU_SIZE    (23)
-#define PREPARE_BUF_MAX_SIZE           (1024)
-#define BLE_WIFI_CFG_SERVICE_UUID      (0x1111)
-#define BLE_WIFI_CFG_PRIMARY_CHAR_UUID (0x2222)
-#define BLE_WIFI_CFG_SECOND_CHAR_UUID  (0x3333)
-#define ADV_CONFIG_FLAG                (1 << 0)
-#define SCAN_RSP_CONFIG_FLAG           (1 << 1)
-#define ESP_BLE_WIFI_CFG_APP_ID        (0x3344)
-#define MTU_RESERVED_SIZE              (3)
-
-static const char *TAG = "DUER_WIFI_CFG_BLE";
-
-static esp_gatt_if_t s_sg_gatts_if  = 0xff;
-static uint16_t s_sg_conn_id        = 0xffff;
-static uint16_t s_service_handle    = 0xffff;
-static uint8_t s_adv_config_done    = 0;
-static bool s_blecfg_alive          = 0;
-static uint16_t s_prepare_handle    = 0;
-static uint8_t *s_prepare_buf       = NULL;
-static int s_prepare_buf_len        = 0;
-static int s_ble_mtu                = BLE_WIFI_CFG_GATTC_MTU_SIZE;
-static xQueueHandle s_msg_queue     = 0;
-static EventGroupHandle_t s_send_done = 0;
-
-static uint8_t MANUFACTURER_DATA[4] = { 0x1C, 0x01, 0x01, 0x11 };
-
-static esp_ble_adv_params_t s_adv_params = {
-    .adv_int_min        = 0x20,
-    .adv_int_max        = 0x40,
-    .adv_type           = ADV_TYPE_IND,
-    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,
-    .channel_map        = ADV_CHNL_ALL,
-    .adv_filter_policy  = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
-};
-
-static uint8_t ble_wifi_cfg_service_uuid128[] = {
-    /* LSB <--------------------------------------------------------------------------------> MSB */
-    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00
-};
-
-static esp_ble_adv_data_t s_adv_data = {
-    .set_scan_rsp        = 0,
-    .include_name        = 0,
-    .include_txpower     = 1,
-    .min_interval        = 0x20,
-    .max_interval        = 0x40,
-    .appearance          = 0x00,
-    .manufacturer_len    = sizeof(MANUFACTURER_DATA),
-    .p_manufacturer_data = MANUFACTURER_DATA,
-    .service_data_len    = 0,
-    .p_service_data      = NULL,
-    .service_uuid_len    = sizeof(ble_wifi_cfg_service_uuid128),
-    .p_service_uuid      = ble_wifi_cfg_service_uuid128,
-    .flag                = (ESP_BLE_ADV_FLAG_LIMIT_DISC | ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
-};
-
-static esp_ble_adv_data_t s_scan_rsp_data = {
-    .set_scan_rsp        = 1,
-    .include_name        = 1,
-    .include_txpower     = 1,
-    .appearance          = 0x00,
-    .manufacturer_len    = 0,
-    .p_manufacturer_data = NULL,
-    .service_data_len    = 0,
-    .p_service_data      = NULL,
-    .flag                = (ESP_BLE_ADV_FLAG_LIMIT_DISC | ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
-};
-
-static const uint8_t s_char_prop = (ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE
-        | ESP_GATT_CHAR_PROP_BIT_WRITE_NR | ESP_GATT_CHAR_PROP_BIT_INDICATE | ESP_GATT_CHAR_PROP_BIT_NOTIFY);
-
-static const uint16_t s_primary_service_uuid    = ESP_GATT_UUID_PRI_SERVICE;
-static const uint16_t s_service_uuid            = BLE_WIFI_CFG_SERVICE_UUID;
-static const uint16_t s_primary_char_uuid       = BLE_WIFI_CFG_PRIMARY_CHAR_UUID;
-static const uint16_t s_second_char_uuid        = BLE_WIFI_CFG_SECOND_CHAR_UUID;
-static const uint16_t s_desc_uuid               = ESP_GATT_UUID_CHAR_DECLARE; // ESP_GATT_UUID_CHAR_CLIENT_CONFIG
-static const uint16_t s_client_config_uuid      = ESP_GATT_UUID_CHAR_CLIENT_CONFIG;
-
-static duer_ble_wifi_cfg_callbacks_t s_callbacks;
-
-static uint16_t s_primary_char_handle;
-static uint16_t s_second_char_handle;
-
-/* Full Database Description - Used to add attributes into the database */
-static const esp_gatts_attr_db_t s_ble_gatt_db[BLE_IDX_NB] =
-{
-    // Service Declaration
-    [BLE_IDX_SVC]            =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_primary_service_uuid, ESP_GATT_PERM_READ,
-      sizeof(s_service_uuid), sizeof(s_service_uuid), (uint8_t *)&s_service_uuid}},
-
-    /* Characteristic Declaration */
-    [BLE_IDX_TX_CHAR]        =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_desc_uuid, ESP_GATT_PERM_READ,
-      sizeof(uint8_t), sizeof(uint8_t), (uint8_t *)&s_char_prop}},
-
-    /* Characteristic Value */
-    [BLE_IDX_TX_VAL]         =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_primary_char_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
-      0, 0, NULL}},
-
-    /* Characteristic Configuration Descriptor */
-    [BLE_IDX_TX_NOTIFY_CFG]  =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
-      0, 0, NULL}},
-
-    /* Characteristic Declaration */
-    [BLE_IDX_RX_CHAR]        =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_desc_uuid, ESP_GATT_PERM_READ,
-      sizeof(uint8_t), sizeof(uint8_t), (uint8_t *)&s_char_prop}},
-
-    /* Characteristic Value */
-    [BLE_IDX_RX_VAL]         =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_second_char_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
-      0, 0, NULL}},
-
-    /* Characteristic Configuration Descriptor */
-    [BLE_IDX_RX_NOTIFY_CFG]  =
-    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
-      0, 0, NULL}}
-};
-
-extern char *duer_get_device_name();
-
-static void duer_ble_data_handle_task(void *pdata)
-{
-    duer_ble_msg_t msg;
-
-    while (1) {
-        if (pdTRUE == xQueueReceive(s_msg_queue, &msg, portMAX_DELAY)) {
-            ESP_LOGD(TAG, "msg.msg_id = %d, msg.data_len = %d", msg.msg_id, msg.data_len);
-            if (msg.msg_id == DUER_BLE_MSG_DATA) {
-                if (msg.data) {
-                    if (s_callbacks.on_ble_recv_data) {
-                        s_callbacks.on_ble_recv_data(msg.data, msg.data_len, msg.handle);
-                    }
-                    audio_free(msg.data);
-                }
-            } else if (msg.msg_id == DUER_BLE_MSG_CONNECT) {
-                if (s_callbacks.on_ble_connect_status) {
-                    s_callbacks.on_ble_connect_status(true);
-                }
-            } else if (msg.msg_id == DUER_BLE_MSG_DISCONNECT) {
-                if (s_callbacks.on_ble_connect_status) {
-                    s_callbacks.on_ble_connect_status(false);
-                }
-            } else if (msg.msg_id == DUER_BLE_MSG_EXIT) {
-                break;
-            } else {
-                ESP_LOGI(TAG, "unkown msg");
-            }
-        }
-    }
-
-    vQueueDelete(s_msg_queue);
-    s_msg_queue = NULL;
-
-    vTaskDelete(NULL);
-}
-
-static int duer_ble_data_post(uint8_t *data, uint16_t data_len, uint16_t handle)
-{
-    duer_ble_msg_t msg;
-
-    if (s_msg_queue == NULL || data == NULL || data_len == 0) {
-        return -1;
-    }
-
-    memset(&msg, 0, sizeof(msg));
-    msg.data = audio_calloc(1, data_len);
-    if (msg.data == NULL) {
-        return -1;
-    }
-    memcpy(msg.data, data, data_len);
-
-    msg.msg_id = DUER_BLE_MSG_DATA;
-    msg.data_len = data_len;
-    msg.handle = handle;
-    ESP_LOGD(TAG, "duer_ble_data_post %d", handle);
-    if (xQueueSend(s_msg_queue, &msg, portMAX_DELAY) != pdTRUE) {
-        ESP_LOGE(TAG, "Post failed");
-        return -1;
-    }
-
-    return 0;
-}
-
-static int duer_ble_data_task_init(void)
-{
-    int ret = 0;
-
-    if (s_msg_queue != NULL) {
-        return -1;
-    }
-
-    s_msg_queue = xQueueCreate(10, sizeof(duer_ble_msg_t));
-    if (s_msg_queue == NULL) {
-        ESP_LOGE(TAG, "ble msg queue create error.");
-        return -1;
-    }
-
-    ret = xTaskCreate(duer_ble_data_handle_task, "duer_ble_data", 1024 * 5, NULL, 5, NULL);
-    if (ret != 1) {
-        ESP_LOGI(TAG, "xTaskCreate, ret %d", ret);
-        vQueueDelete(s_msg_queue);
-        s_msg_queue = NULL;
-        return -1;
-    }
-
-    return 0;
-}
-
-static int duer_send_empty_event(int msg_id)
-{
-    if (s_msg_queue) {
-        duer_ble_msg_t msg;
-        memset(&msg, 0, sizeof(msg));
-        msg.msg_id = msg_id;
-        if (xQueueSend(s_msg_queue, &msg, portMAX_DELAY) != pdTRUE) {
-            ESP_LOGE(TAG, "Post failed");
-            return -1;
-        }
-    }
-
-    return 0;
-}
-
-static int duer_ble_data_task_deinit(void)
-{
-    return duer_send_empty_event(DUER_BLE_MSG_EXIT);
-}
-
-static void duer_on_ble_connect(void)
-{
-    duer_send_empty_event(DUER_BLE_MSG_CONNECT);
-    esp_ble_gap_stop_advertising();
-}
-
-static void duer_on_ble_disconnect(void)
-{
-    duer_send_empty_event(DUER_BLE_MSG_DISCONNECT);
-}
-
-static void gatts_ble_wifi_cfg_profile_event_handler(
-    esp_gatts_cb_event_t event,
-    esp_gatt_if_t gatts_if,
-    esp_ble_gatts_cb_param_t *param)
-{
-    switch (event) {
-        case ESP_GATTS_REG_EVT: {
-            ESP_LOGI(TAG, "[%s] ESP_GATTS_REG_EVT: %d", __func__, gatts_if);
-            esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(duer_get_device_name());
-            if (set_dev_name_ret) {
-                ESP_LOGI(TAG, "[%s] set device name failed, error code = %x", __func__, set_dev_name_ret);
-            }
-
-            // config adv data
-            esp_err_t ret = esp_ble_gap_config_adv_data(&s_adv_data);
-            if (ret) {
-                ESP_LOGI(TAG, "[%s] config adv data failed, error code = %x", __func__, ret);
-            }
-            s_adv_config_done |= ADV_CONFIG_FLAG;
-
-            // config scan rssvonse data
-            ret = esp_ble_gap_config_adv_data(&s_scan_rsp_data);
-            if (ret) {
-                ESP_LOGI(TAG, "[%s] config scan raw scan rsp data failed, error code = %x", __func__, ret);
-            }
-            s_adv_config_done |= SCAN_RSP_CONFIG_FLAG;
-
-            esp_err_t create_attr_ret = esp_ble_gatts_create_attr_tab(s_ble_gatt_db, gatts_if, BLE_IDX_NB, 0);
-            if (create_attr_ret) {
-                ESP_LOGI(TAG, "[%s] create attr table failed, error code = %x", __func__, create_attr_ret);
-            }
-        } break;
-
-        case ESP_GATTS_UNREG_EVT:
-            duer_ble_data_task_deinit();
-            s_sg_gatts_if = 0xff;
-            break;
-        case ESP_GATTS_CONNECT_EVT:
-            ESP_LOGI(TAG, "[%s] ESP_GATTS_CONNECT_EVT: %d", __func__, gatts_if);
-            s_sg_conn_id = param->connect.conn_id;
-            duer_on_ble_connect();
-            break;
-
-        case ESP_GATTS_CREAT_ATTR_TAB_EVT:
-            ESP_LOGI(TAG, "[%s] ESP_GATTS_CREAT_ATTR_TAB_EVT, status %d, handles 0x%x", __func__,
-                param->add_attr_tab.status, param->add_attr_tab.handles[0]);
-
-            if (param->add_attr_tab.status != ESP_GATT_OK) {
-                ESP_LOGI(TAG, "[%s] create attribute table failed, error code=0x%x", __func__, param->add_attr_tab.status);
-            } else if (param->add_attr_tab.num_handle != BLE_IDX_NB) {
-                ESP_LOGI(TAG, "[%s] create attribute table abnormally, num_handle (%d) doesn't equal to BLE_IDX_NB(%d)", __func__, param->add_attr_tab.num_handle, BLE_IDX_NB);
-            } else {
-                s_primary_char_handle = param->add_attr_tab.handles[BLE_IDX_TX_VAL];
-                s_second_char_handle = param->add_attr_tab.handles[BLE_IDX_RX_VAL];
-                s_service_handle = param->add_attr_tab.handles[BLE_IDX_SVC];
-                ESP_LOGW(TAG, "pri %d, sec %d, ser %d", s_primary_char_handle, s_second_char_handle, s_service_handle);
-                esp_ble_gatts_start_service(s_service_handle);
-            }
-            break;
-        case ESP_GATTS_DISCONNECT_EVT:
-            ESP_LOGI(TAG, "[%s] ESP_GATTS_DISCONNECT_EVT, reason = 0x%x", __func__, param->disconnect.reason);
-            s_sg_conn_id = 0xffff;
-            duer_on_ble_disconnect();
-            break;
-        case ESP_GATTS_READ_EVT:
-            ESP_LOGI(TAG, "[%s] ESP_GATTS_READ_EVT, conn_id %d, trans_id %d, handle %d", __func__,
-                (int)param->read.conn_id, (int)param->read.trans_id, (int)param->read.handle);
-            esp_gatt_rsp_t rsp;
-            memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
-            rsp.attr_value.handle = param->read.handle;
-            rsp.attr_value.len = 1;
-            rsp.attr_value.value[0] = 0;
-            esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id, ESP_GATT_OK, &rsp);
-            break;
-
-        case ESP_GATTS_WRITE_EVT:
-            ESP_LOGD(TAG, "ESP_GATTS_WRITE_EVT %d", param->write.is_prep);
-            if (param->write.is_prep) {
-                // the data length of gattc write  must be less than GATTS_DEMO_CHAR_VAL_LEN_MAX.
-                ESP_LOGI(TAG, "[%s] GATT_WRITE_EVT, handle = %d, value len = %d, value :", __func__, param->write.handle, param->write.len);
-                esp_gatt_status_t status = ESP_GATT_OK;
-                if (s_prepare_buf == NULL) {
-                    s_prepare_buf = audio_calloc(1, PREPARE_BUF_MAX_SIZE);
-                    if (s_prepare_buf == NULL) {
-                        ESP_LOGI(TAG, "calloc s_prepare_buf failed");
-                        status = ESP_GATT_NO_RESOURCES;
-                    }
-                } else {
-                    if (param->write.offset > PREPARE_BUF_MAX_SIZE) {
-                        status = ESP_GATT_INVALID_OFFSET;
-                    } else if ((param->write.offset + param->write.len) > PREPARE_BUF_MAX_SIZE) {
-                        status = ESP_GATT_INVALID_ATTR_LEN;
-                    }
-                }
-
-                if (s_prepare_buf) {
-                    memcpy(s_prepare_buf + param->write.offset, param->write.value, param->write.len);
-                    s_prepare_buf_len += param->write.len;
-                    s_prepare_handle = param->write.handle;
-                }
-
-                if (param->write.need_rsp) {
-                    esp_gatt_rsp_t rsp;
-                    memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
-                    rsp.attr_value.handle = param->write.handle;
-                    rsp.attr_value.len = param->write.len;
-                    rsp.attr_value.offset = param->write.offset;
-                    memcpy(rsp.attr_value.value, param->write.value, param->write.len);
-
-                    esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, status, &rsp);
-                }
-                break;
-            } else {
-                ESP_LOGD(TAG, "normal write, len %d, offset %d", param->write.len, param->write.offset);
-                duer_ble_data_post(param->write.value, param->write.len, param->write.handle);
-                if (param->write.need_rsp) {
-                    esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id,
-                        ESP_GATT_OK, NULL);
-                }
-            }
-            break;
-        case ESP_GATTS_EXEC_WRITE_EVT:
-            // the length of gattc prepare write data must be less than GATTS_DEMO_CHAR_VAL_LEN_MAX.
-            ESP_LOGW(TAG, "ESP_GATTS_EXEC_WRITE_EVT");
-            esp_ble_gatts_send_response(gatts_if, param->exec_write.conn_id, param->exec_write.trans_id, ESP_GATT_OK, NULL);
-            duer_ble_data_post(s_prepare_buf, s_prepare_buf_len, s_prepare_handle);
-            if (s_prepare_buf) {
-                audio_free(s_prepare_buf);
-                s_prepare_buf = NULL;
-            }
-            break;
-        case ESP_GATTS_MTU_EVT:
-            ESP_LOGI(TAG, "ESP_GATTS_MTU_EVT, MTU %d", param->mtu.mtu);
-            s_ble_mtu = param->mtu.mtu;
-            break;
-        case ESP_GATTS_CONF_EVT:
-            xEventGroupSetBits(s_send_done, BIT0);
-            break;
-        case ESP_GATTS_START_EVT:
-        case ESP_GATTS_STOP_EVT:
-        case ESP_GATTS_OPEN_EVT:
-        case ESP_GATTS_CANCEL_OPEN_EVT:
-        case ESP_GATTS_CLOSE_EVT:
-        case ESP_GATTS_LISTEN_EVT:
-        case ESP_GATTS_CONGEST_EVT:
-        case ESP_GATTS_DELETE_EVT:
-        default:
-            ESP_LOGI(TAG, "[%s] event %d", __func__, event);
-            break;
-    }
-}
-
-static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
-{
-    /* If event is register event, store the gatts_if for each profile */
-    if (event == ESP_GATTS_REG_EVT) {
-        if (param->reg.status == ESP_GATT_OK) {
-            if (param->reg.app_id != ESP_BLE_WIFI_CFG_APP_ID) {
-                ESP_LOGI(TAG, "[%s] register, app_id %04x, it should be %04x", __func__,
-                    param->reg.app_id, ESP_BLE_WIFI_CFG_APP_ID);
-                return;
-            }
-            s_sg_gatts_if = gatts_if;
-        } else {
-            ESP_LOGI(TAG, "Reg app failed, app_id %04x, status %d",
-                param->reg.app_id,
-                param->reg.status);
-            return;
-        }
-    }
-
-    /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
-    if (gatts_if == ESP_GATT_IF_NONE || gatts_if == s_sg_gatts_if) {
-        gatts_ble_wifi_cfg_profile_event_handler(event, gatts_if, param);
-    }
-}
-
-static void esp_ble_wifi_cfg_gap_event_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
-{
-    ESP_LOGD(TAG, "[%s] event %d", __func__, event);
-    switch (event) {
-        case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
-            s_adv_config_done &= (~ADV_CONFIG_FLAG);
-            if (s_adv_config_done == 0) {
-                ESP_LOGI(TAG, "esp_ble_gap_start_advertising");
-                esp_ble_gap_start_advertising(&s_adv_params);
-            }
-            break;
-        case ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:
-            s_adv_config_done &= (~SCAN_RSP_CONFIG_FLAG);
-            if (s_adv_config_done == 0) {
-                ESP_LOGI(TAG, "esp_ble_gap_start_advertising");
-                esp_ble_gap_start_advertising(&s_adv_params);
-            }
-            break;
-        case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
-            ESP_LOGI(TAG, "[%s] event ESP_GAP_BLE_ADV_START_COMPLETE_EVT", __func__);
-            break;
-
-        case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:
-            ESP_LOGI(TAG, "[%s] event ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT", __func__);
-            break;
-        default:
-            ESP_LOGI(TAG, "[%s] event %d", __func__, event);
-            break;
-    }
-}
-
-int duer_ble_send_data(uint8_t *data, uint32_t data_len, uint16_t attr_id)
-{
-    int offset = 0;
-    int send_len = 0;
-    int max_data_len = 0;
-
-    ESP_LOGD(TAG, "duer_ble_send_data %d", attr_id);
-
-    if (attr_id == 0) {
-        attr_id = s_second_char_handle;
-    }
-
-    max_data_len = s_ble_mtu - MTU_RESERVED_SIZE;
-
-    while (offset < data_len) {
-        send_len = (data_len - offset) > max_data_len ? max_data_len : (data_len - offset);
-        DUER_DUMPD("data", data + offset, send_len);
-        esp_ble_gatts_send_indicate(s_sg_gatts_if, s_sg_conn_id, attr_id, send_len, data + offset, true);
-        offset += send_len;
-        if (xEventGroupWaitBits(s_send_done, BIT0, true, true, pdMS_TO_TICKS(1000)) != pdTRUE) {
-            ESP_LOGI(TAG, "wait failed");
-        }
-    }
-
-    return 0;
-}
-
-int duer_wifi_cfg_ble_host_init(duer_ble_wifi_cfg_callbacks_t *callbacks)
-{
-    if (s_blecfg_alive ||
-        callbacks == NULL ||
-        callbacks->on_ble_connect_status == NULL ||
-        callbacks->on_ble_recv_data == NULL) {
-        return -1;
-    }
-    s_blecfg_alive = true;
-    memcpy(&s_callbacks, callbacks, sizeof(s_callbacks));
-
-    ESP_ERROR_CHECK(esp_ble_gap_register_callback(esp_ble_wifi_cfg_gap_event_cb));
-    ESP_ERROR_CHECK(esp_ble_gatts_register_callback(gatts_event_handler));
-    ESP_ERROR_CHECK(esp_ble_gatts_app_register(ESP_BLE_WIFI_CFG_APP_ID));
-    ESP_ERROR_CHECK(esp_ble_gatt_set_local_mtu(BLE_WIFI_CFG_GATTC_MTU_SIZE));
-
-    ESP_ERROR_CHECK(duer_ble_data_task_init());
-
-    if (!s_send_done) {
-        s_send_done = xEventGroupCreate();
-    }
-
-    return 0;
-}
-
-int duer_wifi_cfg_ble_host_deinit(void)
-{
-    if (s_blecfg_alive) {
-        if (s_sg_conn_id != 0xffff) {
-            esp_ble_gap_disconnect(NULL);
-            s_sg_conn_id = 0xffff;
-        }
-        esp_ble_gap_stop_advertising();
-
-        if (s_service_handle != 0xffff) {
-            esp_ble_gatts_stop_service(s_service_handle);
-            esp_ble_gatts_delete_service(s_service_handle);
-            s_sg_conn_id = 0xffff;
-        }
-
-        if (s_sg_gatts_if != 0xff) {
-            esp_ble_gatts_app_unregister(s_sg_gatts_if);
-            s_sg_gatts_if = 0xff;
-        }
-        duer_ble_data_task_deinit();
-        s_blecfg_alive = false;
-    }
-    return 0;
-}
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/event_groups.h"
+#include "freertos/queue.h"
+#include "freertos/task.h"
+
+#include "esp_err.h"
+#include "esp_log.h"
+
+#include "lightduer_lib.h"
+#include "lightduer_log.h"
+#include "lightduer_memory.h"
+
+#include "audio_mem.h"
+#include "duer_wifi_cfg.h"
+#include "duer_wifi_cfg_if.h"
+
+#ifdef CONFIG_BT_BLE_ENABLED
+#include "esp_gap_ble_api.h"
+#include "esp_gatt_common_api.h"
+#include "esp_gatts_api.h"
+
+enum {
+    BLE_IDX_SVC,
+    BLE_IDX_TX_CHAR,
+    BLE_IDX_TX_VAL,
+    BLE_IDX_TX_NOTIFY_CFG,
+    BLE_IDX_RX_CHAR,
+    BLE_IDX_RX_VAL,
+    BLE_IDX_RX_NOTIFY_CFG,
+    BLE_IDX_NB,
+};
+
+enum {
+    DUER_BLE_MSG_DATA,
+    DUER_BLE_MSG_CONNECT,
+    DUER_BLE_MSG_DISCONNECT,
+    DUER_BLE_MSG_EXIT
+};
+
+typedef struct {
+    uint8_t msg_id;
+    uint8_t *data;
+    uint16_t data_len;
+    uint16_t handle;
+} duer_ble_msg_t;
+
+#define BLE_WIFI_CFG_GATTC_MTU_SIZE    (23)
+#define PREPARE_BUF_MAX_SIZE           (1024)
+#define BLE_WIFI_CFG_SERVICE_UUID      (0x1111)
+#define BLE_WIFI_CFG_PRIMARY_CHAR_UUID (0x2222)
+#define BLE_WIFI_CFG_SECOND_CHAR_UUID  (0x3333)
+#define ADV_CONFIG_FLAG                (1 << 0)
+#define SCAN_RSP_CONFIG_FLAG           (1 << 1)
+#define ESP_BLE_WIFI_CFG_APP_ID        (0x3344)
+#define MTU_RESERVED_SIZE              (3)
+
+static const char *TAG = "DUER_WIFI_CFG_BLE";
+
+static esp_gatt_if_t s_sg_gatts_if  = 0xff;
+static uint16_t s_sg_conn_id        = 0xffff;
+static uint16_t s_service_handle    = 0xffff;
+static uint8_t s_adv_config_done    = 0;
+static bool s_blecfg_alive          = 0;
+static uint16_t s_prepare_handle    = 0;
+static uint8_t *s_prepare_buf       = NULL;
+static int s_prepare_buf_len        = 0;
+static int s_ble_mtu                = BLE_WIFI_CFG_GATTC_MTU_SIZE;
+static xQueueHandle s_msg_queue     = 0;
+static EventGroupHandle_t s_send_done = 0;
+
+static uint8_t MANUFACTURER_DATA[4] = { 0x1C, 0x01, 0x01, 0x11 };
+
+static esp_ble_adv_params_t s_adv_params = {
+    .adv_int_min        = 0x20,
+    .adv_int_max        = 0x40,
+    .adv_type           = ADV_TYPE_IND,
+    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,
+    .channel_map        = ADV_CHNL_ALL,
+    .adv_filter_policy  = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
+};
+
+static uint8_t ble_wifi_cfg_service_uuid128[] = {
+    /* LSB <--------------------------------------------------------------------------------> MSB */
+    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00
+};
+
+static esp_ble_adv_data_t s_adv_data = {
+    .set_scan_rsp        = 0,
+    .include_name        = 0,
+    .include_txpower     = 1,
+    .min_interval        = 0x20,
+    .max_interval        = 0x40,
+    .appearance          = 0x00,
+    .manufacturer_len    = sizeof(MANUFACTURER_DATA),
+    .p_manufacturer_data = MANUFACTURER_DATA,
+    .service_data_len    = 0,
+    .p_service_data      = NULL,
+    .service_uuid_len    = sizeof(ble_wifi_cfg_service_uuid128),
+    .p_service_uuid      = ble_wifi_cfg_service_uuid128,
+    .flag                = (ESP_BLE_ADV_FLAG_LIMIT_DISC | ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
+};
+
+static esp_ble_adv_data_t s_scan_rsp_data = {
+    .set_scan_rsp        = 1,
+    .include_name        = 1,
+    .include_txpower     = 1,
+    .appearance          = 0x00,
+    .manufacturer_len    = 0,
+    .p_manufacturer_data = NULL,
+    .service_data_len    = 0,
+    .p_service_data      = NULL,
+    .flag                = (ESP_BLE_ADV_FLAG_LIMIT_DISC | ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
+};
+
+static const uint8_t s_char_prop = (ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE
+        | ESP_GATT_CHAR_PROP_BIT_WRITE_NR | ESP_GATT_CHAR_PROP_BIT_INDICATE | ESP_GATT_CHAR_PROP_BIT_NOTIFY);
+
+static const uint16_t s_primary_service_uuid    = ESP_GATT_UUID_PRI_SERVICE;
+static const uint16_t s_service_uuid            = BLE_WIFI_CFG_SERVICE_UUID;
+static const uint16_t s_primary_char_uuid       = BLE_WIFI_CFG_PRIMARY_CHAR_UUID;
+static const uint16_t s_second_char_uuid        = BLE_WIFI_CFG_SECOND_CHAR_UUID;
+static const uint16_t s_desc_uuid               = ESP_GATT_UUID_CHAR_DECLARE; // ESP_GATT_UUID_CHAR_CLIENT_CONFIG
+static const uint16_t s_client_config_uuid      = ESP_GATT_UUID_CHAR_CLIENT_CONFIG;
+
+static duer_ble_wifi_cfg_callbacks_t s_callbacks;
+
+static uint16_t s_primary_char_handle;
+static uint16_t s_second_char_handle;
+
+/* Full Database Description - Used to add attributes into the database */
+static const esp_gatts_attr_db_t s_ble_gatt_db[BLE_IDX_NB] =
+{
+    // Service Declaration
+    [BLE_IDX_SVC]            =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_primary_service_uuid, ESP_GATT_PERM_READ,
+      sizeof(s_service_uuid), sizeof(s_service_uuid), (uint8_t *)&s_service_uuid}},
+
+    /* Characteristic Declaration */
+    [BLE_IDX_TX_CHAR]        =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_desc_uuid, ESP_GATT_PERM_READ,
+      sizeof(uint8_t), sizeof(uint8_t), (uint8_t *)&s_char_prop}},
+
+    /* Characteristic Value */
+    [BLE_IDX_TX_VAL]         =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_primary_char_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
+      0, 0, NULL}},
+
+    /* Characteristic Configuration Descriptor */
+    [BLE_IDX_TX_NOTIFY_CFG]  =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
+      0, 0, NULL}},
+
+    /* Characteristic Declaration */
+    [BLE_IDX_RX_CHAR]        =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_desc_uuid, ESP_GATT_PERM_READ,
+      sizeof(uint8_t), sizeof(uint8_t), (uint8_t *)&s_char_prop}},
+
+    /* Characteristic Value */
+    [BLE_IDX_RX_VAL]         =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_second_char_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
+      0, 0, NULL}},
+
+    /* Characteristic Configuration Descriptor */
+    [BLE_IDX_RX_NOTIFY_CFG]  =
+    {{ESP_GATT_RSP_BY_APP}, {ESP_UUID_LEN_16, (uint8_t *)&s_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
+      0, 0, NULL}}
+};
+
+extern char *duer_get_device_name();
+
+static void duer_ble_data_handle_task(void *pdata)
+{
+    duer_ble_msg_t msg;
+
+    while (1) {
+        if (pdTRUE == xQueueReceive(s_msg_queue, &msg, portMAX_DELAY)) {
+            ESP_LOGD(TAG, "msg.msg_id = %d, msg.data_len = %d", msg.msg_id, msg.data_len);
+            if (msg.msg_id == DUER_BLE_MSG_DATA) {
+                if (msg.data) {
+                    if (s_callbacks.on_ble_recv_data) {
+                        s_callbacks.on_ble_recv_data(msg.data, msg.data_len, msg.handle);
+                    }
+                    audio_free(msg.data);
+                }
+            } else if (msg.msg_id == DUER_BLE_MSG_CONNECT) {
+                if (s_callbacks.on_ble_connect_status) {
+                    s_callbacks.on_ble_connect_status(true);
+                }
+            } else if (msg.msg_id == DUER_BLE_MSG_DISCONNECT) {
+                if (s_callbacks.on_ble_connect_status) {
+                    s_callbacks.on_ble_connect_status(false);
+                }
+            } else if (msg.msg_id == DUER_BLE_MSG_EXIT) {
+                break;
+            } else {
+                ESP_LOGI(TAG, "unkown msg");
+            }
+        }
+    }
+
+    vQueueDelete(s_msg_queue);
+    s_msg_queue = NULL;
+
+    vTaskDelete(NULL);
+}
+
+static int duer_ble_data_post(uint8_t *data, uint16_t data_len, uint16_t handle)
+{
+    duer_ble_msg_t msg;
+
+    if (s_msg_queue == NULL || data == NULL || data_len == 0) {
+        return -1;
+    }
+
+    memset(&msg, 0, sizeof(msg));
+    msg.data = audio_calloc(1, data_len);
+    if (msg.data == NULL) {
+        return -1;
+    }
+    memcpy(msg.data, data, data_len);
+
+    msg.msg_id = DUER_BLE_MSG_DATA;
+    msg.data_len = data_len;
+    msg.handle = handle;
+    ESP_LOGD(TAG, "duer_ble_data_post %d", handle);
+    if (xQueueSend(s_msg_queue, &msg, portMAX_DELAY) != pdTRUE) {
+        ESP_LOGE(TAG, "Post failed");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int duer_ble_data_task_init(void)
+{
+    int ret = 0;
+
+    if (s_msg_queue != NULL) {
+        return -1;
+    }
+
+    s_msg_queue = xQueueCreate(10, sizeof(duer_ble_msg_t));
+    if (s_msg_queue == NULL) {
+        ESP_LOGE(TAG, "ble msg queue create error.");
+        return -1;
+    }
+
+    ret = xTaskCreate(duer_ble_data_handle_task, "duer_ble_data", 1024 * 5, NULL, 5, NULL);
+    if (ret != 1) {
+        ESP_LOGI(TAG, "xTaskCreate, ret %d", ret);
+        vQueueDelete(s_msg_queue);
+        s_msg_queue = NULL;
+        return -1;
+    }
+
+    return 0;
+}
+
+static int duer_send_empty_event(int msg_id)
+{
+    if (s_msg_queue) {
+        duer_ble_msg_t msg;
+        memset(&msg, 0, sizeof(msg));
+        msg.msg_id = msg_id;
+        if (xQueueSend(s_msg_queue, &msg, portMAX_DELAY) != pdTRUE) {
+            ESP_LOGE(TAG, "Post failed");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int duer_ble_data_task_deinit(void)
+{
+    return duer_send_empty_event(DUER_BLE_MSG_EXIT);
+}
+
+static void duer_on_ble_connect(void)
+{
+    duer_send_empty_event(DUER_BLE_MSG_CONNECT);
+    esp_ble_gap_stop_advertising();
+}
+
+static void duer_on_ble_disconnect(void)
+{
+    duer_send_empty_event(DUER_BLE_MSG_DISCONNECT);
+}
+
+static void gatts_ble_wifi_cfg_profile_event_handler(
+    esp_gatts_cb_event_t event,
+    esp_gatt_if_t gatts_if,
+    esp_ble_gatts_cb_param_t *param)
+{
+    switch (event) {
+        case ESP_GATTS_REG_EVT: {
+            ESP_LOGI(TAG, "[%s] ESP_GATTS_REG_EVT: %d", __func__, gatts_if);
+            esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(duer_get_device_name());
+            if (set_dev_name_ret) {
+                ESP_LOGI(TAG, "[%s] set device name failed, error code = %x", __func__, set_dev_name_ret);
+            }
+
+            // config adv data
+            esp_err_t ret = esp_ble_gap_config_adv_data(&s_adv_data);
+            if (ret) {
+                ESP_LOGI(TAG, "[%s] config adv data failed, error code = %x", __func__, ret);
+            }
+            s_adv_config_done |= ADV_CONFIG_FLAG;
+
+            // config scan rssvonse data
+            ret = esp_ble_gap_config_adv_data(&s_scan_rsp_data);
+            if (ret) {
+                ESP_LOGI(TAG, "[%s] config scan raw scan rsp data failed, error code = %x", __func__, ret);
+            }
+            s_adv_config_done |= SCAN_RSP_CONFIG_FLAG;
+
+            esp_err_t create_attr_ret = esp_ble_gatts_create_attr_tab(s_ble_gatt_db, gatts_if, BLE_IDX_NB, 0);
+            if (create_attr_ret) {
+                ESP_LOGI(TAG, "[%s] create attr table failed, error code = %x", __func__, create_attr_ret);
+            }
+        } break;
+
+        case ESP_GATTS_UNREG_EVT:
+            duer_ble_data_task_deinit();
+            s_sg_gatts_if = 0xff;
+            break;
+        case ESP_GATTS_CONNECT_EVT:
+            ESP_LOGI(TAG, "[%s] ESP_GATTS_CONNECT_EVT: %d", __func__, gatts_if);
+            s_sg_conn_id = param->connect.conn_id;
+            duer_on_ble_connect();
+            break;
+
+        case ESP_GATTS_CREAT_ATTR_TAB_EVT:
+            ESP_LOGI(TAG, "[%s] ESP_GATTS_CREAT_ATTR_TAB_EVT, status %d, handles 0x%x", __func__,
+                param->add_attr_tab.status, param->add_attr_tab.handles[0]);
+
+            if (param->add_attr_tab.status != ESP_GATT_OK) {
+                ESP_LOGI(TAG, "[%s] create attribute table failed, error code=0x%x", __func__, param->add_attr_tab.status);
+            } else if (param->add_attr_tab.num_handle != BLE_IDX_NB) {
+                ESP_LOGI(TAG, "[%s] create attribute table abnormally, num_handle (%d) doesn't equal to BLE_IDX_NB(%d)", __func__, param->add_attr_tab.num_handle, BLE_IDX_NB);
+            } else {
+                s_primary_char_handle = param->add_attr_tab.handles[BLE_IDX_TX_VAL];
+                s_second_char_handle = param->add_attr_tab.handles[BLE_IDX_RX_VAL];
+                s_service_handle = param->add_attr_tab.handles[BLE_IDX_SVC];
+                ESP_LOGW(TAG, "pri %d, sec %d, ser %d", s_primary_char_handle, s_second_char_handle, s_service_handle);
+                esp_ble_gatts_start_service(s_service_handle);
+            }
+            break;
+        case ESP_GATTS_DISCONNECT_EVT:
+            ESP_LOGI(TAG, "[%s] ESP_GATTS_DISCONNECT_EVT, reason = 0x%x", __func__, param->disconnect.reason);
+            s_sg_conn_id = 0xffff;
+            duer_on_ble_disconnect();
+            break;
+        case ESP_GATTS_READ_EVT:
+            ESP_LOGI(TAG, "[%s] ESP_GATTS_READ_EVT, conn_id %d, trans_id %d, handle %d", __func__,
+                (int)param->read.conn_id, (int)param->read.trans_id, (int)param->read.handle);
+            esp_gatt_rsp_t rsp;
+            memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
+            rsp.attr_value.handle = param->read.handle;
+            rsp.attr_value.len = 1;
+            rsp.attr_value.value[0] = 0;
+            esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id, ESP_GATT_OK, &rsp);
+            break;
+
+        case ESP_GATTS_WRITE_EVT:
+            ESP_LOGD(TAG, "ESP_GATTS_WRITE_EVT %d", param->write.is_prep);
+            if (param->write.is_prep) {
+                // the data length of gattc write  must be less than GATTS_DEMO_CHAR_VAL_LEN_MAX.
+                ESP_LOGI(TAG, "[%s] GATT_WRITE_EVT, handle = %d, value len = %d, value :", __func__, param->write.handle, param->write.len);
+                esp_gatt_status_t status = ESP_GATT_OK;
+                if (s_prepare_buf == NULL) {
+                    s_prepare_buf = audio_calloc(1, PREPARE_BUF_MAX_SIZE);
+                    if (s_prepare_buf == NULL) {
+                        ESP_LOGI(TAG, "calloc s_prepare_buf failed");
+                        status = ESP_GATT_NO_RESOURCES;
+                    }
+                } else {
+                    if (param->write.offset > PREPARE_BUF_MAX_SIZE) {
+                        status = ESP_GATT_INVALID_OFFSET;
+                    } else if ((param->write.offset + param->write.len) > PREPARE_BUF_MAX_SIZE) {
+                        status = ESP_GATT_INVALID_ATTR_LEN;
+                    }
+                }
+
+                if (s_prepare_buf) {
+                    memcpy(s_prepare_buf + param->write.offset, param->write.value, param->write.len);
+                    s_prepare_buf_len += param->write.len;
+                    s_prepare_handle = param->write.handle;
+                }
+
+                if (param->write.need_rsp) {
+                    esp_gatt_rsp_t rsp;
+                    memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
+                    rsp.attr_value.handle = param->write.handle;
+                    rsp.attr_value.len = param->write.len;
+                    rsp.attr_value.offset = param->write.offset;
+                    memcpy(rsp.attr_value.value, param->write.value, param->write.len);
+
+                    esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, status, &rsp);
+                }
+                break;
+            } else {
+                ESP_LOGD(TAG, "normal write, len %d, offset %d", param->write.len, param->write.offset);
+                duer_ble_data_post(param->write.value, param->write.len, param->write.handle);
+                if (param->write.need_rsp) {
+                    esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id,
+                        ESP_GATT_OK, NULL);
+                }
+            }
+            break;
+        case ESP_GATTS_EXEC_WRITE_EVT:
+            // the length of gattc prepare write data must be less than GATTS_DEMO_CHAR_VAL_LEN_MAX.
+            ESP_LOGW(TAG, "ESP_GATTS_EXEC_WRITE_EVT");
+            esp_ble_gatts_send_response(gatts_if, param->exec_write.conn_id, param->exec_write.trans_id, ESP_GATT_OK, NULL);
+            duer_ble_data_post(s_prepare_buf, s_prepare_buf_len, s_prepare_handle);
+            if (s_prepare_buf) {
+                audio_free(s_prepare_buf);
+                s_prepare_buf = NULL;
+            }
+            break;
+        case ESP_GATTS_MTU_EVT:
+            ESP_LOGI(TAG, "ESP_GATTS_MTU_EVT, MTU %d", param->mtu.mtu);
+            s_ble_mtu = param->mtu.mtu;
+            break;
+        case ESP_GATTS_CONF_EVT:
+            xEventGroupSetBits(s_send_done, BIT0);
+            break;
+        case ESP_GATTS_START_EVT:
+        case ESP_GATTS_STOP_EVT:
+        case ESP_GATTS_OPEN_EVT:
+        case ESP_GATTS_CANCEL_OPEN_EVT:
+        case ESP_GATTS_CLOSE_EVT:
+        case ESP_GATTS_LISTEN_EVT:
+        case ESP_GATTS_CONGEST_EVT:
+        case ESP_GATTS_DELETE_EVT:
+        default:
+            ESP_LOGI(TAG, "[%s] event %d", __func__, event);
+            break;
+    }
+}
+
+static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
+{
+    /* If event is register event, store the gatts_if for each profile */
+    if (event == ESP_GATTS_REG_EVT) {
+        if (param->reg.status == ESP_GATT_OK) {
+            if (param->reg.app_id != ESP_BLE_WIFI_CFG_APP_ID) {
+                ESP_LOGI(TAG, "[%s] register, app_id %04x, it should be %04x", __func__,
+                    param->reg.app_id, ESP_BLE_WIFI_CFG_APP_ID);
+                return;
+            }
+            s_sg_gatts_if = gatts_if;
+        } else {
+            ESP_LOGI(TAG, "Reg app failed, app_id %04x, status %d",
+                param->reg.app_id,
+                param->reg.status);
+            return;
+        }
+    }
+
+    /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
+    if (gatts_if == ESP_GATT_IF_NONE || gatts_if == s_sg_gatts_if) {
+        gatts_ble_wifi_cfg_profile_event_handler(event, gatts_if, param);
+    }
+}
+
+static void esp_ble_wifi_cfg_gap_event_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
+{
+    ESP_LOGD(TAG, "[%s] event %d", __func__, event);
+    switch (event) {
+        case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
+            s_adv_config_done &= (~ADV_CONFIG_FLAG);
+            if (s_adv_config_done == 0) {
+                ESP_LOGI(TAG, "esp_ble_gap_start_advertising");
+                esp_ble_gap_start_advertising(&s_adv_params);
+            }
+            break;
+        case ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:
+            s_adv_config_done &= (~SCAN_RSP_CONFIG_FLAG);
+            if (s_adv_config_done == 0) {
+                ESP_LOGI(TAG, "esp_ble_gap_start_advertising");
+                esp_ble_gap_start_advertising(&s_adv_params);
+            }
+            break;
+        case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
+            ESP_LOGI(TAG, "[%s] event ESP_GAP_BLE_ADV_START_COMPLETE_EVT", __func__);
+            break;
+
+        case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:
+            ESP_LOGI(TAG, "[%s] event ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT", __func__);
+            break;
+        default:
+            ESP_LOGI(TAG, "[%s] event %d", __func__, event);
+            break;
+    }
+}
+
+int duer_ble_send_data(uint8_t *data, uint32_t data_len, uint16_t attr_id)
+{
+    int offset = 0;
+    int send_len = 0;
+    int max_data_len = 0;
+
+    ESP_LOGD(TAG, "duer_ble_send_data %d", attr_id);
+
+    if (attr_id == 0) {
+        attr_id = s_second_char_handle;
+    }
+
+    max_data_len = s_ble_mtu - MTU_RESERVED_SIZE;
+
+    while (offset < data_len) {
+        send_len = (data_len - offset) > max_data_len ? max_data_len : (data_len - offset);
+        DUER_DUMPD("data", data + offset, send_len);
+        esp_ble_gatts_send_indicate(s_sg_gatts_if, s_sg_conn_id, attr_id, send_len, data + offset, true);
+        offset += send_len;
+        if (xEventGroupWaitBits(s_send_done, BIT0, true, true, pdMS_TO_TICKS(1000)) != pdTRUE) {
+            ESP_LOGI(TAG, "wait failed");
+        }
+    }
+
+    return 0;
+}
+
+int duer_wifi_cfg_ble_host_init(duer_ble_wifi_cfg_callbacks_t *callbacks)
+{
+    if (s_blecfg_alive ||
+        callbacks == NULL ||
+        callbacks->on_ble_connect_status == NULL ||
+        callbacks->on_ble_recv_data == NULL) {
+        return -1;
+    }
+    s_blecfg_alive = true;
+    memcpy(&s_callbacks, callbacks, sizeof(s_callbacks));
+
+    ESP_ERROR_CHECK(esp_ble_gap_register_callback(esp_ble_wifi_cfg_gap_event_cb));
+    ESP_ERROR_CHECK(esp_ble_gatts_register_callback(gatts_event_handler));
+    ESP_ERROR_CHECK(esp_ble_gatts_app_register(ESP_BLE_WIFI_CFG_APP_ID));
+    ESP_ERROR_CHECK(esp_ble_gatt_set_local_mtu(BLE_WIFI_CFG_GATTC_MTU_SIZE));
+
+    ESP_ERROR_CHECK(duer_ble_data_task_init());
+
+    if (!s_send_done) {
+        s_send_done = xEventGroupCreate();
+    }
+
+    return 0;
+}
+
+int duer_wifi_cfg_ble_host_deinit(void)
+{
+    if (s_blecfg_alive) {
+        if (s_sg_conn_id != 0xffff) {
+            esp_ble_gap_disconnect(NULL);
+            s_sg_conn_id = 0xffff;
+        }
+        esp_ble_gap_stop_advertising();
+
+        if (s_service_handle != 0xffff) {
+            esp_ble_gatts_stop_service(s_service_handle);
+            esp_ble_gatts_delete_service(s_service_handle);
+            s_sg_conn_id = 0xffff;
+        }
+
+        if (s_sg_gatts_if != 0xff) {
+            esp_ble_gatts_app_unregister(s_sg_gatts_if);
+            s_sg_gatts_if = 0xff;
+        }
+        duer_ble_data_task_deinit();
+        s_blecfg_alive = false;
+    }
+    return 0;
+}
+
 #endif /* CONFIG_BT_BLE_ENABLED */
\ No newline at end of file
diff --git a/components/dueros_service/duer_wifi_cfg_dummy.c b/components/dueros_service/duer_wifi_cfg_dummy.c
index 44279c9f..b9d379ee 100644
--- a/components/dueros_service/duer_wifi_cfg_dummy.c
+++ b/components/dueros_service/duer_wifi_cfg_dummy.c
@@ -1,51 +1,51 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-
-#include "duer_wifi_cfg_if.h"
-#include "esp_log.h"
-
-#ifndef CONFIG_BT_BLE_ENABLED
-
-static char *TAG = "duer_wifi_cfg_dummy";
-
-int duer_ble_send_data(uint8_t *data, uint32_t data_len, uint16_t attr_id)
-{
-    ESP_LOGE(TAG, "[%s]: Please enable ble in sdkconfig", __func__);
-    return -1;
-}
-
-int duer_wifi_cfg_ble_host_init(duer_ble_wifi_cfg_callbacks_t *callbacks)
-{
-    ESP_LOGE(TAG, "[%s]: Please enable ble in sdkconfig", __func__);
-    return -1;
-}
-
-int duer_wifi_cfg_ble_host_deinit(void)
-{
-    ESP_LOGE(TAG, "[%s]: Please enable ble in sdkconfig", __func__);
-    return -1;
-}
-
-#endif /* #ifndef CONFIG_BT_BLE_ENABLED */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+
+#include "duer_wifi_cfg_if.h"
+#include "esp_log.h"
+
+#ifndef CONFIG_BT_BLE_ENABLED
+
+static char *TAG = "duer_wifi_cfg_dummy";
+
+int duer_ble_send_data(uint8_t *data, uint32_t data_len, uint16_t attr_id)
+{
+    ESP_LOGE(TAG, "[%s]: Please enable ble in sdkconfig", __func__);
+    return -1;
+}
+
+int duer_wifi_cfg_ble_host_init(duer_ble_wifi_cfg_callbacks_t *callbacks)
+{
+    ESP_LOGE(TAG, "[%s]: Please enable ble in sdkconfig", __func__);
+    return -1;
+}
+
+int duer_wifi_cfg_ble_host_deinit(void)
+{
+    ESP_LOGE(TAG, "[%s]: Please enable ble in sdkconfig", __func__);
+    return -1;
+}
+
+#endif /* #ifndef CONFIG_BT_BLE_ENABLED */
diff --git a/components/dueros_service/duer_wifi_cfg_if.h b/components/dueros_service/duer_wifi_cfg_if.h
index ab41ba5c..46c92e28 100644
--- a/components/dueros_service/duer_wifi_cfg_if.h
+++ b/components/dueros_service/duer_wifi_cfg_if.h
@@ -1,49 +1,49 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __DUER_WIFI_CFG_IF_H__
-#define __DUER_WIFI_CFG_IF_H__
-
-#include "esp_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    void (*on_ble_recv_data)(void *data, size_t len, uint16_t handle);
-    void (*on_ble_connect_status)(bool status);
-} duer_ble_wifi_cfg_callbacks_t;
-
-int duer_ble_send_data(uint8_t *data, uint32_t data_len, uint16_t attr_id);
-
-int duer_wifi_cfg_ble_host_init(duer_ble_wifi_cfg_callbacks_t *callbacks);
-
-int duer_wifi_cfg_ble_host_deinit(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __DUER_WIFI_CFG_IF_H__ */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __DUER_WIFI_CFG_IF_H__
+#define __DUER_WIFI_CFG_IF_H__
+
+#include "esp_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    void (*on_ble_recv_data)(void *data, size_t len, uint16_t handle);
+    void (*on_ble_connect_status)(bool status);
+} duer_ble_wifi_cfg_callbacks_t;
+
+int duer_ble_send_data(uint8_t *data, uint32_t data_len, uint16_t attr_id);
+
+int duer_wifi_cfg_ble_host_init(duer_ble_wifi_cfg_callbacks_t *callbacks);
+
+int duer_wifi_cfg_ble_host_deinit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DUER_WIFI_CFG_IF_H__ */
diff --git a/components/dueros_service/dueros_esp_flash.c b/components/dueros_service/dueros_esp_flash.c
index 62cc3801..23ab4028 100644
--- a/components/dueros_service/dueros_esp_flash.c
+++ b/components/dueros_service/dueros_esp_flash.c
@@ -1,136 +1,136 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "dueros_esp_flash.h"
-#include "esp_partition.h"
-#include "audio_mem.h"
-#include "esp_log.h"
-
-#define MAX_FLASH_ALERT_COUNT   30
-
-// 4k Byte erase size (12 bits), for erase.
-#define FLASH_SECTOR_ALIGN_BITS         12
-// 4 Byte page size (2 bits), for write.
-#define FLASH_PAGE_ALIGN_BITS           8
-// 4 byte (2 bits), for read flash data.
-#define FLASH_WORD_ALIGN_BITS           2
-
-static const char *TAG              = "DUER_FLASH";
-
-static const duer_flash_config_t s_flash_config = {
-    FLASH_SECTOR_ALIGN_BITS,
-    FLASH_PAGE_ALIGN_BITS,
-    FLASH_WORD_ALIGN_BITS,
-};
-
-static const char *s_parti_label_list[] = {
-    "alert",
-};
-
-static duer_flash_string_context_t s_ctx_list[] = {
-    {{NULL, 0, NULL}, MAX_FLASH_ALERT_COUNT, NULL},
-};
-
-duer_flash_string_context_t *duer_flash_string_init(duer_flash_module module)
-{
-    int i = 0;
-    const char *label = s_parti_label_list[module];
-    duer_flash_string_context_t *rt = &s_ctx_list[module];
-
-    duer_set_flash_config(&s_flash_config);
-
-    if (module >= MAX_FLASH_MODULE) {
-        ESP_LOGE(TAG, "Invalid flash module");
-        return NULL;
-    }
-
-    if (!label) {
-        ESP_LOGE(TAG, "Invalid partition label.");
-        return NULL;
-    }
-
-    rt->ctx.handle = (void *)esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY,
-                     label);
-    if (!rt->ctx.handle) {
-        ESP_LOGE(TAG, "cannot find partition label %s.", label);
-        return NULL;
-    }
-
-    rt->ctx.len = ((esp_partition_t *)(rt->ctx.handle))->size;
-
-    if (!rt->ele_list) {
-        rt->ele_list = (unsigned int *)audio_malloc(sizeof(unsigned int *) * rt->max_ele_count);
-        for (i = 0; i < rt->max_ele_count; ++i) {
-            rt->ele_list[i] = FLASH_INVALID_ADDR;
-        }
-    }
-    return rt;
-}
-
-duer_status_t duer_esp_flash_init(const char *label,
-                                  duer_flash_context_t *ctx,
-                                  duer_flash_config_t *config)
-{
-    if (!label || !ctx || !config) {
-        return DUER_ERR_INVALID_PARAMETER;
-    }
-
-    ctx->handle = (void *)esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY,
-                  label);
-    if (!ctx->handle) {
-        ESP_LOGE(TAG, "cannot find partition label %s.", label);
-        return DUER_ERR_FAILED;
-    }
-
-    ctx->len = ((esp_partition_t *)(ctx->handle))->size;
-    memcpy(config, &s_flash_config, sizeof(*config));
-
-    return DUER_OK;
-}
-
-int duer_flash_read(
-    duer_flash_context_t *ctx,
-    unsigned int offset,
-    void *buf,
-    unsigned int len)
-{
-    return esp_partition_read((esp_partition_t *)(ctx->handle), offset, buf, len);
-}
-
-int duer_flash_write(
-    duer_flash_context_t *ctx,
-    unsigned int offset,
-    void *buf,
-    unsigned int len)
-{
-    return esp_partition_write((esp_partition_t *)(ctx->handle), offset, buf, len);
-}
-
-int duer_flash_erase(
-    duer_flash_context_t *ctx,
-    unsigned int offset,
-    unsigned int len)
-{
-    return esp_partition_erase_range((esp_partition_t *)(ctx->handle), offset, len);
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "dueros_esp_flash.h"
+#include "esp_partition.h"
+#include "audio_mem.h"
+#include "esp_log.h"
+
+#define MAX_FLASH_ALERT_COUNT   30
+
+// 4k Byte erase size (12 bits), for erase.
+#define FLASH_SECTOR_ALIGN_BITS         12
+// 4 Byte page size (2 bits), for write.
+#define FLASH_PAGE_ALIGN_BITS           8
+// 4 byte (2 bits), for read flash data.
+#define FLASH_WORD_ALIGN_BITS           2
+
+static const char *TAG              = "DUER_FLASH";
+
+static const duer_flash_config_t s_flash_config = {
+    FLASH_SECTOR_ALIGN_BITS,
+    FLASH_PAGE_ALIGN_BITS,
+    FLASH_WORD_ALIGN_BITS,
+};
+
+static const char *s_parti_label_list[] = {
+    "alert",
+};
+
+static duer_flash_string_context_t s_ctx_list[] = {
+    {{NULL, 0, NULL}, MAX_FLASH_ALERT_COUNT, NULL},
+};
+
+duer_flash_string_context_t *duer_flash_string_init(duer_flash_module module)
+{
+    int i = 0;
+    const char *label = s_parti_label_list[module];
+    duer_flash_string_context_t *rt = &s_ctx_list[module];
+
+    duer_set_flash_config(&s_flash_config);
+
+    if (module >= MAX_FLASH_MODULE) {
+        ESP_LOGE(TAG, "Invalid flash module");
+        return NULL;
+    }
+
+    if (!label) {
+        ESP_LOGE(TAG, "Invalid partition label.");
+        return NULL;
+    }
+
+    rt->ctx.handle = (void *)esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY,
+                     label);
+    if (!rt->ctx.handle) {
+        ESP_LOGE(TAG, "cannot find partition label %s.", label);
+        return NULL;
+    }
+
+    rt->ctx.len = ((esp_partition_t *)(rt->ctx.handle))->size;
+
+    if (!rt->ele_list) {
+        rt->ele_list = (unsigned int *)audio_malloc(sizeof(unsigned int *) * rt->max_ele_count);
+        for (i = 0; i < rt->max_ele_count; ++i) {
+            rt->ele_list[i] = FLASH_INVALID_ADDR;
+        }
+    }
+    return rt;
+}
+
+duer_status_t duer_esp_flash_init(const char *label,
+                                  duer_flash_context_t *ctx,
+                                  duer_flash_config_t *config)
+{
+    if (!label || !ctx || !config) {
+        return DUER_ERR_INVALID_PARAMETER;
+    }
+
+    ctx->handle = (void *)esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY,
+                  label);
+    if (!ctx->handle) {
+        ESP_LOGE(TAG, "cannot find partition label %s.", label);
+        return DUER_ERR_FAILED;
+    }
+
+    ctx->len = ((esp_partition_t *)(ctx->handle))->size;
+    memcpy(config, &s_flash_config, sizeof(*config));
+
+    return DUER_OK;
+}
+
+int duer_flash_read(
+    duer_flash_context_t *ctx,
+    unsigned int offset,
+    void *buf,
+    unsigned int len)
+{
+    return esp_partition_read((esp_partition_t *)(ctx->handle), offset, buf, len);
+}
+
+int duer_flash_write(
+    duer_flash_context_t *ctx,
+    unsigned int offset,
+    void *buf,
+    unsigned int len)
+{
+    return esp_partition_write((esp_partition_t *)(ctx->handle), offset, buf, len);
+}
+
+int duer_flash_erase(
+    duer_flash_context_t *ctx,
+    unsigned int offset,
+    unsigned int len)
+{
+    return esp_partition_erase_range((esp_partition_t *)(ctx->handle), offset, len);
+}
diff --git a/components/dueros_service/dueros_service.c b/components/dueros_service/dueros_service.c
index 878d7648..147bb710 100644
--- a/components/dueros_service/dueros_service.c
+++ b/components/dueros_service/dueros_service.c
@@ -80,7 +80,7 @@ typedef enum {
 
 typedef struct {
     bool                    login;
-    xQueueHandle            duer_que;
+    QueueHandle_t            duer_que;
     service_state_t         duer_state;
     EventGroupHandle_t      duer_evt;
 } dueros_service_t;
diff --git a/components/dueros_service/esp_audio_device_info.c b/components/dueros_service/esp_audio_device_info.c
index 04444eca..af08b13f 100644
--- a/components/dueros_service/esp_audio_device_info.c
+++ b/components/dueros_service/esp_audio_device_info.c
@@ -1,67 +1,67 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "lightduer_types.h"
-#include "lightduer_dev_info.h"
-
-static const char* TAG="ESP_DEV_INFO";
-
-#define FIRMWARE_VERSION "1.0.0.0"
-
-const duer_system_static_info_t g_system_static_info = {
-    .os_version         = "FreeRTOS V8.2.0",
-    .sw_version         = "ESP32_LYRAT_"FIRMWARE_VERSION,
-    .brand              = "ESPRESSIF",
-    .hardware_version   = "ESP32",
-    .equipment_type     = "ESP32_LYRAT",
-    .ram_size           = 5120,
-    .rom_size           = 4096,
-};
-
-static int get_firmware_version(char *firmware_version)
-{
-    strncpy(firmware_version, FIRMWARE_VERSION, FIRMWARE_VERSION_LEN);
-    return 0;
-}
-
-static struct DevInfoOps dev_info_ops = {
-    .get_firmware_version = get_firmware_version,
-};
-
-int duer_init_device_info(void)
-{
-    int ret = 0;
-
-    ret = duer_register_device_info_ops(&dev_info_ops);
-    if (ret != 0) {
-        ESP_LOGE(TAG, "Dev Info: Register dev ops failed");
-    }
-    return ret;
-}
-
-char *duer_get_device_name()
-{
-    return CONFIG_DUEROS_DEVICE_NAME;
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "lightduer_types.h"
+#include "lightduer_dev_info.h"
+
+static const char* TAG="ESP_DEV_INFO";
+
+#define FIRMWARE_VERSION "1.0.0.0"
+
+const duer_system_static_info_t g_system_static_info = {
+    .os_version         = "FreeRTOS V8.2.0",
+    .sw_version         = "ESP32_LYRAT_"FIRMWARE_VERSION,
+    .brand              = "ESPRESSIF",
+    .hardware_version   = "ESP32",
+    .equipment_type     = "ESP32_LYRAT",
+    .ram_size           = 5120,
+    .rom_size           = 4096,
+};
+
+static int get_firmware_version(char *firmware_version)
+{
+    strncpy(firmware_version, FIRMWARE_VERSION, FIRMWARE_VERSION_LEN);
+    return 0;
+}
+
+static struct DevInfoOps dev_info_ops = {
+    .get_firmware_version = get_firmware_version,
+};
+
+int duer_init_device_info(void)
+{
+    int ret = 0;
+
+    ret = duer_register_device_info_ops(&dev_info_ops);
+    if (ret != 0) {
+        ESP_LOGE(TAG, "Dev Info: Register dev ops failed");
+    }
+    return ret;
+}
+
+char *duer_get_device_name()
+{
+    return CONFIG_DUEROS_DEVICE_NAME;
 }
\ No newline at end of file
diff --git a/components/dueros_service/include/duer_profile.h b/components/dueros_service/include/duer_profile.h
index 4e055f88..36759190 100644
--- a/components/dueros_service/include/duer_profile.h
+++ b/components/dueros_service/include/duer_profile.h
@@ -1,86 +1,86 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef __DUER_PROFILE_H__
-#define __DUER_PROFILE_H__
-
-#include "esp_err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Load the duer profile
- *
- * @return
- *     - NULL, Fail
- *     - Others, Success
- */
-const char *duer_profile_load(void);
-
-/**
- * @brief Free the profile loaded
- *
- * @return
- *     - void
- */
-void duer_profile_release(const char *profile);
-
-/**
- * @brief Update the bduss, and clinet id in the profile.
- *
- * @return
- *     - ESP_OK, Success
- *     - Others, Fail
- */
-esp_err_t duer_profile_update(const char *bduss, const char *client_id);
-
-/**
- * @brief Get the profile certified state
- *
- * @return
- *     - (0),  Certified
- *     - (1), Profile load failed
- *     - (2), Profile parse failed
- *     - (3), Profile not certified
- */
-int32_t duer_profile_certified();
-
-/**
- * @brief Get the 'uuid' of the profile
- *
- * @return
- *     - (0), OK
- *     - (1), Profile load failed
- *     - (2), Profile parse failed
- *     - (3), Profile has no 'uuid'
- */
-int32_t duer_profile_get_uuid(char *buf, size_t blen);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //__DUER_PROFILE_H__
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __DUER_PROFILE_H__
+#define __DUER_PROFILE_H__
+
+#include "esp_err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Load the duer profile
+ *
+ * @return
+ *     - NULL, Fail
+ *     - Others, Success
+ */
+const char *duer_profile_load(void);
+
+/**
+ * @brief Free the profile loaded
+ *
+ * @return
+ *     - void
+ */
+void duer_profile_release(const char *profile);
+
+/**
+ * @brief Update the bduss, and clinet id in the profile.
+ *
+ * @return
+ *     - ESP_OK, Success
+ *     - Others, Fail
+ */
+esp_err_t duer_profile_update(const char *bduss, const char *client_id);
+
+/**
+ * @brief Get the profile certified state
+ *
+ * @return
+ *     - (0),  Certified
+ *     - (1), Profile load failed
+ *     - (2), Profile parse failed
+ *     - (3), Profile not certified
+ */
+int32_t duer_profile_certified();
+
+/**
+ * @brief Get the 'uuid' of the profile
+ *
+ * @return
+ *     - (0), OK
+ *     - (1), Profile load failed
+ *     - (2), Profile parse failed
+ *     - (3), Profile has no 'uuid'
+ */
+int32_t duer_profile_get_uuid(char *buf, size_t blen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__DUER_PROFILE_H__
diff --git a/components/dueros_service/include/duer_wifi_cfg.h b/components/dueros_service/include/duer_wifi_cfg.h
index 1c911bde..e65f4b54 100644
--- a/components/dueros_service/include/duer_wifi_cfg.h
+++ b/components/dueros_service/include/duer_wifi_cfg.h
@@ -1,90 +1,90 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef __DUER_WIFI_CFG_H__
-#define __DUER_WIFI_CFG_H__
-
-#include "esp_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Event id of the duer wifi configure process
- */
-typedef enum {
-    DUER_WIFI_CFG_SSID_GET,     /*!< Event Data: `duer_wifi_ssid_get_t` */
-    DUER_WIFI_CFG_BLE_CONN,     /*!< Event Data: NULL */
-    DUER_WIFI_CFG_BLE_DISC,     /*!< Event Data: NULL */
-} duer_wifi_cfg_event_t;
-
-/**
- * @brief Event data of `DUER_WIFI_CFG_SSID_GET`
- */
-typedef struct {
-    char *ssid;             /*!< SSID */
-    char *pwd;              /*!< Password */
-    char *bduss;            /*!< Got from server, should write back to profile */
-    char *device_bduss;     /*!< Got from server, should write back to profile */
-} duer_wifi_ssid_get_t;
-
-/**
- * @brief The callback prototype of WiFi configure events.
- */
-typedef void (*duer_wifi_cfg_user_cb_t)(duer_wifi_cfg_event_t event, void *data);
-
-/**
- * @brief The callback prototype of WiFi configure events.
- */
-typedef struct {
-    duer_wifi_cfg_user_cb_t user_cb; /*!< User callback */
-    const char *client_id;           /*!< Duer client id */
-    const char *pub_key;             /*!< Duer public key */
-} duer_wifi_cfg_t;
-
-/**
- * @brief Initialize the duer WiFi configuration process
- *
- * @param[in] cfg  Provide initialization configuration
- *
- * @return
- *      - 0: Sucess
- *      - Others: Failed
- */
-int duer_wifi_cfg_init(duer_wifi_cfg_t *cfg);
-
-/**
- * @brief Deinitialize the duer WiFi configuration process
- *
- * @return
- *      - 0: Sucess
- *      - Others: Failed
- */
-int duer_wifi_cfg_deinit(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //__DUER_WIFI_CFG_H__
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef __DUER_WIFI_CFG_H__
+#define __DUER_WIFI_CFG_H__
+
+#include "esp_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Event id of the duer wifi configure process
+ */
+typedef enum {
+    DUER_WIFI_CFG_SSID_GET,     /*!< Event Data: `duer_wifi_ssid_get_t` */
+    DUER_WIFI_CFG_BLE_CONN,     /*!< Event Data: NULL */
+    DUER_WIFI_CFG_BLE_DISC,     /*!< Event Data: NULL */
+} duer_wifi_cfg_event_t;
+
+/**
+ * @brief Event data of `DUER_WIFI_CFG_SSID_GET`
+ */
+typedef struct {
+    char *ssid;             /*!< SSID */
+    char *pwd;              /*!< Password */
+    char *bduss;            /*!< Got from server, should write back to profile */
+    char *device_bduss;     /*!< Got from server, should write back to profile */
+} duer_wifi_ssid_get_t;
+
+/**
+ * @brief The callback prototype of WiFi configure events.
+ */
+typedef void (*duer_wifi_cfg_user_cb_t)(duer_wifi_cfg_event_t event, void *data);
+
+/**
+ * @brief The callback prototype of WiFi configure events.
+ */
+typedef struct {
+    duer_wifi_cfg_user_cb_t user_cb; /*!< User callback */
+    const char *client_id;           /*!< Duer client id */
+    const char *pub_key;             /*!< Duer public key */
+} duer_wifi_cfg_t;
+
+/**
+ * @brief Initialize the duer WiFi configuration process
+ *
+ * @param[in] cfg  Provide initialization configuration
+ *
+ * @return
+ *      - 0: Sucess
+ *      - Others: Failed
+ */
+int duer_wifi_cfg_init(duer_wifi_cfg_t *cfg);
+
+/**
+ * @brief Deinitialize the duer WiFi configuration process
+ *
+ * @return
+ *      - 0: Sucess
+ *      - Others: Failed
+ */
+int duer_wifi_cfg_deinit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__DUER_WIFI_CFG_H__
diff --git a/components/dueros_service/include/dueros_esp_flash.h b/components/dueros_service/include/dueros_esp_flash.h
index 5ff8c1ad..3d8e1955 100644
--- a/components/dueros_service/include/dueros_esp_flash.h
+++ b/components/dueros_service/include/dueros_esp_flash.h
@@ -1,63 +1,63 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _DUEROS_SERVICE_ESP_FLASH_H
-#define _DUEROS_SERVICE_ESP_FLASH_H
-
-#include "lightduer_types.h"
-#include "lightduer_flash_strings.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * @brief Initialize flash partition for alert service
- *
- * @param[in] module   The audio service instance
- *
- * @return
- *     - NULL, Fail
- *     - Others, Success
- */
-duer_flash_string_context_t *duer_flash_string_init(duer_flash_module module);
-
-/*
- * @brief Initialize flash partition for dueros service
- *
- * @param[in] label     A pointer to partition label
- * @param[in] ctx       A pointer to `duer_flash_context_t`
- * @param[in] config    A pointer to `duer_flash_config_t`
- *
- * @return
- *     - ESP_OK, Success
- *     - Others, Fail
- */
-duer_status_t duer_esp_flash_init(const char *label, duer_flash_context_t *ctx, duer_flash_config_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _DUEROS_SERVICE_ESP_FLASH_H */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _DUEROS_SERVICE_ESP_FLASH_H
+#define _DUEROS_SERVICE_ESP_FLASH_H
+
+#include "lightduer_types.h"
+#include "lightduer_flash_strings.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * @brief Initialize flash partition for alert service
+ *
+ * @param[in] module   The audio service instance
+ *
+ * @return
+ *     - NULL, Fail
+ *     - Others, Success
+ */
+duer_flash_string_context_t *duer_flash_string_init(duer_flash_module module);
+
+/*
+ * @brief Initialize flash partition for dueros service
+ *
+ * @param[in] label     A pointer to partition label
+ * @param[in] ctx       A pointer to `duer_flash_context_t`
+ * @param[in] config    A pointer to `duer_flash_config_t`
+ *
+ * @return
+ *     - ESP_OK, Success
+ *     - Others, Fail
+ */
+duer_status_t duer_esp_flash_init(const char *label, duer_flash_context_t *ctx, duer_flash_config_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DUEROS_SERVICE_ESP_FLASH_H */
diff --git a/components/dueros_service/include/dueros_service.h b/components/dueros_service/include/dueros_service.h
index 4f602fb4..a6d166a1 100644
--- a/components/dueros_service/include/dueros_service.h
+++ b/components/dueros_service/include/dueros_service.h
@@ -1,123 +1,123 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _DUEROS_SERVICE_H_
-#define _DUEROS_SERVICE_H_
-
-#include "audio_service.h"
-#include "duer_wifi_cfg.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Status of WiFi connection
- */
-typedef struct {
-    int status;     /*!< Please refer to: `enum duer_dipb_client_status_e` */
-    int err;        /*!< Please refer to: `enum duer_wifi_connect_error_code_e` */
-} dueros_wifi_st_t;
-
-/**
- * @brief Create the dueros service
- *
- * @return
- *     - NULL, Fail
- *     - Others, Success
- */
-audio_service_handle_t dueros_service_create();
-
-/**
- * @brief Get dueros service state
- *
- * @return The state of service
- *
- */
-service_state_t dueros_service_state_get();
-
-/**
- * @brief Upload voice to backend server
- *
- * @param handle  dueros service handle
- * @param buf     Data buffer
- * @param len     Size of buffer
- *
- * @return
- *         ESP_OK
- *         ESP_FAIL
- */
-esp_err_t dueros_voice_upload(audio_service_handle_t handle, void *buf, int len);
-
-/**
- * @brief Cancel the current session
- *
- * @param handle  dueros service handle
- *
- * @return
- *         ESP_OK
- *         ESP_FAIL
- */
-esp_err_t dueros_voice_cancel(audio_service_handle_t handle);
-
-/**
- * @brief Start the wifi configure process
- *
- * @param handle  Dueros service handle
- * @param cfg     Configuration
- *
- * @return
- *         ESP_OK
- *         ESP_FAIL
- */
-esp_err_t dueros_start_wifi_cfg(audio_service_handle_t handle, duer_wifi_cfg_t *cfg);
-
-/**
- * @brief Stop the wifi configure process
- *
- * @param handle  Dueros service handle
- *
- * @return
- *         ESP_OK
- *         ESP_FAIL
- */
-esp_err_t dueros_stop_wifi_cfg(audio_service_handle_t handle);
-
-/**
- * @brief Report the wifi status to dipb
- *
- * @param handle  Dueros service handle
- * @param st      WiFi status and error code
- *
- * @return
- *         ESP_OK
- *         ESP_FAIL
- */
-esp_err_t dueros_wifi_status_report(audio_service_handle_t handle, dueros_wifi_st_t *st);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _DUEROS_SERVICE_H_
+#define _DUEROS_SERVICE_H_
+
+#include "audio_service.h"
+#include "duer_wifi_cfg.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Status of WiFi connection
+ */
+typedef struct {
+    int status;     /*!< Please refer to: `enum duer_dipb_client_status_e` */
+    int err;        /*!< Please refer to: `enum duer_wifi_connect_error_code_e` */
+} dueros_wifi_st_t;
+
+/**
+ * @brief Create the dueros service
+ *
+ * @return
+ *     - NULL, Fail
+ *     - Others, Success
+ */
+audio_service_handle_t dueros_service_create();
+
+/**
+ * @brief Get dueros service state
+ *
+ * @return The state of service
+ *
+ */
+service_state_t dueros_service_state_get();
+
+/**
+ * @brief Upload voice to backend server
+ *
+ * @param handle  dueros service handle
+ * @param buf     Data buffer
+ * @param len     Size of buffer
+ *
+ * @return
+ *         ESP_OK
+ *         ESP_FAIL
+ */
+esp_err_t dueros_voice_upload(audio_service_handle_t handle, void *buf, int len);
+
+/**
+ * @brief Cancel the current session
+ *
+ * @param handle  dueros service handle
+ *
+ * @return
+ *         ESP_OK
+ *         ESP_FAIL
+ */
+esp_err_t dueros_voice_cancel(audio_service_handle_t handle);
+
+/**
+ * @brief Start the wifi configure process
+ *
+ * @param handle  Dueros service handle
+ * @param cfg     Configuration
+ *
+ * @return
+ *         ESP_OK
+ *         ESP_FAIL
+ */
+esp_err_t dueros_start_wifi_cfg(audio_service_handle_t handle, duer_wifi_cfg_t *cfg);
+
+/**
+ * @brief Stop the wifi configure process
+ *
+ * @param handle  Dueros service handle
+ *
+ * @return
+ *         ESP_OK
+ *         ESP_FAIL
+ */
+esp_err_t dueros_stop_wifi_cfg(audio_service_handle_t handle);
+
+/**
+ * @brief Report the wifi status to dipb
+ *
+ * @param handle  Dueros service handle
+ * @param st      WiFi status and error code
+ *
+ * @return
+ *         ESP_OK
+ *         ESP_FAIL
+ */
+esp_err_t dueros_wifi_status_report(audio_service_handle_t handle, dueros_wifi_st_t *st);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/dueros_service/include/esp_audio_device_info.h b/components/dueros_service/include/esp_audio_device_info.h
index d0a5df19..2c22892d 100644
--- a/components/dueros_service/include/esp_audio_device_info.h
+++ b/components/dueros_service/include/esp_audio_device_info.h
@@ -1,54 +1,54 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ESP_ADUIO_DEVICE_INFO_H
-#define _ESP_ADUIO_DEVICE_INFO_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Initialise Device Information
- *
- * @param void:
- *
- * @return int: Success: 0
- *              Failed:  Other
- */
-extern int duer_init_device_info(void);
-
-/*
- * Get device name
- *
- * @param void:
- *
- * @return string: device name defined by user
- */
-extern char *duer_get_device_name();
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // _ESP_ADUIO_DEVICE_INFO_H
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ESP_ADUIO_DEVICE_INFO_H
+#define _ESP_ADUIO_DEVICE_INFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Initialise Device Information
+ *
+ * @param void:
+ *
+ * @return int: Success: 0
+ *              Failed:  Other
+ */
+extern int duer_init_device_info(void);
+
+/*
+ * Get device name
+ *
+ * @param void:
+ *
+ * @return string: device name defined by user
+ */
+extern char *duer_get_device_name();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _ESP_ADUIO_DEVICE_INFO_H
diff --git a/components/dueros_service/nvs.csv b/components/dueros_service/nvs.csv
index 300fc6ca..b542b4bc 100644
--- a/components/dueros_service/nvs.csv
+++ b/components/dueros_service/nvs.csv
@@ -1,4 +1,4 @@
-# Sample csv file
-key,type,encoding,value
-duer,namespace,,
-profile,file,string,duer_profile
+# Sample csv file
+key,type,encoding,value
+duer,namespace,,
+profile,file,string,duer_profile
diff --git a/components/esp_codec_dev/Kconfig b/components/esp_codec_dev/Kconfig
index 7f1c8193..86f3c2e4 100755
--- a/components/esp_codec_dev/Kconfig
+++ b/components/esp_codec_dev/Kconfig
@@ -1,8 +1,8 @@
 menu "Audio Codec Device Configuration"
    config ESP_IDF_VERSION
-       string
-       option env="ESP_IDF_VERSION"
-
+        string "ESP-IDF Version"
+        default "5.1"
+       
     config CODEC_I2C_BACKWARD_COMPATIBLE
         bool "Enable backward compatibility for the I2C driver (force use of the old i2c_driver above v5.3)"
         default y  
diff --git a/components/esp_event_cast/esp_event_cast.c b/components/esp_event_cast/esp_event_cast.c
index 8cad8f4f..dad60fab 100644
--- a/components/esp_event_cast/esp_event_cast.c
+++ b/components/esp_event_cast/esp_event_cast.c
@@ -37,13 +37,13 @@ static const char *TAG = "EVT_CAST";
 
 typedef struct esp_evt_cast_item {
     STAILQ_ENTRY(esp_evt_cast_item)     next;
-    xQueueHandle                        que;
+    QueueHandle_t                        que;
 } esp_evt_cast_item_t;
 
 typedef STAILQ_HEAD(esp_event_cast_list, esp_evt_cast_item) esp_event_cast_list_t;
 
 typedef struct esp_event_cast {
-    xSemaphoreHandle        _mux;
+    SemaphoreHandle_t        _mux;
     esp_event_cast_list_t   evt_list;
 } esp_event_cast_t;
 
@@ -75,7 +75,7 @@ esp_err_t esp_event_cast_destroy(esp_event_cast_handle_t handle)
     return ESP_FAIL;
 }
 
-esp_err_t esp_event_cast_register(esp_event_cast_handle_t handle, xQueueHandle que)
+esp_err_t esp_event_cast_register(esp_event_cast_handle_t handle, QueueHandle_t que)
 {
     if ((handle == NULL) || (que == NULL)) {
         ESP_LOGE(TAG, "func:%s, invalid parameters, handle=%p, que=%p", __func__, handle, que);
@@ -92,7 +92,7 @@ esp_err_t esp_event_cast_register(esp_event_cast_handle_t handle, xQueueHandle q
     return ESP_OK;
 }
 
-esp_err_t esp_event_cast_unregister(esp_event_cast_handle_t handle, xQueueHandle que)
+esp_err_t esp_event_cast_unregister(esp_event_cast_handle_t handle, QueueHandle_t que)
 {
     if ((handle == NULL) || (que == NULL)) {
         ESP_LOGE(TAG, "func:%s, invalid parameters, handle=%p, que=%p", __func__, handle, que);
diff --git a/components/esp_event_cast/include/esp_event_cast.h b/components/esp_event_cast/include/esp_event_cast.h
index aff08edf..6322872a 100644
--- a/components/esp_event_cast/include/esp_event_cast.h
+++ b/components/esp_event_cast/include/esp_event_cast.h
@@ -57,7 +57,7 @@ esp_err_t esp_event_cast_destroy(esp_event_cast_handle_t handle);
  *     - ESP_OK: success
  *     - ESP_FAIL: others
  */
-esp_err_t esp_event_cast_register(esp_event_cast_handle_t handle, xQueueHandle que);
+esp_err_t esp_event_cast_register(esp_event_cast_handle_t handle, QueueHandle_t que);
 
 /**
  * @brief Remove queue item from esp_event_cast_handle_t object, but does't delete the queue
@@ -69,7 +69,7 @@ esp_err_t esp_event_cast_register(esp_event_cast_handle_t handle, xQueueHandle q
  *     - ESP_OK: success
  *     - ESP_FAIL: others
  */
-esp_err_t esp_event_cast_unregister(esp_event_cast_handle_t handle, xQueueHandle que);
+esp_err_t esp_event_cast_unregister(esp_event_cast_handle_t handle, QueueHandle_t que);
 
 /**
  * @brief Broadcasting the data to receiver
diff --git a/components/esp_peripherals/CMakeLists.txt b/components/esp_peripherals/CMakeLists.txt
index ab27f35d..fec2b946 100644
--- a/components/esp_peripherals/CMakeLists.txt
+++ b/components/esp_peripherals/CMakeLists.txt
@@ -1,76 +1,76 @@
-set(idf_version "${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}")
-
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./include
-                ./lib/adc_button
-                ./lib/gpio_isr
-                ./lib/button
-                ./lib/blufi
-                ./lib/IS31FL3216
-                ./lib/aw2013
-                ./lib/tca9554
-                ./driver/i2c_bus)
-
-list(APPEND COMPONENT_SRCS ./esp_peripherals.c
-                ./periph_adc_button.c
-                ./periph_button.c
-                ./periph_console.c
-                ./periph_gpio_isr.c
-                ./periph_is31fl3216.c
-                ./periph_led.c
-                ./periph_spiffs.c
-                ./periph_wifi.c
-                ./periph_aw2013.c
-                ./periph_ws2812.c
-                ./periph_lcd.c
-                ./lib/button/button.c
-                ./lib/blufi/blufi_security.c
-                ./lib/blufi/wifibleconfig.c
-                ./lib/adc_button/adc_button.c
-                ./lib/IS31FL3216/IS31FL3216.c
-                ./lib/tca9554/tca9554.c
-                ./lib/gpio_isr/gpio_isr.c)
-
-if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_LESS "5.3")
-    list(APPEND COMPONENT_SRCS  ./driver/i2c_bus/i2c_bus.c)
-else()
-    list(APPEND COMPONENT_SRCS  ./driver/i2c_bus/i2c_bus_v2.c)
-endif()
-
-IF (CONFIG_IDF_TARGET STREQUAL "esp32")
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard ./lib/touch)
-list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c ./periph_touch.c ./lib/touch/touch.c)
-
-ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32c3")
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard)
-list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c)
-
-ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32c6")
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard)
-list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c)
-
-ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32s3")
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard ./lib/touch)
-list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c ./periph_touch.c ./lib/touch/touch.c)
-
-ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32s2")
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard ./lib/touch)
-list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c ./periph_touch.c ./lib/touch/touch.c)
-
-ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32p4")
-list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard)
-list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c)
-ENDIF ()
-
-set(COMPONENT_REQUIRES driver audio_hal audio_sal fatfs console audio_pipeline audio_board spiffs display_service esp_dispatcher bt mbedtls wpa_supplicant nvs_flash)
-
-IF (((IDF_VERSION_MAJOR EQUAL 4) AND (IDF_VERSION_MINOR GREATER 3)) OR (IDF_VERSION_MAJOR GREATER 4))
-list(APPEND COMPONENT_REQUIRES esp_lcd)
-ENDIF()
-
-if (idf_version VERSION_GREATER_EQUAL "5.0")
-list(APPEND COMPONENT_PRIV_REQUIRES esp_adc)
-else()
-list(APPEND COMPONENT_PRIV_REQUIRES esp_adc_cal)
-endif()
-
-register_component()
+set(idf_version "${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}")
+
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./include
+                ./lib/adc_button
+                ./lib/gpio_isr
+                ./lib/button
+                ./lib/blufi
+                ./lib/IS31FL3216
+                ./lib/aw2013
+                ./lib/tca9554
+                ./driver/i2c_bus)
+
+list(APPEND COMPONENT_SRCS ./esp_peripherals.c
+                ./periph_adc_button.c
+                ./periph_button.c
+                ./periph_console.c
+                ./periph_gpio_isr.c
+                ./periph_is31fl3216.c
+                ./periph_led.c
+                ./periph_spiffs.c
+                ./periph_wifi.c
+                ./periph_aw2013.c
+                ./periph_ws2812.c
+                ./periph_lcd.c
+                ./lib/button/button.c
+                ./lib/blufi/blufi_security.c
+                ./lib/blufi/wifibleconfig.c
+                ./lib/adc_button/adc_button.c
+                ./lib/IS31FL3216/IS31FL3216.c
+                ./lib/tca9554/tca9554.c
+                ./lib/gpio_isr/gpio_isr.c)
+
+if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_LESS "5.3")
+    list(APPEND COMPONENT_SRCS  ./driver/i2c_bus/i2c_bus.c)
+else()
+    list(APPEND COMPONENT_SRCS  ./driver/i2c_bus/i2c_bus_v2.c)
+endif()
+
+IF (CONFIG_IDF_TARGET STREQUAL "esp32")
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard ./lib/touch)
+list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c ./periph_touch.c ./lib/touch/touch.c)
+
+ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32c3")
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard)
+list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c)
+
+ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32c6")
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard)
+list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c)
+
+ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32s3")
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard ./lib/touch)
+list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c ./periph_touch.c ./lib/touch/touch.c)
+
+ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32s2")
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard ./lib/touch)
+list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c ./periph_touch.c ./lib/touch/touch.c)
+
+ELSEIF (CONFIG_IDF_TARGET STREQUAL "esp32p4")
+list(APPEND COMPONENT_ADD_INCLUDEDIRS ./lib/sdcard)
+list(APPEND COMPONENT_SRCS ./lib/sdcard/sdcard.c ./periph_sdcard.c)
+ENDIF ()
+
+set(COMPONENT_REQUIRES driver audio_hal audio_sal fatfs console audio_pipeline audio_board spiffs display_service esp_dispatcher bt mbedtls wpa_supplicant nvs_flash)
+
+IF (((IDF_VERSION_MAJOR EQUAL 4) AND (IDF_VERSION_MINOR GREATER 3)) OR (IDF_VERSION_MAJOR GREATER 4))
+list(APPEND COMPONENT_REQUIRES esp_lcd)
+ENDIF()
+
+if (idf_version VERSION_GREATER_EQUAL "5.0")
+list(APPEND COMPONENT_PRIV_REQUIRES esp_adc)
+else()
+list(APPEND COMPONENT_PRIV_REQUIRES esp_adc_cal)
+endif()
+
+register_component()
diff --git a/components/esp_peripherals/component.mk b/components/esp_peripherals/component.mk
index c1ff1763..967fe2c6 100644
--- a/components/esp_peripherals/component.mk
+++ b/components/esp_peripherals/component.mk
@@ -1,10 +1,10 @@
-#
-# "main" pseudo-component makefile.
-#
-# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
-
-COMPONENT_ADD_INCLUDEDIRS := ./include ./lib/adc_button ./lib/gpio_isr ./driver/i2c_bus ./lib/aw2013
-COMPONENT_SRCDIRS :=  . ./lib ./lib/sdcard ./lib/button ./lib/touch ./lib/blufi ./lib/adc_button ./lib/IS31FL3216 ./driver/i2c_bus ./lib/gpio_isr ./lib/aw2013
-COMPONENT_PRIV_INCLUDEDIRS := ./lib/sdcard ./lib/button ./lib/touch ./lib/blufi ./lib/IS31FL3216 ./driver/i2c_bus
-
-CFLAGS+=-D__FILENAME__=\"$(<F)\"
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
+
+COMPONENT_ADD_INCLUDEDIRS := ./include ./lib/adc_button ./lib/gpio_isr ./driver/i2c_bus ./lib/aw2013
+COMPONENT_SRCDIRS :=  . ./lib ./lib/sdcard ./lib/button ./lib/touch ./lib/blufi ./lib/adc_button ./lib/IS31FL3216 ./driver/i2c_bus ./lib/gpio_isr ./lib/aw2013
+COMPONENT_PRIV_INCLUDEDIRS := ./lib/sdcard ./lib/button ./lib/touch ./lib/blufi ./lib/IS31FL3216 ./driver/i2c_bus
+
+CFLAGS+=-D__FILENAME__=\"$(<F)\"
diff --git a/components/esp_peripherals/driver/i2c_bus/i2c_bus.c b/components/esp_peripherals/driver/i2c_bus/i2c_bus.c
index 32f3c21c..63144968 100644
--- a/components/esp_peripherals/driver/i2c_bus/i2c_bus.c
+++ b/components/esp_peripherals/driver/i2c_bus/i2c_bus.c
@@ -1,231 +1,231 @@
-/*
-  * ESPRESSIF MIT License
-  *
-  * Copyright (c) 2017 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
-  *
-  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
-  * it is free of charge, to any person obtaining a copy of this software and associated
-  * documentation files (the "Software"), to deal in the Software without restriction, including
-  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-  * to do so, subject to the following conditions:
-  *
-  * The above copyright notice and this permission notice shall be included in all copies or
-  * substantial portions of the Software.
-  *
-  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-  *
-  */
-
-#include <stdio.h>
-#include <string.h>
-#include "esp_log.h"
-#include "driver/i2c.h"
-#include "i2c_bus.h"
-#include "audio_mutex.h"
-#include "audio_mem.h"
-
-#define ESP_INTR_FLG_DEFAULT  (0)
-#define ESP_I2C_MASTER_BUF_LEN  (0)
-#define I2C_ACK_CHECK_EN 1
-
-#define I2C_BUS_CHECK(a, str, ret)  if(!(a)) {                               \
-    ESP_LOGE(TAG, "%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);   \
-    return (ret);                                                            \
-}
-
-typedef struct {
-    i2c_config_t     i2c_conf;   /*!<I2C bus parameters*/
-    i2c_port_t       i2c_port;   /*!<I2C port number */
-    int              ref_count;  /*!<Reference Count for multiple client */
-    xSemaphoreHandle bus_lock;   /*!<Lock for bus */
-} i2c_bus_t;
-
-static const char *TAG = "I2C_BUS";
-
-static i2c_bus_t *i2c_bus[I2C_NUM_MAX];
-
-i2c_bus_handle_t i2c_bus_create(i2c_port_t port, i2c_config_t *conf)
-{
-    I2C_BUS_CHECK(port < I2C_NUM_MAX, "I2C port error", NULL);
-    I2C_BUS_CHECK(conf != NULL, "Configuration not initialized", NULL);
-
-    if (i2c_bus[port]) {
-        // Check whether it is the same group i2c
-        if (memcmp(conf, &i2c_bus[port]->i2c_conf, sizeof(i2c_config_t)) == 0) {
-            i2c_bus[port]->ref_count++;
-            ESP_LOGW(TAG, "I2C bus has been already created, [port:%d]", port);
-            return i2c_bus[port];
-        } else {
-            ESP_LOGE(TAG, "Have not enough slot(%d) to create I2C bus", port);
-            return NULL;
-        }
-    }
-
-    i2c_bus[port] = (i2c_bus_t *) audio_calloc(1, sizeof(i2c_bus_t));
-    i2c_bus[port]->i2c_conf = *conf;
-    i2c_bus[port]->i2c_port = port;
-    i2c_bus[port]->ref_count++;
-    esp_err_t ret = i2c_param_config(i2c_bus[port]->i2c_port, &i2c_bus[port]->i2c_conf);
-    if (ret != ESP_OK) {
-        goto error;
-    }
-    ret = i2c_driver_install(i2c_bus[port]->i2c_port, i2c_bus[port]->i2c_conf.mode, ESP_I2C_MASTER_BUF_LEN, ESP_I2C_MASTER_BUF_LEN, ESP_INTR_FLG_DEFAULT);
-    if (ret != ESP_OK) {
-        goto error;
-    }
-    i2c_bus[port]->bus_lock = mutex_create();
-    if (i2c_bus[port]->bus_lock == NULL) {
-        goto error;
-    }
-    return (i2c_bus_handle_t) i2c_bus[port];
-
-error:
-    if (i2c_bus[port]) {
-        if (i2c_bus[port]->bus_lock == NULL) {
-            mutex_destroy(i2c_bus[port]->bus_lock);
-        }
-        audio_free(i2c_bus[port]);
-    }
-    return NULL;
-}
-
-esp_err_t i2c_bus_write_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int regLen, uint8_t *data, int datalen)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
-    I2C_BUS_CHECK(p_bus->i2c_port < I2C_NUM_MAX, "I2C port error", ESP_FAIL);
-    I2C_BUS_CHECK(data != NULL, "Not initialized input data pointer", ESP_FAIL);
-    esp_err_t ret = ESP_OK;
-    mutex_lock(p_bus->bus_lock);
-    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
-    ret |= i2c_master_start(cmd);
-    ret |= i2c_master_write_byte(cmd, addr, 1);
-    ret |= i2c_master_write(cmd, reg, regLen, I2C_ACK_CHECK_EN);
-    ret |= i2c_master_write(cmd, data, datalen, I2C_ACK_CHECK_EN);
-    ret |= i2c_master_stop(cmd);
-    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_RATE_MS);
-    i2c_cmd_link_delete(cmd);
-    mutex_unlock(p_bus->bus_lock);
-    I2C_BUS_CHECK(ret == 0, "I2C Bus WriteReg Error", ESP_FAIL);
-    return ret;
-}
-
-esp_err_t i2c_bus_write_data(i2c_bus_handle_t bus, int addr, uint8_t *data, int datalen)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
-    I2C_BUS_CHECK(p_bus->i2c_port < I2C_NUM_MAX, "I2C port error", ESP_FAIL);
-    I2C_BUS_CHECK(data != NULL, "Not initialized input data pointer", ESP_FAIL);
-    esp_err_t ret = ESP_OK;
-    mutex_lock(p_bus->bus_lock);
-    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
-    ret |= i2c_master_start(cmd);
-    ret |= i2c_master_write_byte(cmd, addr, 1);
-    ret |= i2c_master_write(cmd, data, datalen, I2C_ACK_CHECK_EN);
-    ret |= i2c_master_stop(cmd);
-    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_RATE_MS);
-    i2c_cmd_link_delete(cmd);
-    mutex_unlock(p_bus->bus_lock);
-    I2C_BUS_CHECK(ret == 0, "I2C Bus WriteReg Error", ESP_FAIL);
-    return ret;
-}
-
-esp_err_t i2c_bus_read_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int reglen, uint8_t *outdata, int datalen)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
-    I2C_BUS_CHECK(p_bus->i2c_port < I2C_NUM_MAX, "I2C port error", ESP_FAIL);
-    I2C_BUS_CHECK(outdata != NULL, "Not initialized output data buffer pointer", ESP_FAIL);
-    esp_err_t ret = ESP_OK;
-    mutex_lock(p_bus->bus_lock);
-    i2c_cmd_handle_t cmd;
-    cmd = i2c_cmd_link_create();
-    ret |= i2c_master_start(cmd);
-    ret |= i2c_master_write_byte(cmd, addr, I2C_ACK_CHECK_EN);
-    ret |= i2c_master_write(cmd, reg, reglen, I2C_ACK_CHECK_EN);
-    ret |= i2c_master_stop(cmd);
-    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_RATE_MS);
-    i2c_cmd_link_delete(cmd);
-
-    cmd = i2c_cmd_link_create();
-    ret |= i2c_master_start(cmd);
-    ret |= i2c_master_write_byte(cmd, addr | 0x01, I2C_ACK_CHECK_EN);
-
-    for (int i = 0; i < datalen - 1; i++) {
-        ret |= i2c_master_read_byte(cmd, &outdata[i], 0);
-    }
-    ret |= i2c_master_read_byte(cmd, &outdata[datalen - 1], 1);
-
-    ret |= i2c_master_stop(cmd);
-    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_RATE_MS);
-    i2c_cmd_link_delete(cmd);
-
-    mutex_unlock(p_bus->bus_lock);
-    I2C_BUS_CHECK(ret == 0, "I2C Bus ReadReg Error", ESP_FAIL);
-    return ret;
-}
-
-esp_err_t i2c_bus_delete(i2c_bus_handle_t bus)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
-    if (--p_bus->ref_count == 0) {
-        i2c_driver_delete(p_bus->i2c_port);
-        i2c_bus[p_bus->i2c_port] = NULL;
-        mutex_destroy(p_bus->bus_lock);
-        audio_free(p_bus);
-    }
-    return ESP_OK;
-}
-
-esp_err_t i2c_bus_cmd_begin(i2c_bus_handle_t bus, i2c_cmd_handle_t cmd, portBASE_TYPE ticks_to_wait)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    I2C_BUS_CHECK(cmd != NULL, "I2C cmd error", ESP_FAIL);
-    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
-
-    esp_err_t ret = i2c_master_cmd_begin(p_bus->i2c_port, cmd, ticks_to_wait);
-    return ret;
-}
-
-esp_err_t i2c_bus_probe_addr(i2c_bus_handle_t bus, uint8_t addr)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    /* Use 7 bit address here */
-    if (addr >= 0x80) {
-        ESP_LOGE(TAG, "I2C addr out of range");
-        return ESP_ERR_INVALID_ARG;
-    }
-
-    i2c_bus_t *i2c_bus = (i2c_bus_t *) bus;
-    mutex_lock(i2c_bus->bus_lock);
-    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
-    i2c_master_start(cmd);
-    i2c_master_write_byte(cmd, addr, I2C_ACK_CHECK_EN);
-    i2c_master_stop(cmd);
-    esp_err_t ret_val = i2c_master_cmd_begin(i2c_bus->i2c_port, cmd, pdMS_TO_TICKS(500));
-    i2c_cmd_link_delete(cmd);
-    mutex_unlock(i2c_bus->bus_lock);
-
-    /* Get probe result if ESP_OK equals to ret_val */
-    return ret_val;
-}
-
-esp_err_t i2c_bus_run_cb(i2c_bus_handle_t bus, i2c_run_cb_t cb, void *arg)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    I2C_BUS_CHECK(cb != NULL, "Invalid callback", ESP_FAIL);
-
-    i2c_bus_t *i2c_bus = (i2c_bus_t *) bus;
-    mutex_lock(i2c_bus->bus_lock);
-    (*cb)(i2c_bus->i2c_port, arg);
-    mutex_unlock(i2c_bus->bus_lock);
-
-    return ESP_OK;
-}
+/*
+  * ESPRESSIF MIT License
+  *
+  * Copyright (c) 2017 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+  *
+  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
+  * it is free of charge, to any person obtaining a copy of this software and associated
+  * documentation files (the "Software"), to deal in the Software without restriction, including
+  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+  * to do so, subject to the following conditions:
+  *
+  * The above copyright notice and this permission notice shall be included in all copies or
+  * substantial portions of the Software.
+  *
+  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+  *
+  */
+
+#include <stdio.h>
+#include <string.h>
+#include "esp_log.h"
+#include "driver/i2c.h"
+#include "i2c_bus.h"
+#include "audio_mutex.h"
+#include "audio_mem.h"
+
+#define ESP_INTR_FLG_DEFAULT  (0)
+#define ESP_I2C_MASTER_BUF_LEN  (0)
+#define I2C_ACK_CHECK_EN 1
+
+#define I2C_BUS_CHECK(a, str, ret)  if(!(a)) {                               \
+    ESP_LOGE(TAG, "%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);   \
+    return (ret);                                                            \
+}
+
+typedef struct {
+    i2c_config_t     i2c_conf;   /*!<I2C bus parameters*/
+    i2c_port_t       i2c_port;   /*!<I2C port number */
+    int              ref_count;  /*!<Reference Count for multiple client */
+    SemaphoreHandle_t bus_lock;   /*!<Lock for bus */
+} i2c_bus_t;
+
+static const char *TAG = "I2C_BUS";
+
+static i2c_bus_t *i2c_bus[I2C_NUM_MAX];
+
+i2c_bus_handle_t i2c_bus_create(i2c_port_t port, i2c_config_t *conf)
+{
+    I2C_BUS_CHECK(port < I2C_NUM_MAX, "I2C port error", NULL);
+    I2C_BUS_CHECK(conf != NULL, "Configuration not initialized", NULL);
+
+    if (i2c_bus[port]) {
+        // Check whether it is the same group i2c
+        if (memcmp(conf, &i2c_bus[port]->i2c_conf, sizeof(i2c_config_t)) == 0) {
+            i2c_bus[port]->ref_count++;
+            ESP_LOGW(TAG, "I2C bus has been already created, [port:%d]", port);
+            return i2c_bus[port];
+        } else {
+            ESP_LOGE(TAG, "Have not enough slot(%d) to create I2C bus", port);
+            return NULL;
+        }
+    }
+
+    i2c_bus[port] = (i2c_bus_t *) audio_calloc(1, sizeof(i2c_bus_t));
+    i2c_bus[port]->i2c_conf = *conf;
+    i2c_bus[port]->i2c_port = port;
+    i2c_bus[port]->ref_count++;
+    esp_err_t ret = i2c_param_config(i2c_bus[port]->i2c_port, &i2c_bus[port]->i2c_conf);
+    if (ret != ESP_OK) {
+        goto error;
+    }
+    ret = i2c_driver_install(i2c_bus[port]->i2c_port, i2c_bus[port]->i2c_conf.mode, ESP_I2C_MASTER_BUF_LEN, ESP_I2C_MASTER_BUF_LEN, ESP_INTR_FLG_DEFAULT);
+    if (ret != ESP_OK) {
+        goto error;
+    }
+    i2c_bus[port]->bus_lock = mutex_create();
+    if (i2c_bus[port]->bus_lock == NULL) {
+        goto error;
+    }
+    return (i2c_bus_handle_t) i2c_bus[port];
+
+error:
+    if (i2c_bus[port]) {
+        if (i2c_bus[port]->bus_lock == NULL) {
+            mutex_destroy(i2c_bus[port]->bus_lock);
+        }
+        audio_free(i2c_bus[port]);
+    }
+    return NULL;
+}
+
+esp_err_t i2c_bus_write_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int regLen, uint8_t *data, int datalen)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
+    I2C_BUS_CHECK(p_bus->i2c_port < I2C_NUM_MAX, "I2C port error", ESP_FAIL);
+    I2C_BUS_CHECK(data != NULL, "Not initialized input data pointer", ESP_FAIL);
+    esp_err_t ret = ESP_OK;
+    mutex_lock(p_bus->bus_lock);
+    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
+    ret |= i2c_master_start(cmd);
+    ret |= i2c_master_write_byte(cmd, addr, 1);
+    ret |= i2c_master_write(cmd, reg, regLen, I2C_ACK_CHECK_EN);
+    ret |= i2c_master_write(cmd, data, datalen, I2C_ACK_CHECK_EN);
+    ret |= i2c_master_stop(cmd);
+    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_PERIOD_MS);
+    i2c_cmd_link_delete(cmd);
+    mutex_unlock(p_bus->bus_lock);
+    I2C_BUS_CHECK(ret == 0, "I2C Bus WriteReg Error", ESP_FAIL);
+    return ret;
+}
+
+esp_err_t i2c_bus_write_data(i2c_bus_handle_t bus, int addr, uint8_t *data, int datalen)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
+    I2C_BUS_CHECK(p_bus->i2c_port < I2C_NUM_MAX, "I2C port error", ESP_FAIL);
+    I2C_BUS_CHECK(data != NULL, "Not initialized input data pointer", ESP_FAIL);
+    esp_err_t ret = ESP_OK;
+    mutex_lock(p_bus->bus_lock);
+    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
+    ret |= i2c_master_start(cmd);
+    ret |= i2c_master_write_byte(cmd, addr, 1);
+    ret |= i2c_master_write(cmd, data, datalen, I2C_ACK_CHECK_EN);
+    ret |= i2c_master_stop(cmd);
+    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_PERIOD_MS);
+    i2c_cmd_link_delete(cmd);
+    mutex_unlock(p_bus->bus_lock);
+    I2C_BUS_CHECK(ret == 0, "I2C Bus WriteReg Error", ESP_FAIL);
+    return ret;
+}
+
+esp_err_t i2c_bus_read_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int reglen, uint8_t *outdata, int datalen)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
+    I2C_BUS_CHECK(p_bus->i2c_port < I2C_NUM_MAX, "I2C port error", ESP_FAIL);
+    I2C_BUS_CHECK(outdata != NULL, "Not initialized output data buffer pointer", ESP_FAIL);
+    esp_err_t ret = ESP_OK;
+    mutex_lock(p_bus->bus_lock);
+    i2c_cmd_handle_t cmd;
+    cmd = i2c_cmd_link_create();
+    ret |= i2c_master_start(cmd);
+    ret |= i2c_master_write_byte(cmd, addr, I2C_ACK_CHECK_EN);
+    ret |= i2c_master_write(cmd, reg, reglen, I2C_ACK_CHECK_EN);
+    ret |= i2c_master_stop(cmd);
+    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_PERIOD_MS);
+    i2c_cmd_link_delete(cmd);
+
+    cmd = i2c_cmd_link_create();
+    ret |= i2c_master_start(cmd);
+    ret |= i2c_master_write_byte(cmd, addr | 0x01, I2C_ACK_CHECK_EN);
+
+    for (int i = 0; i < datalen - 1; i++) {
+        ret |= i2c_master_read_byte(cmd, &outdata[i], 0);
+    }
+    ret |= i2c_master_read_byte(cmd, &outdata[datalen - 1], 1);
+
+    ret |= i2c_master_stop(cmd);
+    ret |= i2c_master_cmd_begin(p_bus->i2c_port, cmd, 1000 / portTICK_PERIOD_MS);
+    i2c_cmd_link_delete(cmd);
+
+    mutex_unlock(p_bus->bus_lock);
+    I2C_BUS_CHECK(ret == 0, "I2C Bus ReadReg Error", ESP_FAIL);
+    return ret;
+}
+
+esp_err_t i2c_bus_delete(i2c_bus_handle_t bus)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
+    if (--p_bus->ref_count == 0) {
+        i2c_driver_delete(p_bus->i2c_port);
+        i2c_bus[p_bus->i2c_port] = NULL;
+        mutex_destroy(p_bus->bus_lock);
+        audio_free(p_bus);
+    }
+    return ESP_OK;
+}
+
+esp_err_t i2c_bus_cmd_begin(i2c_bus_handle_t bus, i2c_cmd_handle_t cmd, portBASE_TYPE ticks_to_wait)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    I2C_BUS_CHECK(cmd != NULL, "I2C cmd error", ESP_FAIL);
+    i2c_bus_t *p_bus = (i2c_bus_t *) bus;
+
+    esp_err_t ret = i2c_master_cmd_begin(p_bus->i2c_port, cmd, ticks_to_wait);
+    return ret;
+}
+
+esp_err_t i2c_bus_probe_addr(i2c_bus_handle_t bus, uint8_t addr)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    /* Use 7 bit address here */
+    if (addr >= 0x80) {
+        ESP_LOGE(TAG, "I2C addr out of range");
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    i2c_bus_t *i2c_bus = (i2c_bus_t *) bus;
+    mutex_lock(i2c_bus->bus_lock);
+    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
+    i2c_master_start(cmd);
+    i2c_master_write_byte(cmd, addr, I2C_ACK_CHECK_EN);
+    i2c_master_stop(cmd);
+    esp_err_t ret_val = i2c_master_cmd_begin(i2c_bus->i2c_port, cmd, pdMS_TO_TICKS(500));
+    i2c_cmd_link_delete(cmd);
+    mutex_unlock(i2c_bus->bus_lock);
+
+    /* Get probe result if ESP_OK equals to ret_val */
+    return ret_val;
+}
+
+esp_err_t i2c_bus_run_cb(i2c_bus_handle_t bus, i2c_run_cb_t cb, void *arg)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    I2C_BUS_CHECK(cb != NULL, "Invalid callback", ESP_FAIL);
+
+    i2c_bus_t *i2c_bus = (i2c_bus_t *) bus;
+    mutex_lock(i2c_bus->bus_lock);
+    (*cb)(i2c_bus->i2c_port, arg);
+    mutex_unlock(i2c_bus->bus_lock);
+
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/driver/i2c_bus/i2c_bus.h b/components/esp_peripherals/driver/i2c_bus/i2c_bus.h
index 88bda9fc..4baac431 100644
--- a/components/esp_peripherals/driver/i2c_bus/i2c_bus.h
+++ b/components/esp_peripherals/driver/i2c_bus/i2c_bus.h
@@ -1,212 +1,212 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2017 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef _IOT_I2C_BUS_H_
-#define _IOT_I2C_BUS_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif  /* __cplusplus */
-
-#include "audio_idf_version.h"
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0))
-#include "driver/i2c_master.h"
-#endif  /* (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0)) */
-
-#include "driver/i2c.h"
-
-typedef void *i2c_bus_handle_t;
-typedef void (*i2c_run_cb_t)(i2c_port_t port, void *arg);
-
-/**
- * @brief  Create and init I2C bus and return a I2C bus handle
- *
- * @param  port  I2C port number
- * @param  conf  Pointer to I2C parameters
- *
- * @return
- *       - I2C  bus handle
- */
-i2c_bus_handle_t i2c_bus_create(i2c_port_t port, i2c_config_t *conf);
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0))
-/**
- * @brief  Set I2S master bus handle
- *
- * @param  port           I2C port number
- * @param  master_handle  I2C master bus handle.
- *
- * @return
- *       - ESP_OK  on success
- */
-esp_err_t i2c_bus_set_master_handle(i2c_port_t port, i2c_master_bus_handle_t master_handle);
-
-/**
- * @brief  Get I2S master bus handle
- *
- * @param  port  I2C port number
- *
- * @return
- *       - I2C  master bus handle.
- */
-i2c_master_bus_handle_t i2c_bus_get_master_handle(i2c_port_t port);
-
-/**
- * @brief  Read certain bytes of data from I2C bus by address
- *
- *         ___________________________________________________
- *         | start | slave_addr + rd_bit + ack | .....  | stop |
- *         --------|---------------------------|-- -----|------|
- *
- * @note  Directly reads the data in the registers address without a write action
- *
- * @param  bus      I2C bus handle
- * @param  addr     The address of the device
- * @param  outdata  The outdata pointer
- * @param  datalen  The length of outdata
- *
- * @return
- *       - ESP_OK    Success
- *       - ESP_FAIL  Fail
- */
-esp_err_t i2c_bus_read_bytes_directly(i2c_bus_handle_t bus, int addr, uint8_t *outdata, int datalen);
-
-/**
- * @brief  Set I2C bus clock frequency
- *
- * @note  This function need called before any i2c bus read or write operation
- *
- * @param  bus        I2C bus handle
- * @param  clk_speed  I2C clk frequency
- *
- * @return
- *       - ESP_OK    Success
- *       - ESP_FAIL  Fail
- */
-esp_err_t i2c_bus_set_clk(i2c_bus_handle_t bus, uint32_t clk_speed);
-
-#else
-
-/**
- * @brief  I2C start sending buffered commands
- *
- * @param  bus            I2C bus handle
- * @param  cmd            I2C cmd handle
- * @param  ticks_to_wait  Maximum blocking time
- *
- * @return
- *       - ESP_OK    Success
- *       - ESP_FAIL  Fail
- */
-esp_err_t i2c_bus_cmd_begin(i2c_bus_handle_t bus, i2c_cmd_handle_t cmd, portBASE_TYPE ticks_to_wait);
-
-#endif  /* (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0)) */
-
-/**
- * @brief  Write bytes to I2C bus
- *
- * @param  bus      I2C bus handle
- * @param  addr     The address of the device
- * @param  reg      The register of the device
- * @param  regLen   The length of register
- * @param  data     The data pointer
- * @param  datalen  The length of data
- *
- * @return
- *       - NULL    Fail
- *       - Others  Success
- */
-esp_err_t i2c_bus_write_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int regLen, uint8_t *data, int datalen);
-
-/**
- * @brief  Write data to I2C bus
- *
- * @param  bus      I2C bus handle
- * @param  addr     The address of the device
- * @param  data     The data pointer
- * @param  datalen  The length of data
- *
- * @return
- *       - NULL    Fail
- *       - Others  Success
- */
-esp_err_t i2c_bus_write_data(i2c_bus_handle_t bus, int addr, uint8_t *data, int datalen);
-
-/**
- * @brief  Read bytes to I2C bus
- *
- * @param  bus      I2C bus handle
- * @param  addr     The address of the device
- * @param  reg      The register of the device
- * @param  regLen   The length of register
- * @param  outdata  The outdata pointer
- * @param  datalen  The length of outdata
- *
- * @return
- *       - NULL    Fail
- *       - Others  Success
- */
-esp_err_t i2c_bus_read_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int reglen, uint8_t *outdata, int datalen);
-
-/**
- * @brief  Delete and release the I2C bus object
- *
- * @param  bus  I2C bus handle
- *
- * @return
- *       - ESP_OK    Success
- *       - ESP_FAIL  Fail
- */
-esp_err_t i2c_bus_delete(i2c_bus_handle_t bus);
-
-/**
- * @brief  Auto probe the I2C device
- *
- * @param  bus   I2C bus handle
- * @param  addr  I2C 8bit address
- *
- * @return
- *       - ESP_OK    Found a I2C device
- *       - ESP_FAIL  Fail
- */
-esp_err_t i2c_bus_probe_addr(i2c_bus_handle_t bus, uint8_t addr);
-
-/**
- * @brief  Lock the I2C bus while executing the given callback
- *
- * @param  bus  I2C bus handle
- * @param  cb   The callback to execute
- * @param  arg  The argument for the callback
- *
- * @return
- *       - ESP_OK    Done calling callback function
- *       - ESP_FAIL  Fail
- */
-esp_err_t i2c_bus_run_cb(i2c_bus_handle_t bus, i2c_run_cb_t cb, void *arg);
-
-#ifdef __cplusplus
-}
-#endif  /* __cplusplus */
-
-#endif  /* _IOT_I2C_BUS_H_ */
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2017 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef _IOT_I2C_BUS_H_
+#define _IOT_I2C_BUS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+#include "audio_idf_version.h"
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0))
+#include "driver/i2c_master.h"
+#endif  /* (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0)) */
+
+#include "driver/i2c.h"
+
+typedef void *i2c_bus_handle_t;
+typedef void (*i2c_run_cb_t)(i2c_port_t port, void *arg);
+
+/**
+ * @brief  Create and init I2C bus and return a I2C bus handle
+ *
+ * @param  port  I2C port number
+ * @param  conf  Pointer to I2C parameters
+ *
+ * @return
+ *       - I2C  bus handle
+ */
+i2c_bus_handle_t i2c_bus_create(i2c_port_t port, i2c_config_t *conf);
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0))
+/**
+ * @brief  Set I2S master bus handle
+ *
+ * @param  port           I2C port number
+ * @param  master_handle  I2C master bus handle.
+ *
+ * @return
+ *       - ESP_OK  on success
+ */
+esp_err_t i2c_bus_set_master_handle(i2c_port_t port, i2c_master_bus_handle_t master_handle);
+
+/**
+ * @brief  Get I2S master bus handle
+ *
+ * @param  port  I2C port number
+ *
+ * @return
+ *       - I2C  master bus handle.
+ */
+i2c_master_bus_handle_t i2c_bus_get_master_handle(i2c_port_t port);
+
+/**
+ * @brief  Read certain bytes of data from I2C bus by address
+ *
+ *         ___________________________________________________
+ *         | start | slave_addr + rd_bit + ack | .....  | stop |
+ *         --------|---------------------------|-- -----|------|
+ *
+ * @note  Directly reads the data in the registers address without a write action
+ *
+ * @param  bus      I2C bus handle
+ * @param  addr     The address of the device
+ * @param  outdata  The outdata pointer
+ * @param  datalen  The length of outdata
+ *
+ * @return
+ *       - ESP_OK    Success
+ *       - ESP_FAIL  Fail
+ */
+esp_err_t i2c_bus_read_bytes_directly(i2c_bus_handle_t bus, int addr, uint8_t *outdata, int datalen);
+
+/**
+ * @brief  Set I2C bus clock frequency
+ *
+ * @note  This function need called before any i2c bus read or write operation
+ *
+ * @param  bus        I2C bus handle
+ * @param  clk_speed  I2C clk frequency
+ *
+ * @return
+ *       - ESP_OK    Success
+ *       - ESP_FAIL  Fail
+ */
+esp_err_t i2c_bus_set_clk(i2c_bus_handle_t bus, uint32_t clk_speed);
+
+#else
+
+/**
+ * @brief  I2C start sending buffered commands
+ *
+ * @param  bus            I2C bus handle
+ * @param  cmd            I2C cmd handle
+ * @param  ticks_to_wait  Maximum blocking time
+ *
+ * @return
+ *       - ESP_OK    Success
+ *       - ESP_FAIL  Fail
+ */
+esp_err_t i2c_bus_cmd_begin(i2c_bus_handle_t bus, i2c_cmd_handle_t cmd, portBASE_TYPE ticks_to_wait);
+
+#endif  /* (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0)) */
+
+/**
+ * @brief  Write bytes to I2C bus
+ *
+ * @param  bus      I2C bus handle
+ * @param  addr     The address of the device
+ * @param  reg      The register of the device
+ * @param  regLen   The length of register
+ * @param  data     The data pointer
+ * @param  datalen  The length of data
+ *
+ * @return
+ *       - NULL    Fail
+ *       - Others  Success
+ */
+esp_err_t i2c_bus_write_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int regLen, uint8_t *data, int datalen);
+
+/**
+ * @brief  Write data to I2C bus
+ *
+ * @param  bus      I2C bus handle
+ * @param  addr     The address of the device
+ * @param  data     The data pointer
+ * @param  datalen  The length of data
+ *
+ * @return
+ *       - NULL    Fail
+ *       - Others  Success
+ */
+esp_err_t i2c_bus_write_data(i2c_bus_handle_t bus, int addr, uint8_t *data, int datalen);
+
+/**
+ * @brief  Read bytes to I2C bus
+ *
+ * @param  bus      I2C bus handle
+ * @param  addr     The address of the device
+ * @param  reg      The register of the device
+ * @param  regLen   The length of register
+ * @param  outdata  The outdata pointer
+ * @param  datalen  The length of outdata
+ *
+ * @return
+ *       - NULL    Fail
+ *       - Others  Success
+ */
+esp_err_t i2c_bus_read_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int reglen, uint8_t *outdata, int datalen);
+
+/**
+ * @brief  Delete and release the I2C bus object
+ *
+ * @param  bus  I2C bus handle
+ *
+ * @return
+ *       - ESP_OK    Success
+ *       - ESP_FAIL  Fail
+ */
+esp_err_t i2c_bus_delete(i2c_bus_handle_t bus);
+
+/**
+ * @brief  Auto probe the I2C device
+ *
+ * @param  bus   I2C bus handle
+ * @param  addr  I2C 8bit address
+ *
+ * @return
+ *       - ESP_OK    Found a I2C device
+ *       - ESP_FAIL  Fail
+ */
+esp_err_t i2c_bus_probe_addr(i2c_bus_handle_t bus, uint8_t addr);
+
+/**
+ * @brief  Lock the I2C bus while executing the given callback
+ *
+ * @param  bus  I2C bus handle
+ * @param  cb   The callback to execute
+ * @param  arg  The argument for the callback
+ *
+ * @return
+ *       - ESP_OK    Done calling callback function
+ *       - ESP_FAIL  Fail
+ */
+esp_err_t i2c_bus_run_cb(i2c_bus_handle_t bus, i2c_run_cb_t cb, void *arg);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* _IOT_I2C_BUS_H_ */
diff --git a/components/esp_peripherals/driver/i2c_bus/i2c_bus_v2.c b/components/esp_peripherals/driver/i2c_bus/i2c_bus_v2.c
index cd4034b9..6474c84e 100644
--- a/components/esp_peripherals/driver/i2c_bus/i2c_bus_v2.c
+++ b/components/esp_peripherals/driver/i2c_bus/i2c_bus_v2.c
@@ -1,259 +1,259 @@
-/*
-  * ESPRESSIF MIT License
-  *
-  * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
-  *
-  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
-  * it is free of charge, to any person obtaining a copy of this software and associated
-  * documentation files (the "Software"), to deal in the Software without restriction, including
-  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-  * to do so, subject to the following conditions:
-  *
-  * The above copyright notice and this permission notice shall be included in all copies or
-  * substantial portions of the Software.
-  *
-  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-  *
-  */
-
-#include <string.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include <sys/queue.h>
-#include "esp_log.h"
-#include "esp_heap_caps.h"
-#include "driver/i2c.h"
-#include "audio_mutex.h"
-#include "audio_mem.h"
-#include "audio_error.h"
-#include "i2c_bus.h"
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0))
-
-static const char *TAG = "i2c_bus_v2";
-
-#define I2C_BUS_CHECK(a, str, ret)  if(!(a)) {                               \
-    ESP_LOGE(TAG, "%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);   \
-    return (ret);                                                            \
-}
-
-#define I2C_BUS_PORT_CHECK_RET(port, err) do {      \
-    if (port < 0 || port > I2C_NUM_MAX) {           \
-        ESP_LOGE(TAG, "Invalid i2c port %d", port); \
-        return err;                                 \
-    }                                               \
-} while (0)
-
-#define DEFAULT_I2C_TRANS_TIMEOUT  (200)   // default i2c transmit timeout (ms)
-
-typedef struct i2c_dev_info_s {
-    SLIST_ENTRY(i2c_dev_info_s)  next;
-    uint16_t                     dev_addr;
-    i2c_master_dev_handle_t      dev_handle;
-} i2c_dev_info_t;
-
-typedef struct {
-    uint8_t                      port;
-    uint32_t                     clk;
-} i2c_bus_info_t;
-
-typedef struct {
-    i2c_master_bus_handle_t      master_handle;
-    int                          ref_count;
-    xSemaphoreHandle             bus_lock;
-    SLIST_HEAD( ,i2c_dev_info_s) dev_lists;
-} i2c_master_info_t;
- 
-static i2c_master_info_t master[I2C_NUM_MAX];
-
-static i2c_master_dev_handle_t get_i2c_device_handle(i2c_bus_info_t* bus, uint16_t addr)
-{
-    i2c_dev_info_t* dev_info = NULL;
-    SLIST_FOREACH(dev_info, &master[bus->port].dev_lists, next) {
-        if (dev_info->dev_addr == addr) {
-            return dev_info->dev_handle;
-        }
-    }
-    return NULL;
-}
-
-static i2c_master_dev_handle_t add_i2c_device(i2c_bus_info_t* bus, uint16_t addr)
-{
-    i2c_dev_info_t* dev_info = audio_calloc(1, sizeof(i2c_dev_info_t)); // calloc and put to dev lists
-    I2C_BUS_CHECK(dev_info, "Insufficient memory", NULL);
-    i2c_device_config_t cfg = {
-        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
-        .device_address = addr >> 1,
-        .scl_speed_hz = bus->clk,
-    };
-    esp_err_t ret = i2c_master_bus_add_device(master[bus->port].master_handle, &cfg, &dev_info->dev_handle);
-    AUDIO_RET_ON_FALSE(TAG, ret, return NULL, "Failed to add device to bus");
-    dev_info->dev_addr = addr;
-    SLIST_INSERT_HEAD(&master[bus->port].dev_lists, dev_info, next);
-    return dev_info->dev_handle;
-}
-
-static i2c_master_dev_handle_t try_get_i2c_device_handle(i2c_bus_info_t* bus, uint16_t addr)
-{
-    i2c_master_dev_handle_t handle = get_i2c_device_handle(bus, addr);
-    if (handle) {
-        return handle;
-    }
-    return add_i2c_device(bus, addr);
-}
-
-static i2c_master_bus_handle_t i2c_master_create(i2c_port_t port, i2c_config_t *cfg)
-{
-    esp_err_t ret = ESP_OK;
-    i2c_master_bus_handle_t i2c_bus_handle;
-    i2c_master_bus_config_t i2c_bus_config = {0};
-    i2c_bus_config.clk_source = I2C_CLK_SRC_DEFAULT;
-    i2c_bus_config.i2c_port = port;
-    i2c_bus_config.scl_io_num = cfg->scl_io_num;
-    i2c_bus_config.sda_io_num = cfg->sda_io_num;
-    i2c_bus_config.glitch_ignore_cnt = 7;
-    i2c_bus_config.flags.enable_internal_pullup = true;
-    ret = i2c_new_master_bus(&i2c_bus_config, &i2c_bus_handle);
-    if (ret == ESP_OK) {
-        return i2c_bus_handle;
-    }
-    return NULL;
-}
-
-i2c_bus_handle_t i2c_bus_create(i2c_port_t port, i2c_config_t *conf)
-{
-    I2C_BUS_PORT_CHECK_RET(port, NULL);
-    I2C_BUS_CHECK(conf != NULL, "Configuration not initialized", NULL);
-
-    if (master[port].master_handle == NULL) {
-        ESP_LOGW(TAG, "I2C master handle is NULL, will create new one");
-        master[port].master_handle = i2c_master_create(port, conf);
-        AUDIO_MEM_CHECK(TAG, master[port].master_handle, return NULL);
-    }
-    if (master[port].bus_lock == NULL) {
-        master[port].bus_lock = mutex_create();
-        AUDIO_MEM_CHECK(TAG, master[port].bus_lock, return NULL;);
-        SLIST_INIT(&master[port].dev_lists);
-    }
-    i2c_bus_info_t* bus = audio_calloc(1, sizeof(i2c_bus_info_t));
-    bus->port = port;
-    bus->clk = conf->master.clk_speed;
-    __sync_fetch_and_add(&master[port].ref_count, 1);
-
-    return (i2c_bus_handle_t)bus;
-}
-
-esp_err_t i2c_bus_write_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int regLen, uint8_t *data, int datalen)
-{
-    i2c_bus_info_t* bus_info = (i2c_bus_info_t*)bus;
-    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
-    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
-
-    int write_len = regLen + datalen;
-    uint8_t *write_buffer = (uint8_t*)audio_calloc(1, write_len);
-    AUDIO_MEM_CHECK(TAG, write_buffer, return ESP_FAIL);
-
-    memcpy(write_buffer, reg, regLen);
-    memcpy(write_buffer + regLen, data, datalen);
-    mutex_lock(master[bus_info->port].bus_lock);
-    int ret = i2c_master_transmit(dev_handle, write_buffer, write_len, DEFAULT_I2C_TRANS_TIMEOUT);
-    mutex_unlock(master[bus_info->port].bus_lock);
-    AUDIO_RET_ON_FALSE(TAG, ret, {audio_free(write_buffer); return ESP_FAIL;}, "I2C bus write bytes failed");
-    audio_free(write_buffer);
-    return ESP_OK;
-}
-
-esp_err_t i2c_bus_set_master_handle(i2c_port_t port, i2c_master_bus_handle_t master_handle)
-{
-    I2C_BUS_PORT_CHECK_RET(port, ESP_ERR_INVALID_ARG);
-    master[port].master_handle = master_handle;
-    return ESP_OK;
-}
-
-i2c_master_bus_handle_t i2c_bus_get_master_handle(i2c_port_t port)
-{
-    I2C_BUS_PORT_CHECK_RET(port, NULL);
-    i2c_master_bus_handle_t bus =  master[port].master_handle;
-    return bus;
-}
-
-esp_err_t i2c_bus_write_data(i2c_bus_handle_t bus, int addr, uint8_t *data, int datalen)
-{
-    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
-    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
-    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
-
-    mutex_lock(master[bus_info->port].bus_lock);
-    esp_err_t ret = i2c_master_transmit(dev_handle, data, datalen, DEFAULT_I2C_TRANS_TIMEOUT);
-    mutex_unlock(master[bus_info->port].bus_lock);
-    AUDIO_RET_ON_FALSE(TAG, ret, {return ESP_FAIL;}, "I2C bus write bytes failed");
-    return ESP_OK;
-}
-
-esp_err_t i2c_bus_read_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int reglen, uint8_t *outdata, int datalen)
-{
-    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
-    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
-    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
-
-    mutex_lock(master[bus_info->port].bus_lock);
-    esp_err_t ret = i2c_master_transmit_receive(dev_handle, reg, reglen, outdata, datalen, DEFAULT_I2C_TRANS_TIMEOUT);
-    mutex_unlock(master[bus_info->port].bus_lock);
-    AUDIO_RET_ON_FALSE(TAG, ret, {return ESP_FAIL;}, "I2C bus read bytes failed");
-    return ESP_OK;
-}
-
-esp_err_t i2c_bus_read_bytes_directly(i2c_bus_handle_t bus, int addr, uint8_t *outdata, int datalen)
-{
-    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
-    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
-    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
-
-    mutex_lock(master[bus_info->port].bus_lock);
-    esp_err_t ret = i2c_master_receive(dev_handle, outdata, datalen, DEFAULT_I2C_TRANS_TIMEOUT);
-    mutex_unlock(master[bus_info->port].bus_lock);
-    AUDIO_RET_ON_FALSE(TAG, ret, {return ESP_FAIL;}, "I2C bus read bytes failed");
-    return ESP_OK;
-}
-
-esp_err_t i2c_bus_delete(i2c_bus_handle_t bus)
-{
-    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
-    __sync_fetch_and_sub(&master[bus_info->port].ref_count, 1);
-    if (master[bus_info->port].ref_count == 0) {
-        mutex_destroy(master[bus_info->port].bus_lock);
-        master[bus_info->port].bus_lock = NULL;
-    }
-    audio_free(bus);
-    return ESP_OK;
-}
-
-esp_err_t i2c_bus_probe_addr(i2c_bus_handle_t bus, uint8_t addr)
-{
-    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
-    esp_err_t ret = ESP_OK;
-    mutex_lock(master[bus_info->port].bus_lock);
-    ret = i2c_master_probe(master[bus_info->port].master_handle, addr >> 1, DEFAULT_I2C_TRANS_TIMEOUT);
-    mutex_unlock(master[bus_info->port].bus_lock);
-    return ret;
-}
-
-esp_err_t i2c_bus_run_cb(i2c_bus_handle_t bus, i2c_run_cb_t cb, void *arg)
-{
-    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
-    I2C_BUS_CHECK(cb != NULL, "Invalid callback", ESP_FAIL);
-
-    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
-    mutex_lock(master[bus_info->port].bus_lock);
-    (*cb)(bus_info->port, arg);
-    mutex_unlock(master[bus_info->port].bus_lock);
-    return ESP_OK;
-}
-
-#endif /* ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0) */
+/*
+  * ESPRESSIF MIT License
+  *
+  * Copyright (c) 2024 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+  *
+  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
+  * it is free of charge, to any person obtaining a copy of this software and associated
+  * documentation files (the "Software"), to deal in the Software without restriction, including
+  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+  * to do so, subject to the following conditions:
+  *
+  * The above copyright notice and this permission notice shall be included in all copies or
+  * substantial portions of the Software.
+  *
+  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+  *
+  */
+
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include <sys/queue.h>
+#include "esp_log.h"
+#include "esp_heap_caps.h"
+#include "driver/i2c.h"
+#include "audio_mutex.h"
+#include "audio_mem.h"
+#include "audio_error.h"
+#include "i2c_bus.h"
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0))
+
+static const char *TAG = "i2c_bus_v2";
+
+#define I2C_BUS_CHECK(a, str, ret)  if(!(a)) {                               \
+    ESP_LOGE(TAG, "%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);   \
+    return (ret);                                                            \
+}
+
+#define I2C_BUS_PORT_CHECK_RET(port, err) do {      \
+    if (port < 0 || port > I2C_NUM_MAX) {           \
+        ESP_LOGE(TAG, "Invalid i2c port %d", port); \
+        return err;                                 \
+    }                                               \
+} while (0)
+
+#define DEFAULT_I2C_TRANS_TIMEOUT  (200)   // default i2c transmit timeout (ms)
+
+typedef struct i2c_dev_info_s {
+    SLIST_ENTRY(i2c_dev_info_s)  next;
+    uint16_t                     dev_addr;
+    i2c_master_dev_handle_t      dev_handle;
+} i2c_dev_info_t;
+
+typedef struct {
+    uint8_t                      port;
+    uint32_t                     clk;
+} i2c_bus_info_t;
+
+typedef struct {
+    i2c_master_bus_handle_t      master_handle;
+    int                          ref_count;
+    xSemaphoreHandle             bus_lock;
+    SLIST_HEAD( ,i2c_dev_info_s) dev_lists;
+} i2c_master_info_t;
+ 
+static i2c_master_info_t master[I2C_NUM_MAX];
+
+static i2c_master_dev_handle_t get_i2c_device_handle(i2c_bus_info_t* bus, uint16_t addr)
+{
+    i2c_dev_info_t* dev_info = NULL;
+    SLIST_FOREACH(dev_info, &master[bus->port].dev_lists, next) {
+        if (dev_info->dev_addr == addr) {
+            return dev_info->dev_handle;
+        }
+    }
+    return NULL;
+}
+
+static i2c_master_dev_handle_t add_i2c_device(i2c_bus_info_t* bus, uint16_t addr)
+{
+    i2c_dev_info_t* dev_info = audio_calloc(1, sizeof(i2c_dev_info_t)); // calloc and put to dev lists
+    I2C_BUS_CHECK(dev_info, "Insufficient memory", NULL);
+    i2c_device_config_t cfg = {
+        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
+        .device_address = addr >> 1,
+        .scl_speed_hz = bus->clk,
+    };
+    esp_err_t ret = i2c_master_bus_add_device(master[bus->port].master_handle, &cfg, &dev_info->dev_handle);
+    AUDIO_RET_ON_FALSE(TAG, ret, return NULL, "Failed to add device to bus");
+    dev_info->dev_addr = addr;
+    SLIST_INSERT_HEAD(&master[bus->port].dev_lists, dev_info, next);
+    return dev_info->dev_handle;
+}
+
+static i2c_master_dev_handle_t try_get_i2c_device_handle(i2c_bus_info_t* bus, uint16_t addr)
+{
+    i2c_master_dev_handle_t handle = get_i2c_device_handle(bus, addr);
+    if (handle) {
+        return handle;
+    }
+    return add_i2c_device(bus, addr);
+}
+
+static i2c_master_bus_handle_t i2c_master_create(i2c_port_t port, i2c_config_t *cfg)
+{
+    esp_err_t ret = ESP_OK;
+    i2c_master_bus_handle_t i2c_bus_handle;
+    i2c_master_bus_config_t i2c_bus_config = {0};
+    i2c_bus_config.clk_source = I2C_CLK_SRC_DEFAULT;
+    i2c_bus_config.i2c_port = port;
+    i2c_bus_config.scl_io_num = cfg->scl_io_num;
+    i2c_bus_config.sda_io_num = cfg->sda_io_num;
+    i2c_bus_config.glitch_ignore_cnt = 7;
+    i2c_bus_config.flags.enable_internal_pullup = true;
+    ret = i2c_new_master_bus(&i2c_bus_config, &i2c_bus_handle);
+    if (ret == ESP_OK) {
+        return i2c_bus_handle;
+    }
+    return NULL;
+}
+
+i2c_bus_handle_t i2c_bus_create(i2c_port_t port, i2c_config_t *conf)
+{
+    I2C_BUS_PORT_CHECK_RET(port, NULL);
+    I2C_BUS_CHECK(conf != NULL, "Configuration not initialized", NULL);
+
+    if (master[port].master_handle == NULL) {
+        ESP_LOGW(TAG, "I2C master handle is NULL, will create new one");
+        master[port].master_handle = i2c_master_create(port, conf);
+        AUDIO_MEM_CHECK(TAG, master[port].master_handle, return NULL);
+    }
+    if (master[port].bus_lock == NULL) {
+        master[port].bus_lock = mutex_create();
+        AUDIO_MEM_CHECK(TAG, master[port].bus_lock, return NULL;);
+        SLIST_INIT(&master[port].dev_lists);
+    }
+    i2c_bus_info_t* bus = audio_calloc(1, sizeof(i2c_bus_info_t));
+    bus->port = port;
+    bus->clk = conf->master.clk_speed;
+    __sync_fetch_and_add(&master[port].ref_count, 1);
+
+    return (i2c_bus_handle_t)bus;
+}
+
+esp_err_t i2c_bus_write_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int regLen, uint8_t *data, int datalen)
+{
+    i2c_bus_info_t* bus_info = (i2c_bus_info_t*)bus;
+    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
+    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
+
+    int write_len = regLen + datalen;
+    uint8_t *write_buffer = (uint8_t*)audio_calloc(1, write_len);
+    AUDIO_MEM_CHECK(TAG, write_buffer, return ESP_FAIL);
+
+    memcpy(write_buffer, reg, regLen);
+    memcpy(write_buffer + regLen, data, datalen);
+    mutex_lock(master[bus_info->port].bus_lock);
+    int ret = i2c_master_transmit(dev_handle, write_buffer, write_len, DEFAULT_I2C_TRANS_TIMEOUT);
+    mutex_unlock(master[bus_info->port].bus_lock);
+    AUDIO_RET_ON_FALSE(TAG, ret, {audio_free(write_buffer); return ESP_FAIL;}, "I2C bus write bytes failed");
+    audio_free(write_buffer);
+    return ESP_OK;
+}
+
+esp_err_t i2c_bus_set_master_handle(i2c_port_t port, i2c_master_bus_handle_t master_handle)
+{
+    I2C_BUS_PORT_CHECK_RET(port, ESP_ERR_INVALID_ARG);
+    master[port].master_handle = master_handle;
+    return ESP_OK;
+}
+
+i2c_master_bus_handle_t i2c_bus_get_master_handle(i2c_port_t port)
+{
+    I2C_BUS_PORT_CHECK_RET(port, NULL);
+    i2c_master_bus_handle_t bus =  master[port].master_handle;
+    return bus;
+}
+
+esp_err_t i2c_bus_write_data(i2c_bus_handle_t bus, int addr, uint8_t *data, int datalen)
+{
+    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
+    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
+    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
+
+    mutex_lock(master[bus_info->port].bus_lock);
+    esp_err_t ret = i2c_master_transmit(dev_handle, data, datalen, DEFAULT_I2C_TRANS_TIMEOUT);
+    mutex_unlock(master[bus_info->port].bus_lock);
+    AUDIO_RET_ON_FALSE(TAG, ret, {return ESP_FAIL;}, "I2C bus write bytes failed");
+    return ESP_OK;
+}
+
+esp_err_t i2c_bus_read_bytes(i2c_bus_handle_t bus, int addr, uint8_t *reg, int reglen, uint8_t *outdata, int datalen)
+{
+    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
+    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
+    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
+
+    mutex_lock(master[bus_info->port].bus_lock);
+    esp_err_t ret = i2c_master_transmit_receive(dev_handle, reg, reglen, outdata, datalen, DEFAULT_I2C_TRANS_TIMEOUT);
+    mutex_unlock(master[bus_info->port].bus_lock);
+    AUDIO_RET_ON_FALSE(TAG, ret, {return ESP_FAIL;}, "I2C bus read bytes failed");
+    return ESP_OK;
+}
+
+esp_err_t i2c_bus_read_bytes_directly(i2c_bus_handle_t bus, int addr, uint8_t *outdata, int datalen)
+{
+    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
+    i2c_master_dev_handle_t dev_handle = try_get_i2c_device_handle(bus, addr);
+    I2C_BUS_CHECK(dev_handle != NULL, "I2C device handle is NULL", ESP_FAIL);
+
+    mutex_lock(master[bus_info->port].bus_lock);
+    esp_err_t ret = i2c_master_receive(dev_handle, outdata, datalen, DEFAULT_I2C_TRANS_TIMEOUT);
+    mutex_unlock(master[bus_info->port].bus_lock);
+    AUDIO_RET_ON_FALSE(TAG, ret, {return ESP_FAIL;}, "I2C bus read bytes failed");
+    return ESP_OK;
+}
+
+esp_err_t i2c_bus_delete(i2c_bus_handle_t bus)
+{
+    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
+    __sync_fetch_and_sub(&master[bus_info->port].ref_count, 1);
+    if (master[bus_info->port].ref_count == 0) {
+        mutex_destroy(master[bus_info->port].bus_lock);
+        master[bus_info->port].bus_lock = NULL;
+    }
+    audio_free(bus);
+    return ESP_OK;
+}
+
+esp_err_t i2c_bus_probe_addr(i2c_bus_handle_t bus, uint8_t addr)
+{
+    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
+    esp_err_t ret = ESP_OK;
+    mutex_lock(master[bus_info->port].bus_lock);
+    ret = i2c_master_probe(master[bus_info->port].master_handle, addr >> 1, DEFAULT_I2C_TRANS_TIMEOUT);
+    mutex_unlock(master[bus_info->port].bus_lock);
+    return ret;
+}
+
+esp_err_t i2c_bus_run_cb(i2c_bus_handle_t bus, i2c_run_cb_t cb, void *arg)
+{
+    I2C_BUS_CHECK(bus != NULL, "Handle error", ESP_FAIL);
+    I2C_BUS_CHECK(cb != NULL, "Invalid callback", ESP_FAIL);
+
+    i2c_bus_info_t *bus_info = (i2c_bus_info_t *)bus;
+    mutex_lock(master[bus_info->port].bus_lock);
+    (*cb)(bus_info->port, arg);
+    mutex_unlock(master[bus_info->port].bus_lock);
+    return ESP_OK;
+}
+
+#endif /* ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 3, 0) */
diff --git a/components/esp_peripherals/esp_peripherals.c b/components/esp_peripherals/esp_peripherals.c
index 0f85c53e..50ca8c30 100644
--- a/components/esp_peripherals/esp_peripherals.c
+++ b/components/esp_peripherals/esp_peripherals.c
@@ -1,519 +1,519 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "sys/queue.h"
-#include "driver/gpio.h"
-#include "esp_log.h"
-#include "audio_event_iface.h"
-#include "audio_mutex.h"
-#include "esp_peripherals.h"
-#include "audio_thread.h"
-#include "audio_mem.h"
-#include "audio_idf_version.h"
-
-static const char *TAG = "ESP_PERIPH";
-
-#define DEFAULT_ESP_PERIPH_WAIT_TICK       (10/portTICK_RATE_MS)
-
-struct esp_periph {
-    char                       *tag;
-    bool                        disabled;
-    esp_periph_id_t             periph_id;
-    esp_periph_func             init;
-    esp_periph_run_func         run;
-    esp_periph_func             destroy;
-    esp_periph_state_t          state;
-    void                       *source;
-    void                       *periph_data;
-    esp_periph_event_t         *on_evt;
-    TimerHandle_t               timer;
-    STAILQ_ENTRY(esp_periph)    entries;
-};
-
-typedef struct esp_periph_sets {
-    EventGroupHandle_t                              state_event_bits;
-    xSemaphoreHandle                                lock;
-    int                                             task_stack;
-    int                                             task_prio;
-    int                                             task_core;
-    audio_thread_t                                  audio_thread;
-    bool                                            ext_stack;
-    bool                                            run;
-    esp_periph_event_t                              event_handle;
-    int                                             periph_dynamic_id;
-    STAILQ_HEAD(esp_periph_list_item, esp_periph)   periph_list;
-} esp_periph_set_t;
-
-static const int STARTED_BIT = BIT0;
-static const int STOPPED_BIT = BIT1;
-
-static esp_err_t esp_periph_wait_for_stop(esp_periph_set_handle_t periph_set_handle, TickType_t ticks_to_wait);
-
-static esp_err_t process_peripheral_event(audio_event_iface_msg_t *msg, void *context)
-{
-    esp_periph_handle_t periph_evt = (esp_periph_handle_t) msg->source;
-    esp_periph_handle_t periph;
-    esp_periph_set_t *sets = context;
-    STAILQ_FOREACH(periph, &sets->periph_list, entries) {
-        if (periph->periph_id == periph_evt->periph_id
-            && periph_evt->state == PERIPH_STATE_RUNNING
-            && periph_evt->run
-            && !periph_evt->disabled) {
-            return periph_evt->run(periph_evt, msg);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_set_change_waiting_time(esp_periph_set_handle_t periph_set_handle, int time_ms)
-{
-    audio_event_iface_set_cmd_waiting_timeout(esp_periph_set_get_event_iface(periph_set_handle), time_ms / portTICK_RATE_MS);
-    return ESP_OK;
-}
-
-static void esp_periph_task(void *pv)
-{
-    esp_periph_handle_t periph;
-    esp_periph_set_handle_t periph_set_handle = (esp_periph_set_handle_t)pv;
-    ESP_LOGD(TAG, "esp_periph_task is running, handle:%p", periph_set_handle);
-    xEventGroupSetBits(periph_set_handle->state_event_bits, STARTED_BIT);
-    xEventGroupClearBits(periph_set_handle->state_event_bits, STOPPED_BIT);
-
-    while (periph_set_handle->run) {
-        mutex_lock(periph_set_handle->lock);
-        STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
-            if (periph->disabled) {
-                continue;
-            }
-            if (periph->state == PERIPH_STATE_INIT && periph->init) {
-                ESP_LOGD(TAG, "PERIPH[%s]->init", periph->tag);
-                if (periph->init(periph) == ESP_OK) {
-                    periph->state = PERIPH_STATE_RUNNING;
-                } else {
-                    periph->state = PERIPH_STATE_ERROR;
-                }
-            }
-        }
-        mutex_unlock(periph_set_handle->lock);
-        audio_event_iface_waiting_cmd_msg(esp_periph_set_get_event_iface(periph_set_handle));
-    }
-    STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
-        esp_periph_stop_timer(periph);
-        if (periph->destroy) {
-            periph->destroy(periph);
-        }
-    }
-    xEventGroupClearBits(periph_set_handle->state_event_bits, STARTED_BIT);
-    xEventGroupSetBits(periph_set_handle->state_event_bits, STOPPED_BIT);
-
-    vTaskDelete(NULL);
-}
-
-esp_periph_set_handle_t esp_periph_set_init(esp_periph_config_t *config)
-{
-    esp_err_t ret = ESP_OK;
-    esp_periph_set_t *periph_sets = NULL;
-    int _err_step = 1;
-    bool _success =
-        (
-            (periph_sets                   = audio_calloc(1, sizeof(esp_periph_set_t))) && _err_step ++ &&
-            (periph_sets->state_event_bits = xEventGroupCreate())                  && _err_step ++ &&
-            (periph_sets->lock             = mutex_create())                       && _err_step ++
-        );
-
-    AUDIO_MEM_CHECK(TAG, _success, {
-        goto _periph_init_failed;
-    });
-
-    STAILQ_INIT(&periph_sets->periph_list);
-
-    //TODO: Should we uninstall gpio isr service??
-    //TODO: Because gpio need for sdcard and gpio, then install isr here
-    ret = gpio_install_isr_service(ESP_INTR_FLAG_LEVEL2);
-    if (ret == ESP_ERR_NOT_FOUND) {
-        ESP_LOGE(TAG, "No free interrupt found with ESP_INTR_FLAG_LEVEL2");
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0))
-        ESP_LOGE(TAG,"Select an available interrupt level based on the interrupt table below");
-        esp_intr_dump(stdout);
-#endif // ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0)
-    }
-
-    periph_sets->run = false;
-    xEventGroupClearBits(periph_sets->state_event_bits, STARTED_BIT);
-    xEventGroupSetBits(periph_sets->state_event_bits, STOPPED_BIT);
-    periph_sets->task_stack = config->task_stack;
-    periph_sets->task_prio = config->task_prio;
-    periph_sets->task_core = config->task_core;
-    periph_sets->ext_stack = config->extern_stack;
-
-    audio_event_iface_cfg_t event_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    event_cfg.queue_set_size = 0;
-    event_cfg.context = periph_sets;
-    event_cfg.on_cmd = process_peripheral_event;
-    periph_sets->event_handle.iface = audio_event_iface_init(&event_cfg);
-    periph_sets->periph_dynamic_id = PERIPH_ID_CUSTOM_BASE;
-
-    AUDIO_MEM_CHECK(TAG, periph_sets->event_handle.iface, goto _periph_init_failed);
-    audio_event_iface_set_cmd_waiting_timeout(periph_sets->event_handle.iface, DEFAULT_ESP_PERIPH_WAIT_TICK);
-    return periph_sets;
-
-_periph_init_failed:
-    if (periph_sets) {
-        mutex_destroy(periph_sets->lock);
-        vEventGroupDelete(periph_sets->state_event_bits);
-
-        if (periph_sets->event_handle.iface) {
-            audio_event_iface_destroy(periph_sets->event_handle.iface);
-        }
-
-        audio_free(periph_sets);
-        periph_sets = NULL;
-    }
-    return NULL;
-}
-
-esp_err_t esp_periph_remove_from_set(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph)
-{
-    STAILQ_REMOVE(&periph_set_handle->periph_list, periph, esp_periph, entries);
-    esp_periph_register_on_events(periph, NULL);
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_alloc_periph_id(esp_periph_set_handle_t periph_set_handle, int *periph_id)
-{
-    if ((periph_set_handle == NULL) || (periph_id == NULL)) {
-        AUDIO_ERROR(TAG, "Invalid parameters: periph_set_handle or periph_id is NULL");
-        return ESP_FAIL;
-    }
-    *periph_id = periph_set_handle->periph_dynamic_id++;
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_set_destroy(esp_periph_set_handle_t periph_set_handle)
-{
-    if (periph_set_handle == NULL) {
-        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
-        return ESP_FAIL;
-    }
-    periph_set_handle->run = false;
-    esp_periph_wait_for_stop(periph_set_handle, portMAX_DELAY);
-    esp_periph_handle_t item, tmp;
-    STAILQ_FOREACH_SAFE(item, &periph_set_handle->periph_list, entries, tmp) {
-        STAILQ_REMOVE(&periph_set_handle->periph_list, item, esp_periph, entries);
-        audio_free(item->tag);
-        audio_free(item);
-    }
-    mutex_destroy(periph_set_handle->lock);
-    vEventGroupDelete(periph_set_handle->state_event_bits);
-
-    gpio_uninstall_isr_service();
-    audio_event_iface_destroy(periph_set_handle->event_handle.iface);
-    audio_free(periph_set_handle);
-    periph_set_handle = NULL;
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_set_stop_all(esp_periph_set_handle_t periph_set_handle)
-{
-    if (periph_set_handle == NULL) {
-        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
-        return ESP_FAIL;
-    }
-    esp_periph_handle_t periph;
-    STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
-        periph->disabled = true;
-    }
-    return ESP_OK;
-}
-
-esp_periph_handle_t esp_periph_set_get_by_id(esp_periph_set_handle_t periph_set_handle, int periph_id)
-{
-    esp_periph_handle_t periph;
-    if (periph_set_handle == NULL) {
-        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
-        return NULL;
-    }
-    mutex_lock(periph_set_handle->lock);
-    STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
-        if (periph->periph_id == periph_id) {
-            mutex_unlock(periph_set_handle->lock);
-            return periph;
-        }
-    }
-    ESP_LOGD(TAG, "Periph id %d not found", periph_id);
-    mutex_unlock(periph_set_handle->lock);
-    return NULL;
-}
-
-audio_event_iface_handle_t esp_periph_set_get_event_iface(esp_periph_set_handle_t periph_set_handle)
-{
-    return periph_set_handle->event_handle.iface;
-}
-
-esp_err_t esp_periph_set_register_callback(esp_periph_set_handle_t periph_set_handle, esp_periph_event_handle_t cb, void *user_context)
-{
-    if (periph_set_handle == NULL) {
-        return ESP_FAIL;
-    } else {
-        periph_set_handle->event_handle.cb = cb;
-        periph_set_handle->event_handle.user_ctx = user_context;
-        return ESP_OK;
-    }
-}
-
-QueueHandle_t esp_periph_set_get_queue(esp_periph_set_handle_t periph_set_handle)
-{
-    return audio_event_iface_get_queue_handle(periph_set_handle->event_handle.iface);
-}
-
-esp_err_t esp_periph_wait_for_stop(esp_periph_set_handle_t periph_set_handle, TickType_t ticks_to_wait)
-{
-    EventGroupHandle_t ev_bits = periph_set_handle->state_event_bits;
-
-    EventBits_t uxBits = xEventGroupWaitBits(ev_bits, STOPPED_BIT, false, true, ticks_to_wait);
-    if (uxBits & STOPPED_BIT) {
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t esp_periph_set_list_init(esp_periph_set_handle_t periph_set)
-{
-    esp_periph_handle_t periph;
-    STAILQ_FOREACH(periph, &periph_set->periph_list, entries) {
-        if (periph->init) {
-            periph->init(periph);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_set_list_run(esp_periph_set_handle_t periph_set, audio_event_iface_msg_t msg)
-{
-    esp_periph_handle_t periph;
-    STAILQ_FOREACH(periph, &periph_set->periph_list, entries) {
-        if (periph->run) {
-            periph->run(periph, &msg);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_set_list_destroy(esp_periph_set_handle_t periph_set)
-{
-    esp_periph_handle_t periph;
-    STAILQ_FOREACH(periph, &periph_set->periph_list, entries) {
-        if (periph->destroy) {
-            periph->destroy(periph);
-        }
-    }
-    return ESP_OK;
-}
-
-esp_periph_handle_t esp_periph_create(int periph_id, const char *tag)
-{
-    esp_periph_handle_t new_entry = audio_calloc(1, sizeof(struct esp_periph));
-
-    AUDIO_MEM_CHECK(TAG, new_entry, return NULL);
-    if (tag) {
-        new_entry->tag = audio_strdup(tag);
-    } else {
-        new_entry->tag = audio_strdup("periph");
-    }
-    AUDIO_MEM_CHECK(TAG, new_entry->tag, {
-        audio_free(new_entry);
-        return NULL;
-    })
-    new_entry->state = PERIPH_STATE_INIT;
-    new_entry->periph_id = periph_id;
-    return new_entry;
-}
-
-esp_err_t esp_periph_set_function(esp_periph_handle_t periph,
-                                  esp_periph_func init,
-                                  esp_periph_run_func run,
-                                  esp_periph_func destroy)
-{
-    periph->init = init;
-    periph->run = run;
-    periph->destroy = destroy;
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_start(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph)
-{
-    if (periph_set_handle == NULL) {
-        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
-        return ESP_FAIL;
-    }
-    if (esp_periph_set_get_by_id(periph_set_handle, periph->periph_id) != NULL) {
-        ESP_LOGI(TAG, "This peripheral has been added");
-        periph->disabled = false;
-    } else {
-        esp_periph_register_on_events(periph, &periph_set_handle->event_handle);
-        STAILQ_INSERT_TAIL(&periph_set_handle->periph_list, periph, entries);
-    }
-    if (periph_set_handle->run == false && periph_set_handle->task_stack > 0) {
-        periph_set_handle->run = true;
-        if (audio_thread_create(&periph_set_handle->audio_thread,
-                                 "esp_periph",
-                                 esp_periph_task,
-                                 periph_set_handle,
-                                 periph_set_handle->task_stack,
-                                 periph_set_handle->task_prio,
-                                 periph_set_handle->ext_stack,
-                                 periph_set_handle->task_core) != ESP_OK) {
-            ESP_LOGE(TAG, "Create [%s] task failed", periph->tag);
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_stop(esp_periph_handle_t periph)
-{
-    if (periph) {
-        periph->disabled = true;
-        return ESP_OK;
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_send_cmd(esp_periph_handle_t periph, int cmd, void *data, int data_len)
-{
-    if (periph->on_evt == NULL) {
-        return ESP_FAIL;
-    }
-    audio_event_iface_msg_t msg;
-    msg.cmd = cmd;
-    msg.source = periph;
-    msg.source_type = periph->periph_id;
-    msg.data = (void *)data;
-    msg.data_len = data_len;
-    return audio_event_iface_cmd(periph->on_evt->iface, &msg);
-}
-
-esp_err_t esp_periph_send_cmd_from_isr(esp_periph_handle_t periph, int cmd, void *data, int data_len)
-{
-    if (periph->on_evt == NULL) {
-        return ESP_FAIL;
-    }
-    audio_event_iface_msg_t msg;
-    msg.cmd = cmd;
-    msg.source = periph;
-    msg.source_type = periph->periph_id;
-    msg.data = (void *)data;
-    msg.data_len = data_len;
-    return audio_event_iface_cmd_from_isr(periph->on_evt->iface, &msg);
-}
-
-esp_err_t esp_periph_send_event(esp_periph_handle_t periph, int event_id, void *data, int data_len)
-{
-    if (periph->on_evt == NULL) {
-        return ESP_FAIL;
-    }
-    audio_event_iface_msg_t msg;
-    msg.source_type = periph->periph_id;
-    msg.cmd = event_id;
-    msg.data = data;
-    msg.data_len = data_len;
-    msg.need_free_data = false;
-    msg.source = periph;
-
-    if (periph->on_evt->cb) {
-        periph->on_evt->cb(&msg, periph->on_evt->user_ctx);
-    }
-    return audio_event_iface_sendout(periph->on_evt->iface, &msg);
-}
-
-esp_err_t esp_periph_start_timer(esp_periph_handle_t periph, TickType_t interval_tick, timer_callback callback)
-{
-    if (periph->timer == NULL) {
-        periph->timer = xTimerCreate("periph_itmer", interval_tick, pdTRUE, periph, callback);
-        if (xTimerStart(periph->timer, 0) != pdTRUE) {
-            AUDIO_ERROR(TAG, "Error to starting timer");
-            return ESP_FAIL;
-        }
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_stop_timer(esp_periph_handle_t periph)
-{
-    if (periph->timer) {
-        xTimerStop(periph->timer, portMAX_DELAY);
-        xTimerDelete(periph->timer, portMAX_DELAY);
-        periph->timer = NULL;
-    }
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_set_data(esp_periph_handle_t periph, void *data)
-{
-    periph->periph_data = data;
-    return ESP_OK;
-}
-
-void *esp_periph_get_data(esp_periph_handle_t periph)
-{
-    return periph->periph_data;
-}
-
-esp_periph_state_t esp_periph_get_state(esp_periph_handle_t periph)
-{
-    return periph->state;
-}
-
-esp_periph_id_t esp_periph_get_id(esp_periph_handle_t periph)
-{
-    return periph->periph_id;
-}
-
-esp_err_t esp_periph_set_id(esp_periph_handle_t periph, esp_periph_id_t periph_id)
-{
-    periph->periph_id = periph_id;
-    return ESP_OK;
-}
-
-esp_err_t esp_periph_init(esp_periph_handle_t periph)
-{
-    return periph->init(periph);
-}
-
-esp_err_t esp_periph_run(esp_periph_handle_t periph)
-{
-    return periph->run(periph, NULL);
-}
-
-esp_err_t esp_periph_destroy(esp_periph_handle_t periph)
-{
-    return periph->destroy(periph);
-}
-
-esp_err_t esp_periph_register_on_events(esp_periph_handle_t periph, esp_periph_event_t *evts)
-{
-    periph->on_evt = evts;
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "sys/queue.h"
+#include "driver/gpio.h"
+#include "esp_log.h"
+#include "audio_event_iface.h"
+#include "audio_mutex.h"
+#include "esp_peripherals.h"
+#include "audio_thread.h"
+#include "audio_mem.h"
+#include "audio_idf_version.h"
+
+static const char *TAG = "ESP_PERIPH";
+
+#define DEFAULT_ESP_PERIPH_WAIT_TICK       (10/portTICK_PERIOD_MS)
+
+struct esp_periph {
+    char                       *tag;
+    bool                        disabled;
+    esp_periph_id_t             periph_id;
+    esp_periph_func             init;
+    esp_periph_run_func         run;
+    esp_periph_func             destroy;
+    esp_periph_state_t          state;
+    void                       *source;
+    void                       *periph_data;
+    esp_periph_event_t         *on_evt;
+    TimerHandle_t               timer;
+    STAILQ_ENTRY(esp_periph)    entries;
+};
+
+typedef struct esp_periph_sets {
+    EventGroupHandle_t                              state_event_bits;
+    SemaphoreHandle_t                                lock;
+    int                                             task_stack;
+    int                                             task_prio;
+    int                                             task_core;
+    audio_thread_t                                  audio_thread;
+    bool                                            ext_stack;
+    bool                                            run;
+    esp_periph_event_t                              event_handle;
+    int                                             periph_dynamic_id;
+    STAILQ_HEAD(esp_periph_list_item, esp_periph)   periph_list;
+} esp_periph_set_t;
+
+static const int STARTED_BIT = BIT0;
+static const int STOPPED_BIT = BIT1;
+
+static esp_err_t esp_periph_wait_for_stop(esp_periph_set_handle_t periph_set_handle, TickType_t ticks_to_wait);
+
+static esp_err_t process_peripheral_event(audio_event_iface_msg_t *msg, void *context)
+{
+    esp_periph_handle_t periph_evt = (esp_periph_handle_t) msg->source;
+    esp_periph_handle_t periph;
+    esp_periph_set_t *sets = context;
+    STAILQ_FOREACH(periph, &sets->periph_list, entries) {
+        if (periph->periph_id == periph_evt->periph_id
+            && periph_evt->state == PERIPH_STATE_RUNNING
+            && periph_evt->run
+            && !periph_evt->disabled) {
+            return periph_evt->run(periph_evt, msg);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_set_change_waiting_time(esp_periph_set_handle_t periph_set_handle, int time_ms)
+{
+    audio_event_iface_set_cmd_waiting_timeout(esp_periph_set_get_event_iface(periph_set_handle), time_ms / portTICK_PERIOD_MS);
+    return ESP_OK;
+}
+
+static void esp_periph_task(void *pv)
+{
+    esp_periph_handle_t periph;
+    esp_periph_set_handle_t periph_set_handle = (esp_periph_set_handle_t)pv;
+    ESP_LOGD(TAG, "esp_periph_task is running, handle:%p", periph_set_handle);
+    xEventGroupSetBits(periph_set_handle->state_event_bits, STARTED_BIT);
+    xEventGroupClearBits(periph_set_handle->state_event_bits, STOPPED_BIT);
+
+    while (periph_set_handle->run) {
+        mutex_lock(periph_set_handle->lock);
+        STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
+            if (periph->disabled) {
+                continue;
+            }
+            if (periph->state == PERIPH_STATE_INIT && periph->init) {
+                ESP_LOGD(TAG, "PERIPH[%s]->init", periph->tag);
+                if (periph->init(periph) == ESP_OK) {
+                    periph->state = PERIPH_STATE_RUNNING;
+                } else {
+                    periph->state = PERIPH_STATE_ERROR;
+                }
+            }
+        }
+        mutex_unlock(periph_set_handle->lock);
+        audio_event_iface_waiting_cmd_msg(esp_periph_set_get_event_iface(periph_set_handle));
+    }
+    STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
+        esp_periph_stop_timer(periph);
+        if (periph->destroy) {
+            periph->destroy(periph);
+        }
+    }
+    xEventGroupClearBits(periph_set_handle->state_event_bits, STARTED_BIT);
+    xEventGroupSetBits(periph_set_handle->state_event_bits, STOPPED_BIT);
+
+    vTaskDelete(NULL);
+}
+
+esp_periph_set_handle_t esp_periph_set_init(esp_periph_config_t *config)
+{
+    esp_err_t ret = ESP_OK;
+    esp_periph_set_t *periph_sets = NULL;
+    int _err_step = 1;
+    bool _success =
+        (
+            (periph_sets                   = audio_calloc(1, sizeof(esp_periph_set_t))) && _err_step ++ &&
+            (periph_sets->state_event_bits = xEventGroupCreate())                  && _err_step ++ &&
+            (periph_sets->lock             = mutex_create())                       && _err_step ++
+        );
+
+    AUDIO_MEM_CHECK(TAG, _success, {
+        goto _periph_init_failed;
+    });
+
+    STAILQ_INIT(&periph_sets->periph_list);
+
+    //TODO: Should we uninstall gpio isr service??
+    //TODO: Because gpio need for sdcard and gpio, then install isr here
+    ret = gpio_install_isr_service(ESP_INTR_FLAG_LEVEL2);
+    if (ret == ESP_ERR_NOT_FOUND) {
+        ESP_LOGE(TAG, "No free interrupt found with ESP_INTR_FLAG_LEVEL2");
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0))
+        ESP_LOGE(TAG,"Select an available interrupt level based on the interrupt table below");
+        esp_intr_dump(stdout);
+#endif // ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0)
+    }
+
+    periph_sets->run = false;
+    xEventGroupClearBits(periph_sets->state_event_bits, STARTED_BIT);
+    xEventGroupSetBits(periph_sets->state_event_bits, STOPPED_BIT);
+    periph_sets->task_stack = config->task_stack;
+    periph_sets->task_prio = config->task_prio;
+    periph_sets->task_core = config->task_core;
+    periph_sets->ext_stack = config->extern_stack;
+
+    audio_event_iface_cfg_t event_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    event_cfg.queue_set_size = 0;
+    event_cfg.context = periph_sets;
+    event_cfg.on_cmd = process_peripheral_event;
+    periph_sets->event_handle.iface = audio_event_iface_init(&event_cfg);
+    periph_sets->periph_dynamic_id = PERIPH_ID_CUSTOM_BASE;
+
+    AUDIO_MEM_CHECK(TAG, periph_sets->event_handle.iface, goto _periph_init_failed);
+    audio_event_iface_set_cmd_waiting_timeout(periph_sets->event_handle.iface, DEFAULT_ESP_PERIPH_WAIT_TICK);
+    return periph_sets;
+
+_periph_init_failed:
+    if (periph_sets) {
+        mutex_destroy(periph_sets->lock);
+        vEventGroupDelete(periph_sets->state_event_bits);
+
+        if (periph_sets->event_handle.iface) {
+            audio_event_iface_destroy(periph_sets->event_handle.iface);
+        }
+
+        audio_free(periph_sets);
+        periph_sets = NULL;
+    }
+    return NULL;
+}
+
+esp_err_t esp_periph_remove_from_set(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph)
+{
+    STAILQ_REMOVE(&periph_set_handle->periph_list, periph, esp_periph, entries);
+    esp_periph_register_on_events(periph, NULL);
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_alloc_periph_id(esp_periph_set_handle_t periph_set_handle, int *periph_id)
+{
+    if ((periph_set_handle == NULL) || (periph_id == NULL)) {
+        AUDIO_ERROR(TAG, "Invalid parameters: periph_set_handle or periph_id is NULL");
+        return ESP_FAIL;
+    }
+    *periph_id = periph_set_handle->periph_dynamic_id++;
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_set_destroy(esp_periph_set_handle_t periph_set_handle)
+{
+    if (periph_set_handle == NULL) {
+        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
+        return ESP_FAIL;
+    }
+    periph_set_handle->run = false;
+    esp_periph_wait_for_stop(periph_set_handle, portMAX_DELAY);
+    esp_periph_handle_t item, tmp;
+    STAILQ_FOREACH_SAFE(item, &periph_set_handle->periph_list, entries, tmp) {
+        STAILQ_REMOVE(&periph_set_handle->periph_list, item, esp_periph, entries);
+        audio_free(item->tag);
+        audio_free(item);
+    }
+    mutex_destroy(periph_set_handle->lock);
+    vEventGroupDelete(periph_set_handle->state_event_bits);
+
+    gpio_uninstall_isr_service();
+    audio_event_iface_destroy(periph_set_handle->event_handle.iface);
+    audio_free(periph_set_handle);
+    periph_set_handle = NULL;
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_set_stop_all(esp_periph_set_handle_t periph_set_handle)
+{
+    if (periph_set_handle == NULL) {
+        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
+        return ESP_FAIL;
+    }
+    esp_periph_handle_t periph;
+    STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
+        periph->disabled = true;
+    }
+    return ESP_OK;
+}
+
+esp_periph_handle_t esp_periph_set_get_by_id(esp_periph_set_handle_t periph_set_handle, int periph_id)
+{
+    esp_periph_handle_t periph;
+    if (periph_set_handle == NULL) {
+        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
+        return NULL;
+    }
+    mutex_lock(periph_set_handle->lock);
+    STAILQ_FOREACH(periph, &periph_set_handle->periph_list, entries) {
+        if (periph->periph_id == periph_id) {
+            mutex_unlock(periph_set_handle->lock);
+            return periph;
+        }
+    }
+    ESP_LOGD(TAG, "Periph id %d not found", periph_id);
+    mutex_unlock(periph_set_handle->lock);
+    return NULL;
+}
+
+audio_event_iface_handle_t esp_periph_set_get_event_iface(esp_periph_set_handle_t periph_set_handle)
+{
+    return periph_set_handle->event_handle.iface;
+}
+
+esp_err_t esp_periph_set_register_callback(esp_periph_set_handle_t periph_set_handle, esp_periph_event_handle_t cb, void *user_context)
+{
+    if (periph_set_handle == NULL) {
+        return ESP_FAIL;
+    } else {
+        periph_set_handle->event_handle.cb = cb;
+        periph_set_handle->event_handle.user_ctx = user_context;
+        return ESP_OK;
+    }
+}
+
+QueueHandle_t esp_periph_set_get_queue(esp_periph_set_handle_t periph_set_handle)
+{
+    return audio_event_iface_get_queue_handle(periph_set_handle->event_handle.iface);
+}
+
+esp_err_t esp_periph_wait_for_stop(esp_periph_set_handle_t periph_set_handle, TickType_t ticks_to_wait)
+{
+    EventGroupHandle_t ev_bits = periph_set_handle->state_event_bits;
+
+    EventBits_t uxBits = xEventGroupWaitBits(ev_bits, STOPPED_BIT, false, true, ticks_to_wait);
+    if (uxBits & STOPPED_BIT) {
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t esp_periph_set_list_init(esp_periph_set_handle_t periph_set)
+{
+    esp_periph_handle_t periph;
+    STAILQ_FOREACH(periph, &periph_set->periph_list, entries) {
+        if (periph->init) {
+            periph->init(periph);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_set_list_run(esp_periph_set_handle_t periph_set, audio_event_iface_msg_t msg)
+{
+    esp_periph_handle_t periph;
+    STAILQ_FOREACH(periph, &periph_set->periph_list, entries) {
+        if (periph->run) {
+            periph->run(periph, &msg);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_set_list_destroy(esp_periph_set_handle_t periph_set)
+{
+    esp_periph_handle_t periph;
+    STAILQ_FOREACH(periph, &periph_set->periph_list, entries) {
+        if (periph->destroy) {
+            periph->destroy(periph);
+        }
+    }
+    return ESP_OK;
+}
+
+esp_periph_handle_t esp_periph_create(int periph_id, const char *tag)
+{
+    esp_periph_handle_t new_entry = audio_calloc(1, sizeof(struct esp_periph));
+
+    AUDIO_MEM_CHECK(TAG, new_entry, return NULL);
+    if (tag) {
+        new_entry->tag = audio_strdup(tag);
+    } else {
+        new_entry->tag = audio_strdup("periph");
+    }
+    AUDIO_MEM_CHECK(TAG, new_entry->tag, {
+        audio_free(new_entry);
+        return NULL;
+    })
+    new_entry->state = PERIPH_STATE_INIT;
+    new_entry->periph_id = periph_id;
+    return new_entry;
+}
+
+esp_err_t esp_periph_set_function(esp_periph_handle_t periph,
+                                  esp_periph_func init,
+                                  esp_periph_run_func run,
+                                  esp_periph_func destroy)
+{
+    periph->init = init;
+    periph->run = run;
+    periph->destroy = destroy;
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_start(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph)
+{
+    if (periph_set_handle == NULL) {
+        AUDIO_ERROR(TAG, "Peripherals have not been initialized");
+        return ESP_FAIL;
+    }
+    if (esp_periph_set_get_by_id(periph_set_handle, periph->periph_id) != NULL) {
+        ESP_LOGI(TAG, "This peripheral has been added");
+        periph->disabled = false;
+    } else {
+        esp_periph_register_on_events(periph, &periph_set_handle->event_handle);
+        STAILQ_INSERT_TAIL(&periph_set_handle->periph_list, periph, entries);
+    }
+    if (periph_set_handle->run == false && periph_set_handle->task_stack > 0) {
+        periph_set_handle->run = true;
+        if (audio_thread_create(&periph_set_handle->audio_thread,
+                                 "esp_periph",
+                                 esp_periph_task,
+                                 periph_set_handle,
+                                 periph_set_handle->task_stack,
+                                 periph_set_handle->task_prio,
+                                 periph_set_handle->ext_stack,
+                                 periph_set_handle->task_core) != ESP_OK) {
+            ESP_LOGE(TAG, "Create [%s] task failed", periph->tag);
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_stop(esp_periph_handle_t periph)
+{
+    if (periph) {
+        periph->disabled = true;
+        return ESP_OK;
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_send_cmd(esp_periph_handle_t periph, int cmd, void *data, int data_len)
+{
+    if (periph->on_evt == NULL) {
+        return ESP_FAIL;
+    }
+    audio_event_iface_msg_t msg;
+    msg.cmd = cmd;
+    msg.source = periph;
+    msg.source_type = periph->periph_id;
+    msg.data = (void *)data;
+    msg.data_len = data_len;
+    return audio_event_iface_cmd(periph->on_evt->iface, &msg);
+}
+
+esp_err_t esp_periph_send_cmd_from_isr(esp_periph_handle_t periph, int cmd, void *data, int data_len)
+{
+    if (periph->on_evt == NULL) {
+        return ESP_FAIL;
+    }
+    audio_event_iface_msg_t msg;
+    msg.cmd = cmd;
+    msg.source = periph;
+    msg.source_type = periph->periph_id;
+    msg.data = (void *)data;
+    msg.data_len = data_len;
+    return audio_event_iface_cmd_from_isr(periph->on_evt->iface, &msg);
+}
+
+esp_err_t esp_periph_send_event(esp_periph_handle_t periph, int event_id, void *data, int data_len)
+{
+    if (periph->on_evt == NULL) {
+        return ESP_FAIL;
+    }
+    audio_event_iface_msg_t msg;
+    msg.source_type = periph->periph_id;
+    msg.cmd = event_id;
+    msg.data = data;
+    msg.data_len = data_len;
+    msg.need_free_data = false;
+    msg.source = periph;
+
+    if (periph->on_evt->cb) {
+        periph->on_evt->cb(&msg, periph->on_evt->user_ctx);
+    }
+    return audio_event_iface_sendout(periph->on_evt->iface, &msg);
+}
+
+esp_err_t esp_periph_start_timer(esp_periph_handle_t periph, TickType_t interval_tick, timer_callback callback)
+{
+    if (periph->timer == NULL) {
+        periph->timer = xTimerCreate("periph_itmer", interval_tick, pdTRUE, periph, callback);
+        if (xTimerStart(periph->timer, 0) != pdTRUE) {
+            AUDIO_ERROR(TAG, "Error to starting timer");
+            return ESP_FAIL;
+        }
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_stop_timer(esp_periph_handle_t periph)
+{
+    if (periph->timer) {
+        xTimerStop(periph->timer, portMAX_DELAY);
+        xTimerDelete(periph->timer, portMAX_DELAY);
+        periph->timer = NULL;
+    }
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_set_data(esp_periph_handle_t periph, void *data)
+{
+    periph->periph_data = data;
+    return ESP_OK;
+}
+
+void *esp_periph_get_data(esp_periph_handle_t periph)
+{
+    return periph->periph_data;
+}
+
+esp_periph_state_t esp_periph_get_state(esp_periph_handle_t periph)
+{
+    return periph->state;
+}
+
+esp_periph_id_t esp_periph_get_id(esp_periph_handle_t periph)
+{
+    return periph->periph_id;
+}
+
+esp_err_t esp_periph_set_id(esp_periph_handle_t periph, esp_periph_id_t periph_id)
+{
+    periph->periph_id = periph_id;
+    return ESP_OK;
+}
+
+esp_err_t esp_periph_init(esp_periph_handle_t periph)
+{
+    return periph->init(periph);
+}
+
+esp_err_t esp_periph_run(esp_periph_handle_t periph)
+{
+    return periph->run(periph, NULL);
+}
+
+esp_err_t esp_periph_destroy(esp_periph_handle_t periph)
+{
+    return periph->destroy(periph);
+}
+
+esp_err_t esp_periph_register_on_events(esp_periph_handle_t periph, esp_periph_event_t *evts)
+{
+    periph->on_evt = evts;
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/include/esp_peripherals.h b/components/esp_peripherals/include/esp_peripherals.h
index ad4f9fe9..fa677f10 100644
--- a/components/esp_peripherals/include/esp_peripherals.h
+++ b/components/esp_peripherals/include/esp_peripherals.h
@@ -1,505 +1,506 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ESP_PERIPHERALS_H_
-#define _ESP_PERIPHERALS_H_
-
-#include "audio_error.h"
-#include "audio_event_iface.h"
-#include "audio_common.h"
-#include "freertos/event_groups.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Peripheral Identify, this must be unique for each peripheral added to the peripherals list
- */
-typedef enum {
-    PERIPH_ID_BUTTON      = AUDIO_ELEMENT_TYPE_PERIPH + 1,
-    PERIPH_ID_TOUCH       = AUDIO_ELEMENT_TYPE_PERIPH + 2,
-    PERIPH_ID_SDCARD      = AUDIO_ELEMENT_TYPE_PERIPH + 3,
-    PERIPH_ID_WIFI        = AUDIO_ELEMENT_TYPE_PERIPH + 4,
-    PERIPH_ID_FLASH       = AUDIO_ELEMENT_TYPE_PERIPH + 5,
-    PERIPH_ID_AUXIN       = AUDIO_ELEMENT_TYPE_PERIPH + 6,
-    PERIPH_ID_ADC         = AUDIO_ELEMENT_TYPE_PERIPH + 7,
-    PERIPH_ID_CONSOLE     = AUDIO_ELEMENT_TYPE_PERIPH + 8,
-    PERIPH_ID_BLUETOOTH   = AUDIO_ELEMENT_TYPE_PERIPH + 9,
-    PERIPH_ID_LED         = AUDIO_ELEMENT_TYPE_PERIPH + 10,
-    PERIPH_ID_SPIFFS      = AUDIO_ELEMENT_TYPE_PERIPH + 11,
-    PERIPH_ID_ADC_BTN     = AUDIO_ELEMENT_TYPE_PERIPH + 12,
-    PERIPH_ID_IS31FL3216  = AUDIO_ELEMENT_TYPE_PERIPH + 13,
-    PERIPH_ID_GPIO_ISR    = AUDIO_ELEMENT_TYPE_PERIPH + 14,
-    PERIPH_ID_WS2812      = AUDIO_ELEMENT_TYPE_PERIPH + 15,
-    PERIPH_ID_AW2013      = AUDIO_ELEMENT_TYPE_PERIPH + 16,
-    PERIPH_ID_LCD         = AUDIO_ELEMENT_TYPE_PERIPH + 17,
-    PERIPH_ID_CUSTOM_BASE = AUDIO_ELEMENT_TYPE_PERIPH + 18
-} esp_periph_id_t;
-
-/**
- * @brief Peripheral working state
- */
-typedef enum {
-    PERIPH_STATE_NULL,
-    PERIPH_STATE_INIT,
-    PERIPH_STATE_RUNNING,
-    PERIPH_STATE_PAUSE,
-    PERIPH_STATE_STOPPING,
-    PERIPH_STATE_ERROR,
-    PERIPH_STATE_STATUS_MAX,
-} esp_periph_state_t;
-
-typedef struct esp_periph_sets *esp_periph_set_handle_t;
-typedef struct esp_periph *esp_periph_handle_t;
-typedef esp_err_t (*esp_periph_func)(esp_periph_handle_t periph);
-typedef esp_err_t (*esp_periph_run_func)(esp_periph_handle_t periph, audio_event_iface_msg_t *msg);
-typedef esp_err_t (*esp_periph_event_handle_t)(audio_event_iface_msg_t *event, void *context);
-typedef void (*timer_callback)(xTimerHandle tmr);
-
-/**
- * @brief Common peripherals configurations
- */
-typedef struct {
-    int                         task_stack;             /*!< >0 Service task stack size; =0 without task created */
-    int                         task_prio;              /*!< Service task priority (based on freeRTOS priority) */
-    int                         task_core;              /*!< Service task running in core (0 or 1) */
-    bool                        extern_stack;           /*!< Service task stack allocate on extern ram */
-} esp_periph_config_t;
-
-/**
- * @brief peripheral events
- */
-typedef struct esp_periph_event {
-    void                           *user_ctx;   /*!< peripheral context data */
-    esp_periph_event_handle_t       cb;         /*!< peripheral callback function */
-    audio_event_iface_handle_t      iface;      /*!< peripheral event */
-} esp_periph_event_t;
-
-#define DEFAULT_ESP_PERIPH_STACK_SIZE      (4*1024)
-#define DEFAULT_ESP_PERIPH_TASK_PRIO       (5)
-#define DEFAULT_ESP_PERIPH_TASK_CORE       (0)
-
-#define DEFAULT_ESP_PERIPH_SET_CONFIG() {\
-    .task_stack         = DEFAULT_ESP_PERIPH_STACK_SIZE,   \
-    .task_prio          = DEFAULT_ESP_PERIPH_TASK_PRIO,    \
-    .task_core          = DEFAULT_ESP_PERIPH_TASK_CORE,    \
-    .extern_stack       = false,                           \
-}
-
-/**
- * @brief     Initialize esp_peripheral sets, create empty peripherals list.
- *            Call this function before starting any peripherals (with `esp_periph_start`). This call will initialize the data needed
- *            for esp_peripherals to work, but does not actually create the task. The `event_handle` is optional if you want to
- *            receive events from this callback function. The esp_peripherals task will send all events out to event_iface, can be
- *            listen by event_iface by `esp_periph_get_event_iface`. The `user_context` will sent `esp_periph_event_handle_t`
- *            as *context parameter.
- *
- * @param[in] config   The configurations
- *
- * @return The peripheral sets instance
- */
-esp_periph_set_handle_t esp_periph_set_init(esp_periph_config_t *config);
-
-/**
- * @brief      This function will stop and kill the monitor task, calling all destroy callback functions of the peripheral
- *             (so you do not need to destroy the peripheral object manually).
- *             It will also remove all memory allocated to the peripherals list,
- *             so you need to call the `esp_periph_set_init` function again if you want to use it.
- *
- * @param      periph_set_handle The esp_periph_set_handle_t instance
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_destroy(esp_periph_set_handle_t periph_set_handle);
-
-/**
- * @brief      Stop monitoring all peripherals, the peripheral state is still kept. This funciton only temporary disables the peripheral.
- *
- * @param      periph_set_handle The esp_periph_set_handle_t instance
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_stop_all(esp_periph_set_handle_t periph_set_handle);
-
-/**
- * @brief       Get the peripheral handle by Peripheral ID
- *
- * @param       periph_set_handle The esp_periph_set_handle_t instance
- *
- * @param[in]   periph_id as esp_periph_id_t, or any ID you use when calling `esp_periph_create`
- *
- *
- * @return     The esp_periph_handle_t
- */
-esp_periph_handle_t esp_periph_set_get_by_id(esp_periph_set_handle_t periph_set_handle, int periph_id);
-
-/**
- * @brief      Return the event_iface used by this esp_peripherals
- *
- * @param      periph_set_handle The esp_periph_set_handle_t instance
- *
- * @return     The audio event iface handle
- */
-audio_event_iface_handle_t esp_periph_set_get_event_iface(esp_periph_set_handle_t periph_set_handle);
-
-/**
- * @brief      Register peripheral sets event callback function.
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- * @param      cb                   The event handle callback function
- * @param      user_context         The user context pointer
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_register_callback(esp_periph_set_handle_t periph_set_handle, esp_periph_event_handle_t cb, void *user_context);
-
-/**
- * @brief      Peripheral is using event_iface to control the event, all events are send out to event_iface queue.
- *             This function will be useful in case we want to read events directly from the event_iface queue.
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- *
- * @return     The queue handle
- */
-QueueHandle_t esp_periph_set_get_queue(esp_periph_set_handle_t periph_set_handle);
-
-/**
- * @brief      Call this function to initialize all the listed peripherals.
- * @note       Work with no task peripheral set only
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_list_init(esp_periph_set_handle_t periph_set_handle);
-
-/**
- * @brief      Call this function to run all the listed peripherals.
- * @note       Work with no task peripheral set only
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- * @param      msg                  The audio_event_iface_msg_t handle message
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_list_run(esp_periph_set_handle_t periph_set_handle, audio_event_iface_msg_t msg);
-
-/**
- * @brief      Call this function to destroy all the listed peripherals.
- * @note       Work with no task peripheral set only
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_list_destroy(esp_periph_set_handle_t periph_set_handle);
-
-/**
- * @brief      Call this function to remove periph from periph_set.
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- * @param      periph               The esp_periph_handle_t instance
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_remove_from_set(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph);
-
-/**
- * @brief  Allocated a peripheral ID from the periph_set.
- *
- * @note  This function can apply for a peripheral ID to realize a customized peripheral module.
- *        The requested peripheral ID will not be included in `esp_periph_id_t`
- *
- * @param[in]   periph_set_handle  The esp_periph_set_handle_t instance
- * @param[out]  periph_id          The peripheral identifier
- *
- * @return
- *       - ESP_OK
- *       - ESP_FAIL
- */
-esp_err_t esp_periph_alloc_periph_id(esp_periph_set_handle_t periph_set_handle, int *periph_id);
-
-/**
- * @brief      Call this function to change periph_set waiting time.
- *
- * @param      periph_set_handle    The esp_periph_set_handle_t instance
- * @param      time_ms              The waiting time
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_change_waiting_time(esp_periph_set_handle_t periph_set_handle, int time_ms);
-
-/**
- * @brief      Call this function to initialize a new peripheral
- *
- * @param[in]  periph_id  The periph identifier
- * @param[in]  tag        The tag name, we named it easy to get in debug logs
- *
- * @return     The peripheral handle
- */
-esp_periph_handle_t esp_periph_create(int periph_id, const char *tag);
-
-/**
- * @brief      Each peripheral has a cycle of sequential operations from initialization,
- *             execution of commands to destroying the peripheral. These operations are
- *             represented by functions passed as call parameters to this function.
- *
- * @param[in]  periph   The periph
- * @param[in]  init     The initialize
- * @param[in]  run      The run
- * @param[in]  destroy  The destroy
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_function(esp_periph_handle_t periph,
-                                  esp_periph_func init,
-                                  esp_periph_run_func run,
-                                  esp_periph_func destroy);
-
-/**
- * @brief     Add the peripheral to peripherals list, enable and start monitor task (if task stack size > 0)
- *
- * @param[in] periph_set_handle     The esp_periph_set_handle_t instance
- * @param[in] periph                The peripheral instance
- *
- * @note
- *        This peripheral must be first created by calling `esp_periph_create`
- *
- * @return
- *     - ESP_OK on success
- *     - ESP_FAIL when any errors
- */
-esp_err_t esp_periph_start(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph);
-
-/**
- * @brief      Stop monitoring the peripheral, the peripheral state is still kept. This funciton only temporary disables the peripheral.
- *
- * @param[in]  periph  The periph
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_stop(esp_periph_handle_t periph);
-
-/**
- * @brief      When this function is called, the command is passed to the event_iface command queue,
- *             and the `esp_periph_run_func` of this peripheral will be executed in the main peripheral task.
- *             This function can be called from any task, basically it only sends a queue to the main peripheral task
- *
- * @param[in]  periph    The periph
- * @param[in]  cmd       The command
- * @param      data      The data
- * @param[in]  data_len  The data length
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_send_cmd(esp_periph_handle_t periph, int cmd, void *data, int data_len);
-
-/**
- * @brief      Similar to `esp_periph_send_cmd`, but it can be called in the hardware interrupt handle
- *
- * @param[in]  periph    The periph
- * @param[in]  cmd       The command
- * @param      data      The data
- * @param[in]  data_len  The data length
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_send_cmd_from_isr(esp_periph_handle_t periph, int cmd, void *data, int data_len);
-
-/**
- * @brief      In addition to sending an event via event_iface, this function will dispatch the `event_handle` callback
- *             if the event_handle callback is provided at `esp_periph_init`
- *
- * @param[in]  periph    The peripheral
- * @param[in]  event_id  The event identifier
- * @param      data      The data
- * @param[in]  data_len  The data length
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_send_event(esp_periph_handle_t periph, int event_id, void *data, int data_len);
-
-/**
- * @brief      Each peripheral can initialize a timer, which is by default NULL.
- *             When this function is called, the timer for the peripheral is created
- *             and it invokes the callback function every interval tick.
- *
- * @note
- *             - You do not need to stop or destroy the timer, when the `esp_periph_destroy` function is called, it will stop and destroy all
- *             - This timer using FreeRTOS Timer, with autoreload = true
- *
- * @param[in]  periph          The peripheral
- * @param[in]  interval_tick   The interval tick
- * @param[in]  callback        The callback
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_start_timer(esp_periph_handle_t periph, TickType_t interval_tick, timer_callback callback);
-
-/**
- * @brief      Stop peripheral timer
- *
- * @param[in]  periph  The peripheral
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_stop_timer(esp_periph_handle_t periph);
-
-/**
- * @brief      Set the user data
- *
- * @note       Make sure the `data` lifetime is sufficient, this function does not copy all data, it only stores the data pointer
- *
- * @param[in]  periph  The peripheral
- * @param      data    The data
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_data(esp_periph_handle_t periph, void *data);
-
-/**
- * @brief      Get the user data stored in the peripheral
- *
- * @param[in]  periph  The peripheral
- *
- * @return     Peripheral data pointer
- */
-void *esp_periph_get_data(esp_periph_handle_t periph);
-
-/**
- * @brief      Get the current state of peripheral.
- *
- * @param[in]  periph  The handle of peripheral
- *
- * @return     The peripharal working state
- */
-esp_periph_state_t esp_periph_get_state(esp_periph_handle_t periph);
-
-/**
- * @brief      Get Peripheral identifier
- *
- * @param[in]  periph  The peripheral
- *
- * @return     The peripheral identifier
- */
-esp_periph_id_t esp_periph_get_id(esp_periph_handle_t periph);
-
-/**
- * @brief      Set Peripheral identifier
- *
- * @param[in]  periph     The peripheral
- * @param[in]  periph_id  The peripheral identifier
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_set_id(esp_periph_handle_t periph, esp_periph_id_t periph_id);
-
-/**
- * @brief      Call this to execute `init` function of peripheral instance
- *
- * @param      periph     The peripheral handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_init(esp_periph_handle_t periph);
-
-/**
- * @brief      Call this to execute `run` function of peripheral instance
- *
- * @param      periph     The peripheral handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_run(esp_periph_handle_t periph);
-
-/**
- * @brief      Call this to execute `destroy` function of peripheral instance
- *
- * @param      periph     The peripheral handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_destroy(esp_periph_handle_t periph);
-
-/**
- * @brief      Rigster peripheral on event handle
- *
- * @param      periph     The peripheral handle
- * @param      evts       The esp_periph_event_t handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_periph_register_on_events(esp_periph_handle_t periph, esp_periph_event_t *evts);
-
-#define periph_tick_get esp_periph_tick_get
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ESP_PERIPHERALS_H_
+#define _ESP_PERIPHERALS_H_
+
+#include "audio_error.h"
+#include "audio_event_iface.h"
+#include "audio_common.h"
+#include "freertos/event_groups.h"
+#include "freertos/timers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Peripheral Identify, this must be unique for each peripheral added to the peripherals list
+ */
+typedef enum {
+    PERIPH_ID_BUTTON      = AUDIO_ELEMENT_TYPE_PERIPH + 1,
+    PERIPH_ID_TOUCH       = AUDIO_ELEMENT_TYPE_PERIPH + 2,
+    PERIPH_ID_SDCARD      = AUDIO_ELEMENT_TYPE_PERIPH + 3,
+    PERIPH_ID_WIFI        = AUDIO_ELEMENT_TYPE_PERIPH + 4,
+    PERIPH_ID_FLASH       = AUDIO_ELEMENT_TYPE_PERIPH + 5,
+    PERIPH_ID_AUXIN       = AUDIO_ELEMENT_TYPE_PERIPH + 6,
+    PERIPH_ID_ADC         = AUDIO_ELEMENT_TYPE_PERIPH + 7,
+    PERIPH_ID_CONSOLE     = AUDIO_ELEMENT_TYPE_PERIPH + 8,
+    PERIPH_ID_BLUETOOTH   = AUDIO_ELEMENT_TYPE_PERIPH + 9,
+    PERIPH_ID_LED         = AUDIO_ELEMENT_TYPE_PERIPH + 10,
+    PERIPH_ID_SPIFFS      = AUDIO_ELEMENT_TYPE_PERIPH + 11,
+    PERIPH_ID_ADC_BTN     = AUDIO_ELEMENT_TYPE_PERIPH + 12,
+    PERIPH_ID_IS31FL3216  = AUDIO_ELEMENT_TYPE_PERIPH + 13,
+    PERIPH_ID_GPIO_ISR    = AUDIO_ELEMENT_TYPE_PERIPH + 14,
+    PERIPH_ID_WS2812      = AUDIO_ELEMENT_TYPE_PERIPH + 15,
+    PERIPH_ID_AW2013      = AUDIO_ELEMENT_TYPE_PERIPH + 16,
+    PERIPH_ID_LCD         = AUDIO_ELEMENT_TYPE_PERIPH + 17,
+    PERIPH_ID_CUSTOM_BASE = AUDIO_ELEMENT_TYPE_PERIPH + 18
+} esp_periph_id_t;
+
+/**
+ * @brief Peripheral working state
+ */
+typedef enum {
+    PERIPH_STATE_NULL,
+    PERIPH_STATE_INIT,
+    PERIPH_STATE_RUNNING,
+    PERIPH_STATE_PAUSE,
+    PERIPH_STATE_STOPPING,
+    PERIPH_STATE_ERROR,
+    PERIPH_STATE_STATUS_MAX,
+} esp_periph_state_t;
+
+typedef struct esp_periph_sets *esp_periph_set_handle_t;
+typedef struct esp_periph *esp_periph_handle_t;
+typedef esp_err_t (*esp_periph_func)(esp_periph_handle_t periph);
+typedef esp_err_t (*esp_periph_run_func)(esp_periph_handle_t periph, audio_event_iface_msg_t *msg);
+typedef esp_err_t (*esp_periph_event_handle_t)(audio_event_iface_msg_t *event, void *context);
+typedef void (*timer_callback)(TimerHandle_t tmr);
+
+/**
+ * @brief Common peripherals configurations
+ */
+typedef struct {
+    int                         task_stack;             /*!< >0 Service task stack size; =0 without task created */
+    int                         task_prio;              /*!< Service task priority (based on freeRTOS priority) */
+    int                         task_core;              /*!< Service task running in core (0 or 1) */
+    bool                        extern_stack;           /*!< Service task stack allocate on extern ram */
+} esp_periph_config_t;
+
+/**
+ * @brief peripheral events
+ */
+typedef struct esp_periph_event {
+    void                           *user_ctx;   /*!< peripheral context data */
+    esp_periph_event_handle_t       cb;         /*!< peripheral callback function */
+    audio_event_iface_handle_t      iface;      /*!< peripheral event */
+} esp_periph_event_t;
+
+#define DEFAULT_ESP_PERIPH_STACK_SIZE      (4*1024)
+#define DEFAULT_ESP_PERIPH_TASK_PRIO       (5)
+#define DEFAULT_ESP_PERIPH_TASK_CORE       (0)
+
+#define DEFAULT_ESP_PERIPH_SET_CONFIG() {\
+    .task_stack         = DEFAULT_ESP_PERIPH_STACK_SIZE,   \
+    .task_prio          = DEFAULT_ESP_PERIPH_TASK_PRIO,    \
+    .task_core          = DEFAULT_ESP_PERIPH_TASK_CORE,    \
+    .extern_stack       = false,                           \
+}
+
+/**
+ * @brief     Initialize esp_peripheral sets, create empty peripherals list.
+ *            Call this function before starting any peripherals (with `esp_periph_start`). This call will initialize the data needed
+ *            for esp_peripherals to work, but does not actually create the task. The `event_handle` is optional if you want to
+ *            receive events from this callback function. The esp_peripherals task will send all events out to event_iface, can be
+ *            listen by event_iface by `esp_periph_get_event_iface`. The `user_context` will sent `esp_periph_event_handle_t`
+ *            as *context parameter.
+ *
+ * @param[in] config   The configurations
+ *
+ * @return The peripheral sets instance
+ */
+esp_periph_set_handle_t esp_periph_set_init(esp_periph_config_t *config);
+
+/**
+ * @brief      This function will stop and kill the monitor task, calling all destroy callback functions of the peripheral
+ *             (so you do not need to destroy the peripheral object manually).
+ *             It will also remove all memory allocated to the peripherals list,
+ *             so you need to call the `esp_periph_set_init` function again if you want to use it.
+ *
+ * @param      periph_set_handle The esp_periph_set_handle_t instance
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_destroy(esp_periph_set_handle_t periph_set_handle);
+
+/**
+ * @brief      Stop monitoring all peripherals, the peripheral state is still kept. This funciton only temporary disables the peripheral.
+ *
+ * @param      periph_set_handle The esp_periph_set_handle_t instance
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_stop_all(esp_periph_set_handle_t periph_set_handle);
+
+/**
+ * @brief       Get the peripheral handle by Peripheral ID
+ *
+ * @param       periph_set_handle The esp_periph_set_handle_t instance
+ *
+ * @param[in]   periph_id as esp_periph_id_t, or any ID you use when calling `esp_periph_create`
+ *
+ *
+ * @return     The esp_periph_handle_t
+ */
+esp_periph_handle_t esp_periph_set_get_by_id(esp_periph_set_handle_t periph_set_handle, int periph_id);
+
+/**
+ * @brief      Return the event_iface used by this esp_peripherals
+ *
+ * @param      periph_set_handle The esp_periph_set_handle_t instance
+ *
+ * @return     The audio event iface handle
+ */
+audio_event_iface_handle_t esp_periph_set_get_event_iface(esp_periph_set_handle_t periph_set_handle);
+
+/**
+ * @brief      Register peripheral sets event callback function.
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ * @param      cb                   The event handle callback function
+ * @param      user_context         The user context pointer
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_register_callback(esp_periph_set_handle_t periph_set_handle, esp_periph_event_handle_t cb, void *user_context);
+
+/**
+ * @brief      Peripheral is using event_iface to control the event, all events are send out to event_iface queue.
+ *             This function will be useful in case we want to read events directly from the event_iface queue.
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ *
+ * @return     The queue handle
+ */
+QueueHandle_t esp_periph_set_get_queue(esp_periph_set_handle_t periph_set_handle);
+
+/**
+ * @brief      Call this function to initialize all the listed peripherals.
+ * @note       Work with no task peripheral set only
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_list_init(esp_periph_set_handle_t periph_set_handle);
+
+/**
+ * @brief      Call this function to run all the listed peripherals.
+ * @note       Work with no task peripheral set only
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ * @param      msg                  The audio_event_iface_msg_t handle message
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_list_run(esp_periph_set_handle_t periph_set_handle, audio_event_iface_msg_t msg);
+
+/**
+ * @brief      Call this function to destroy all the listed peripherals.
+ * @note       Work with no task peripheral set only
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_list_destroy(esp_periph_set_handle_t periph_set_handle);
+
+/**
+ * @brief      Call this function to remove periph from periph_set.
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ * @param      periph               The esp_periph_handle_t instance
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_remove_from_set(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph);
+
+/**
+ * @brief  Allocated a peripheral ID from the periph_set.
+ *
+ * @note  This function can apply for a peripheral ID to realize a customized peripheral module.
+ *        The requested peripheral ID will not be included in `esp_periph_id_t`
+ *
+ * @param[in]   periph_set_handle  The esp_periph_set_handle_t instance
+ * @param[out]  periph_id          The peripheral identifier
+ *
+ * @return
+ *       - ESP_OK
+ *       - ESP_FAIL
+ */
+esp_err_t esp_periph_alloc_periph_id(esp_periph_set_handle_t periph_set_handle, int *periph_id);
+
+/**
+ * @brief      Call this function to change periph_set waiting time.
+ *
+ * @param      periph_set_handle    The esp_periph_set_handle_t instance
+ * @param      time_ms              The waiting time
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_change_waiting_time(esp_periph_set_handle_t periph_set_handle, int time_ms);
+
+/**
+ * @brief      Call this function to initialize a new peripheral
+ *
+ * @param[in]  periph_id  The periph identifier
+ * @param[in]  tag        The tag name, we named it easy to get in debug logs
+ *
+ * @return     The peripheral handle
+ */
+esp_periph_handle_t esp_periph_create(int periph_id, const char *tag);
+
+/**
+ * @brief      Each peripheral has a cycle of sequential operations from initialization,
+ *             execution of commands to destroying the peripheral. These operations are
+ *             represented by functions passed as call parameters to this function.
+ *
+ * @param[in]  periph   The periph
+ * @param[in]  init     The initialize
+ * @param[in]  run      The run
+ * @param[in]  destroy  The destroy
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_function(esp_periph_handle_t periph,
+                                  esp_periph_func init,
+                                  esp_periph_run_func run,
+                                  esp_periph_func destroy);
+
+/**
+ * @brief     Add the peripheral to peripherals list, enable and start monitor task (if task stack size > 0)
+ *
+ * @param[in] periph_set_handle     The esp_periph_set_handle_t instance
+ * @param[in] periph                The peripheral instance
+ *
+ * @note
+ *        This peripheral must be first created by calling `esp_periph_create`
+ *
+ * @return
+ *     - ESP_OK on success
+ *     - ESP_FAIL when any errors
+ */
+esp_err_t esp_periph_start(esp_periph_set_handle_t periph_set_handle, esp_periph_handle_t periph);
+
+/**
+ * @brief      Stop monitoring the peripheral, the peripheral state is still kept. This funciton only temporary disables the peripheral.
+ *
+ * @param[in]  periph  The periph
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_stop(esp_periph_handle_t periph);
+
+/**
+ * @brief      When this function is called, the command is passed to the event_iface command queue,
+ *             and the `esp_periph_run_func` of this peripheral will be executed in the main peripheral task.
+ *             This function can be called from any task, basically it only sends a queue to the main peripheral task
+ *
+ * @param[in]  periph    The periph
+ * @param[in]  cmd       The command
+ * @param      data      The data
+ * @param[in]  data_len  The data length
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_send_cmd(esp_periph_handle_t periph, int cmd, void *data, int data_len);
+
+/**
+ * @brief      Similar to `esp_periph_send_cmd`, but it can be called in the hardware interrupt handle
+ *
+ * @param[in]  periph    The periph
+ * @param[in]  cmd       The command
+ * @param      data      The data
+ * @param[in]  data_len  The data length
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_send_cmd_from_isr(esp_periph_handle_t periph, int cmd, void *data, int data_len);
+
+/**
+ * @brief      In addition to sending an event via event_iface, this function will dispatch the `event_handle` callback
+ *             if the event_handle callback is provided at `esp_periph_init`
+ *
+ * @param[in]  periph    The peripheral
+ * @param[in]  event_id  The event identifier
+ * @param      data      The data
+ * @param[in]  data_len  The data length
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_send_event(esp_periph_handle_t periph, int event_id, void *data, int data_len);
+
+/**
+ * @brief      Each peripheral can initialize a timer, which is by default NULL.
+ *             When this function is called, the timer for the peripheral is created
+ *             and it invokes the callback function every interval tick.
+ *
+ * @note
+ *             - You do not need to stop or destroy the timer, when the `esp_periph_destroy` function is called, it will stop and destroy all
+ *             - This timer using FreeRTOS Timer, with autoreload = true
+ *
+ * @param[in]  periph          The peripheral
+ * @param[in]  interval_tick   The interval tick
+ * @param[in]  callback        The callback
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_start_timer(esp_periph_handle_t periph, TickType_t interval_tick, timer_callback callback);
+
+/**
+ * @brief      Stop peripheral timer
+ *
+ * @param[in]  periph  The peripheral
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_stop_timer(esp_periph_handle_t periph);
+
+/**
+ * @brief      Set the user data
+ *
+ * @note       Make sure the `data` lifetime is sufficient, this function does not copy all data, it only stores the data pointer
+ *
+ * @param[in]  periph  The peripheral
+ * @param      data    The data
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_data(esp_periph_handle_t periph, void *data);
+
+/**
+ * @brief      Get the user data stored in the peripheral
+ *
+ * @param[in]  periph  The peripheral
+ *
+ * @return     Peripheral data pointer
+ */
+void *esp_periph_get_data(esp_periph_handle_t periph);
+
+/**
+ * @brief      Get the current state of peripheral.
+ *
+ * @param[in]  periph  The handle of peripheral
+ *
+ * @return     The peripharal working state
+ */
+esp_periph_state_t esp_periph_get_state(esp_periph_handle_t periph);
+
+/**
+ * @brief      Get Peripheral identifier
+ *
+ * @param[in]  periph  The peripheral
+ *
+ * @return     The peripheral identifier
+ */
+esp_periph_id_t esp_periph_get_id(esp_periph_handle_t periph);
+
+/**
+ * @brief      Set Peripheral identifier
+ *
+ * @param[in]  periph     The peripheral
+ * @param[in]  periph_id  The peripheral identifier
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_set_id(esp_periph_handle_t periph, esp_periph_id_t periph_id);
+
+/**
+ * @brief      Call this to execute `init` function of peripheral instance
+ *
+ * @param      periph     The peripheral handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_init(esp_periph_handle_t periph);
+
+/**
+ * @brief      Call this to execute `run` function of peripheral instance
+ *
+ * @param      periph     The peripheral handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_run(esp_periph_handle_t periph);
+
+/**
+ * @brief      Call this to execute `destroy` function of peripheral instance
+ *
+ * @param      periph     The peripheral handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_destroy(esp_periph_handle_t periph);
+
+/**
+ * @brief      Rigster peripheral on event handle
+ *
+ * @param      periph     The peripheral handle
+ * @param      evts       The esp_periph_event_t handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_periph_register_on_events(esp_periph_handle_t periph, esp_periph_event_t *evts);
+
+#define periph_tick_get esp_periph_tick_get
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_adc_button.h b/components/esp_peripherals/include/periph_adc_button.h
index af97414a..169f23fc 100644
--- a/components/esp_peripherals/include/periph_adc_button.h
+++ b/components/esp_peripherals/include/periph_adc_button.h
@@ -1,101 +1,101 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PERIPH_ADC_BUTTON_H_
-#define _PERIPH_ADC_BUTTON_H_
-
-#include "driver/adc.h"
-#include "adc_button.h"
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ADC_BUTTON_STACK_SIZE           2500
-#define ADC_BUTTON_TASK_PRIORITY        10
-#define ADC_BUTTON_TASK_CORE_ID         0
-
-/**
- * @brief      The configuration of ADC Button
- */
-typedef struct {
-    adc_arr_t *arr;  /*!< An array with configuration of buttons */
-    int arr_size;    /*!< The array size */
-    adc_btn_task_cfg_t task_cfg; /*!< Adc button task configuration */
-} periph_adc_button_cfg_t;
-
-#define PERIPH_ADC_BUTTON_DEFAULT_CONFIG() {   \
-    .task_cfg = {                              \
-        .task_stack = ADC_BUTTON_STACK_SIZE,   \
-        .task_core  = ADC_BUTTON_TASK_CORE_ID, \
-        .task_prio  = ADC_BUTTON_TASK_PRIORITY,\
-        .ext_stack  = false                    \
-    }                                          \
-}
-
-typedef enum {
-    PERIPH_ADC_BUTTON_IDLE = 0,
-    PERIPH_ADC_BUTTON_PRESSED,
-    PERIPH_ADC_BUTTON_RELEASE,
-    PERIPH_ADC_BUTTON_LONG_PRESSED,
-    PERIPH_ADC_BUTTON_LONG_RELEASE,
-} periph_adc_button_event_id_t;
-
-/**
-* ESP32 ADC1 channels and GPIO table
-*   ADC1_CHANNEL_0 -  GPIO36
-*   ADC1_CHANNEL_1 -  GPIO37
-*   ADC1_CHANNEL_2 -  GPIO38
-*   ADC1_CHANNEL_3 -  GPIO39
-*   ADC1_CHANNEL_4 -  GPIO32
-*   ADC1_CHANNEL_5 -  GPIO33
-*   ADC1_CHANNEL_6 -  GPIO34
-*   ADC1_CHANNEL_7 -  GPIO35
-*
-**/
-
-#define ADC_DEFAULT_ARR() {   \
-    .adc_ch = ADC1_CHANNEL_3, \
-    .adc_level_step = NULL,   \
-    .total_steps = 6,         \
-    .press_judge_time = 3000, \
-}
-
-/**
- * @brief      Create the button peripheral handle for esp_peripherals.
- *
- * @note       The handle created by this function is automatically destroyed when esp_periph_destroy is called.
- *
- * @param      btn_cfg  The button configuration.
- *
- * @return     The esp peripheral handle.
- */
-esp_periph_handle_t periph_adc_button_init(periph_adc_button_cfg_t *btn_cfg);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PERIPH_ADC_BUTTON_H_
+#define _PERIPH_ADC_BUTTON_H_
+
+#include "driver/adc.h"
+#include "adc_button.h"
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ADC_BUTTON_STACK_SIZE           2500
+#define ADC_BUTTON_TASK_PRIORITY        10
+#define ADC_BUTTON_TASK_CORE_ID         0
+
+/**
+ * @brief      The configuration of ADC Button
+ */
+typedef struct {
+    adc_arr_t *arr;  /*!< An array with configuration of buttons */
+    int arr_size;    /*!< The array size */
+    adc_btn_task_cfg_t task_cfg; /*!< Adc button task configuration */
+} periph_adc_button_cfg_t;
+
+#define PERIPH_ADC_BUTTON_DEFAULT_CONFIG() {   \
+    .task_cfg = {                              \
+        .task_stack = ADC_BUTTON_STACK_SIZE,   \
+        .task_core  = ADC_BUTTON_TASK_CORE_ID, \
+        .task_prio  = ADC_BUTTON_TASK_PRIORITY,\
+        .ext_stack  = false                    \
+    }                                          \
+}
+
+typedef enum {
+    PERIPH_ADC_BUTTON_IDLE = 0,
+    PERIPH_ADC_BUTTON_PRESSED,
+    PERIPH_ADC_BUTTON_RELEASE,
+    PERIPH_ADC_BUTTON_LONG_PRESSED,
+    PERIPH_ADC_BUTTON_LONG_RELEASE,
+} periph_adc_button_event_id_t;
+
+/**
+* ESP32 ADC1 channels and GPIO table
+*   ADC1_CHANNEL_0 -  GPIO36
+*   ADC1_CHANNEL_1 -  GPIO37
+*   ADC1_CHANNEL_2 -  GPIO38
+*   ADC1_CHANNEL_3 -  GPIO39
+*   ADC1_CHANNEL_4 -  GPIO32
+*   ADC1_CHANNEL_5 -  GPIO33
+*   ADC1_CHANNEL_6 -  GPIO34
+*   ADC1_CHANNEL_7 -  GPIO35
+*
+**/
+
+#define ADC_DEFAULT_ARR() {   \
+    .adc_ch = ADC1_CHANNEL_3, \
+    .adc_level_step = NULL,   \
+    .total_steps = 6,         \
+    .press_judge_time = 3000, \
+}
+
+/**
+ * @brief      Create the button peripheral handle for esp_peripherals.
+ *
+ * @note       The handle created by this function is automatically destroyed when esp_periph_destroy is called.
+ *
+ * @param      btn_cfg  The button configuration.
+ *
+ * @return     The esp peripheral handle.
+ */
+esp_periph_handle_t periph_adc_button_init(periph_adc_button_cfg_t *btn_cfg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_aw2013.h b/components/esp_peripherals/include/periph_aw2013.h
index 1b3e47b1..a60a4f46 100644
--- a/components/esp_peripherals/include/periph_aw2013.h
+++ b/components/esp_peripherals/include/periph_aw2013.h
@@ -1,126 +1,126 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PERIPH_AW2013_H_
-#define _PERIPH_AW2013_H_
-
-#include "esp_peripherals.h"
-#include "aw2013.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum {
-    AW2013_MODE_LED,
-    AW2013_MODE_FADE,
-    AW2013_MODE_AUTO
-} periph_aw2013_mode_t;
-
-/**
- * @brief Configuration of aw2013
- */
-typedef struct {
-    periph_aw2013_mode_t mode;          /*!< Work mode of aw2013 */
-    aw2013_brightness_t bright;  /*!< The brightness of aw2013 */
-    uint32_t rgb_value;                 /*!< rgb value to be set */
-} periph_aw2013_cfg_t;
-
-/**
- * @brief Initializate aw2013
- *
- * @param aw2013_cfg  Parameters of aw2013
- *
- * @return
- *     - NULL   Error
- *     - others Success
- */
-esp_periph_handle_t periph_aw2013_init(periph_aw2013_cfg_t *aw2013_cfg);
-
-/**
- * @brief Set the brightness of aw2013
- *
- * @param periph  The aw2013's handle
- * @param bright  The brightness to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL Error
- */
-esp_err_t periph_aw2013_set_brightless(esp_periph_handle_t periph, aw2013_brightness_t bright);
-
-/**
- * @brief Set the time periods of aw2013
- *
- * @param periph  The aw2013's handle
- * @param time    The time period to be set
- * @param level   The time value to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL Error
- */
-esp_err_t periph_aw2013_set_time(esp_periph_handle_t periph, aw2013_time_t time, aw2013_time_level_t level);
-
-/**
- * @brief Set the work mode of aw2013
- *
- * @param periph  The aw2013's handle
- * @param mode    The work mode to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL Error
- */
-esp_err_t periph_aw2013_set_mode(esp_periph_handle_t periph, periph_aw2013_mode_t mode);
-
-/**
- * @brief Set the rgb value of aw2013
- *
- * @param periph  The aw2013's handle
- * @param value   The value for rgb to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL Error
- */
-esp_err_t periph_aw2013_set_rgb_value(esp_periph_handle_t periph, uint32_t value);
-
-/**
- * @brief Set the repeat time in auto flash mode
- *
- * @param periph  The aw2013's handle
- * @param cnt     Cycle times to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL Error
- */
-esp_err_t periph_aw2013_set_repeat_time(esp_periph_handle_t periph, uint8_t cnt);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PERIPH_AW2013_H_
+#define _PERIPH_AW2013_H_
+
+#include "esp_peripherals.h"
+#include "aw2013.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    AW2013_MODE_LED,
+    AW2013_MODE_FADE,
+    AW2013_MODE_AUTO
+} periph_aw2013_mode_t;
+
+/**
+ * @brief Configuration of aw2013
+ */
+typedef struct {
+    periph_aw2013_mode_t mode;          /*!< Work mode of aw2013 */
+    aw2013_brightness_t bright;  /*!< The brightness of aw2013 */
+    uint32_t rgb_value;                 /*!< rgb value to be set */
+} periph_aw2013_cfg_t;
+
+/**
+ * @brief Initializate aw2013
+ *
+ * @param aw2013_cfg  Parameters of aw2013
+ *
+ * @return
+ *     - NULL   Error
+ *     - others Success
+ */
+esp_periph_handle_t periph_aw2013_init(periph_aw2013_cfg_t *aw2013_cfg);
+
+/**
+ * @brief Set the brightness of aw2013
+ *
+ * @param periph  The aw2013's handle
+ * @param bright  The brightness to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL Error
+ */
+esp_err_t periph_aw2013_set_brightless(esp_periph_handle_t periph, aw2013_brightness_t bright);
+
+/**
+ * @brief Set the time periods of aw2013
+ *
+ * @param periph  The aw2013's handle
+ * @param time    The time period to be set
+ * @param level   The time value to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL Error
+ */
+esp_err_t periph_aw2013_set_time(esp_periph_handle_t periph, aw2013_time_t time, aw2013_time_level_t level);
+
+/**
+ * @brief Set the work mode of aw2013
+ *
+ * @param periph  The aw2013's handle
+ * @param mode    The work mode to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL Error
+ */
+esp_err_t periph_aw2013_set_mode(esp_periph_handle_t periph, periph_aw2013_mode_t mode);
+
+/**
+ * @brief Set the rgb value of aw2013
+ *
+ * @param periph  The aw2013's handle
+ * @param value   The value for rgb to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL Error
+ */
+esp_err_t periph_aw2013_set_rgb_value(esp_periph_handle_t periph, uint32_t value);
+
+/**
+ * @brief Set the repeat time in auto flash mode
+ *
+ * @param periph  The aw2013's handle
+ * @param cnt     Cycle times to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL Error
+ */
+esp_err_t periph_aw2013_set_repeat_time(esp_periph_handle_t periph, uint8_t cnt);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_button.h b/components/esp_peripherals/include/periph_button.h
index e52bf8b4..38a47de4 100644
--- a/components/esp_peripherals/include/periph_button.h
+++ b/components/esp_peripherals/include/periph_button.h
@@ -1,68 +1,68 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _BUTTON_DEV_H_
-#define _BUTTON_DEV_H_
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   The Button peripheral configuration
- */
-typedef struct {
-    uint64_t gpio_mask;     /*!< GPIO Mask using for this Button peripheral, it is BIT(GPIO_NUM), ex: GPIO_SEL_36 | GPIO_SEL_36 */
-    int long_press_time_ms; /*!< Long press duration in milliseconds, default is 2000ms */
-} periph_button_cfg_t;
-
-/**
- * @brief      Peripheral button event id
- */
-typedef enum {
-    PERIPH_BUTTON_UNCHANGE = 0, /*!< No event */
-    PERIPH_BUTTON_PRESSED,      /*!< When button is pressed */
-    PERIPH_BUTTON_RELEASE,      /*!< When button is released */
-    PERIPH_BUTTON_LONG_PRESSED, /*!< When button is pressed and kept for more than `long_press_time_ms` */
-    PERIPH_BUTTON_LONG_RELEASE, /*!< When button is released and event PERIPH_BUTTON_LONG_PRESSED happened */
-} periph_button_event_id_t;
-
-/**
- * @brief      Create the button peripheral handle for esp_peripherals.
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      but_cfg  The but configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_button_init(periph_button_cfg_t* but_cfg);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _BUTTON_DEV_H_
+#define _BUTTON_DEV_H_
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   The Button peripheral configuration
+ */
+typedef struct {
+    uint64_t gpio_mask;     /*!< GPIO Mask using for this Button peripheral, it is BIT(GPIO_NUM), ex: GPIO_SEL_36 | GPIO_SEL_36 */
+    int long_press_time_ms; /*!< Long press duration in milliseconds, default is 2000ms */
+} periph_button_cfg_t;
+
+/**
+ * @brief      Peripheral button event id
+ */
+typedef enum {
+    PERIPH_BUTTON_UNCHANGE = 0, /*!< No event */
+    PERIPH_BUTTON_PRESSED,      /*!< When button is pressed */
+    PERIPH_BUTTON_RELEASE,      /*!< When button is released */
+    PERIPH_BUTTON_LONG_PRESSED, /*!< When button is pressed and kept for more than `long_press_time_ms` */
+    PERIPH_BUTTON_LONG_RELEASE, /*!< When button is released and event PERIPH_BUTTON_LONG_PRESSED happened */
+} periph_button_event_id_t;
+
+/**
+ * @brief      Create the button peripheral handle for esp_peripherals.
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      but_cfg  The but configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_button_init(periph_button_cfg_t* but_cfg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_console.h b/components/esp_peripherals/include/periph_console.h
index 44a5d006..787a7514 100644
--- a/components/esp_peripherals/include/periph_console.h
+++ b/components/esp_peripherals/include/periph_console.h
@@ -1,78 +1,78 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PERIPH_CONSOLE_H_
-#define _PERIPH_CONSOLE_H_
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef esp_err_t (*console_cmd_callback_t)(esp_periph_handle_t periph, int argc, char *argv[]);
-
-#define CONSOLE_DEFAULT_TASK_PRIO       (5)
-#define CONSOLE_DEFAULT_TASK_STACK      (1024*5)
-#define CONSOLE_DEFAULT_BUFFER_SIZE     (256)
-#define CONSOLE_DEFAULT_PROMPT_STRING   "esp32>"
-
-
-
-/**
- * @brief      Command structure
- */
-typedef struct {
-    const char              *cmd;   /*!< Name of command, must be unique */
-    int                     id;     /*!< Command ID will be sent together when the command is matched */
-    const char              *help;  /*!< Explanation of the command */
-    console_cmd_callback_t  func;   /*!< Function callback for the command */
-} periph_console_cmd_t;
-
-/**
- * @brief      Console Peripheral configuration
- */
-typedef struct {
-    int                         command_num;    /*!< Total number of commands */
-    const periph_console_cmd_t  *commands;      /*!< Pointer to array of commands */
-    int                         task_stack;     /*!< Console task stack, using default if the value is zero */
-    int                         task_prio;      /*!< Console task priority (based on freeRTOS priority), using default if the value is zero */
-    int                         buffer_size;    /*!< Size of console input buffer */
-    const char                  *prompt_string; /*!< Console prompt string, using default CONSOLE_PROMPT_STRING if the pointer is NULL */
-} periph_console_cfg_t;
-
-/**
- * @brief      Initialize Console Peripheral
- *
- * @param      config  The configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_console_init(periph_console_cfg_t *config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PERIPH_CONSOLE_H_
+#define _PERIPH_CONSOLE_H_
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef esp_err_t (*console_cmd_callback_t)(esp_periph_handle_t periph, int argc, char *argv[]);
+
+#define CONSOLE_DEFAULT_TASK_PRIO       (5)
+#define CONSOLE_DEFAULT_TASK_STACK      (1024*5)
+#define CONSOLE_DEFAULT_BUFFER_SIZE     (256)
+#define CONSOLE_DEFAULT_PROMPT_STRING   "esp32>"
+
+
+
+/**
+ * @brief      Command structure
+ */
+typedef struct {
+    const char              *cmd;   /*!< Name of command, must be unique */
+    int                     id;     /*!< Command ID will be sent together when the command is matched */
+    const char              *help;  /*!< Explanation of the command */
+    console_cmd_callback_t  func;   /*!< Function callback for the command */
+} periph_console_cmd_t;
+
+/**
+ * @brief      Console Peripheral configuration
+ */
+typedef struct {
+    int                         command_num;    /*!< Total number of commands */
+    const periph_console_cmd_t  *commands;      /*!< Pointer to array of commands */
+    int                         task_stack;     /*!< Console task stack, using default if the value is zero */
+    int                         task_prio;      /*!< Console task priority (based on freeRTOS priority), using default if the value is zero */
+    int                         buffer_size;    /*!< Size of console input buffer */
+    const char                  *prompt_string; /*!< Console prompt string, using default CONSOLE_PROMPT_STRING if the pointer is NULL */
+} periph_console_cfg_t;
+
+/**
+ * @brief      Initialize Console Peripheral
+ *
+ * @param      config  The configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_console_init(periph_console_cfg_t *config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_gpio_isr.h b/components/esp_peripherals/include/periph_gpio_isr.h
index 038e002b..b2dfd778 100644
--- a/components/esp_peripherals/include/periph_gpio_isr.h
+++ b/components/esp_peripherals/include/periph_gpio_isr.h
@@ -1,87 +1,87 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PERIPH_GPIO_ISR_H_
-#define _PERIPH_GPIO_ISR_H_
-
-#include "esp_peripherals.h"
-#include "driver/gpio.h"
-#include "gpio_isr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @breif Set the gpio number and gpio interruption type
- */
-typedef struct {
-    int gpio_num;           /*!< gpio number */
-    gpio_int_type_t type;   /*!< interruption type */
-} gpio_isr_info_t;
-
-/**
- * @brief The configuration of gpio isr
- */
-typedef struct {
-    int info_size;                    /*!< number of gpio to be register */
-    gpio_isr_info_t *gpio_isr_info;   /*!< an array of gpio's infomation */
-}periph_gpio_isr_cfg_t;
-
-/**
- * @brief     Create the gpio's interrupt service routines handle for esp_peripherals
- *
- * @param     isr_config  The gpio isr configuration
- *
- * @return    The esp peripheral handle
- */
-esp_periph_handle_t periph_gpio_isr_init(periph_gpio_isr_cfg_t *isr_config);
-
-/**
- * @breif      Add a gpio to isr
- *
- * @param      gpio_info  The gpio interruption type and gpio number
- *
- * @return
- *      - ESP_OK   success
- *      - ESP_FAIL fail
- */
-esp_err_t periph_gpio_isr_add(gpio_isr_info_t *gpio_info);
-
-/**
- * @brief       Unregister a gpio from isr
- *
- * @param       The number of gpio to be unregistered
- *
- *@return
- *     - ESP_OK    success
- *     - ESP_FAIL  failed
- */
-esp_err_t periph_gpio_isr_delete(int gpio_num);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PERIPH_GPIO_ISR_H_
+#define _PERIPH_GPIO_ISR_H_
+
+#include "esp_peripherals.h"
+#include "driver/gpio.h"
+#include "gpio_isr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @breif Set the gpio number and gpio interruption type
+ */
+typedef struct {
+    int gpio_num;           /*!< gpio number */
+    gpio_int_type_t type;   /*!< interruption type */
+} gpio_isr_info_t;
+
+/**
+ * @brief The configuration of gpio isr
+ */
+typedef struct {
+    int info_size;                    /*!< number of gpio to be register */
+    gpio_isr_info_t *gpio_isr_info;   /*!< an array of gpio's infomation */
+}periph_gpio_isr_cfg_t;
+
+/**
+ * @brief     Create the gpio's interrupt service routines handle for esp_peripherals
+ *
+ * @param     isr_config  The gpio isr configuration
+ *
+ * @return    The esp peripheral handle
+ */
+esp_periph_handle_t periph_gpio_isr_init(periph_gpio_isr_cfg_t *isr_config);
+
+/**
+ * @breif      Add a gpio to isr
+ *
+ * @param      gpio_info  The gpio interruption type and gpio number
+ *
+ * @return
+ *      - ESP_OK   success
+ *      - ESP_FAIL fail
+ */
+esp_err_t periph_gpio_isr_add(gpio_isr_info_t *gpio_info);
+
+/**
+ * @brief       Unregister a gpio from isr
+ *
+ * @param       The number of gpio to be unregistered
+ *
+ *@return
+ *     - ESP_OK    success
+ *     - ESP_FAIL  failed
+ */
+esp_err_t periph_gpio_isr_delete(int gpio_num);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_is31fl3216.h b/components/esp_peripherals/include/periph_is31fl3216.h
index ee0c825d..3304a7d5 100644
--- a/components/esp_peripherals/include/periph_is31fl3216.h
+++ b/components/esp_peripherals/include/periph_is31fl3216.h
@@ -1,174 +1,174 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef __PERIPH_IS31FL3216_H__
-#define __PERIPH_IS31FL3216_H__
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define IS31FL3216_CH_NUM 16   //Should be less than or equal to 16
-#define BLUE_LED_MAX_NUM  12
-
-typedef enum {
-    IS31FL3216_STATE_UNKNOWN,
-    IS31FL3216_STATE_OFF,
-    IS31FL3216_STATE_ON,
-    IS31FL3216_STATE_FLASH,
-    IS31FL3216_STATE_BY_AUDIO,
-    IS31FL3216_STATE_SHIFT,
-} periph_is31fl3216_state_t;
-
-typedef enum {
-    PERIPH_IS31_SHIFT_MODE_UNKNOWN,
-    PERIPH_IS31_SHIFT_MODE_ACC,     /*!< accumulation mode */
-    PERIPH_IS31_SHIFT_MODE_SINGLE,
-} periph_is31_shift_mode_t;
-
-/**
- * @brief      The configuration of is31fl3216
- */
-typedef struct {
-    uint32_t                    duty[IS31FL3216_CH_NUM];    /*!<An array of the is31fl3216's duty*/
-    uint16_t                    is31fl3216_pattern;         /*!<Current enable channel*/
-    periph_is31fl3216_state_t   state;                      /*!<The state of all the channels*/
-} periph_is31fl3216_cfg_t;
-
-/**
- * @brief      Initializate the is31fl3216
- *
- * @param      is31fl3216_config
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_periph_handle_t periph_is31fl3216_init(periph_is31fl3216_cfg_t *is31fl3216_config);
-
-/**
- * @brief      Set the state of all the channels
- *
- * @param      periph               The is31fl3216 handle
- * @param      state                The state of all channels
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_state(esp_periph_handle_t periph, periph_is31fl3216_state_t state);
-
-/**
- * @brief      Set the current enable channels
- *
- * @param      periph                The is31fl3216 handle
- * @param      blink_pattern         The bit pattern of enabled channels
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_blink_pattern(esp_periph_handle_t periph, uint16_t blink_pattern);
-
-/**
- * @brief      Set the duty of the channel
- *
- * @param      periph                The is31fl3216 handle
- * @param      index                 The channel number
- * @param      value                 The value of the channel's duty to be set
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_duty(esp_periph_handle_t periph, uint8_t index, uint8_t value);
-
-/**
- * @brief      Set the duty step of flash
- *
- * @param      periph              The is31fl3216 handle
- * @param      step                The step of flash
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_duty_step(esp_periph_handle_t periph, uint8_t step);
-
-/**
- * @brief      Set the internval time
- *
- * @param      periph                The is31fl3216 handle
- * @param      interval_ms           Time of interval
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_interval(esp_periph_handle_t periph, uint16_t interval_ms);
-
-/**
- * @brief      Set the shift mode
- *
- * @param      periph                The is31fl3216 handle
- * @param      mode                  Mode of periph_is31_shift_mode_t
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_shift_mode(esp_periph_handle_t periph, periph_is31_shift_mode_t mode);
-
-/**
- * @brief      Set the light on numbers
- *
- * @param      periph                The is31fl3216 handle
- * @param      light_on_num          Enabled led number
- * @param      max_light_num         Maximum led number
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_light_on_num(esp_periph_handle_t periph, uint16_t light_on_num, uint16_t max_light_num);
-
-/**
- * @brief      Set the action time
- *
- * @param      periph                The is31fl3216 handle
- * @param      act_ms                Action time, unit is millisecond, 0 is infinite
- *
- * @return
- *     - ESP_OK    Success
- *     - ESP_FAIL  Fail
- */
-esp_err_t periph_is31fl3216_set_act_time(esp_periph_handle_t periph, uint16_t act_ms);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef __PERIPH_IS31FL3216_H__
+#define __PERIPH_IS31FL3216_H__
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IS31FL3216_CH_NUM 16   //Should be less than or equal to 16
+#define BLUE_LED_MAX_NUM  12
+
+typedef enum {
+    IS31FL3216_STATE_UNKNOWN,
+    IS31FL3216_STATE_OFF,
+    IS31FL3216_STATE_ON,
+    IS31FL3216_STATE_FLASH,
+    IS31FL3216_STATE_BY_AUDIO,
+    IS31FL3216_STATE_SHIFT,
+} periph_is31fl3216_state_t;
+
+typedef enum {
+    PERIPH_IS31_SHIFT_MODE_UNKNOWN,
+    PERIPH_IS31_SHIFT_MODE_ACC,     /*!< accumulation mode */
+    PERIPH_IS31_SHIFT_MODE_SINGLE,
+} periph_is31_shift_mode_t;
+
+/**
+ * @brief      The configuration of is31fl3216
+ */
+typedef struct {
+    uint32_t                    duty[IS31FL3216_CH_NUM];    /*!<An array of the is31fl3216's duty*/
+    uint16_t                    is31fl3216_pattern;         /*!<Current enable channel*/
+    periph_is31fl3216_state_t   state;                      /*!<The state of all the channels*/
+} periph_is31fl3216_cfg_t;
+
+/**
+ * @brief      Initializate the is31fl3216
+ *
+ * @param      is31fl3216_config
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_periph_handle_t periph_is31fl3216_init(periph_is31fl3216_cfg_t *is31fl3216_config);
+
+/**
+ * @brief      Set the state of all the channels
+ *
+ * @param      periph               The is31fl3216 handle
+ * @param      state                The state of all channels
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_state(esp_periph_handle_t periph, periph_is31fl3216_state_t state);
+
+/**
+ * @brief      Set the current enable channels
+ *
+ * @param      periph                The is31fl3216 handle
+ * @param      blink_pattern         The bit pattern of enabled channels
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_blink_pattern(esp_periph_handle_t periph, uint16_t blink_pattern);
+
+/**
+ * @brief      Set the duty of the channel
+ *
+ * @param      periph                The is31fl3216 handle
+ * @param      index                 The channel number
+ * @param      value                 The value of the channel's duty to be set
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_duty(esp_periph_handle_t periph, uint8_t index, uint8_t value);
+
+/**
+ * @brief      Set the duty step of flash
+ *
+ * @param      periph              The is31fl3216 handle
+ * @param      step                The step of flash
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_duty_step(esp_periph_handle_t periph, uint8_t step);
+
+/**
+ * @brief      Set the internval time
+ *
+ * @param      periph                The is31fl3216 handle
+ * @param      interval_ms           Time of interval
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_interval(esp_periph_handle_t periph, uint16_t interval_ms);
+
+/**
+ * @brief      Set the shift mode
+ *
+ * @param      periph                The is31fl3216 handle
+ * @param      mode                  Mode of periph_is31_shift_mode_t
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_shift_mode(esp_periph_handle_t periph, periph_is31_shift_mode_t mode);
+
+/**
+ * @brief      Set the light on numbers
+ *
+ * @param      periph                The is31fl3216 handle
+ * @param      light_on_num          Enabled led number
+ * @param      max_light_num         Maximum led number
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_light_on_num(esp_periph_handle_t periph, uint16_t light_on_num, uint16_t max_light_num);
+
+/**
+ * @brief      Set the action time
+ *
+ * @param      periph                The is31fl3216 handle
+ * @param      act_ms                Action time, unit is millisecond, 0 is infinite
+ *
+ * @return
+ *     - ESP_OK    Success
+ *     - ESP_FAIL  Fail
+ */
+esp_err_t periph_is31fl3216_set_act_time(esp_periph_handle_t periph, uint16_t act_ms);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_lcd.h b/components/esp_peripherals/include/periph_lcd.h
index 25e3aae4..9623258c 100644
--- a/components/esp_peripherals/include/periph_lcd.h
+++ b/components/esp_peripherals/include/periph_lcd.h
@@ -1,99 +1,99 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PERIPH_LCD_H_
-#define _PERIPH_LCD_H_
-
-#include "esp_lcd_panel_io.h"  // Do not use extern "C" with this header to avoid C++ linkage issues.
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
-#include "esp_lcd_panel_vendor.h"
-#include "driver/spi_master.h"
-#include "esp_peripherals.h"
-
-typedef esp_err_t (*perph_lcd_rest)(esp_periph_handle_t self, void *ctx);
-
-typedef esp_err_t (*get_lcd_io_bus)(void *bus, esp_lcd_panel_io_spi_config_t *io_config, esp_lcd_panel_io_handle_t *out_panel_io);
-
-typedef esp_err_t (*get_lcd_panel)(const esp_lcd_panel_io_handle_t panel_io, const esp_lcd_panel_dev_config_t *panel_dev_config,
-                                   esp_lcd_panel_handle_t *ret_panel);
-
-/**
- * @brief   LCD vendor initialize callback
- * @note    Same LCD driver can drive multiple LCD devices
- *          Each device use specified vendor driver code (consisted by a group of setting commands)
- *          Users can setup it through `esp_lcd_panel_io_tx_param` using `esp_lcd_panel_io_handle_t`
- */
-typedef esp_err_t (*lcd_vender_init_func)(const esp_lcd_panel_io_handle_t panel_io);
-/**
- * @brief   The LCD peripheral configurations
- */
-typedef struct {
-    void                                *io_bus;
-    get_lcd_io_bus                      new_panel_io;
-    esp_lcd_panel_io_spi_config_t       *lcd_io_cfg;
-
-    get_lcd_panel                       new_lcd_panel;
-    lcd_vender_init_func                vendor_init;
-    esp_lcd_panel_dev_config_t          *lcd_dev_cfg;
-    perph_lcd_rest                      rest_cb;
-    void                                *rest_cb_ctx;
-
-    bool                                lcd_swap_xy;
-    bool                                lcd_mirror_x;
-    bool                                lcd_mirror_y;
-    bool                                lcd_color_invert;
-} periph_lcd_cfg_t;
-
-/**
- * @brief      Create the LCD peripheral handle for esp_peripherals
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      config  The configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_lcd_init(periph_lcd_cfg_t *config);
-
-/**
- * @brief      Get the `esp_lcd_panel_handle_t` with given LCD peripheral handle
- *
- * @param      handle  The LCD peripheral handle
- *
- * @return     The `esp_lcd_panel_handle_t` handle
- */
-esp_lcd_panel_handle_t periph_lcd_get_panel_handle(esp_periph_handle_t handle);
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PERIPH_LCD_H_
+#define _PERIPH_LCD_H_
+
+#include "esp_lcd_panel_io.h"  // Do not use extern "C" with this header to avoid C++ linkage issues.
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
+#include "esp_lcd_panel_vendor.h"
+#include "driver/spi_master.h"
+#include "esp_peripherals.h"
+
+typedef esp_err_t (*perph_lcd_rest)(esp_periph_handle_t self, void *ctx);
+
+typedef esp_err_t (*get_lcd_io_bus)(void *bus, esp_lcd_panel_io_spi_config_t *io_config, esp_lcd_panel_io_handle_t *out_panel_io);
+
+typedef esp_err_t (*get_lcd_panel)(const esp_lcd_panel_io_handle_t panel_io, const esp_lcd_panel_dev_config_t *panel_dev_config,
+                                   esp_lcd_panel_handle_t *ret_panel);
+
+/**
+ * @brief   LCD vendor initialize callback
+ * @note    Same LCD driver can drive multiple LCD devices
+ *          Each device use specified vendor driver code (consisted by a group of setting commands)
+ *          Users can setup it through `esp_lcd_panel_io_tx_param` using `esp_lcd_panel_io_handle_t`
+ */
+typedef esp_err_t (*lcd_vender_init_func)(const esp_lcd_panel_io_handle_t panel_io);
+/**
+ * @brief   The LCD peripheral configurations
+ */
+typedef struct {
+    void                                *io_bus;
+    get_lcd_io_bus                      new_panel_io;
+    esp_lcd_panel_io_spi_config_t       *lcd_io_cfg;
+
+    get_lcd_panel                       new_lcd_panel;
+    lcd_vender_init_func                vendor_init;
+    esp_lcd_panel_dev_config_t          *lcd_dev_cfg;
+    perph_lcd_rest                      rest_cb;
+    void                                *rest_cb_ctx;
+
+    bool                                lcd_swap_xy;
+    bool                                lcd_mirror_x;
+    bool                                lcd_mirror_y;
+    bool                                lcd_color_invert;
+} periph_lcd_cfg_t;
+
+/**
+ * @brief      Create the LCD peripheral handle for esp_peripherals
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      config  The configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_lcd_init(periph_lcd_cfg_t *config);
+
+/**
+ * @brief      Get the `esp_lcd_panel_handle_t` with given LCD peripheral handle
+ *
+ * @param      handle  The LCD peripheral handle
+ *
+ * @return     The `esp_lcd_panel_handle_t` handle
+ */
+esp_lcd_panel_handle_t periph_lcd_get_panel_handle(esp_periph_handle_t handle);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_led.h b/components/esp_peripherals/include/periph_led.h
index 13c8ec7e..d70b3d10 100644
--- a/components/esp_peripherals/include/periph_led.h
+++ b/components/esp_peripherals/include/periph_led.h
@@ -1,111 +1,111 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _PERIPH_LED_H_
-#define _PERIPH_LED_H_
-
-#include "driver/ledc.h"
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      Peripheral LED event id
- */
-typedef enum {
-    PERIPH_LED_UNCHANGE = 0,  /*!< No event */
-    PERIPH_LED_BLINK_FINISH,  /*!< When LED blink is finished */
-} periph_led_event_id_t;
-
-/**
- * @brief      Peripheral LED idle output level
- */
-typedef enum {
-    PERIPH_LED_IDLE_LEVEL_LOW,  /*!< Low level output */
-    PERIPH_LED_IDLE_LEVEL_HIGH  /*!< High level output */
-} periph_led_idle_level_t;
-
-/**
- * @brief   The LED peripheral configuration
- */
-typedef struct {
-    ledc_mode_t      led_speed_mode;        /*!< LEDC speed speed_mode, high-speed mode or low-speed mode */
-    ledc_timer_bit_t led_duty_resolution;   /*!< LEDC channel duty resolution */
-    ledc_timer_t     led_timer_num;         /*!< Select the timer source of channel (0 - 3) */
-    uint32_t         led_freq_hz;           /*!< LEDC timer frequency (Hz) */
-    int              gpio_num;              /*!< Optional, < 0 invalid gpio number */
-} periph_led_cfg_t;
-
-/**
- * @brief      Create the LED peripheral handle for esp_peripherals
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      config  The configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_led_init(periph_led_cfg_t* config);
-
-/**
- * @brief      Bink LED Peripheral, this function will automatically configure the gpio_num to control the LED,
- *             with `time_on_ms` as the time (in milliseconds) switch from OFF to ON (or ON if fade is disabled),
- *             and `time_off_ms` as the time (in milliseconds) switch from ON to OFF (or OFF if fade is disabled).
- *             When switching from ON -> OFF and vice versa, the loop decreases once, and will turn off the effect when the loop is 0.
- *             With a loop value less than 0, the LED effect will loop endlessly.
- *             PERIPH_LED_BLINK_FINISH events will be sent at each end of loop
- *
- * @param[in]  periph       The LED periph
- * @param[in]  gpio_num     The gpio number
- * @param[in]  time_on_ms   The time on milliseconds
- * @param[in]  time_off_ms  The time off milliseconds
- * @param[in]  fade         Fading enabled
- * @param[in]  loop         Loop
- * @param[in]  level        idle level
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_led_blink(esp_periph_handle_t periph, int gpio_num, int time_on_ms, int time_off_ms, bool fade, int loop, periph_led_idle_level_t level);
-
-/**
- * @brief      Stop Blink the LED
- *
- * @param[in]  periph    The periph
- * @param[in]  gpio_num  The gpio number
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_led_stop(esp_periph_handle_t periph, int gpio_num);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _PERIPH_LED_H_
+#define _PERIPH_LED_H_
+
+#include "driver/ledc.h"
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      Peripheral LED event id
+ */
+typedef enum {
+    PERIPH_LED_UNCHANGE = 0,  /*!< No event */
+    PERIPH_LED_BLINK_FINISH,  /*!< When LED blink is finished */
+} periph_led_event_id_t;
+
+/**
+ * @brief      Peripheral LED idle output level
+ */
+typedef enum {
+    PERIPH_LED_IDLE_LEVEL_LOW,  /*!< Low level output */
+    PERIPH_LED_IDLE_LEVEL_HIGH  /*!< High level output */
+} periph_led_idle_level_t;
+
+/**
+ * @brief   The LED peripheral configuration
+ */
+typedef struct {
+    ledc_mode_t      led_speed_mode;        /*!< LEDC speed speed_mode, high-speed mode or low-speed mode */
+    ledc_timer_bit_t led_duty_resolution;   /*!< LEDC channel duty resolution */
+    ledc_timer_t     led_timer_num;         /*!< Select the timer source of channel (0 - 3) */
+    uint32_t         led_freq_hz;           /*!< LEDC timer frequency (Hz) */
+    int              gpio_num;              /*!< Optional, < 0 invalid gpio number */
+} periph_led_cfg_t;
+
+/**
+ * @brief      Create the LED peripheral handle for esp_peripherals
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      config  The configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_led_init(periph_led_cfg_t* config);
+
+/**
+ * @brief      Bink LED Peripheral, this function will automatically configure the gpio_num to control the LED,
+ *             with `time_on_ms` as the time (in milliseconds) switch from OFF to ON (or ON if fade is disabled),
+ *             and `time_off_ms` as the time (in milliseconds) switch from ON to OFF (or OFF if fade is disabled).
+ *             When switching from ON -> OFF and vice versa, the loop decreases once, and will turn off the effect when the loop is 0.
+ *             With a loop value less than 0, the LED effect will loop endlessly.
+ *             PERIPH_LED_BLINK_FINISH events will be sent at each end of loop
+ *
+ * @param[in]  periph       The LED periph
+ * @param[in]  gpio_num     The gpio number
+ * @param[in]  time_on_ms   The time on milliseconds
+ * @param[in]  time_off_ms  The time off milliseconds
+ * @param[in]  fade         Fading enabled
+ * @param[in]  loop         Loop
+ * @param[in]  level        idle level
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_led_blink(esp_periph_handle_t periph, int gpio_num, int time_on_ms, int time_off_ms, bool fade, int loop, periph_led_idle_level_t level);
+
+/**
+ * @brief      Stop Blink the LED
+ *
+ * @param[in]  periph    The periph
+ * @param[in]  gpio_num  The gpio number
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_led_stop(esp_periph_handle_t periph, int gpio_num);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_sdcard.h b/components/esp_peripherals/include/periph_sdcard.h
index 93ccb5b1..574a41a6 100644
--- a/components/esp_peripherals/include/periph_sdcard.h
+++ b/components/esp_peripherals/include/periph_sdcard.h
@@ -1,92 +1,92 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _SDCARD_DEV_H_
-#define _SDCARD_DEV_H_
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Peripheral sdcard event id
- */
-typedef enum  {
-    SDCARD_STATUS_UNKNOWN,              /*!< No event */
-    SDCARD_STATUS_CARD_DETECT_CHANGE,   /*!< Detect changes in the card_detect pin */
-    SDCARD_STATUS_MOUNTED,              /*!< SDCARD mounted successfully */
-    SDCARD_STATUS_UNMOUNTED,            /*!< SDCARD unmounted successfully */
-    SDCARD_STATUS_MOUNT_ERROR,          /*!< SDCARD mount error */
-    SDCARD_STATUS_UNMOUNT_ERROR,        /*!< SDCARD unmount error */
-} periph_sdcard_event_id_t;
-
-/**
- * @brief  SD card mode, SPI, 1-line SD mode, 4-line SD mode
- *
- */
-typedef enum {
-    SD_MODE_SPI    = 0x0,  /*!< sd_card SPI*/
-    SD_MODE_1_LINE = 0x1,  /*!< sd_card 1-line SD mode*/
-    SD_MODE_4_LINE = 0x4,  /*!< sd_card 4-line SD mode*/
-    SD_MODE_8_LINE = 0x8,  /*!< sd_card 8-line SD mode*/
-    SD_MODE_MAX,
-} periph_sdcard_mode_t;
-
-/**
- * @brief   The SD Card Peripheral configuration
- */
-typedef struct {
-    int card_detect_pin;        /*!< Card detect gpio number */
-    const char* root;           /*!< Base path for vfs */
-    periph_sdcard_mode_t mode;  /*!< card mode*/
-} periph_sdcard_cfg_t;
-
-
-/**
- * @brief      Create the sdcard peripheral handle for esp_peripherals
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      sdcard_config  The sdcard configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_sdcard_init(periph_sdcard_cfg_t* sdcard_config);
-
-/**
- * @brief      Check the sdcard is mounted or not.
- *
- * @param[in]  periph  The periph
- *
- * @return     SDCARD mounted state
- */
-bool periph_sdcard_is_mounted(esp_periph_handle_t periph);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _SDCARD_DEV_H_
+#define _SDCARD_DEV_H_
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Peripheral sdcard event id
+ */
+typedef enum  {
+    SDCARD_STATUS_UNKNOWN,              /*!< No event */
+    SDCARD_STATUS_CARD_DETECT_CHANGE,   /*!< Detect changes in the card_detect pin */
+    SDCARD_STATUS_MOUNTED,              /*!< SDCARD mounted successfully */
+    SDCARD_STATUS_UNMOUNTED,            /*!< SDCARD unmounted successfully */
+    SDCARD_STATUS_MOUNT_ERROR,          /*!< SDCARD mount error */
+    SDCARD_STATUS_UNMOUNT_ERROR,        /*!< SDCARD unmount error */
+} periph_sdcard_event_id_t;
+
+/**
+ * @brief  SD card mode, SPI, 1-line SD mode, 4-line SD mode
+ *
+ */
+typedef enum {
+    SD_MODE_SPI    = 0x0,  /*!< sd_card SPI*/
+    SD_MODE_1_LINE = 0x1,  /*!< sd_card 1-line SD mode*/
+    SD_MODE_4_LINE = 0x4,  /*!< sd_card 4-line SD mode*/
+    SD_MODE_8_LINE = 0x8,  /*!< sd_card 8-line SD mode*/
+    SD_MODE_MAX,
+} periph_sdcard_mode_t;
+
+/**
+ * @brief   The SD Card Peripheral configuration
+ */
+typedef struct {
+    int card_detect_pin;        /*!< Card detect gpio number */
+    const char* root;           /*!< Base path for vfs */
+    periph_sdcard_mode_t mode;  /*!< card mode*/
+} periph_sdcard_cfg_t;
+
+
+/**
+ * @brief      Create the sdcard peripheral handle for esp_peripherals
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      sdcard_config  The sdcard configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_sdcard_init(periph_sdcard_cfg_t* sdcard_config);
+
+/**
+ * @brief      Check the sdcard is mounted or not.
+ *
+ * @param[in]  periph  The periph
+ *
+ * @return     SDCARD mounted state
+ */
+bool periph_sdcard_is_mounted(esp_periph_handle_t periph);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_spiffs.h b/components/esp_peripherals/include/periph_spiffs.h
index a1e21912..9bd63135 100644
--- a/components/esp_peripherals/include/periph_spiffs.h
+++ b/components/esp_peripherals/include/periph_spiffs.h
@@ -1,80 +1,80 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _SPIFFS_DEV_H_
-#define _SPIFFS_DEV_H_
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Peripheral spiffs event id
- */
-typedef enum  {
-    SPIFFS_STATUS_UNKNOWN,              /*!< No event */
-    SPIFFS_STATUS_MOUNTED,              /*!< SPIFFS mounted successfully */
-    SPIFFS_STATUS_UNMOUNTED,            /*!< SPIFFS unmounted successfully */
-    SPIFFS_STATUS_MOUNT_ERROR,          /*!< SPIFFS mount error */
-    SPIFFS_STATUS_UNMOUNT_ERROR,        /*!< SPIFFS unmount error */
-} periph_spiffs_event_id_t;
-
-/**
- * @brief   The SPIFFS Peripheral configuration
- */
-typedef struct {
-    const char* root;               /*!< Base path for vfs */
-    const char* partition_label;    /*!< Optional, label of SPIFFS partition to use. If set to NULL, first partition with subtype=spiffs will be used. */
-    size_t max_files;               /*!< Maximum number of files that could be open at the same time. */
-    bool format_if_mount_failed;    /*!< If true, it will format the file system if it fails to mount. */
-} periph_spiffs_cfg_t;
-
-
-/**
- * @brief      Create the spiffs peripheral handle for esp_peripherals
- *
- * @note       The handle created by this function will be automatically destroyed when `esp_periph_destroy` is called
- *
- * @param      spiffs_config  The spiffs configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_spiffs_init(periph_spiffs_cfg_t* spiffs_config);
-
-/**
- * @brief      Check if the SPIFFS is mounted or not.
- *
- * @param[in]  periph  The periph
- *
- * @return     SPIFFS mounted state
- */
-bool periph_spiffs_is_mounted(esp_periph_handle_t periph);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _SPIFFS_DEV_H_
+#define _SPIFFS_DEV_H_
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Peripheral spiffs event id
+ */
+typedef enum  {
+    SPIFFS_STATUS_UNKNOWN,              /*!< No event */
+    SPIFFS_STATUS_MOUNTED,              /*!< SPIFFS mounted successfully */
+    SPIFFS_STATUS_UNMOUNTED,            /*!< SPIFFS unmounted successfully */
+    SPIFFS_STATUS_MOUNT_ERROR,          /*!< SPIFFS mount error */
+    SPIFFS_STATUS_UNMOUNT_ERROR,        /*!< SPIFFS unmount error */
+} periph_spiffs_event_id_t;
+
+/**
+ * @brief   The SPIFFS Peripheral configuration
+ */
+typedef struct {
+    const char* root;               /*!< Base path for vfs */
+    const char* partition_label;    /*!< Optional, label of SPIFFS partition to use. If set to NULL, first partition with subtype=spiffs will be used. */
+    size_t max_files;               /*!< Maximum number of files that could be open at the same time. */
+    bool format_if_mount_failed;    /*!< If true, it will format the file system if it fails to mount. */
+} periph_spiffs_cfg_t;
+
+
+/**
+ * @brief      Create the spiffs peripheral handle for esp_peripherals
+ *
+ * @note       The handle created by this function will be automatically destroyed when `esp_periph_destroy` is called
+ *
+ * @param      spiffs_config  The spiffs configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_spiffs_init(periph_spiffs_cfg_t* spiffs_config);
+
+/**
+ * @brief      Check if the SPIFFS is mounted or not.
+ *
+ * @param[in]  periph  The periph
+ *
+ * @return     SPIFFS mounted state
+ */
+bool periph_spiffs_is_mounted(esp_periph_handle_t periph);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_touch.h b/components/esp_peripherals/include/periph_touch.h
index ff3b8e0f..52410e1c 100644
--- a/components/esp_peripherals/include/periph_touch.h
+++ b/components/esp_peripherals/include/periph_touch.h
@@ -1,86 +1,86 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TOUCH_DEV_H_
-#define _TOUCH_DEV_H_
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      Touch pad selection
- */
-typedef enum {
-    TOUCH_PAD_SEL0 = BIT(0),
-    TOUCH_PAD_SEL1 = BIT(1),
-    TOUCH_PAD_SEL2 = BIT(2),
-    TOUCH_PAD_SEL3 = BIT(3),
-    TOUCH_PAD_SEL4 = BIT(4),
-    TOUCH_PAD_SEL5 = BIT(5),
-    TOUCH_PAD_SEL6 = BIT(6),
-    TOUCH_PAD_SEL7 = BIT(7),
-    TOUCH_PAD_SEL8 = BIT(8),
-    TOUCH_PAD_SEL9 = BIT(9),
-} esp_touch_pad_sel_t;
-
-/**
- * @brief   The Touch peripheral configuration
- */
-typedef struct {
-    int touch_mask;             /*!< Touch pad mask using for this Touch peripheral, ex: TOUCH_PAD_SEL0 | TOUCH_PAD_SEL1  */
-    int tap_threshold_percent;  /*!< Tap threshold percent, Tap event will be determined if the percentage value is less than the non-touch value */
-    int long_tap_time_ms;       /*!< Long tap duration in milliseconds, default is 2000ms, PERIPH_TOUCH_LONG_TAP will be occurred if TAP and time hold longer than this value */
-} periph_touch_cfg_t;
-
-/**
- * @brief      Peripheral touch event id
- */
-typedef enum {
-    PERIPH_TOUCH_UNCHANGE = 0,  /*!< No event */
-    PERIPH_TOUCH_TAP,           /*!< When touch pad is tapped */
-    PERIPH_TOUCH_RELEASE,       /*!< When touch pad is released after tap */
-    PERIPH_TOUCH_LONG_TAP,      /*!< When touch pad is tapped and held after `long_tap_time_ms` time */
-    PERIPH_TOUCH_LONG_RELEASE,  /*!< When touch pad is released after long tap */
-} periph_touch_event_id_t;
-
-
-/**
- * @brief      Create the touch peripheral handle for esp_peripherals
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      config  The configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_touch_init(periph_touch_cfg_t* config);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TOUCH_DEV_H_
+#define _TOUCH_DEV_H_
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      Touch pad selection
+ */
+typedef enum {
+    TOUCH_PAD_SEL0 = BIT(0),
+    TOUCH_PAD_SEL1 = BIT(1),
+    TOUCH_PAD_SEL2 = BIT(2),
+    TOUCH_PAD_SEL3 = BIT(3),
+    TOUCH_PAD_SEL4 = BIT(4),
+    TOUCH_PAD_SEL5 = BIT(5),
+    TOUCH_PAD_SEL6 = BIT(6),
+    TOUCH_PAD_SEL7 = BIT(7),
+    TOUCH_PAD_SEL8 = BIT(8),
+    TOUCH_PAD_SEL9 = BIT(9),
+} esp_touch_pad_sel_t;
+
+/**
+ * @brief   The Touch peripheral configuration
+ */
+typedef struct {
+    int touch_mask;             /*!< Touch pad mask using for this Touch peripheral, ex: TOUCH_PAD_SEL0 | TOUCH_PAD_SEL1  */
+    int tap_threshold_percent;  /*!< Tap threshold percent, Tap event will be determined if the percentage value is less than the non-touch value */
+    int long_tap_time_ms;       /*!< Long tap duration in milliseconds, default is 2000ms, PERIPH_TOUCH_LONG_TAP will be occurred if TAP and time hold longer than this value */
+} periph_touch_cfg_t;
+
+/**
+ * @brief      Peripheral touch event id
+ */
+typedef enum {
+    PERIPH_TOUCH_UNCHANGE = 0,  /*!< No event */
+    PERIPH_TOUCH_TAP,           /*!< When touch pad is tapped */
+    PERIPH_TOUCH_RELEASE,       /*!< When touch pad is released after tap */
+    PERIPH_TOUCH_LONG_TAP,      /*!< When touch pad is tapped and held after `long_tap_time_ms` time */
+    PERIPH_TOUCH_LONG_RELEASE,  /*!< When touch pad is released after long tap */
+} periph_touch_event_id_t;
+
+
+/**
+ * @brief      Create the touch peripheral handle for esp_peripherals
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      config  The configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_touch_init(periph_touch_cfg_t* config);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/include/periph_wifi.h b/components/esp_peripherals/include/periph_wifi.h
index da4d0242..a9273e43 100644
--- a/components/esp_peripherals/include/periph_wifi.h
+++ b/components/esp_peripherals/include/periph_wifi.h
@@ -1,161 +1,161 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _DEV_WIFI_H_
-#define _DEV_WIFI_H_
-
-#include "esp_wifi_types.h"
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      Peripheral Wi-Fi event id
- */
-typedef enum {
-    PERIPH_WIFI_UNCHANGE = 0,
-    PERIPH_WIFI_CONNECTING,
-    PERIPH_WIFI_CONNECTED,
-    PERIPH_WIFI_DISCONNECTED,
-    PERIPH_WIFI_SETTING,
-    PERIPH_WIFI_CONFIG_DONE,
-    PERIPH_WIFI_CONFIG_ERROR,
-    PERIPH_WIFI_ERROR,
-} periph_wifi_state_t;
-
-/**
- * @brief   Wi-Fi setup mode type
- */
-typedef enum {
-    WIFI_CONFIG_ESPTOUCH,           /*!< Using smartconfig with ESPTOUCH protocol */
-    WIFI_CONFIG_AIRKISS,            /*!< Using smartconfig with AIRKISS protocol */
-    WIFI_CONFIG_ESPTOUCH_AIRKISS,   /*!< Using smartconfig with ESPTOUCH_AIRKISS protocol */
-    WIFI_CONFIG_WPS,                /*!< Using WPS (not support) */
-    WIFI_CONFIG_BLUEFI,             /*!< Using BLUEFI*/
-    WIFI_CONFIG_WEB,                /*!< Using HTTP Server (not support) */
-} periph_wifi_config_mode_t;
-
-/**
- * @brief   The WPA2 enterprise peripheral configuration
- */
-typedef struct {
-    bool          diasble_wpa2_e;       /*!< Disable wpa2 enterprise */
-    int           eap_method;           /*!< TLS: 0, PEAP: 1, TTLS: 2 */
-    char          *ca_pem_start;        /*!< binary wpa2 ca pem start */
-    char          *ca_pem_end;          /*!< binary wpa2 ca pem end */
-    char          *wpa2_e_cert_start;   /*!< binary wpa2 cert start */
-    char          *wpa2_e_cert_end;     /*!< binary wpa2 cert end */
-    char          *wpa2_e_key_start;    /*!< binary wpa2 key start */
-    char          *wpa2_e_key_end;      /*!< binary wpa2 key end */
-    const char    *eap_id;              /*!< Identity in phase 1 of EAP procedure */
-    const char    *eap_username;        /*!< Username for EAP method (PEAP and TTLS)  */    
-    const char    *eap_password;        /*!< Password for EAP method (PEAP and TTLS) */
-} periph_wpa2_enterprise_cfg_t;
-
-/**
- * @brief The Wi-Fi peripheral configuration
- */
-typedef struct {
-    bool                              disable_auto_reconnect;   /*!< Disable Wi-Fi auto reconnect */
-    int                               reconnect_timeout_ms;     /*!< The reconnect timeout after disconnected from Wi-Fi network */
-    wifi_config_t                     wifi_config;              /*!< Wifi configure */
-    periph_wpa2_enterprise_cfg_t      wpa2_e_cfg;               /*!< wpa2 enterprise config */
-} periph_wifi_cfg_t;
-
-/**
- * @brief      Create the wifi peripheral handle for esp_peripherals
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      config  The configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_wifi_init(periph_wifi_cfg_t* config);
-
-/**
- * @brief      This function will block current thread (in `tick_to_wait` tick) and wait until ESP32 connected to the Wi-Fi network, and got ip
- *
- * @param[in]  periph        The periph
- * @param[in]  tick_to_wait  The tick to wait
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_wifi_wait_for_connected(esp_periph_handle_t periph, TickType_t tick_to_wait);
-
-/**
- * @brief      Check the Wi-Fi connection status
- *
- * @param[in]  periph  The periph
- *
- * @return     Wi-Fi network status
- */
-periph_wifi_state_t periph_wifi_is_connected(esp_periph_handle_t periph);
-
-/**
- * @brief      Set Wi-Fi listen interval for ESP32 station to receive beacon
- *
- * @param[in]  periph  The wifi periph
- * @param[in]  interval  listen interval. units: AP beacon intervals(see BcnInt, default: 100ms)
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t esp_wifi_set_listen_interval(esp_periph_handle_t periph, int interval);
-
-/**
- * @brief      Start Wi-Fi network setup in `mode`
- *
- * @param[in]  periph   The periph
- * @param[in]  mode     The mode
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_wifi_config_start(esp_periph_handle_t periph, periph_wifi_config_mode_t mode);
-
-/**
- * @brief      Wait for Wi-Fi setup done
- * @param[in]  periph        The periph
- * @param[in]  tick_to_wait  The tick to wait
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_wifi_config_wait_done(esp_periph_handle_t periph, TickType_t tick_to_wait);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _DEV_WIFI_H_
+#define _DEV_WIFI_H_
+
+#include "esp_wifi_types.h"
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      Peripheral Wi-Fi event id
+ */
+typedef enum {
+    PERIPH_WIFI_UNCHANGE = 0,
+    PERIPH_WIFI_CONNECTING,
+    PERIPH_WIFI_CONNECTED,
+    PERIPH_WIFI_DISCONNECTED,
+    PERIPH_WIFI_SETTING,
+    PERIPH_WIFI_CONFIG_DONE,
+    PERIPH_WIFI_CONFIG_ERROR,
+    PERIPH_WIFI_ERROR,
+} periph_wifi_state_t;
+
+/**
+ * @brief   Wi-Fi setup mode type
+ */
+typedef enum {
+    WIFI_CONFIG_ESPTOUCH,           /*!< Using smartconfig with ESPTOUCH protocol */
+    WIFI_CONFIG_AIRKISS,            /*!< Using smartconfig with AIRKISS protocol */
+    WIFI_CONFIG_ESPTOUCH_AIRKISS,   /*!< Using smartconfig with ESPTOUCH_AIRKISS protocol */
+    WIFI_CONFIG_WPS,                /*!< Using WPS (not support) */
+    WIFI_CONFIG_BLUEFI,             /*!< Using BLUEFI*/
+    WIFI_CONFIG_WEB,                /*!< Using HTTP Server (not support) */
+} periph_wifi_config_mode_t;
+
+/**
+ * @brief   The WPA2 enterprise peripheral configuration
+ */
+typedef struct {
+    bool          diasble_wpa2_e;       /*!< Disable wpa2 enterprise */
+    int           eap_method;           /*!< TLS: 0, PEAP: 1, TTLS: 2 */
+    char          *ca_pem_start;        /*!< binary wpa2 ca pem start */
+    char          *ca_pem_end;          /*!< binary wpa2 ca pem end */
+    char          *wpa2_e_cert_start;   /*!< binary wpa2 cert start */
+    char          *wpa2_e_cert_end;     /*!< binary wpa2 cert end */
+    char          *wpa2_e_key_start;    /*!< binary wpa2 key start */
+    char          *wpa2_e_key_end;      /*!< binary wpa2 key end */
+    const char    *eap_id;              /*!< Identity in phase 1 of EAP procedure */
+    const char    *eap_username;        /*!< Username for EAP method (PEAP and TTLS)  */    
+    const char    *eap_password;        /*!< Password for EAP method (PEAP and TTLS) */
+} periph_wpa2_enterprise_cfg_t;
+
+/**
+ * @brief The Wi-Fi peripheral configuration
+ */
+typedef struct {
+    bool                              disable_auto_reconnect;   /*!< Disable Wi-Fi auto reconnect */
+    int                               reconnect_timeout_ms;     /*!< The reconnect timeout after disconnected from Wi-Fi network */
+    wifi_config_t                     wifi_config;              /*!< Wifi configure */
+    periph_wpa2_enterprise_cfg_t      wpa2_e_cfg;               /*!< wpa2 enterprise config */
+} periph_wifi_cfg_t;
+
+/**
+ * @brief      Create the wifi peripheral handle for esp_peripherals
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      config  The configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_wifi_init(periph_wifi_cfg_t* config);
+
+/**
+ * @brief      This function will block current thread (in `tick_to_wait` tick) and wait until ESP32 connected to the Wi-Fi network, and got ip
+ *
+ * @param[in]  periph        The periph
+ * @param[in]  tick_to_wait  The tick to wait
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_wifi_wait_for_connected(esp_periph_handle_t periph, TickType_t tick_to_wait);
+
+/**
+ * @brief      Check the Wi-Fi connection status
+ *
+ * @param[in]  periph  The periph
+ *
+ * @return     Wi-Fi network status
+ */
+periph_wifi_state_t periph_wifi_is_connected(esp_periph_handle_t periph);
+
+/**
+ * @brief      Set Wi-Fi listen interval for ESP32 station to receive beacon
+ *
+ * @param[in]  periph  The wifi periph
+ * @param[in]  interval  listen interval. units: AP beacon intervals(see BcnInt, default: 100ms)
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t esp_wifi_set_listen_interval(esp_periph_handle_t periph, int interval);
+
+/**
+ * @brief      Start Wi-Fi network setup in `mode`
+ *
+ * @param[in]  periph   The periph
+ * @param[in]  mode     The mode
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_wifi_config_start(esp_periph_handle_t periph, periph_wifi_config_mode_t mode);
+
+/**
+ * @brief      Wait for Wi-Fi setup done
+ * @param[in]  periph        The periph
+ * @param[in]  tick_to_wait  The tick to wait
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_wifi_config_wait_done(esp_periph_handle_t periph, TickType_t tick_to_wait);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/components/esp_peripherals/include/periph_ws2812.h b/components/esp_peripherals/include/periph_ws2812.h
old mode 100755
new mode 100644
index 2ede64d2..896bbfff
--- a/components/esp_peripherals/include/periph_ws2812.h
+++ b/components/esp_peripherals/include/periph_ws2812.h
@@ -1,118 +1,118 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#ifndef _PERIPH_WS2812_DRIVER_H
-#define _PERIPH_WS2812_DRIVER_H
-
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   The RGB peripheral value
- */
-typedef uint32_t periph_rgb_value;
-
-#define make_rgb_value(x, y, z)  (((int)(z) << 16) + ((int)(y) << 8 )+ (x))
-
-#define LED2812_COLOR_BLACK   make_rgb_value(0,   0,  0)
-#define LED2812_COLOR_BLUE    make_rgb_value(0,   0,   255)
-#define LED2812_COLOR_GREEN   make_rgb_value(0,   255, 0)
-#define LED2812_COLOR_CYAN    make_rgb_value(0,   255, 255)
-#define LED2812_COLOR_RED     make_rgb_value(255, 0,   0)
-#define LED2812_COLOR_PURPLE  make_rgb_value(255, 0,   255)
-#define LED2812_COLOR_YELLOW  make_rgb_value(255, 255, 0)
-#define LED2812_COLOR_WHITE   make_rgb_value(255, 255, 255)
-#define LED2812_COLOR_ORANGE  make_rgb_value(255, 165, 0)
-
-/**
- * @brief   The ws2812 peripheral configuration
- */
-typedef struct {
-    int      gpio_num;     /*!< The GPIO number of ws2812*/
-    int      led_num;      /*!< The number of ws2812 */
-}periph_ws2812_cfg_t;
-
-/**
- * @brief   The periph ws2812 mode
- */
-typedef enum {
-    PERIPH_WS2812_BLINK,
-    PERIPH_WS2812_FADE,
-    PERIPH_WS2812_ONE,
-} periph_ws2812_mode_t;
-
-/**
- * @brief   The periph ws2812 control config
- */
-typedef struct periph_ws2812_ctrl_cfg {
-    periph_rgb_value         color;          /*!< The RGB  value */
-    uint32_t                 time_on_ms;     /*!< The time on milliseconds, suggest min is 100 ms */
-    uint32_t                 time_off_ms;    /*!< The time off milliseconds, suggest min is 100 ms */
-    uint32_t                 loop;           /*!< The times offloop */
-    periph_ws2812_mode_t     mode;           /*!< ws2812 mode (setting color, blink or fade) */
-} periph_ws2812_ctrl_cfg_t;
-
-/**
- * @brief      Create the ws2812 peripheral handle for esp_peripherals
- *
- * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
- *
- * @param      config  The configuration
- *
- * @return     The esp peripheral handle
- */
-esp_periph_handle_t periph_ws2812_init(periph_ws2812_cfg_t *config);
-
-/**
- * @brief      Control ws2812 Peripheral
- *
- * @param[in]  periph            The ws2812 periph
- * @param[in]  control_cfg       The ws2812 color config
- * @param[in]  ctx               The ctx
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_ws2812_control(esp_periph_handle_t periph, periph_ws2812_ctrl_cfg_t *control_cfg, void *ctx);
-
-/**
- * @brief      Stop ws2812
- *
- * @param[in]  periph    The periph
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t periph_ws2812_stop(esp_periph_handle_t periph);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#ifndef _PERIPH_WS2812_DRIVER_H
+#define _PERIPH_WS2812_DRIVER_H
+
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   The RGB peripheral value
+ */
+typedef uint32_t periph_rgb_value;
+
+#define make_rgb_value(x, y, z)  (((int)(z) << 16) + ((int)(y) << 8 )+ (x))
+
+#define LED2812_COLOR_BLACK   make_rgb_value(0,   0,  0)
+#define LED2812_COLOR_BLUE    make_rgb_value(0,   0,   255)
+#define LED2812_COLOR_GREEN   make_rgb_value(0,   255, 0)
+#define LED2812_COLOR_CYAN    make_rgb_value(0,   255, 255)
+#define LED2812_COLOR_RED     make_rgb_value(255, 0,   0)
+#define LED2812_COLOR_PURPLE  make_rgb_value(255, 0,   255)
+#define LED2812_COLOR_YELLOW  make_rgb_value(255, 255, 0)
+#define LED2812_COLOR_WHITE   make_rgb_value(255, 255, 255)
+#define LED2812_COLOR_ORANGE  make_rgb_value(255, 165, 0)
+
+/**
+ * @brief   The ws2812 peripheral configuration
+ */
+typedef struct {
+    int      gpio_num;     /*!< The GPIO number of ws2812*/
+    int      led_num;      /*!< The number of ws2812 */
+}periph_ws2812_cfg_t;
+
+/**
+ * @brief   The periph ws2812 mode
+ */
+typedef enum {
+    PERIPH_WS2812_BLINK,
+    PERIPH_WS2812_FADE,
+    PERIPH_WS2812_ONE,
+} periph_ws2812_mode_t;
+
+/**
+ * @brief   The periph ws2812 control config
+ */
+typedef struct periph_ws2812_ctrl_cfg {
+    periph_rgb_value         color;          /*!< The RGB  value */
+    uint32_t                 time_on_ms;     /*!< The time on milliseconds, suggest min is 100 ms */
+    uint32_t                 time_off_ms;    /*!< The time off milliseconds, suggest min is 100 ms */
+    uint32_t                 loop;           /*!< The times offloop */
+    periph_ws2812_mode_t     mode;           /*!< ws2812 mode (setting color, blink or fade) */
+} periph_ws2812_ctrl_cfg_t;
+
+/**
+ * @brief      Create the ws2812 peripheral handle for esp_peripherals
+ *
+ * @note       The handle was created by this function automatically destroy when `esp_periph_destroy` is called
+ *
+ * @param      config  The configuration
+ *
+ * @return     The esp peripheral handle
+ */
+esp_periph_handle_t periph_ws2812_init(periph_ws2812_cfg_t *config);
+
+/**
+ * @brief      Control ws2812 Peripheral
+ *
+ * @param[in]  periph            The ws2812 periph
+ * @param[in]  control_cfg       The ws2812 color config
+ * @param[in]  ctx               The ctx
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_ws2812_control(esp_periph_handle_t periph, periph_ws2812_ctrl_cfg_t *control_cfg, void *ctx);
+
+/**
+ * @brief      Stop ws2812
+ *
+ * @param[in]  periph    The periph
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t periph_ws2812_stop(esp_periph_handle_t periph);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.c b/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.c
index 97b80941..438ce590 100644
--- a/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.c
+++ b/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.c
@@ -1,325 +1,325 @@
-/*
-  * ESPRESSIF MIT License
-  *
-  * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
-  *
-  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
-  * it is free of charge, to any person obtaining a copy of this software and associated
-  * documentation files (the "Software"), to deal in the Software without restriction, including
-  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-  * to do so, subject to the following conditions:
-  *
-  * The above copyright notice and this permission notice shall be included in all copies or
-  * substantial portions of the Software.
-  *
-  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-  *
-  */
-
-#include <stdio.h>
-#include <string.h>
-#include "driver/i2c.h"
-#include "esp_log.h"
-#include "IS31FL3216.h"
-#include "i2c_bus.h"
-#include "audio_mem.h"
-
-#define IS31FL3216_WRITE_BIT        0x00
-
-#define I2C_MASTER_SCL_IO           23        /*!< gpio number for I2C master clock */
-#define I2C_MASTER_SDA_IO           18        /*!< gpio number for I2C master data  */
-#define I2C_MASTER_NUM          I2C_NUM_0     /*!< I2C port number for master dev */
-#define I2C_MASTER_FREQ_HZ          100000    /*!< I2C master clock frequency */
-
-#define IS31FL3216_ADDRESS          0xE8      /*!< I2C Addr*/
-
-#define IS31_ERROR_CHECK(con) if(!(con)) {ESP_LOGE(TAG,"err line: %d", __LINE__);}
-#define IS31_PARAM_CHECK(con) if(!(con)) {ESP_LOGE(TAG,"Parameter error: %d", __LINE__);}
-#define IS31_CHECK_I2C_RES(res) if(ret == ESP_FAIL) {ESP_LOGE(TAG, "Is31fl3216[%s]: FAIL\n", __FUNCTION__);} \
-                                else if(ret == ESP_ERR_TIMEOUT) {ESP_LOGE(TAG, "Is31fl3216[%s]: TIMEOUT\n", __FUNCTION__);}
-typedef struct {
-    i2c_bus_handle_t bus;
-    uint16_t addr;
-} is31fl3216_dev_t;
-
-uint8_t Is31Value[10] = {0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-static char *TAG = "IS31";
-
-/**
- * @brief set software shutdown mode
- */
-static esp_err_t is31fl3216_write_reg(is31fl3216_handle_t handle, is31fl3216_reg_t regAddr, uint8_t *data, uint8_t data_num)
-{
-    IS31_PARAM_CHECK(NULL != data);
-    is31fl3216_dev_t *dev = (is31fl3216_dev_t *) handle;
-    esp_err_t ret = i2c_bus_write_bytes(dev->bus, IS31FL3216_ADDRESS | IS31FL3216_WRITE_BIT, (uint8_t *)&regAddr, 1, data, data_num);
-    return ret;
-}
-
-/**
- * @brief change channels PWM duty cycle data register
- */
-static esp_err_t is31fl3218S_channel_duty_by_bits(is31fl3216_handle_t handle, uint32_t by_bits, uint8_t duty)
-{
-    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; i++) {
-        if ((by_bits >> i) & 0x1) {
-            esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_PWM_16 + (IS31FL3216_CH_NUM_MAX - i - 1), &duty, 1);
-            if (ret == ESP_OK) {
-                //PASS
-            } else {
-                IS31_CHECK_I2C_RES(ret);
-                return ret;
-            }
-        }
-    }
-    return ESP_OK;
-}
-
-/**
- * @brief Load PWM Register and LED Control Registers data
- */
-esp_err_t is31fl3216_update_reg(is31fl3216_handle_t handle)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    uint8_t m = 0;
-    return is31fl3216_write_reg(handle, IS31FL3216_REG_UPDATE, &m, 1);
-}
-
-/**
- * @brief set software shutdown mode
- */
-esp_err_t is31fl3216_power(is31fl3216_handle_t handle, is31fl3216_pwr_t mode)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    if (IS31FL3216_PWR_SHUTDOWN == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 7))) | (1 << 7);
-    } else if (IS31FL3216_PWR_NORMAL == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 7)));
-    } else {
-        return ESP_FAIL;
-    }
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CONFIG, (uint8_t *) &Is31Value[IS31FL3216_REG_CONFIG], 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_work_mode_set(is31fl3216_handle_t handle, is31fl3216_work_mode_t mode)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    if (IS31FL3216_MODE_PWM == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(3 << 5)));
-    } else if (IS31FL3216_MODE_AUTO_FRAME == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(3 << 5))) | (1 << 5);
-    } else if (IS31FL3216_MODE_FRAME == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(3 << 5))) | (2 << 5);
-    } else {
-        return ESP_FAIL;
-    }
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CONFIG, (uint8_t *) &Is31Value[IS31FL3216_REG_CONFIG], 1);
-    return ret;
-}
-
-/**
- * @brief change channels PWM duty cycle data register
- */
-esp_err_t is31fl3216_ch_duty_set(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits, uint8_t duty)
-{
-    esp_err_t ret = ESP_OK;
-    IS31_PARAM_CHECK(NULL != handle);
-    ret = is31fl3218S_channel_duty_by_bits(handle, ch_bits, duty);
-    if (ret != ESP_OK) {
-        IS31_CHECK_I2C_RES(ret);
-        return ret;
-    }
-    ret = is31fl3216_update_reg(handle);
-    if (ret != ESP_OK) {
-        IS31_CHECK_I2C_RES(ret);
-        return ret;
-    }
-    return ESP_OK;
-}
-
-/**
- * @brief change channels PWM duty cycle data register
- */
-esp_err_t is31fl3216_ch_enable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits)
-{
-    esp_err_t ret = ESP_OK;
-    IS31_PARAM_CHECK(NULL != handle);
-    uint16_t value = 0;
-    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; ++i) {
-        if ((ch_bits >> i) & 0x01) {
-            value |= (1 << i);
-        }
-    }
-    Is31Value[IS31FL3216_REG_LED_CTRL_H] |= value >> 8;
-    Is31Value[IS31FL3216_REG_LED_CTRL_L] |= value;
-    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_CTRL_H, &Is31Value[IS31FL3216_REG_LED_CTRL_H], 2);
-    return ret;
-}
-
-/**
- * @brief change channels PWM duty cycle data register
- */
-esp_err_t is31fl3216_ch_disable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits)
-{
-    esp_err_t ret = ESP_OK;
-    IS31_PARAM_CHECK(NULL != handle);
-    uint16_t value = ((uint16_t)Is31Value[IS31FL3216_REG_LED_CTRL_H]) << 8;
-    value |= Is31Value[IS31FL3216_REG_LED_CTRL_L];
-    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; ++i) {
-        if ((ch_bits >> i) & 0x01) {
-            value = value & (~(1 << i));
-        }
-    }
-    Is31Value[IS31FL3216_REG_LED_CTRL_H] = value >> 8;
-    Is31Value[IS31FL3216_REG_LED_CTRL_L] = value;
-    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_CTRL_H, &Is31Value[IS31FL3216_REG_LED_CTRL_H], 2);
-    return ret;
-}
-
-esp_err_t is31fl3216_cur_mode_set(is31fl3216_handle_t handle, is31fl3216_cur_mode_t mode)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    if (IS31FL3216_CUR_MODE_REXT == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 4)));
-    } else if (IS31FL3216_CUR_MODE_AUDIO == mode) {
-        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 4))) | (1 << 4);
-    } else {
-        return ESP_FAIL;
-    }
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CONFIG, (uint8_t *) &Is31Value[IS31FL3216_REG_CONFIG], 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_cur_value_set(is31fl3216_handle_t handle, is31fl3216_cur_value_t value)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(7 << 4))) | value << 4;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_ags_value_set(is31fl3216_handle_t handle, is31fl3216_ags_value_t value)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(7 << 0))) | value << 0;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_agc_cfg(is31fl3216_handle_t handle, uint32_t en)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(1 << 3))) | en << 3;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_cascade_mode_set(is31fl3216_handle_t handle, is31fl3216_cascade_mode_t mode)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(1 << 7))) | mode << 7;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_sample_rate_set(is31fl3216_handle_t handle, uint32_t value)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    uint8_t dat = value;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_ADC_RATE, &dat, 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_frame_time_set(is31fl3216_handle_t handle, is31fl3216_delay_time_t time)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    uint8_t dat = time << 5;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_FRAME_DELAY, &dat, 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_first_frame_set(is31fl3216_handle_t handle, uint32_t frame)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    uint8_t dat = frame << 5;
-    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_FRAME_START, &dat, 1);
-    return ret;
-}
-
-esp_err_t is31fl3216_frame_value_set(is31fl3216_handle_t handle, uint32_t num, uint8_t *data, uint32_t len)
-{
-    IS31_PARAM_CHECK(NULL != handle);
-    IS31_PARAM_CHECK(NULL != data);
-    uint8_t startAddr = IS31FL3216_REG_FRAME1_CTRL + (num - 1) * 18;
-    esp_err_t ret = is31fl3216_write_reg(handle, startAddr, data, len);
-    return ret;
-}
-
-esp_err_t is31fl3216_reset(is31fl3216_handle_t handle)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t dat = 0x00;
-    IS31_PARAM_CHECK(NULL != handle);
-    ret = is31fl3216_power(handle, IS31FL3216_PWR_NORMAL);
-    if (ret) {
-        return ret;
-    }
-    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; ++i) {
-        ret = is31fl3216_ch_duty_set(handle, 1 << i, 0);
-        if (ret) {
-            return ret;
-        }
-    }
-    ret = is31fl3216_ch_enable(handle, IS31FL3216_CH_ALL);
-    if (ret) {
-        return ret;
-    }
-
-    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &dat, 1);
-    if (ret) {
-        return ret;
-    }
-    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CH_CONFIG, &dat, 1);
-    return ret;
-}
-
-/**
- * @brief i2c master initialization
- */
-
-is31fl3216_handle_t is31fl3216_init(void)
-{
-    i2c_config_t conf = {0};
-    conf.mode = I2C_MODE_MASTER;
-    conf.sda_io_num = I2C_MASTER_SDA_IO;
-    conf.sda_pullup_en = GPIO_PULLUP_ENABLE;
-    conf.scl_io_num = I2C_MASTER_SCL_IO;
-    conf.scl_pullup_en = GPIO_PULLUP_ENABLE;
-    conf.master.clk_speed = I2C_MASTER_FREQ_HZ;
-    is31fl3216_dev_t *led = (is31fl3216_dev_t *) audio_calloc(1, sizeof(is31fl3216_dev_t));
-    led->bus = i2c_bus_create(I2C_MASTER_NUM, &conf);
-    led->addr = IS31FL3216_ADDRESS;
-    IS31_ERROR_CHECK(ESP_OK == is31fl3216_power(led, IS31FL3216_PWR_NORMAL));
-    IS31_ERROR_CHECK(ESP_OK == is31fl3216_cur_mode_set(led, IS31FL3216_CUR_MODE_REXT));
-    IS31_ERROR_CHECK(ESP_OK == is31fl3216_cur_value_set(led, IS31FL3216_CUR_0_75));
-    return (is31fl3216_handle_t) led;
-}
-
-esp_err_t is31fl3216_deinit(is31fl3216_handle_t handle)
-{
-    is31fl3216_dev_t *dev = (is31fl3216_dev_t *) handle;
-    if (dev->bus) {
-        i2c_bus_delete(dev->bus);
-        dev->bus = NULL;
-    }
-    audio_free(dev);
-    return ESP_OK;
-}
+/*
+  * ESPRESSIF MIT License
+  *
+  * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+  *
+  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
+  * it is free of charge, to any person obtaining a copy of this software and associated
+  * documentation files (the "Software"), to deal in the Software without restriction, including
+  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+  * to do so, subject to the following conditions:
+  *
+  * The above copyright notice and this permission notice shall be included in all copies or
+  * substantial portions of the Software.
+  *
+  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+  *
+  */
+
+#include <stdio.h>
+#include <string.h>
+#include "driver/i2c.h"
+#include "esp_log.h"
+#include "IS31FL3216.h"
+#include "i2c_bus.h"
+#include "audio_mem.h"
+
+#define IS31FL3216_WRITE_BIT        0x00
+
+#define I2C_MASTER_SCL_IO           23        /*!< gpio number for I2C master clock */
+#define I2C_MASTER_SDA_IO           18        /*!< gpio number for I2C master data  */
+#define I2C_MASTER_NUM          I2C_NUM_0     /*!< I2C port number for master dev */
+#define I2C_MASTER_FREQ_HZ          100000    /*!< I2C master clock frequency */
+
+#define IS31FL3216_ADDRESS          0xE8      /*!< I2C Addr*/
+
+#define IS31_ERROR_CHECK(con) if(!(con)) {ESP_LOGE(TAG,"err line: %d", __LINE__);}
+#define IS31_PARAM_CHECK(con) if(!(con)) {ESP_LOGE(TAG,"Parameter error: %d", __LINE__);}
+#define IS31_CHECK_I2C_RES(res) if(ret == ESP_FAIL) {ESP_LOGE(TAG, "Is31fl3216[%s]: FAIL\n", __FUNCTION__);} \
+                                else if(ret == ESP_ERR_TIMEOUT) {ESP_LOGE(TAG, "Is31fl3216[%s]: TIMEOUT\n", __FUNCTION__);}
+typedef struct {
+    i2c_bus_handle_t bus;
+    uint16_t addr;
+} is31fl3216_dev_t;
+
+uint8_t Is31Value[10] = {0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+static char *TAG = "IS31";
+
+/**
+ * @brief set software shutdown mode
+ */
+static esp_err_t is31fl3216_write_reg(is31fl3216_handle_t handle, is31fl3216_reg_t regAddr, uint8_t *data, uint8_t data_num)
+{
+    IS31_PARAM_CHECK(NULL != data);
+    is31fl3216_dev_t *dev = (is31fl3216_dev_t *) handle;
+    esp_err_t ret = i2c_bus_write_bytes(dev->bus, IS31FL3216_ADDRESS | IS31FL3216_WRITE_BIT, (uint8_t *)&regAddr, 1, data, data_num);
+    return ret;
+}
+
+/**
+ * @brief change channels PWM duty cycle data register
+ */
+static esp_err_t is31fl3218S_channel_duty_by_bits(is31fl3216_handle_t handle, uint32_t by_bits, uint8_t duty)
+{
+    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; i++) {
+        if ((by_bits >> i) & 0x1) {
+            esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_PWM_16 + (IS31FL3216_CH_NUM_MAX - i - 1), &duty, 1);
+            if (ret == ESP_OK) {
+                //PASS
+            } else {
+                IS31_CHECK_I2C_RES(ret);
+                return ret;
+            }
+        }
+    }
+    return ESP_OK;
+}
+
+/**
+ * @brief Load PWM Register and LED Control Registers data
+ */
+esp_err_t is31fl3216_update_reg(is31fl3216_handle_t handle)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    uint8_t m = 0;
+    return is31fl3216_write_reg(handle, IS31FL3216_REG_UPDATE, &m, 1);
+}
+
+/**
+ * @brief set software shutdown mode
+ */
+esp_err_t is31fl3216_power(is31fl3216_handle_t handle, is31fl3216_pwr_t mode)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    if (IS31FL3216_PWR_SHUTDOWN == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 7))) | (1 << 7);
+    } else if (IS31FL3216_PWR_NORMAL == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 7)));
+    } else {
+        return ESP_FAIL;
+    }
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CONFIG, (uint8_t *) &Is31Value[IS31FL3216_REG_CONFIG], 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_work_mode_set(is31fl3216_handle_t handle, is31fl3216_work_mode_t mode)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    if (IS31FL3216_MODE_PWM == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(3 << 5)));
+    } else if (IS31FL3216_MODE_AUTO_FRAME == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(3 << 5))) | (1 << 5);
+    } else if (IS31FL3216_MODE_FRAME == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(3 << 5))) | (2 << 5);
+    } else {
+        return ESP_FAIL;
+    }
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CONFIG, (uint8_t *) &Is31Value[IS31FL3216_REG_CONFIG], 1);
+    return ret;
+}
+
+/**
+ * @brief change channels PWM duty cycle data register
+ */
+esp_err_t is31fl3216_ch_duty_set(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits, uint8_t duty)
+{
+    esp_err_t ret = ESP_OK;
+    IS31_PARAM_CHECK(NULL != handle);
+    ret = is31fl3218S_channel_duty_by_bits(handle, ch_bits, duty);
+    if (ret != ESP_OK) {
+        IS31_CHECK_I2C_RES(ret);
+        return ret;
+    }
+    ret = is31fl3216_update_reg(handle);
+    if (ret != ESP_OK) {
+        IS31_CHECK_I2C_RES(ret);
+        return ret;
+    }
+    return ESP_OK;
+}
+
+/**
+ * @brief change channels PWM duty cycle data register
+ */
+esp_err_t is31fl3216_ch_enable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits)
+{
+    esp_err_t ret = ESP_OK;
+    IS31_PARAM_CHECK(NULL != handle);
+    uint16_t value = 0;
+    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; ++i) {
+        if ((ch_bits >> i) & 0x01) {
+            value |= (1 << i);
+        }
+    }
+    Is31Value[IS31FL3216_REG_LED_CTRL_H] |= value >> 8;
+    Is31Value[IS31FL3216_REG_LED_CTRL_L] |= value;
+    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_CTRL_H, &Is31Value[IS31FL3216_REG_LED_CTRL_H], 2);
+    return ret;
+}
+
+/**
+ * @brief change channels PWM duty cycle data register
+ */
+esp_err_t is31fl3216_ch_disable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits)
+{
+    esp_err_t ret = ESP_OK;
+    IS31_PARAM_CHECK(NULL != handle);
+    uint16_t value = ((uint16_t)Is31Value[IS31FL3216_REG_LED_CTRL_H]) << 8;
+    value |= Is31Value[IS31FL3216_REG_LED_CTRL_L];
+    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; ++i) {
+        if ((ch_bits >> i) & 0x01) {
+            value = value & (~(1 << i));
+        }
+    }
+    Is31Value[IS31FL3216_REG_LED_CTRL_H] = value >> 8;
+    Is31Value[IS31FL3216_REG_LED_CTRL_L] = value;
+    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_CTRL_H, &Is31Value[IS31FL3216_REG_LED_CTRL_H], 2);
+    return ret;
+}
+
+esp_err_t is31fl3216_cur_mode_set(is31fl3216_handle_t handle, is31fl3216_cur_mode_t mode)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    if (IS31FL3216_CUR_MODE_REXT == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 4)));
+    } else if (IS31FL3216_CUR_MODE_AUDIO == mode) {
+        Is31Value[IS31FL3216_REG_CONFIG] = (Is31Value[IS31FL3216_REG_CONFIG] & (~(1 << 4))) | (1 << 4);
+    } else {
+        return ESP_FAIL;
+    }
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CONFIG, (uint8_t *) &Is31Value[IS31FL3216_REG_CONFIG], 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_cur_value_set(is31fl3216_handle_t handle, is31fl3216_cur_value_t value)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(7 << 4))) | value << 4;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_ags_value_set(is31fl3216_handle_t handle, is31fl3216_ags_value_t value)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(7 << 0))) | value << 0;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_agc_cfg(is31fl3216_handle_t handle, uint32_t en)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(1 << 3))) | en << 3;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_cascade_mode_set(is31fl3216_handle_t handle, is31fl3216_cascade_mode_t mode)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    Is31Value[IS31FL3216_REG_LED_EFFECT] = (Is31Value[IS31FL3216_REG_LED_EFFECT] & (~(1 << 7))) | mode << 7;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &Is31Value[IS31FL3216_REG_LED_EFFECT], 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_sample_rate_set(is31fl3216_handle_t handle, uint32_t value)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    uint8_t dat = value;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_ADC_RATE, &dat, 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_frame_time_set(is31fl3216_handle_t handle, is31fl3216_delay_time_t time)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    uint8_t dat = time << 5;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_FRAME_DELAY, &dat, 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_first_frame_set(is31fl3216_handle_t handle, uint32_t frame)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    uint8_t dat = frame << 5;
+    esp_err_t ret = is31fl3216_write_reg(handle, IS31FL3216_REG_FRAME_START, &dat, 1);
+    return ret;
+}
+
+esp_err_t is31fl3216_frame_value_set(is31fl3216_handle_t handle, uint32_t num, uint8_t *data, uint32_t len)
+{
+    IS31_PARAM_CHECK(NULL != handle);
+    IS31_PARAM_CHECK(NULL != data);
+    uint8_t startAddr = IS31FL3216_REG_FRAME1_CTRL + (num - 1) * 18;
+    esp_err_t ret = is31fl3216_write_reg(handle, startAddr, data, len);
+    return ret;
+}
+
+esp_err_t is31fl3216_reset(is31fl3216_handle_t handle)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t dat = 0x00;
+    IS31_PARAM_CHECK(NULL != handle);
+    ret = is31fl3216_power(handle, IS31FL3216_PWR_NORMAL);
+    if (ret) {
+        return ret;
+    }
+    for (int i = 0; i < IS31FL3216_CH_NUM_MAX; ++i) {
+        ret = is31fl3216_ch_duty_set(handle, 1 << i, 0);
+        if (ret) {
+            return ret;
+        }
+    }
+    ret = is31fl3216_ch_enable(handle, IS31FL3216_CH_ALL);
+    if (ret) {
+        return ret;
+    }
+
+    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_LED_EFFECT, &dat, 1);
+    if (ret) {
+        return ret;
+    }
+    ret = is31fl3216_write_reg(handle, IS31FL3216_REG_CH_CONFIG, &dat, 1);
+    return ret;
+}
+
+/**
+ * @brief i2c master initialization
+ */
+
+is31fl3216_handle_t is31fl3216_init(void)
+{
+    i2c_config_t conf = {0};
+    conf.mode = I2C_MODE_MASTER;
+    conf.sda_io_num = I2C_MASTER_SDA_IO;
+    conf.sda_pullup_en = GPIO_PULLUP_ENABLE;
+    conf.scl_io_num = I2C_MASTER_SCL_IO;
+    conf.scl_pullup_en = GPIO_PULLUP_ENABLE;
+    conf.master.clk_speed = I2C_MASTER_FREQ_HZ;
+    is31fl3216_dev_t *led = (is31fl3216_dev_t *) audio_calloc(1, sizeof(is31fl3216_dev_t));
+    led->bus = i2c_bus_create(I2C_MASTER_NUM, &conf);
+    led->addr = IS31FL3216_ADDRESS;
+    IS31_ERROR_CHECK(ESP_OK == is31fl3216_power(led, IS31FL3216_PWR_NORMAL));
+    IS31_ERROR_CHECK(ESP_OK == is31fl3216_cur_mode_set(led, IS31FL3216_CUR_MODE_REXT));
+    IS31_ERROR_CHECK(ESP_OK == is31fl3216_cur_value_set(led, IS31FL3216_CUR_0_75));
+    return (is31fl3216_handle_t) led;
+}
+
+esp_err_t is31fl3216_deinit(is31fl3216_handle_t handle)
+{
+    is31fl3216_dev_t *dev = (is31fl3216_dev_t *) handle;
+    if (dev->bus) {
+        i2c_bus_delete(dev->bus);
+        dev->bus = NULL;
+    }
+    audio_free(dev);
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.h b/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.h
index 100b04db..20957454 100644
--- a/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.h
+++ b/components/esp_peripherals/lib/IS31FL3216/IS31FL3216.h
@@ -1,395 +1,395 @@
-/*
-  * ESPRESSIF MIT License
-  *
-  * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
-  *
-  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
-  * it is free of charge, to any person obtaining a copy of this software and associated
-  * documentation files (the "Software"), to deal in the Software without restriction, including
-  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
-  * to do so, subject to the following conditions:
-  *
-  * The above copyright notice and this permission notice shall be included in all copies or
-  * substantial portions of the Software.
-  *
-  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-  *
-  */
-
-#ifndef _IOT_IS31FL3216_H_
-#define _IOT_IS31FL3216_H_
-
-#include "driver/i2c.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define IS31FL3216_CH_NUM_MAX 16
-#define IS31FL3216_DUTY_MAX   255
-
-typedef enum {
-    IS31FL3216_PWR_NORMAL = 0,            /**< Normal operation */
-    IS31FL3216_PWR_SHUTDOWN,              /**< Software shutdown mode */
-    IS31FL3216_PWR_MAX,
-} is31fl3216_pwr_t;
-
-typedef enum {
-    IS31FL3216_MODE_PWM = 0,              /**< PWM control mode operation*/
-    IS31FL3216_MODE_AUTO_FRAME,           /**< Auto frame play mode operation */
-    IS31FL3216_MODE_FRAME,                /**< Audio frame mode operation */
-    IS31FL3216_MODE_MAX,
-} is31fl3216_work_mode_t;
-
-typedef enum {
-    IS31FL3216_CUR_MODE_REXT = 0,         /**< Output current is set by register */
-    IS31FL3216_CUR_MODE_AUDIO,            /**< Output current is modulated by audio signal */
-    IS31FL3216_CUR_MODE_MAX,
-} is31fl3216_cur_mode_t;
-
-typedef enum {
-    IS31FL3216_CUR_1_00 = 0,              /**< Output Current Selection */
-    IS31FL3216_CUR_0_75,
-    IS31FL3216_CUR_0_50,
-    IS31FL3216_CUR_0_25,
-    IS31FL3216_CUR_2_00,
-    IS31FL3216_CUR_1_75,
-    IS31FL3216_CUR_1_50,
-    IS31FL3216_CUR_1_25,
-    IS31FL3216_CUR_MAX,
-} is31fl3216_cur_value_t;
-
-typedef enum {
-    IS31FL3216_CASCADE_MASTER = 0,       /**< Chip Cascade Mode */
-    IS31FL3216_CASCADE_SLAVE,
-} is31fl3216_cascade_mode_t;
-
-typedef enum {
-    IS31FL3216_AGS_0DB = 0,              /**< Audio Gain Selection */
-    IS31FL3216_AGS_3DB,
-    IS31FL3216_AGS_6DB,
-    IS31FL3216_AGS_9DB,
-    IS31FL3216_AGS_12DB,
-    IS31FL3216_AGS_15DB,
-    IS31FL3216_AGS_18DB,
-    IS31FL3216_AGS_21DB,
-    IS31FL3216_AGS_MAX,
-} is31fl3216_ags_value_t;
-
-typedef enum {
-    IS31FL3216_TIME_32MS = 0,            /**< Frame Delay Time */
-    IS31FL3216_TIME_64MS,
-    IS31FL3216_TIME_128MS,
-    IS31FL3216_TIME_256MS,
-    IS31FL3216_TIME_512MS,
-    IS31FL3216_TIME_1024MS,
-    IS31FL3216_TIME_2048MS,
-    IS31FL3216_TIME_4096MS,
-    IS31FL3216_TIME_MAX,
-} is31fl3216_delay_time_t;
-
-
-typedef enum {
-    IS31FL3216_REG_CONFIG      = 0x00,   /* Configuration register */
-    IS31FL3216_REG_LED_CTRL_H  = 0x01,   /* LED control register OUT9-OUT16 enable bit */
-    IS31FL3216_REG_LED_CTRL_L  = 0x02,   /* LED control register OUT1-OUT8 enable bit */
-    IS31FL3216_REG_LED_EFFECT  = 0x03,   /* Set the output current and the audio gain */
-    IS31FL3216_REG_CH_CONFIG   = 0x04,   /* Set the operating mode of OUT9~OUT16 */
-    IS31FL3216_REG_GPIO_CONFIG = 0x05,   /* Set the operating mode of OUT9~OUT16 as the GPIO port */
-    IS31FL3216_REG_OUTPUT      = 0x06,   /* Set the logic level of OUT9~OUT16 as the output port */
-    IS31FL3216_REG_INPUT_CTRL  = 0x07,   /* Set the interrupt function of OUT9~OUT16 */
-    IS31FL3216_REG_STATE       = 0x08,   /* Store the state of OUT9~OUT16 as the input port */
-    IS31FL3216_REG_ADC_RATE    = 0x09,   /* Set the ADC sample rate of the input signal */
-
-    IS31FL3216_REG_PWM_16      = 0x10,   /* Set the PWM duty cycle data */
-    IS31FL3216_REG_PWM_15,
-    IS31FL3216_REG_PWM_14,
-    IS31FL3216_REG_PWM_13,
-    IS31FL3216_REG_PWM_12,
-    IS31FL3216_REG_PWM_11,
-    IS31FL3216_REG_PWM_10,
-    IS31FL3216_REG_PWM_09,
-    IS31FL3216_REG_PWM_08,
-    IS31FL3216_REG_PWM_07,
-    IS31FL3216_REG_PWM_06,
-    IS31FL3216_REG_PWM_05,
-    IS31FL3216_REG_PWM_04,
-    IS31FL3216_REG_PWM_03,
-    IS31FL3216_REG_PWM_02,
-    IS31FL3216_REG_PWM_01,
-
-    IS31FL3216_REG_FRAME1_CTRL = 0x20,  /* Store the data of 8 frames */
-    IS31FL3216_REG_FRAME1_PWM  = 0x22,
-    IS31FL3216_REG_FRAME2_CTRL = 0x32,
-    IS31FL3216_REG_FRAME2_PWM  = 0x34,
-    IS31FL3216_REG_FRAME3_CTRL = 0x44,
-    IS31FL3216_REG_FRAME3_PWM  = 0x46,
-    IS31FL3216_REG_FRAME4_CTRL = 0x56,
-    IS31FL3216_REG_FRAME4_PWM  = 0x58,
-    IS31FL3216_REG_FRAME5_CTRL = 0x68,
-    IS31FL3216_REG_FRAME5_PWM  = 0x6A,
-    IS31FL3216_REG_FRAME6_CTRL = 0x7A,
-    IS31FL3216_REG_FRAME6_PWM  = 0x7C,
-    IS31FL3216_REG_FRAME7_CTRL = 0x8C,
-    IS31FL3216_REG_FRAME7_PWM  = 0x8E,
-    IS31FL3216_REG_FRAME8_CTRL = 0x9E,
-    IS31FL3216_REG_FRAME8_PWM  = 0xA0,
-
-    IS31FL3216_REG_UPDATE      = 0xB0,  /* Load PWM Register data */
-    IS31FL3216_REG_FRAME_DELAY = 0xB6,  /* Set the delay time between each frame */
-    IS31FL3216_REG_FRAME_START = 0xB7,  /* Set the start frame in Auto Frame Play Mode */
-    IS31FL3216_REG_MAX,
-} is31fl3216_reg_t;
-
-typedef enum {
-    IS31FL3216_CH_1   = 0x0001,         /**< channel by bit shit */
-    IS31FL3216_CH_2   = 0x0002,
-    IS31FL3216_CH_3   = 0x0004,
-    IS31FL3216_CH_4   = 0x0008,
-    IS31FL3216_CH_5   = 0x0010,
-    IS31FL3216_CH_6   = 0x0020,
-    IS31FL3216_CH_7   = 0x0040,
-    IS31FL3216_CH_8   = 0x0080,
-    IS31FL3216_CH_9   = 0x0100,
-    IS31FL3216_CH_10  = 0x0200,
-    IS31FL3216_CH_11  = 0x0400,
-    IS31FL3216_CH_12  = 0x0800,
-    IS31FL3216_CH_13  = 0x1000,
-    IS31FL3216_CH_14  = 0x2000,
-    IS31FL3216_CH_15  = 0x4000,
-    IS31FL3216_CH_16  = 0x8000,
-    IS31FL3216_CH_ALL = 0xFFFF,
-} is31_pwm_channel_t;
-
-typedef void *is31fl3216_handle_t;
-
-/**
- * @brief The Shutdown Register sets software shutdown mode of IS31FL3216.
- *
- * @param handle  led dev handle
- * @param mode  shutdown mode or Normal
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- *     - ESP_ERR_TIMEOUT  timeout
- */
-esp_err_t is31fl3216_power(is31fl3216_handle_t handle, is31fl3216_pwr_t mode);
-
-/**
- * @brief set the duty for the channels
- *
- * @param handle  led dev handle
- * @param ch_bits the sequence num of channels  //e.g.: 1UL << the number of channel
- * @param duty    set the duty between 0-255
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_ch_duty_set(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits, uint8_t duty);
-
-/**
- * @brief set the work mode of channels
- *
- * @param handle  led dev handle
- * @param mode    led work mode
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_work_mode_set(is31fl3216_handle_t handle, is31fl3216_work_mode_t mode);
-
-/**
- * @brief enable the channels
- *
- * @param handle  led dev handle
- * @param ch_bits the sequence num of channels  //e.g.: ch_bits = 1UL << the number of channel
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_ch_enable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits);
-
-/**
- * @brief disable the channels
- *
- * @param handle  led dev handle
- * @param ch_bits the sequence num of channels  //e.g.: chbits = 1UL << the number of channel
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_ch_disable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits);
-
-/**
- * @brief set the mode of output current
- *
- * @param handle  led dev handle
- * @param mode    output current mode
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_cur_mode_set(is31fl3216_handle_t handle, is31fl3216_cur_mode_t mode);
-
-/**
- * @brief set the value of output current
- *
- * @param handle  led dev handle
- * @param value   output current value
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_cur_value_set(is31fl3216_handle_t handle, is31fl3216_cur_value_t value);
-
-/**
- * @brief choose the audio gain
- *
- * @param handle  led dev handle
- * @param value   selection of audio gain
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_ags_value_set(is31fl3216_handle_t handle, is31fl3216_ags_value_t value);
-
-/**
- * @brief enable or disable audio gain
- *
- * @param handle  led dev handle
- * @param en      0 or 1 to switch the audio gain
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_agc_cfg(is31fl3216_handle_t handle, uint32_t en);
-
-/**
- * @brief set the mode of chip cascade
- *
- * @param handle  led dev handle
- * @param mode    chip cascade mode
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_cascade_mode_set(is31fl3216_handle_t handle, is31fl3216_cascade_mode_t mode);
-
-/**
- * @brief update the register
- *
- * @param handle  led dev handle
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_update_reg(is31fl3216_handle_t handle);
-
-/**
- * @brief set the sample rate
- *
- * @param handle  led dev handle
- * @param value   set value
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_sample_rate_set(is31fl3216_handle_t handle, uint32_t value);
-
-/**
- * @brief set the frame time
- *
- * @param handle  led dev handle
- * @param time    time to set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_frame_time_set(is31fl3216_handle_t handle, is31fl3216_delay_time_t time);
-
-/**
- * @brief choose the first frame to play
- *
- * @param handle  led dev handle
- * @param frame   the seqence num of frame
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_first_frame_set(is31fl3216_handle_t handle, uint32_t frame);
-
-/**
- * @brief write frame data
- *
- * @param handle  led dev handle
- * @param num     the seqence num of frame
- * @param data    data to write
- * @param len     the length of data
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t is31fl3216_frame_value_set(is31fl3216_handle_t handle, uint32_t num, uint8_t *data, uint32_t len);
-
-/**
- * @brief IS31FL3216 will reset all registers to default value.
- *
- * @param handle  led dev handle
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- *     - ESP_ERR_TIMEOUT  timeout
- */
-esp_err_t is31fl3216_reset(is31fl3216_handle_t handle);
-
-/**
- * @brief Create and init sensor object and return a led handle
- *
- * @param bus I2C bus object handle
- *
- * @return
- *     - NULL Fail
- *     - Others Success
- */
-is31fl3216_handle_t is31fl3216_init(void);
-
-/**
- * @brief Delete and release a LED object
- *
- * @param sensor object handle of Is31fl3216
- * @param del_bus Whether to delete the I2C bus
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL Fail
- */
-esp_err_t is31fl3216_deinit(is31fl3216_handle_t handle);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
+/*
+  * ESPRESSIF MIT License
+  *
+  * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+  *
+  * Permission is hereby granted for use on ESPRESSIF SYSTEMS products only, in which case,
+  * it is free of charge, to any person obtaining a copy of this software and associated
+  * documentation files (the "Software"), to deal in the Software without restriction, including
+  * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+  * to do so, subject to the following conditions:
+  *
+  * The above copyright notice and this permission notice shall be included in all copies or
+  * substantial portions of the Software.
+  *
+  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+  *
+  */
+
+#ifndef _IOT_IS31FL3216_H_
+#define _IOT_IS31FL3216_H_
+
+#include "driver/i2c.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IS31FL3216_CH_NUM_MAX 16
+#define IS31FL3216_DUTY_MAX   255
+
+typedef enum {
+    IS31FL3216_PWR_NORMAL = 0,            /**< Normal operation */
+    IS31FL3216_PWR_SHUTDOWN,              /**< Software shutdown mode */
+    IS31FL3216_PWR_MAX,
+} is31fl3216_pwr_t;
+
+typedef enum {
+    IS31FL3216_MODE_PWM = 0,              /**< PWM control mode operation*/
+    IS31FL3216_MODE_AUTO_FRAME,           /**< Auto frame play mode operation */
+    IS31FL3216_MODE_FRAME,                /**< Audio frame mode operation */
+    IS31FL3216_MODE_MAX,
+} is31fl3216_work_mode_t;
+
+typedef enum {
+    IS31FL3216_CUR_MODE_REXT = 0,         /**< Output current is set by register */
+    IS31FL3216_CUR_MODE_AUDIO,            /**< Output current is modulated by audio signal */
+    IS31FL3216_CUR_MODE_MAX,
+} is31fl3216_cur_mode_t;
+
+typedef enum {
+    IS31FL3216_CUR_1_00 = 0,              /**< Output Current Selection */
+    IS31FL3216_CUR_0_75,
+    IS31FL3216_CUR_0_50,
+    IS31FL3216_CUR_0_25,
+    IS31FL3216_CUR_2_00,
+    IS31FL3216_CUR_1_75,
+    IS31FL3216_CUR_1_50,
+    IS31FL3216_CUR_1_25,
+    IS31FL3216_CUR_MAX,
+} is31fl3216_cur_value_t;
+
+typedef enum {
+    IS31FL3216_CASCADE_MASTER = 0,       /**< Chip Cascade Mode */
+    IS31FL3216_CASCADE_SLAVE,
+} is31fl3216_cascade_mode_t;
+
+typedef enum {
+    IS31FL3216_AGS_0DB = 0,              /**< Audio Gain Selection */
+    IS31FL3216_AGS_3DB,
+    IS31FL3216_AGS_6DB,
+    IS31FL3216_AGS_9DB,
+    IS31FL3216_AGS_12DB,
+    IS31FL3216_AGS_15DB,
+    IS31FL3216_AGS_18DB,
+    IS31FL3216_AGS_21DB,
+    IS31FL3216_AGS_MAX,
+} is31fl3216_ags_value_t;
+
+typedef enum {
+    IS31FL3216_TIME_32MS = 0,            /**< Frame Delay Time */
+    IS31FL3216_TIME_64MS,
+    IS31FL3216_TIME_128MS,
+    IS31FL3216_TIME_256MS,
+    IS31FL3216_TIME_512MS,
+    IS31FL3216_TIME_1024MS,
+    IS31FL3216_TIME_2048MS,
+    IS31FL3216_TIME_4096MS,
+    IS31FL3216_TIME_MAX,
+} is31fl3216_delay_time_t;
+
+
+typedef enum {
+    IS31FL3216_REG_CONFIG      = 0x00,   /* Configuration register */
+    IS31FL3216_REG_LED_CTRL_H  = 0x01,   /* LED control register OUT9-OUT16 enable bit */
+    IS31FL3216_REG_LED_CTRL_L  = 0x02,   /* LED control register OUT1-OUT8 enable bit */
+    IS31FL3216_REG_LED_EFFECT  = 0x03,   /* Set the output current and the audio gain */
+    IS31FL3216_REG_CH_CONFIG   = 0x04,   /* Set the operating mode of OUT9~OUT16 */
+    IS31FL3216_REG_GPIO_CONFIG = 0x05,   /* Set the operating mode of OUT9~OUT16 as the GPIO port */
+    IS31FL3216_REG_OUTPUT      = 0x06,   /* Set the logic level of OUT9~OUT16 as the output port */
+    IS31FL3216_REG_INPUT_CTRL  = 0x07,   /* Set the interrupt function of OUT9~OUT16 */
+    IS31FL3216_REG_STATE       = 0x08,   /* Store the state of OUT9~OUT16 as the input port */
+    IS31FL3216_REG_ADC_RATE    = 0x09,   /* Set the ADC sample rate of the input signal */
+
+    IS31FL3216_REG_PWM_16      = 0x10,   /* Set the PWM duty cycle data */
+    IS31FL3216_REG_PWM_15,
+    IS31FL3216_REG_PWM_14,
+    IS31FL3216_REG_PWM_13,
+    IS31FL3216_REG_PWM_12,
+    IS31FL3216_REG_PWM_11,
+    IS31FL3216_REG_PWM_10,
+    IS31FL3216_REG_PWM_09,
+    IS31FL3216_REG_PWM_08,
+    IS31FL3216_REG_PWM_07,
+    IS31FL3216_REG_PWM_06,
+    IS31FL3216_REG_PWM_05,
+    IS31FL3216_REG_PWM_04,
+    IS31FL3216_REG_PWM_03,
+    IS31FL3216_REG_PWM_02,
+    IS31FL3216_REG_PWM_01,
+
+    IS31FL3216_REG_FRAME1_CTRL = 0x20,  /* Store the data of 8 frames */
+    IS31FL3216_REG_FRAME1_PWM  = 0x22,
+    IS31FL3216_REG_FRAME2_CTRL = 0x32,
+    IS31FL3216_REG_FRAME2_PWM  = 0x34,
+    IS31FL3216_REG_FRAME3_CTRL = 0x44,
+    IS31FL3216_REG_FRAME3_PWM  = 0x46,
+    IS31FL3216_REG_FRAME4_CTRL = 0x56,
+    IS31FL3216_REG_FRAME4_PWM  = 0x58,
+    IS31FL3216_REG_FRAME5_CTRL = 0x68,
+    IS31FL3216_REG_FRAME5_PWM  = 0x6A,
+    IS31FL3216_REG_FRAME6_CTRL = 0x7A,
+    IS31FL3216_REG_FRAME6_PWM  = 0x7C,
+    IS31FL3216_REG_FRAME7_CTRL = 0x8C,
+    IS31FL3216_REG_FRAME7_PWM  = 0x8E,
+    IS31FL3216_REG_FRAME8_CTRL = 0x9E,
+    IS31FL3216_REG_FRAME8_PWM  = 0xA0,
+
+    IS31FL3216_REG_UPDATE      = 0xB0,  /* Load PWM Register data */
+    IS31FL3216_REG_FRAME_DELAY = 0xB6,  /* Set the delay time between each frame */
+    IS31FL3216_REG_FRAME_START = 0xB7,  /* Set the start frame in Auto Frame Play Mode */
+    IS31FL3216_REG_MAX,
+} is31fl3216_reg_t;
+
+typedef enum {
+    IS31FL3216_CH_1   = 0x0001,         /**< channel by bit shit */
+    IS31FL3216_CH_2   = 0x0002,
+    IS31FL3216_CH_3   = 0x0004,
+    IS31FL3216_CH_4   = 0x0008,
+    IS31FL3216_CH_5   = 0x0010,
+    IS31FL3216_CH_6   = 0x0020,
+    IS31FL3216_CH_7   = 0x0040,
+    IS31FL3216_CH_8   = 0x0080,
+    IS31FL3216_CH_9   = 0x0100,
+    IS31FL3216_CH_10  = 0x0200,
+    IS31FL3216_CH_11  = 0x0400,
+    IS31FL3216_CH_12  = 0x0800,
+    IS31FL3216_CH_13  = 0x1000,
+    IS31FL3216_CH_14  = 0x2000,
+    IS31FL3216_CH_15  = 0x4000,
+    IS31FL3216_CH_16  = 0x8000,
+    IS31FL3216_CH_ALL = 0xFFFF,
+} is31_pwm_channel_t;
+
+typedef void *is31fl3216_handle_t;
+
+/**
+ * @brief The Shutdown Register sets software shutdown mode of IS31FL3216.
+ *
+ * @param handle  led dev handle
+ * @param mode  shutdown mode or Normal
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ *     - ESP_ERR_TIMEOUT  timeout
+ */
+esp_err_t is31fl3216_power(is31fl3216_handle_t handle, is31fl3216_pwr_t mode);
+
+/**
+ * @brief set the duty for the channels
+ *
+ * @param handle  led dev handle
+ * @param ch_bits the sequence num of channels  //e.g.: 1UL << the number of channel
+ * @param duty    set the duty between 0-255
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_ch_duty_set(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits, uint8_t duty);
+
+/**
+ * @brief set the work mode of channels
+ *
+ * @param handle  led dev handle
+ * @param mode    led work mode
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_work_mode_set(is31fl3216_handle_t handle, is31fl3216_work_mode_t mode);
+
+/**
+ * @brief enable the channels
+ *
+ * @param handle  led dev handle
+ * @param ch_bits the sequence num of channels  //e.g.: ch_bits = 1UL << the number of channel
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_ch_enable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits);
+
+/**
+ * @brief disable the channels
+ *
+ * @param handle  led dev handle
+ * @param ch_bits the sequence num of channels  //e.g.: chbits = 1UL << the number of channel
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_ch_disable(is31fl3216_handle_t handle, is31_pwm_channel_t ch_bits);
+
+/**
+ * @brief set the mode of output current
+ *
+ * @param handle  led dev handle
+ * @param mode    output current mode
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_cur_mode_set(is31fl3216_handle_t handle, is31fl3216_cur_mode_t mode);
+
+/**
+ * @brief set the value of output current
+ *
+ * @param handle  led dev handle
+ * @param value   output current value
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_cur_value_set(is31fl3216_handle_t handle, is31fl3216_cur_value_t value);
+
+/**
+ * @brief choose the audio gain
+ *
+ * @param handle  led dev handle
+ * @param value   selection of audio gain
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_ags_value_set(is31fl3216_handle_t handle, is31fl3216_ags_value_t value);
+
+/**
+ * @brief enable or disable audio gain
+ *
+ * @param handle  led dev handle
+ * @param en      0 or 1 to switch the audio gain
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_agc_cfg(is31fl3216_handle_t handle, uint32_t en);
+
+/**
+ * @brief set the mode of chip cascade
+ *
+ * @param handle  led dev handle
+ * @param mode    chip cascade mode
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_cascade_mode_set(is31fl3216_handle_t handle, is31fl3216_cascade_mode_t mode);
+
+/**
+ * @brief update the register
+ *
+ * @param handle  led dev handle
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_update_reg(is31fl3216_handle_t handle);
+
+/**
+ * @brief set the sample rate
+ *
+ * @param handle  led dev handle
+ * @param value   set value
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_sample_rate_set(is31fl3216_handle_t handle, uint32_t value);
+
+/**
+ * @brief set the frame time
+ *
+ * @param handle  led dev handle
+ * @param time    time to set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_frame_time_set(is31fl3216_handle_t handle, is31fl3216_delay_time_t time);
+
+/**
+ * @brief choose the first frame to play
+ *
+ * @param handle  led dev handle
+ * @param frame   the seqence num of frame
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_first_frame_set(is31fl3216_handle_t handle, uint32_t frame);
+
+/**
+ * @brief write frame data
+ *
+ * @param handle  led dev handle
+ * @param num     the seqence num of frame
+ * @param data    data to write
+ * @param len     the length of data
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t is31fl3216_frame_value_set(is31fl3216_handle_t handle, uint32_t num, uint8_t *data, uint32_t len);
+
+/**
+ * @brief IS31FL3216 will reset all registers to default value.
+ *
+ * @param handle  led dev handle
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ *     - ESP_ERR_TIMEOUT  timeout
+ */
+esp_err_t is31fl3216_reset(is31fl3216_handle_t handle);
+
+/**
+ * @brief Create and init sensor object and return a led handle
+ *
+ * @param bus I2C bus object handle
+ *
+ * @return
+ *     - NULL Fail
+ *     - Others Success
+ */
+is31fl3216_handle_t is31fl3216_init(void);
+
+/**
+ * @brief Delete and release a LED object
+ *
+ * @param sensor object handle of Is31fl3216
+ * @param del_bus Whether to delete the I2C bus
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL Fail
+ */
+esp_err_t is31fl3216_deinit(is31fl3216_handle_t handle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/components/esp_peripherals/lib/adc_button/adc_button.c b/components/esp_peripherals/lib/adc_button/adc_button.c
index 41f8618c..d99e5a02 100644
--- a/components/esp_peripherals/lib/adc_button/adc_button.c
+++ b/components/esp_peripherals/lib/adc_button/adc_button.c
@@ -1,433 +1,433 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/event_groups.h"
-#include "driver/adc.h"
-#include "math.h"
-#include "audio_mem.h"
-#include "esp_adc_cal.h"
-#include "string.h"
-#include "adc_button.h"
-#include "esp_log.h"
-#include "audio_thread.h"
-#include "audio_idf_version.h"
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-#define ADC_ATTEN_11db ADC_ATTEN_DB_11
-#define ADC_WIDTH_12Bit ADC_BITWIDTH_12
-#define ADC_WIDTH_13Bit ADC_BITWIDTH_13
-#endif
-
-#define V_REF                           1100
-
-#define ADC_SAMPLES_NUM                 10
-#define ADC_SAMPLE_INTERVAL_TIME_MS     20
-#define DIAL_VOL_INTERVAL_TIME_MS       150
-
-#define ADC_BTN_INVALID_ID              -1
-#define ADC_BTN_INVALID_ACT_ID          -2
-#define ADC_BTN_DETECT_TIME_MS          20
-#define ADC_BTN_DETECTED_CNT            2
-
-#ifndef ENABLE_ADC_VOLUME
-#define USER_KEY_MAX                    7
-#endif
-
-static char *TAG = "ADC_BTN";
-static EventGroupHandle_t g_event_bit;
-
-typedef struct {
-    adc_button_callback btn_callback;
-    adc_btn_list *head;
-    void *user_data;
-    audio_thread_t audio_thread;
-} adc_btn_tag_t;
-
-static const int default_step_level[USER_KEY_MAX] = {0, 683, 1193, 1631, 2090, 2578, 3103};
-static const int DESTROY_BIT = BIT0;
-static bool _task_flag;
-
-adc_btn_list *adc_btn_create_list(adc_arr_t *adc_conf, int channels)
-{
-    adc_btn_list *head = NULL;
-    adc_btn_list *node = NULL;
-    adc_btn_list *find = NULL;
-    for (int i = 0; i < channels; i++) {
-        node = (adc_btn_list *)audio_calloc(1, sizeof(adc_btn_list));
-        if (NULL == node) {
-            ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
-            return NULL;
-        }
-        memset(node, 0, sizeof(adc_btn_list));
-        adc_arr_t *info = &(node->adc_info);
-        memcpy(info, adc_conf + i, sizeof(adc_arr_t));
-        info->adc_level_step = (int *)audio_calloc(1, (info->total_steps + 1) * sizeof(int));
-        memset(info->adc_level_step, 0, (info->total_steps + 1) * sizeof(int));
-        if (NULL == info->adc_level_step) {
-            ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
-            audio_free(node);
-            return NULL;
-        }
-        if (adc_conf[i].adc_level_step == NULL) {
-            memcpy(info->adc_level_step, default_step_level, USER_KEY_MAX * sizeof(int));
-        } else {
-            memcpy(info->adc_level_step, adc_conf[i].adc_level_step, (adc_conf[i].total_steps + 1) * sizeof(int));
-        }
-        if (info->total_steps > USER_KEY_MAX) {
-            ESP_LOGE(TAG, "The total_steps should be less than USER_KEY_MAX");
-            audio_free(info->adc_level_step);
-            audio_free(node);
-        }
-        node->btn_dscp = (btn_decription *)audio_calloc(1, sizeof(btn_decription) * (adc_conf[i].total_steps));
-        if (NULL == node->btn_dscp) {
-            ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
-            audio_free(info->adc_level_step);
-            audio_free(node);
-        }
-        memset(node->btn_dscp, 0, sizeof(btn_decription) * (adc_conf[i].total_steps));
-        node->next = NULL;
-        if (NULL == head) {
-            head = node;
-            find = head;
-        } else {
-            find->next = node;
-            find = node;
-        }
-    }
-    return head;
-}
-
-esp_err_t adc_btn_destroy_list(adc_btn_list *head)
-{
-    if (head == NULL) {
-        ESP_LOGD(TAG, "The head of list is null");
-        return ESP_OK;
-    }
-    adc_btn_list *find = head;
-    adc_btn_list *tmp = find;
-
-    while (find) {
-        adc_arr_t *info = &(find->adc_info);
-        tmp = find->next;
-        audio_free(find->btn_dscp);
-        audio_free(info->adc_level_step);
-        audio_free(find);
-        find = tmp;
-    }
-    return ESP_OK;
-}
-
-static int get_adc_voltage(int channel)
-{
-    uint32_t data[ADC_SAMPLES_NUM] = { 0 };
-    uint32_t sum = 0;
-    int tmp = 0;
-#if CONFIG_IDF_TARGET_ESP32 || CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32S3
-    esp_adc_cal_characteristics_t characteristics;
-#if CONFIG_IDF_TARGET_ESP32
-    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_12Bit, V_REF, &characteristics);
-#elif CONFIG_IDF_TARGET_ESP32S2
-    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_BIT_13, 0, &characteristics);
-#else
-    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_12Bit, 0, &characteristics);
-#endif
-
-    for (int i = 0; i < ADC_SAMPLES_NUM; ++i) {
-        esp_adc_cal_get_voltage(channel, &characteristics, &data[i]);
-    }
-#endif
-    for (int j = 0; j < ADC_SAMPLES_NUM - 1; j++) {
-        for (int i = 0; i < ADC_SAMPLES_NUM - j - 1; i++) {
-            if (data[i] > data[i + 1]) {
-                tmp = data[i];
-                data[i] = data[i + 1];
-                data[i + 1] = tmp;
-            }
-        }
-    }
-    for (int num = 1; num < ADC_SAMPLES_NUM - 1; num++)
-        sum += data[num];
-    return (sum / (ADC_SAMPLES_NUM - 2));
-}
-
-static int get_button_id(adc_btn_list *node, int adc)
-{
-    int m = ADC_BTN_INVALID_ID;
-    adc_arr_t *info = &(node->adc_info);
-    for (int i = 0; i < info->total_steps; i++) {
-        ESP_LOGV(TAG, "max:%d, adc:%d, i:%d, %d, %d", info->total_steps, adc, i, info->adc_level_step[i], info->adc_level_step[i + 1]);
-        if ((adc > info->adc_level_step[i])
-            && (adc <= info->adc_level_step[i + 1])) {
-            m = i;
-            break;
-        }
-    }
-    return m;
-}
-
-static void reset_btn(btn_decription *btn_dscp, int btn_num)
-{
-    memset(btn_dscp, 0, sizeof(btn_decription) * btn_num);
-    for (int i = 0; i < btn_num; ++i) {
-        btn_dscp[i].active_id = ADC_BTN_INVALID_ID;
-    }
-}
-
-static adc_btn_state_t get_adc_btn_state(int adc_value, int act_id, adc_btn_list *node)
-{
-    adc_btn_state_t st = ADC_BTN_STATE_IDLE;
-    adc_arr_t *info = &(node->adc_info);
-    btn_decription *btn_dscp = node->btn_dscp;
-    int id = get_button_id(node, adc_value);
-    if (id == ADC_BTN_INVALID_ID) {
-        if (act_id == ADC_BTN_INVALID_ACT_ID) {
-            // No old act id and new act id.
-            return ADC_BTN_STATE_IDLE;
-        }
-        if (btn_dscp[act_id].click_cnt <= 1) {
-            return ADC_BTN_STATE_IDLE;
-        }
-        // Have old act ID, new id is invalid
-        // Need to send release event
-        if (btn_dscp[act_id].click_cnt < (info->press_judge_time / ADC_BTN_DETECT_TIME_MS)) {
-            ESP_LOGD(TAG, "pressed: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
-            st = ADC_BTN_STATE_RELEASE;
-        } else {
-            ESP_LOGD(TAG, "long press release: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
-            st = ADC_BTN_STATE_LONG_RELEASE;
-        }
-        btn_dscp[act_id].active_id = -1;
-        btn_dscp[act_id].long_click = 0;
-        btn_dscp[act_id].click_cnt = 0;
-        return st;
-    }
-    // 1.ID is valid and act ID is invalid.
-    if (act_id == ADC_BTN_INVALID_ACT_ID) {
-        // First new act id
-        btn_dscp[id].active_id = id;
-        return ADC_BTN_STATE_IDLE;
-    }
-    // 2.ID and act ID are valid, but not equal.
-    if (id != act_id) {
-        ESP_LOGW(TAG, "Old ID:%d, New ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
-        // Invalid the act ID
-        btn_dscp[act_id].active_id = -1;
-        btn_dscp[act_id].long_click = 0;
-        // Set the new id act ID
-        btn_dscp[id].active_id = id;
-        // Maybe need to check release long pressed.
-        if (btn_dscp[act_id].click_cnt < ADC_BTN_DETECTED_CNT) {
-            btn_dscp[act_id].click_cnt = 0;
-            return ADC_BTN_STATE_IDLE;
-        }
-        btn_dscp[act_id].click_cnt = 0;
-        // Have old act ID, new id is invalid
-        // Need to send release event
-        if (btn_dscp[act_id].click_cnt < (info->press_judge_time / ADC_BTN_DETECT_TIME_MS)) {
-            ESP_LOGD(TAG, "pressed: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
-            return ADC_BTN_STATE_RELEASE;
-        } else {
-            ESP_LOGD(TAG, "long press release: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
-            return ADC_BTN_STATE_LONG_RELEASE;
-        }
-    }
-    // 3.ID and act ID are valid, and equal.
-    btn_dscp[act_id].click_cnt++;
-    if (btn_dscp[act_id].click_cnt == ADC_BTN_DETECTED_CNT) {
-        return ADC_BTN_STATE_PRESSED;
-    }
-
-    if (btn_dscp[act_id].long_click) {
-        return ADC_BTN_STATE_IDLE;
-    }
-    if (btn_dscp[act_id].click_cnt >= (info->press_judge_time / ADC_BTN_DETECT_TIME_MS)) {
-        //Send long click event.
-        ESP_LOGD(TAG, "long press: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
-        st = ADC_BTN_STATE_LONG_PRESSED;
-        btn_dscp[act_id].long_click = 1;
-    }
-    return st;
-}
-
-static void button_task(void *parameters)
-{
-    _task_flag = true;
-    adc_btn_tag_t *tag = (adc_btn_tag_t *)parameters;
-    adc_btn_list *head = tag->head;
-    adc_btn_list *find = head;
-    xEventGroupClearBits(g_event_bit, DESTROY_BIT);
-#if CONFIG_IDF_TARGET_ESP32S2
-    adc1_config_width(ADC_WIDTH_BIT_13);
-#else
-    adc1_config_width(ADC_WIDTH_BIT_12);
-#endif
-
-    while (find) {
-        adc_arr_t *info = &(find->adc_info);
-        reset_btn(find->btn_dscp, info->total_steps);
-        adc1_config_channel_atten(info->adc_ch, ADC_ATTEN_11db);
-        find = find->next;
-    }
-    find = head;
-
-#if defined ENABLE_ADC_VOLUME
-    adc1_config_channel_atten(DIAL_adc_ch, ADC_ATTEN_11db);
-    short adc_vol_prev = ADC_BTN_INVALID_ID;
-    short adc_vol_cur = ADC_BTN_INVALID_ID;
-    short internal_time_ms = DIAL_VOL_INTERVAL_TIME_MS / ADC_SAMPLE_INTERVAL_TIME_MS; /// 10 * 10 = 100ms
-    static bool empty_flag;
-    static bool full_flag;
-    bool is_first_time = true;
-#endif // ENABLE_ADC_VOLUME
-
-    static adc_btn_state_t cur_state = ADC_BTN_STATE_ADC;
-    adc_btn_state_t btn_st = ADC_BTN_STATE_IDLE;
-    int cur_act_id = ADC_BTN_INVALID_ACT_ID;
-    while (_task_flag) {
-#if defined ENABLE_ADC_VOLUME
-        if (internal_time_ms == 0) {
-            adc_vol_cur = get_adc_voltage(DIAL_adc_ch);
-            internal_time_ms = DIAL_VOL_INTERVAL_TIME_MS / ADC_SAMPLE_INTERVAL_TIME_MS;
-            if (adc_vol_prev > 0) {
-                short n = abs(adc_vol_cur - adc_vol_prev);
-                if (is_first_time) {
-                    is_first_time = false;
-                }
-                if (adc_vol_cur < 200) {
-                    if (empty_flag == false) {
-                        ESP_LOGI(TAG, "ABS_LOW:%d, %d->0", n, adc_vol_cur / 25);
-                        empty_flag = true;
-                    }
-                } else if (adc_vol_cur > 2500) {
-                    if (full_flag == false) {
-                        ESP_LOGI(TAG, "ABS_HIGH:%d, %d->100", n, adc_vol_cur / 25);
-                        full_flag = true;
-                    }
-                } else if (n > 80) {
-                    empty_flag = false;
-                    full_flag = false;
-                }
-            }
-            adc_vol_prev = adc_vol_cur;
-        }
-        internal_time_ms--;
-#else
-        find = head;
-        while (find) {
-            adc_arr_t *info = &(find->adc_info);
-            int act_id = ADC_BTN_INVALID_ACT_ID;
-            btn_decription *btn_dscp = find->btn_dscp;
-            switch (cur_state) {
-                case ADC_BTN_STATE_ADC: {
-                        int adc = get_adc_voltage(info->adc_ch);
-                        ESP_LOGD(TAG, "ADC:%d", adc);
-                        for (int i = 0; i < info->total_steps; ++i) {
-                            if (btn_dscp[i].active_id > ADC_BTN_INVALID_ID) {
-                                act_id = i;
-                                break;
-                            }
-                        }
-                        btn_st = get_adc_btn_state(adc, act_id, find);
-                        if (btn_st != ADC_BTN_STATE_IDLE) {
-                            cur_act_id = act_id;
-                            cur_state = btn_st;
-                            ESP_LOGD(TAG, "ADC ID:%d", act_id);
-                        }
-                        break;
-                    }
-                case ADC_BTN_STATE_PRESSED: {
-                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_PRESSED);
-                        cur_state = ADC_BTN_STATE_ADC;
-                        break;
-                    }
-                case ADC_BTN_STATE_LONG_PRESSED: {
-                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_LONG_PRESSED);
-                        cur_state = ADC_BTN_STATE_ADC;
-                        break;
-                    }
-                case ADC_BTN_STATE_LONG_RELEASE: {
-                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_LONG_RELEASE);
-                        cur_state = ADC_BTN_STATE_ADC;
-                        break;
-                    }
-                case ADC_BTN_STATE_RELEASE: {
-                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_RELEASE);
-                        cur_state = ADC_BTN_STATE_ADC;
-                        break;
-                    }
-                default:
-                    ESP_LOGE(TAG, "Not support state %d", cur_state);
-                    break;
-            }
-            find = find->next;
-        }
-#endif // ENABLE_ADC_VOLUME
-
-        vTaskDelay(ADC_SAMPLE_INTERVAL_TIME_MS / portTICK_PERIOD_MS);
-    }
-
-    if (g_event_bit) {
-        xEventGroupSetBits(g_event_bit, DESTROY_BIT);
-    }
-    audio_free(tag);
-    vTaskDelete(NULL);
-}
-
-void adc_btn_delete_task(void)
-{
-    if (_task_flag) {
-        _task_flag = false;
-    }
-
-    if (g_event_bit) {
-        xEventGroupWaitBits(g_event_bit, DESTROY_BIT, pdTRUE, pdFALSE, portMAX_DELAY);
-        vEventGroupDelete(g_event_bit);
-        g_event_bit = NULL;
-    }
-}
-
-void adc_btn_init(void *user_data, adc_button_callback cb, adc_btn_list *head, adc_btn_task_cfg_t *task_cfg)
-{
-    adc_btn_tag_t *tag = audio_calloc(1, sizeof(adc_btn_tag_t));
-    if (NULL == tag) {
-        ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
-        return;
-    }
-    tag->user_data = user_data;
-    tag->head = head;
-    tag->btn_callback = cb;
-
-    g_event_bit = xEventGroupCreate();
-
-    audio_thread_create(&tag->audio_thread,
-                        "button_task", button_task,
-                        (void *)tag,
-                        task_cfg->task_stack,
-                        task_cfg->task_prio,
-                        task_cfg->ext_stack,
-                        task_cfg->task_core);
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/event_groups.h"
+#include "driver/adc.h"
+#include "math.h"
+#include "audio_mem.h"
+#include "esp_adc_cal.h"
+#include "string.h"
+#include "adc_button.h"
+#include "esp_log.h"
+#include "audio_thread.h"
+#include "audio_idf_version.h"
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+#define ADC_ATTEN_11db ADC_ATTEN_DB_11
+#define ADC_WIDTH_12Bit ADC_BITWIDTH_12
+#define ADC_WIDTH_13Bit ADC_BITWIDTH_13
+#endif
+
+#define V_REF                           1100
+
+#define ADC_SAMPLES_NUM                 10
+#define ADC_SAMPLE_INTERVAL_TIME_MS     20
+#define DIAL_VOL_INTERVAL_TIME_MS       150
+
+#define ADC_BTN_INVALID_ID              -1
+#define ADC_BTN_INVALID_ACT_ID          -2
+#define ADC_BTN_DETECT_TIME_MS          20
+#define ADC_BTN_DETECTED_CNT            2
+
+#ifndef ENABLE_ADC_VOLUME
+#define USER_KEY_MAX                    7
+#endif
+
+static char *TAG = "ADC_BTN";
+static EventGroupHandle_t g_event_bit;
+
+typedef struct {
+    adc_button_callback btn_callback;
+    adc_btn_list *head;
+    void *user_data;
+    audio_thread_t audio_thread;
+} adc_btn_tag_t;
+
+static const int default_step_level[USER_KEY_MAX] = {0, 683, 1193, 1631, 2090, 2578, 3103};
+static const int DESTROY_BIT = BIT0;
+static bool _task_flag;
+
+adc_btn_list *adc_btn_create_list(adc_arr_t *adc_conf, int channels)
+{
+    adc_btn_list *head = NULL;
+    adc_btn_list *node = NULL;
+    adc_btn_list *find = NULL;
+    for (int i = 0; i < channels; i++) {
+        node = (adc_btn_list *)audio_calloc(1, sizeof(adc_btn_list));
+        if (NULL == node) {
+            ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
+            return NULL;
+        }
+        memset(node, 0, sizeof(adc_btn_list));
+        adc_arr_t *info = &(node->adc_info);
+        memcpy(info, adc_conf + i, sizeof(adc_arr_t));
+        info->adc_level_step = (int *)audio_calloc(1, (info->total_steps + 1) * sizeof(int));
+        memset(info->adc_level_step, 0, (info->total_steps + 1) * sizeof(int));
+        if (NULL == info->adc_level_step) {
+            ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
+            audio_free(node);
+            return NULL;
+        }
+        if (adc_conf[i].adc_level_step == NULL) {
+            memcpy(info->adc_level_step, default_step_level, USER_KEY_MAX * sizeof(int));
+        } else {
+            memcpy(info->adc_level_step, adc_conf[i].adc_level_step, (adc_conf[i].total_steps + 1) * sizeof(int));
+        }
+        if (info->total_steps > USER_KEY_MAX) {
+            ESP_LOGE(TAG, "The total_steps should be less than USER_KEY_MAX");
+            audio_free(info->adc_level_step);
+            audio_free(node);
+        }
+        node->btn_dscp = (btn_decription *)audio_calloc(1, sizeof(btn_decription) * (adc_conf[i].total_steps));
+        if (NULL == node->btn_dscp) {
+            ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
+            audio_free(info->adc_level_step);
+            audio_free(node);
+        }
+        memset(node->btn_dscp, 0, sizeof(btn_decription) * (adc_conf[i].total_steps));
+        node->next = NULL;
+        if (NULL == head) {
+            head = node;
+            find = head;
+        } else {
+            find->next = node;
+            find = node;
+        }
+    }
+    return head;
+}
+
+esp_err_t adc_btn_destroy_list(adc_btn_list *head)
+{
+    if (head == NULL) {
+        ESP_LOGD(TAG, "The head of list is null");
+        return ESP_OK;
+    }
+    adc_btn_list *find = head;
+    adc_btn_list *tmp = find;
+
+    while (find) {
+        adc_arr_t *info = &(find->adc_info);
+        tmp = find->next;
+        audio_free(find->btn_dscp);
+        audio_free(info->adc_level_step);
+        audio_free(find);
+        find = tmp;
+    }
+    return ESP_OK;
+}
+
+static int get_adc_voltage(int channel)
+{
+    uint32_t data[ADC_SAMPLES_NUM] = { 0 };
+    uint32_t sum = 0;
+    int tmp = 0;
+#if CONFIG_IDF_TARGET_ESP32 || CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32S3
+    esp_adc_cal_characteristics_t characteristics;
+#if CONFIG_IDF_TARGET_ESP32
+    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_12Bit, V_REF, &characteristics);
+#elif CONFIG_IDF_TARGET_ESP32S2
+    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_BIT_13, 0, &characteristics);
+#else
+    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_12Bit, 0, &characteristics);
+#endif
+
+    for (int i = 0; i < ADC_SAMPLES_NUM; ++i) {
+        esp_adc_cal_get_voltage(channel, &characteristics, &data[i]);
+    }
+#endif
+    for (int j = 0; j < ADC_SAMPLES_NUM - 1; j++) {
+        for (int i = 0; i < ADC_SAMPLES_NUM - j - 1; i++) {
+            if (data[i] > data[i + 1]) {
+                tmp = data[i];
+                data[i] = data[i + 1];
+                data[i + 1] = tmp;
+            }
+        }
+    }
+    for (int num = 1; num < ADC_SAMPLES_NUM - 1; num++)
+        sum += data[num];
+    return (sum / (ADC_SAMPLES_NUM - 2));
+}
+
+static int get_button_id(adc_btn_list *node, int adc)
+{
+    int m = ADC_BTN_INVALID_ID;
+    adc_arr_t *info = &(node->adc_info);
+    for (int i = 0; i < info->total_steps; i++) {
+        ESP_LOGV(TAG, "max:%d, adc:%d, i:%d, %d, %d", info->total_steps, adc, i, info->adc_level_step[i], info->adc_level_step[i + 1]);
+        if ((adc > info->adc_level_step[i])
+            && (adc <= info->adc_level_step[i + 1])) {
+            m = i;
+            break;
+        }
+    }
+    return m;
+}
+
+static void reset_btn(btn_decription *btn_dscp, int btn_num)
+{
+    memset(btn_dscp, 0, sizeof(btn_decription) * btn_num);
+    for (int i = 0; i < btn_num; ++i) {
+        btn_dscp[i].active_id = ADC_BTN_INVALID_ID;
+    }
+}
+
+static adc_btn_state_t get_adc_btn_state(int adc_value, int act_id, adc_btn_list *node)
+{
+    adc_btn_state_t st = ADC_BTN_STATE_IDLE;
+    adc_arr_t *info = &(node->adc_info);
+    btn_decription *btn_dscp = node->btn_dscp;
+    int id = get_button_id(node, adc_value);
+    if (id == ADC_BTN_INVALID_ID) {
+        if (act_id == ADC_BTN_INVALID_ACT_ID) {
+            // No old act id and new act id.
+            return ADC_BTN_STATE_IDLE;
+        }
+        if (btn_dscp[act_id].click_cnt <= 1) {
+            return ADC_BTN_STATE_IDLE;
+        }
+        // Have old act ID, new id is invalid
+        // Need to send release event
+        if (btn_dscp[act_id].click_cnt < (info->press_judge_time / ADC_BTN_DETECT_TIME_MS)) {
+            ESP_LOGD(TAG, "pressed: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
+            st = ADC_BTN_STATE_RELEASE;
+        } else {
+            ESP_LOGD(TAG, "long press release: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
+            st = ADC_BTN_STATE_LONG_RELEASE;
+        }
+        btn_dscp[act_id].active_id = -1;
+        btn_dscp[act_id].long_click = 0;
+        btn_dscp[act_id].click_cnt = 0;
+        return st;
+    }
+    // 1.ID is valid and act ID is invalid.
+    if (act_id == ADC_BTN_INVALID_ACT_ID) {
+        // First new act id
+        btn_dscp[id].active_id = id;
+        return ADC_BTN_STATE_IDLE;
+    }
+    // 2.ID and act ID are valid, but not equal.
+    if (id != act_id) {
+        ESP_LOGW(TAG, "Old ID:%d, New ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
+        // Invalid the act ID
+        btn_dscp[act_id].active_id = -1;
+        btn_dscp[act_id].long_click = 0;
+        // Set the new id act ID
+        btn_dscp[id].active_id = id;
+        // Maybe need to check release long pressed.
+        if (btn_dscp[act_id].click_cnt < ADC_BTN_DETECTED_CNT) {
+            btn_dscp[act_id].click_cnt = 0;
+            return ADC_BTN_STATE_IDLE;
+        }
+        btn_dscp[act_id].click_cnt = 0;
+        // Have old act ID, new id is invalid
+        // Need to send release event
+        if (btn_dscp[act_id].click_cnt < (info->press_judge_time / ADC_BTN_DETECT_TIME_MS)) {
+            ESP_LOGD(TAG, "pressed: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
+            return ADC_BTN_STATE_RELEASE;
+        } else {
+            ESP_LOGD(TAG, "long press release: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
+            return ADC_BTN_STATE_LONG_RELEASE;
+        }
+    }
+    // 3.ID and act ID are valid, and equal.
+    btn_dscp[act_id].click_cnt++;
+    if (btn_dscp[act_id].click_cnt == ADC_BTN_DETECTED_CNT) {
+        return ADC_BTN_STATE_PRESSED;
+    }
+
+    if (btn_dscp[act_id].long_click) {
+        return ADC_BTN_STATE_IDLE;
+    }
+    if (btn_dscp[act_id].click_cnt >= (info->press_judge_time / ADC_BTN_DETECT_TIME_MS)) {
+        //Send long click event.
+        ESP_LOGD(TAG, "long press: Act ID:%d, ID:%d, Cnt:%d", act_id, id, btn_dscp[act_id].click_cnt);
+        st = ADC_BTN_STATE_LONG_PRESSED;
+        btn_dscp[act_id].long_click = 1;
+    }
+    return st;
+}
+
+static void button_task(void *parameters)
+{
+    _task_flag = true;
+    adc_btn_tag_t *tag = (adc_btn_tag_t *)parameters;
+    adc_btn_list *head = tag->head;
+    adc_btn_list *find = head;
+    xEventGroupClearBits(g_event_bit, DESTROY_BIT);
+#if CONFIG_IDF_TARGET_ESP32S2
+    adc1_config_width(ADC_WIDTH_BIT_13);
+#else
+    adc1_config_width(ADC_WIDTH_BIT_12);
+#endif
+
+    while (find) {
+        adc_arr_t *info = &(find->adc_info);
+        reset_btn(find->btn_dscp, info->total_steps);
+        adc1_config_channel_atten(info->adc_ch, ADC_ATTEN_11db);
+        find = find->next;
+    }
+    find = head;
+
+#if defined ENABLE_ADC_VOLUME
+    adc1_config_channel_atten(DIAL_adc_ch, ADC_ATTEN_11db);
+    short adc_vol_prev = ADC_BTN_INVALID_ID;
+    short adc_vol_cur = ADC_BTN_INVALID_ID;
+    short internal_time_ms = DIAL_VOL_INTERVAL_TIME_MS / ADC_SAMPLE_INTERVAL_TIME_MS; /// 10 * 10 = 100ms
+    static bool empty_flag;
+    static bool full_flag;
+    bool is_first_time = true;
+#endif // ENABLE_ADC_VOLUME
+
+    static adc_btn_state_t cur_state = ADC_BTN_STATE_ADC;
+    adc_btn_state_t btn_st = ADC_BTN_STATE_IDLE;
+    int cur_act_id = ADC_BTN_INVALID_ACT_ID;
+    while (_task_flag) {
+#if defined ENABLE_ADC_VOLUME
+        if (internal_time_ms == 0) {
+            adc_vol_cur = get_adc_voltage(DIAL_adc_ch);
+            internal_time_ms = DIAL_VOL_INTERVAL_TIME_MS / ADC_SAMPLE_INTERVAL_TIME_MS;
+            if (adc_vol_prev > 0) {
+                short n = abs(adc_vol_cur - adc_vol_prev);
+                if (is_first_time) {
+                    is_first_time = false;
+                }
+                if (adc_vol_cur < 200) {
+                    if (empty_flag == false) {
+                        ESP_LOGI(TAG, "ABS_LOW:%d, %d->0", n, adc_vol_cur / 25);
+                        empty_flag = true;
+                    }
+                } else if (adc_vol_cur > 2500) {
+                    if (full_flag == false) {
+                        ESP_LOGI(TAG, "ABS_HIGH:%d, %d->100", n, adc_vol_cur / 25);
+                        full_flag = true;
+                    }
+                } else if (n > 80) {
+                    empty_flag = false;
+                    full_flag = false;
+                }
+            }
+            adc_vol_prev = adc_vol_cur;
+        }
+        internal_time_ms--;
+#else
+        find = head;
+        while (find) {
+            adc_arr_t *info = &(find->adc_info);
+            int act_id = ADC_BTN_INVALID_ACT_ID;
+            btn_decription *btn_dscp = find->btn_dscp;
+            switch (cur_state) {
+                case ADC_BTN_STATE_ADC: {
+                        int adc = get_adc_voltage(info->adc_ch);
+                        ESP_LOGD(TAG, "ADC:%d", adc);
+                        for (int i = 0; i < info->total_steps; ++i) {
+                            if (btn_dscp[i].active_id > ADC_BTN_INVALID_ID) {
+                                act_id = i;
+                                break;
+                            }
+                        }
+                        btn_st = get_adc_btn_state(adc, act_id, find);
+                        if (btn_st != ADC_BTN_STATE_IDLE) {
+                            cur_act_id = act_id;
+                            cur_state = btn_st;
+                            ESP_LOGD(TAG, "ADC ID:%d", act_id);
+                        }
+                        break;
+                    }
+                case ADC_BTN_STATE_PRESSED: {
+                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_PRESSED);
+                        cur_state = ADC_BTN_STATE_ADC;
+                        break;
+                    }
+                case ADC_BTN_STATE_LONG_PRESSED: {
+                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_LONG_PRESSED);
+                        cur_state = ADC_BTN_STATE_ADC;
+                        break;
+                    }
+                case ADC_BTN_STATE_LONG_RELEASE: {
+                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_LONG_RELEASE);
+                        cur_state = ADC_BTN_STATE_ADC;
+                        break;
+                    }
+                case ADC_BTN_STATE_RELEASE: {
+                        tag->btn_callback((void *)tag->user_data, info->adc_ch, cur_act_id, ADC_BTN_STATE_RELEASE);
+                        cur_state = ADC_BTN_STATE_ADC;
+                        break;
+                    }
+                default:
+                    ESP_LOGE(TAG, "Not support state %d", cur_state);
+                    break;
+            }
+            find = find->next;
+        }
+#endif // ENABLE_ADC_VOLUME
+
+        vTaskDelay(ADC_SAMPLE_INTERVAL_TIME_MS / portTICK_PERIOD_MS);
+    }
+
+    if (g_event_bit) {
+        xEventGroupSetBits(g_event_bit, DESTROY_BIT);
+    }
+    audio_free(tag);
+    vTaskDelete(NULL);
+}
+
+void adc_btn_delete_task(void)
+{
+    if (_task_flag) {
+        _task_flag = false;
+    }
+
+    if (g_event_bit) {
+        xEventGroupWaitBits(g_event_bit, DESTROY_BIT, pdTRUE, pdFALSE, portMAX_DELAY);
+        vEventGroupDelete(g_event_bit);
+        g_event_bit = NULL;
+    }
+}
+
+void adc_btn_init(void *user_data, adc_button_callback cb, adc_btn_list *head, adc_btn_task_cfg_t *task_cfg)
+{
+    adc_btn_tag_t *tag = audio_calloc(1, sizeof(adc_btn_tag_t));
+    if (NULL == tag) {
+        ESP_LOGE(TAG, "Memory allocation failed! Line: %d", __LINE__);
+        return;
+    }
+    tag->user_data = user_data;
+    tag->head = head;
+    tag->btn_callback = cb;
+
+    g_event_bit = xEventGroupCreate();
+
+    audio_thread_create(&tag->audio_thread,
+                        "button_task", button_task,
+                        (void *)tag,
+                        task_cfg->task_stack,
+                        task_cfg->task_prio,
+                        task_cfg->ext_stack,
+                        task_cfg->task_core);
+}
diff --git a/components/esp_peripherals/lib/adc_button/adc_button.h b/components/esp_peripherals/lib/adc_button/adc_button.h
index 12c33318..91cf4314 100644
--- a/components/esp_peripherals/lib/adc_button/adc_button.h
+++ b/components/esp_peripherals/lib/adc_button/adc_button.h
@@ -1,94 +1,94 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ADC_BUTTON_H_
-#define _ADC_BUTTON_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "esp_err.h"
-
-typedef enum {
-    USER_KEY_ID0,
-    USER_KEY_ID1,
-    USER_KEY_ID2,
-    USER_KEY_ID3,
-    USER_KEY_ID4,
-    USER_KEY_ID5,
-    USER_KEY_ID6,
-    USER_KEY_MAX,
-} user_key_id_num;
-
-typedef struct {
-    int adc_ch;
-    int *adc_level_step;
-    int total_steps;
-    int press_judge_time;
-} adc_arr_t;
-
-typedef enum {
-    ADC_BTN_STATE_IDLE,             // 0: idle
-    ADC_BTN_STATE_ADC,              // 1: detect
-    ADC_BTN_STATE_PRESSED,          // 2: pressed
-    ADC_BTN_STATE_RELEASE,          // 3: press released
-    ADC_BTN_STATE_LONG_PRESSED,     // 4: long pressed
-    ADC_BTN_STATE_LONG_RELEASE,     // 5: long Press released
-} adc_btn_state_t;
-
-typedef struct {
-    int         active_id;
-    int         click_cnt;    // Timer tick count
-    int         long_click;
-} btn_decription;
-
-typedef struct adc_btn {
-    adc_arr_t adc_info;
-    btn_decription *btn_dscp;
-    struct adc_btn *next;
-} adc_btn_list;
-
-typedef struct {
-    int task_stack;
-    int task_prio;
-    int task_core;
-    bool ext_stack;
-} adc_btn_task_cfg_t;
-
-typedef void (*adc_button_callback) (void *user_data, int adc, int id, adc_btn_state_t state);
-
-void adc_btn_init(void *user_data, adc_button_callback cb, adc_btn_list *head, adc_btn_task_cfg_t *task_cfg);
-
-adc_btn_list *adc_btn_create_list(adc_arr_t *adc_conf, int channels);
-
-esp_err_t adc_btn_destroy_list(adc_btn_list *head);
-
-void adc_btn_delete_task(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ADC_BUTTON_H_
+#define _ADC_BUTTON_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "esp_err.h"
+
+typedef enum {
+    USER_KEY_ID0,
+    USER_KEY_ID1,
+    USER_KEY_ID2,
+    USER_KEY_ID3,
+    USER_KEY_ID4,
+    USER_KEY_ID5,
+    USER_KEY_ID6,
+    USER_KEY_MAX,
+} user_key_id_num;
+
+typedef struct {
+    int adc_ch;
+    int *adc_level_step;
+    int total_steps;
+    int press_judge_time;
+} adc_arr_t;
+
+typedef enum {
+    ADC_BTN_STATE_IDLE,             // 0: idle
+    ADC_BTN_STATE_ADC,              // 1: detect
+    ADC_BTN_STATE_PRESSED,          // 2: pressed
+    ADC_BTN_STATE_RELEASE,          // 3: press released
+    ADC_BTN_STATE_LONG_PRESSED,     // 4: long pressed
+    ADC_BTN_STATE_LONG_RELEASE,     // 5: long Press released
+} adc_btn_state_t;
+
+typedef struct {
+    int         active_id;
+    int         click_cnt;    // Timer tick count
+    int         long_click;
+} btn_decription;
+
+typedef struct adc_btn {
+    adc_arr_t adc_info;
+    btn_decription *btn_dscp;
+    struct adc_btn *next;
+} adc_btn_list;
+
+typedef struct {
+    int task_stack;
+    int task_prio;
+    int task_core;
+    bool ext_stack;
+} adc_btn_task_cfg_t;
+
+typedef void (*adc_button_callback) (void *user_data, int adc, int id, adc_btn_state_t state);
+
+void adc_btn_init(void *user_data, adc_button_callback cb, adc_btn_list *head, adc_btn_task_cfg_t *task_cfg);
+
+adc_btn_list *adc_btn_create_list(adc_arr_t *adc_conf, int channels);
+
+esp_err_t adc_btn_destroy_list(adc_btn_list *head);
+
+void adc_btn_delete_task(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/aw2013/aw2013.c b/components/esp_peripherals/lib/aw2013/aw2013.c
index d6ab7ad4..0ab922da 100644
--- a/components/esp_peripherals/lib/aw2013/aw2013.c
+++ b/components/esp_peripherals/lib/aw2013/aw2013.c
@@ -1,268 +1,268 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "i2c_bus.h"
-#include "board.h"
-#include "aw2013.h"
-#include "esp_log.h"
-
-#define AW2013_ADDR 0x8a
-#define AW2013_MAX_LED_NUM 3
-#define AW2013_MAX_REPEAT_TIME 15
-
-static const char *TAG = "AW2013";
-
-static i2c_bus_handle_t i2c_handle;
-
-esp_err_t aw2013_set_repeat_time(uint8_t cnt)
-{
-    esp_err_t ret = ESP_OK;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    cnt %= AW2013_MAX_REPEAT_TIME;
-
-    for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-        reg_addr = AW2013_REG_LED0T0CNT + AW2013_MAX_LED_NUM * i;
-        ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-        reg_val &= 0xf0;
-        reg_val |= cnt;
-        ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-    }
-    return ret;
-}
-
-esp_err_t aw2013_set_time(aw2013_time_t time, aw2013_time_level_t level)
-{
-    if (level > AW2013_TIME_LEVEL_8 || time > AW2013_TIME_4) {
-        ESP_LOGE(TAG, "Invalid parameters, time: %d, level: %d", time, level);
-        return ESP_FAIL;
-    }
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    esp_err_t ret = ESP_OK;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-
-    for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-        switch (time) {
-            case AW2013_TIME_0: {
-                    reg_addr = AW2013_REG_LED0T0CNT + AW2013_MAX_LED_NUM * i;
-                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    reg_val &= 0x0f;
-                    reg_val |= (level << 4);
-                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    break;
-                }
-            case AW2013_TIME_1: {
-                    if (level > AW2013_TIME_LEVEL_7) {
-                        level = AW2013_TIME_LEVEL_7;
-                    }
-                    reg_addr = AW2013_REG_LED0T1T2 + AW2013_MAX_LED_NUM * i;
-                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    reg_val &= 0x8f;
-                    reg_val |= (level << 4);
-                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    break;
-                }
-            case AW2013_TIME_2: {
-                    if (level > AW2013_TIME_LEVEL_5) {
-                        level = AW2013_TIME_LEVEL_5;
-                    }
-                    reg_addr = AW2013_REG_LED0T1T2 + AW2013_MAX_LED_NUM * i;
-                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    reg_val &= 0xf8;
-                    reg_val |= level;
-                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    break;
-                }
-            case AW2013_TIME_3: {
-                    if (level > 7) {
-                        level = 7;
-                    }
-                    reg_addr = AW2013_REG_LED0T3T4 + AW2013_MAX_LED_NUM * i;
-                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    reg_val &= 0x8f;
-                    reg_val |= (level << 4);
-                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    break;
-                }
-            case AW2013_TIME_4: {
-                    if (level > 7) {
-                        level = 7;
-                    }
-                    reg_addr = AW2013_REG_LED0T3T4 + AW2013_MAX_LED_NUM * i;
-                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    reg_val &= 0xf8;
-                    reg_val |= level;
-                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-                    break;
-                }
-            default: {
-                    return ESP_FAIL;
-                }
-        }
-    }
-    return ret;
-}
-
-esp_err_t aw2013_enable_fade_mode(bool en)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-
-    if (en) {
-        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-            reg_addr = AW2013_REG_LCFG0 + i;
-            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-            reg_val &= ~(0x01 << 4);
-            reg_val |=  (0x03 << 5);
-            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-        }
-    } else {
-        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-            reg_addr = AW2013_REG_LCFG0 + i;
-            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-            reg_val &= ~(0x03 << 5);
-            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-        }
-    }
-    return ret;
-}
-
-esp_err_t aw2013_enable_auto_flash(bool en)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-
-    if (en) {
-        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-            reg_addr = AW2013_REG_LCFG0 + i;
-            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-            reg_val |= (0x01 << 4);
-            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-        }
-    } else {
-        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-            reg_addr = AW2013_REG_LCFG0 + i;
-            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-            reg_val &= ~(0x01 << 4);
-            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-        }
-    }
-    return ret;
-}
-
-esp_err_t aw2013_set_pwm_value(uint32_t value)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-
-    reg_addr = AW2013_REG_PWM0;
-    reg_val = (value >> 16) & 0xff;
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-
-    reg_addr = AW2013_REG_PWM1;
-    reg_val = (value >> 8) & 0xff;
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-
-    reg_addr = AW2013_REG_PWM2;
-    reg_val = value & 0xff;
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-    return ret;
-}
-
-esp_err_t aw2013_set_brightness(aw2013_brightness_t bright)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-    if (bright > AW2013_BRIGHT_3) {
-        bright = AW2013_BRIGHT_3;
-    }
-    for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
-        reg_addr = AW2013_REG_LCFG0 + i;
-        ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-        reg_val &= 0xfc;
-        reg_val |= bright;
-        ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-    }
-    return ret;
-}
-
-esp_err_t aw2013_reset(void)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t reg_val = 0;
-    uint8_t reg_addr = 0x0;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-
-    reg_addr = AW2013_REG_RESET;
-    reg_addr = AW2013_RESET_VALUE;
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-
-    reg_addr = AW2013_REG_GCR;
-    reg_val = 0x01;
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-
-    reg_addr = AW2013_REG_LCTR;
-    reg_val = 0x07;
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-    ret |= aw2013_set_brightness(1);
-    return ret;
-}
-
-esp_err_t aw2013_init(void)
-{
-    esp_err_t ret = ESP_OK;
-    i2c_config_t config = {
-        .mode = I2C_MODE_MASTER,
-        .master.clk_speed = 100000
-    };
-    ret |= get_i2c_pins(AW2013_I2C_PORT, &config);
-    i2c_handle = i2c_bus_create(AW2013_I2C_PORT, &config);
-    ret |= aw2013_reset();
-    if (ret != ESP_OK) {
-        ESP_LOGE(TAG, "Fail to init aw2013");
-    }
-    return ret;
-}
-
-esp_err_t aw2013_deinit(void)
-{
-    esp_err_t ret = ESP_OK;
-    uint8_t reg_addr = AW2013_REG_RESET;
-    uint8_t reg_val = AW2013_RESET_VALUE;
-    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
-    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
-    ret |= i2c_bus_delete(i2c_handle);
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "i2c_bus.h"
+#include "board.h"
+#include "aw2013.h"
+#include "esp_log.h"
+
+#define AW2013_ADDR 0x8a
+#define AW2013_MAX_LED_NUM 3
+#define AW2013_MAX_REPEAT_TIME 15
+
+static const char *TAG = "AW2013";
+
+static i2c_bus_handle_t i2c_handle;
+
+esp_err_t aw2013_set_repeat_time(uint8_t cnt)
+{
+    esp_err_t ret = ESP_OK;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    cnt %= AW2013_MAX_REPEAT_TIME;
+
+    for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+        reg_addr = AW2013_REG_LED0T0CNT + AW2013_MAX_LED_NUM * i;
+        ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+        reg_val &= 0xf0;
+        reg_val |= cnt;
+        ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+    }
+    return ret;
+}
+
+esp_err_t aw2013_set_time(aw2013_time_t time, aw2013_time_level_t level)
+{
+    if (level > AW2013_TIME_LEVEL_8 || time > AW2013_TIME_4) {
+        ESP_LOGE(TAG, "Invalid parameters, time: %d, level: %d", time, level);
+        return ESP_FAIL;
+    }
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    esp_err_t ret = ESP_OK;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+
+    for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+        switch (time) {
+            case AW2013_TIME_0: {
+                    reg_addr = AW2013_REG_LED0T0CNT + AW2013_MAX_LED_NUM * i;
+                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    reg_val &= 0x0f;
+                    reg_val |= (level << 4);
+                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    break;
+                }
+            case AW2013_TIME_1: {
+                    if (level > AW2013_TIME_LEVEL_7) {
+                        level = AW2013_TIME_LEVEL_7;
+                    }
+                    reg_addr = AW2013_REG_LED0T1T2 + AW2013_MAX_LED_NUM * i;
+                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    reg_val &= 0x8f;
+                    reg_val |= (level << 4);
+                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    break;
+                }
+            case AW2013_TIME_2: {
+                    if (level > AW2013_TIME_LEVEL_5) {
+                        level = AW2013_TIME_LEVEL_5;
+                    }
+                    reg_addr = AW2013_REG_LED0T1T2 + AW2013_MAX_LED_NUM * i;
+                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    reg_val &= 0xf8;
+                    reg_val |= level;
+                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    break;
+                }
+            case AW2013_TIME_3: {
+                    if (level > 7) {
+                        level = 7;
+                    }
+                    reg_addr = AW2013_REG_LED0T3T4 + AW2013_MAX_LED_NUM * i;
+                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    reg_val &= 0x8f;
+                    reg_val |= (level << 4);
+                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    break;
+                }
+            case AW2013_TIME_4: {
+                    if (level > 7) {
+                        level = 7;
+                    }
+                    reg_addr = AW2013_REG_LED0T3T4 + AW2013_MAX_LED_NUM * i;
+                    ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    reg_val &= 0xf8;
+                    reg_val |= level;
+                    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+                    break;
+                }
+            default: {
+                    return ESP_FAIL;
+                }
+        }
+    }
+    return ret;
+}
+
+esp_err_t aw2013_enable_fade_mode(bool en)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+
+    if (en) {
+        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+            reg_addr = AW2013_REG_LCFG0 + i;
+            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+            reg_val &= ~(0x01 << 4);
+            reg_val |=  (0x03 << 5);
+            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+        }
+    } else {
+        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+            reg_addr = AW2013_REG_LCFG0 + i;
+            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+            reg_val &= ~(0x03 << 5);
+            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+        }
+    }
+    return ret;
+}
+
+esp_err_t aw2013_enable_auto_flash(bool en)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+
+    if (en) {
+        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+            reg_addr = AW2013_REG_LCFG0 + i;
+            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+            reg_val |= (0x01 << 4);
+            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+        }
+    } else {
+        for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+            reg_addr = AW2013_REG_LCFG0 + i;
+            ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+            reg_val &= ~(0x01 << 4);
+            ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+        }
+    }
+    return ret;
+}
+
+esp_err_t aw2013_set_pwm_value(uint32_t value)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+
+    reg_addr = AW2013_REG_PWM0;
+    reg_val = (value >> 16) & 0xff;
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+
+    reg_addr = AW2013_REG_PWM1;
+    reg_val = (value >> 8) & 0xff;
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+
+    reg_addr = AW2013_REG_PWM2;
+    reg_val = value & 0xff;
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+    return ret;
+}
+
+esp_err_t aw2013_set_brightness(aw2013_brightness_t bright)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+    if (bright > AW2013_BRIGHT_3) {
+        bright = AW2013_BRIGHT_3;
+    }
+    for (int i = 0; i < AW2013_MAX_LED_NUM; i++) {
+        reg_addr = AW2013_REG_LCFG0 + i;
+        ret |= i2c_bus_read_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+        reg_val &= 0xfc;
+        reg_val |= bright;
+        ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+    }
+    return ret;
+}
+
+esp_err_t aw2013_reset(void)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t reg_val = 0;
+    uint8_t reg_addr = 0x0;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+
+    reg_addr = AW2013_REG_RESET;
+    reg_addr = AW2013_RESET_VALUE;
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+
+    reg_addr = AW2013_REG_GCR;
+    reg_val = 0x01;
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+
+    reg_addr = AW2013_REG_LCTR;
+    reg_val = 0x07;
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+    ret |= aw2013_set_brightness(1);
+    return ret;
+}
+
+esp_err_t aw2013_init(void)
+{
+    esp_err_t ret = ESP_OK;
+    i2c_config_t config = {
+        .mode = I2C_MODE_MASTER,
+        .master.clk_speed = 100000
+    };
+    ret |= get_i2c_pins(AW2013_I2C_PORT, &config);
+    i2c_handle = i2c_bus_create(AW2013_I2C_PORT, &config);
+    ret |= aw2013_reset();
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Fail to init aw2013");
+    }
+    return ret;
+}
+
+esp_err_t aw2013_deinit(void)
+{
+    esp_err_t ret = ESP_OK;
+    uint8_t reg_addr = AW2013_REG_RESET;
+    uint8_t reg_val = AW2013_RESET_VALUE;
+    AUDIO_NULL_CHECK(TAG, i2c_handle, return ESP_FAIL);
+    ret |= i2c_bus_write_bytes(i2c_handle, AW2013_ADDR, &reg_addr, 1, &reg_val, 1);
+    ret |= i2c_bus_delete(i2c_handle);
+    return ret;
+}
diff --git a/components/esp_peripherals/lib/aw2013/aw2013.h b/components/esp_peripherals/lib/aw2013/aw2013.h
index f4feb33e..5d9eb53e 100644
--- a/components/esp_peripherals/lib/aw2013/aw2013.h
+++ b/components/esp_peripherals/lib/aw2013/aw2013.h
@@ -1,199 +1,199 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _AW2013_H_
-#define _AW2013_H_
-
-#include "esp_log.h"
-#include "esp_err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define AW2013_I2C_PORT       I2C_NUM_0
-
-#define AW2013_RESET_VALUE     0x55
-
-#define AW2013_REG_RESET       0x00
-#define AW2013_REG_GCR         0x01
-
-#define AW2013_REG_LCTR        0x30
-
-#define AW2013_REG_LCFG0       0x31
-#define AW2013_REG_LCFG1       0x32
-#define AW2013_REG_LCFG2       0x33
-
-#define AW2013_REG_PWM0        0x34
-#define AW2013_REG_PWM1        0x35
-#define AW2013_REG_PWM2        0x36
-
-#define AW2013_REG_LED0T1T2      0x37
-#define AW2013_REG_LED1T1T2      0x3A
-#define AW2013_REG_LED2T1T2      0x3D
-
-#define AW2013_REG_LED0T3T4      0x38
-#define AW2013_REG_LED1T3T4      0x3B
-#define AW2013_REG_LED2T3T4      0x3E
-
-#define AW2013_REG_LED0T0CNT     0x39
-#define AW2013_REG_LED1T0CNT     0x3C
-#define AW2013_REG_LED2T0CNT     0x3F
-
-typedef enum {
-    AW2013_BRIGHT_0,  // Turn off the lights, the electric current is 0mA
-    AW2013_BRIGHT_1,  // 5mA
-    AW2013_BRIGHT_2,  // 10mA
-    AW2013_BRIGHT_3,  // 15mA
-} aw2013_brightness_t;
-
-// Time periods of a auto flash cycle
-/*-------------------------------------------*\
-|                 __________                  |
-|                /|        |\                 |
-|               / |        | \                |
-|              /  |        |  \               |
-|     ________/   |        |   \__________    |
-|     |       |   |        |   |        |     |
-|     |<--t0->|t1 |<--t2-->|t3 |<--t4-->|     |
-\*-------------------------------------------*/
-typedef enum {
-    AW2013_TIME_0, // T0
-    AW2013_TIME_1, // T1
-    AW2013_TIME_2, // T2
-    AW2013_TIME_3, // T3
-    AW2013_TIME_4  // T4
-} aw2013_time_t;
-
-typedef enum {             // T1-T4     T0
-    AW2013_TIME_LEVEL_0,   // 0.13s  (T0 0s)
-    AW2013_TIME_LEVEL_1,   // 0.26s  (T0 0.13s)
-    AW2013_TIME_LEVEL_2,   // 0.52s  (T0 0.26s)
-    AW2013_TIME_LEVEL_3,   // 1.04s  (T0 0.52s)
-    AW2013_TIME_LEVEL_4,   // 2.08s  (T0 1.04s)
-    AW2013_TIME_LEVEL_5,   // 4.16s  (T0 2.08s)
-    AW2013_TIME_LEVEL_6,   // 8.32s  (T0 4.16s)
-    AW2013_TIME_LEVEL_7,   // 16.64s (T0 8.32s)
-    AW2013_TIME_LEVEL_8,   //        (T0 16.64s)
-} aw2013_time_level_t;
-
-/**
- * @brief Initialize the aw2013 chip
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_init(void);
-
-/**
- * @brief Deinitialize the aw2013 chip
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_deinit(void);
-
-/**
- * @brief Reset the aw2013 chip
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_reset(void);
-
-/**
- * @brief Set rgb value for the aw2013
- *
- * @param value  The value to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_set_pwm_value(uint32_t value);
-
-/**
- * @brief Set repeat times for auto flash
- *
- * @param cnt  Number of repetitions
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_set_repeat_time(uint8_t cnt);
-
-/**
- * @brief Set the time for each time period for auto flash
- *
- * @param time  The time period
- * @param level The time to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_set_time(aw2013_time_t time, aw2013_time_level_t level);
-
-/**
- * @brief Set the brightness
- *
- * @param bright The brightness to be set
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_set_brightness(aw2013_brightness_t bright);
-
-/**
- * @brief Enable the auto flash fuction
- *
- * @param en  Whether to enable
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_enable_auto_flash(bool en);
-
-/**
- * @brief Enable the fade fuction
- *
- * @param en  Whether to enable
- *
- * @return
- *     - ESP_OK Success
- *     - ESP_FAIL error
- */
-esp_err_t aw2013_enable_fade_mode(bool en);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AW2013_H_
+#define _AW2013_H_
+
+#include "esp_log.h"
+#include "esp_err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define AW2013_I2C_PORT       I2C_NUM_0
+
+#define AW2013_RESET_VALUE     0x55
+
+#define AW2013_REG_RESET       0x00
+#define AW2013_REG_GCR         0x01
+
+#define AW2013_REG_LCTR        0x30
+
+#define AW2013_REG_LCFG0       0x31
+#define AW2013_REG_LCFG1       0x32
+#define AW2013_REG_LCFG2       0x33
+
+#define AW2013_REG_PWM0        0x34
+#define AW2013_REG_PWM1        0x35
+#define AW2013_REG_PWM2        0x36
+
+#define AW2013_REG_LED0T1T2      0x37
+#define AW2013_REG_LED1T1T2      0x3A
+#define AW2013_REG_LED2T1T2      0x3D
+
+#define AW2013_REG_LED0T3T4      0x38
+#define AW2013_REG_LED1T3T4      0x3B
+#define AW2013_REG_LED2T3T4      0x3E
+
+#define AW2013_REG_LED0T0CNT     0x39
+#define AW2013_REG_LED1T0CNT     0x3C
+#define AW2013_REG_LED2T0CNT     0x3F
+
+typedef enum {
+    AW2013_BRIGHT_0,  // Turn off the lights, the electric current is 0mA
+    AW2013_BRIGHT_1,  // 5mA
+    AW2013_BRIGHT_2,  // 10mA
+    AW2013_BRIGHT_3,  // 15mA
+} aw2013_brightness_t;
+
+// Time periods of a auto flash cycle
+/*-------------------------------------------*\
+|                 __________                  |
+|                /|        |\                 |
+|               / |        | \                |
+|              /  |        |  \               |
+|     ________/   |        |   \__________    |
+|     |       |   |        |   |        |     |
+|     |<--t0->|t1 |<--t2-->|t3 |<--t4-->|     |
+\*-------------------------------------------*/
+typedef enum {
+    AW2013_TIME_0, // T0
+    AW2013_TIME_1, // T1
+    AW2013_TIME_2, // T2
+    AW2013_TIME_3, // T3
+    AW2013_TIME_4  // T4
+} aw2013_time_t;
+
+typedef enum {             // T1-T4     T0
+    AW2013_TIME_LEVEL_0,   // 0.13s  (T0 0s)
+    AW2013_TIME_LEVEL_1,   // 0.26s  (T0 0.13s)
+    AW2013_TIME_LEVEL_2,   // 0.52s  (T0 0.26s)
+    AW2013_TIME_LEVEL_3,   // 1.04s  (T0 0.52s)
+    AW2013_TIME_LEVEL_4,   // 2.08s  (T0 1.04s)
+    AW2013_TIME_LEVEL_5,   // 4.16s  (T0 2.08s)
+    AW2013_TIME_LEVEL_6,   // 8.32s  (T0 4.16s)
+    AW2013_TIME_LEVEL_7,   // 16.64s (T0 8.32s)
+    AW2013_TIME_LEVEL_8,   //        (T0 16.64s)
+} aw2013_time_level_t;
+
+/**
+ * @brief Initialize the aw2013 chip
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_init(void);
+
+/**
+ * @brief Deinitialize the aw2013 chip
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_deinit(void);
+
+/**
+ * @brief Reset the aw2013 chip
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_reset(void);
+
+/**
+ * @brief Set rgb value for the aw2013
+ *
+ * @param value  The value to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_set_pwm_value(uint32_t value);
+
+/**
+ * @brief Set repeat times for auto flash
+ *
+ * @param cnt  Number of repetitions
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_set_repeat_time(uint8_t cnt);
+
+/**
+ * @brief Set the time for each time period for auto flash
+ *
+ * @param time  The time period
+ * @param level The time to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_set_time(aw2013_time_t time, aw2013_time_level_t level);
+
+/**
+ * @brief Set the brightness
+ *
+ * @param bright The brightness to be set
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_set_brightness(aw2013_brightness_t bright);
+
+/**
+ * @brief Enable the auto flash fuction
+ *
+ * @param en  Whether to enable
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_enable_auto_flash(bool en);
+
+/**
+ * @brief Enable the fade fuction
+ *
+ * @param en  Whether to enable
+ *
+ * @return
+ *     - ESP_OK Success
+ *     - ESP_FAIL error
+ */
+esp_err_t aw2013_enable_fade_mode(bool en);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/blufi/blufi_security.c b/components/esp_peripherals/lib/blufi/blufi_security.c
index 8bc576ab..9c469e58 100644
--- a/components/esp_peripherals/lib/blufi/blufi_security.c
+++ b/components/esp_peripherals/lib/blufi/blufi_security.c
@@ -1,240 +1,240 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "sdkconfig.h"
-#include "audio_mem.h"
-#ifdef CONFIG_BLUEDROID_ENABLED
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "esp_log.h"
-#include "esp_system.h"
-
-#include "mbedtls/aes.h"
-#include "mbedtls/dhm.h"
-#include "mbedtls/md5.h"
-
-#include "audio_idf_version.h"
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-#include "esp32/rom/crc.h"
-#else
-#include "rom/crc.h"
-#endif //(ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-#include "esp_random.h"
-#endif
-
-#define BLUFI_SECURITY_TAG "BLUFI_SECURITY"
-/*
-   The SEC_TYPE_xxx is for self-defined packet data type in the procedure of "BLUFI negotiate key"
-   If using other negotiation procedure to exchange (or generate) a key, the user should redefine the type by yourself.
- */
-#define SEC_TYPE_DH_PARAM_LEN   0x00
-#define SEC_TYPE_DH_PARAM_DATA  0x01
-#define SEC_TYPE_DH_P           0x02
-#define SEC_TYPE_DH_G           0x03
-#define SEC_TYPE_DH_PUBLIC      0x04
-
-struct blufi_security {
-#define DH_SELF_PUB_KEY_LEN     128
-#define DH_SELF_PUB_KEY_BIT_LEN (DH_SELF_PUB_KEY_LEN * 8)
-    uint8_t  self_public_key[DH_SELF_PUB_KEY_LEN];
-#define SHARE_KEY_LEN           128
-#define SHARE_KEY_BIT_LEN       (SHARE_KEY_LEN * 8)
-    uint8_t  share_key[SHARE_KEY_LEN];
-    size_t   share_len;
-#define PSK_LEN                 16
-    uint8_t  psk[PSK_LEN];
-    uint8_t  *dh_param;
-    int      dh_param_len;
-    uint8_t  iv[16];
-    mbedtls_dhm_context dhm;
-    mbedtls_aes_context aes;
-};
-static struct blufi_security *blufi_sec;
-
-static int myrand (void *rng_state, unsigned char *output, size_t len)
-{
-    size_t i;
-    for (i = 0; i < len; ++i) {
-        output[i] = esp_random();
-    }
-
-    return ESP_OK;
-}
-
-void blufi_dh_negotiate_data_handler(uint8_t *data, int len, uint8_t **output_data, int *output_len, bool *need_free)
-{
-    int ret;
-    uint8_t type = data[0];
-
-    if (blufi_sec == NULL) {
-        ESP_LOGE(BLUFI_SECURITY_TAG, "BLUFI Security is not initialized");
-        return;
-    }
-
-    switch (type) {
-    case SEC_TYPE_DH_PARAM_LEN:
-        blufi_sec->dh_param_len = ((data[1]<<8)|data[2]);
-        if (blufi_sec->dh_param) {
-            audio_free(blufi_sec->dh_param);
-            blufi_sec->dh_param = NULL;
-        }
-        blufi_sec->dh_param = (uint8_t *)audio_calloc(1, blufi_sec->dh_param_len);
-        if (blufi_sec->dh_param == NULL) {
-            ESP_LOGE(BLUFI_SECURITY_TAG, "%s, Malloc failed", __func__);
-            return;
-        }
-        break;
-    case SEC_TYPE_DH_PARAM_DATA:{
-        if (blufi_sec->dh_param == NULL) {
-            ESP_LOGE(BLUFI_SECURITY_TAG, "%s, Blufi_sec->dh_param == NULL", __func__);
-            return;
-        }
-        uint8_t *param = blufi_sec->dh_param;
-        memcpy(blufi_sec->dh_param, &data[1], blufi_sec->dh_param_len);
-        ret = mbedtls_dhm_read_params(&blufi_sec->dhm, &param, &param[blufi_sec->dh_param_len]);
-        if (ret) {
-            ESP_LOGE(BLUFI_SECURITY_TAG, "%s Read param failed %d", __func__, ret);
-            return;
-        }
-        audio_free(blufi_sec->dh_param);
-        blufi_sec->dh_param = NULL;
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-        const int dhm_len = mbedtls_dhm_get_len(&blufi_sec->dhm);
-        ret = mbedtls_dhm_make_public(&blufi_sec->dhm, dhm_len, blufi_sec->self_public_key, dhm_len, myrand, NULL);
-#else
-        ret = mbedtls_dhm_make_public(&blufi_sec->dhm, (int) mbedtls_mpi_size( &blufi_sec->dhm.P ), blufi_sec->self_public_key, blufi_sec->dhm.len, myrand, NULL);
- #endif
-        if (ret) {
-            ESP_LOGE(BLUFI_SECURITY_TAG, "%s Make public failed %d", __func__, ret);
-            return;
-        }
-
-        mbedtls_dhm_calc_secret( &blufi_sec->dhm,
-                blufi_sec->share_key,
-                SHARE_KEY_BIT_LEN,
-                &blufi_sec->share_len,
-                NULL, NULL);
-
-        mbedtls_md5(blufi_sec->share_key, blufi_sec->share_len, blufi_sec->psk);
-
-        mbedtls_aes_setkey_enc(&blufi_sec->aes, blufi_sec->psk, 128);
-
-        /* Alloc output data */
-        *output_data = &blufi_sec->self_public_key[0];
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-        *output_len = dhm_len;
-#endif
-        *need_free = false;
-
-    }
-        break;
-    case SEC_TYPE_DH_P:
-        break;
-    case SEC_TYPE_DH_G:
-        break;
-    case SEC_TYPE_DH_PUBLIC:
-        break;
-    }
-}
-
-int blufi_aes_encrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len)
-{
-    int ret;
-    size_t iv_offset = 0;
-    uint8_t iv0[16];
-
-    memcpy(iv0, blufi_sec->iv, sizeof(blufi_sec->iv));
-    /* Set iv8 as the iv0[0] */
-    iv0[0] = iv8;
-
-    ret = mbedtls_aes_crypt_cfb128(&blufi_sec->aes, MBEDTLS_AES_ENCRYPT, crypt_len, &iv_offset, iv0, crypt_data, crypt_data);
-    if (ret) {
-        return ESP_FAIL;
-    }
-
-    return crypt_len;
-}
-
-int blufi_aes_decrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len)
-{
-    int ret;
-    size_t iv_offset = 0;
-    uint8_t iv0[16];
-
-    memcpy(iv0, blufi_sec->iv, sizeof(blufi_sec->iv));
-    /* Set iv8 as the iv0[0] */
-    iv0[0] = iv8;
-
-    ret = mbedtls_aes_crypt_cfb128(&blufi_sec->aes, MBEDTLS_AES_DECRYPT, crypt_len, &iv_offset, iv0, crypt_data, crypt_data);
-    if (ret) {
-        return ESP_FAIL;
-    }
-
-    return crypt_len;
-}
-
-uint16_t blufi_crc_checksum(uint8_t iv8, uint8_t *data, int len)
-{
-    /* This iv8 ignore, not used */
-    return crc16_be(0, data, len);
-}
-
-esp_err_t blufi_security_init(void)
-{
-    blufi_sec = (struct blufi_security *)audio_calloc(1, sizeof(struct blufi_security));
-    if (blufi_sec == NULL) {
-        return ESP_FAIL;
-    }
-
-    mbedtls_dhm_init(&blufi_sec->dhm);
-    mbedtls_aes_init(&blufi_sec->aes);
-
-    memset(blufi_sec->iv, 0x0, 16);
-    return ESP_OK;
-}
-
-esp_err_t blufi_security_deinit(void)
-{
-    if (blufi_sec == NULL) {
-        return ESP_FAIL;
-    }
-    if (blufi_sec->dh_param){
-        audio_free(blufi_sec->dh_param);
-        blufi_sec->dh_param = NULL;
-    }
-    mbedtls_dhm_free(&blufi_sec->dhm);
-    mbedtls_aes_free(&blufi_sec->aes);
-
-    memset(blufi_sec, 0x0, sizeof(struct blufi_security));
-
-    audio_free(blufi_sec);
-    blufi_sec = NULL;
-
-    return ESP_OK;
-}
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "sdkconfig.h"
+#include "audio_mem.h"
+#ifdef CONFIG_BLUEDROID_ENABLED
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "esp_log.h"
+#include "esp_system.h"
+
+#include "mbedtls/aes.h"
+#include "mbedtls/dhm.h"
+#include "mbedtls/md5.h"
+
+#include "audio_idf_version.h"
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+#include "esp32/rom/crc.h"
+#else
+#include "rom/crc.h"
+#endif //(ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+#include "esp_random.h"
+#endif
+
+#define BLUFI_SECURITY_TAG "BLUFI_SECURITY"
+/*
+   The SEC_TYPE_xxx is for self-defined packet data type in the procedure of "BLUFI negotiate key"
+   If using other negotiation procedure to exchange (or generate) a key, the user should redefine the type by yourself.
+ */
+#define SEC_TYPE_DH_PARAM_LEN   0x00
+#define SEC_TYPE_DH_PARAM_DATA  0x01
+#define SEC_TYPE_DH_P           0x02
+#define SEC_TYPE_DH_G           0x03
+#define SEC_TYPE_DH_PUBLIC      0x04
+
+struct blufi_security {
+#define DH_SELF_PUB_KEY_LEN     128
+#define DH_SELF_PUB_KEY_BIT_LEN (DH_SELF_PUB_KEY_LEN * 8)
+    uint8_t  self_public_key[DH_SELF_PUB_KEY_LEN];
+#define SHARE_KEY_LEN           128
+#define SHARE_KEY_BIT_LEN       (SHARE_KEY_LEN * 8)
+    uint8_t  share_key[SHARE_KEY_LEN];
+    size_t   share_len;
+#define PSK_LEN                 16
+    uint8_t  psk[PSK_LEN];
+    uint8_t  *dh_param;
+    int      dh_param_len;
+    uint8_t  iv[16];
+    mbedtls_dhm_context dhm;
+    mbedtls_aes_context aes;
+};
+static struct blufi_security *blufi_sec;
+
+static int myrand (void *rng_state, unsigned char *output, size_t len)
+{
+    size_t i;
+    for (i = 0; i < len; ++i) {
+        output[i] = esp_random();
+    }
+
+    return ESP_OK;
+}
+
+void blufi_dh_negotiate_data_handler(uint8_t *data, int len, uint8_t **output_data, int *output_len, bool *need_free)
+{
+    int ret;
+    uint8_t type = data[0];
+
+    if (blufi_sec == NULL) {
+        ESP_LOGE(BLUFI_SECURITY_TAG, "BLUFI Security is not initialized");
+        return;
+    }
+
+    switch (type) {
+    case SEC_TYPE_DH_PARAM_LEN:
+        blufi_sec->dh_param_len = ((data[1]<<8)|data[2]);
+        if (blufi_sec->dh_param) {
+            audio_free(blufi_sec->dh_param);
+            blufi_sec->dh_param = NULL;
+        }
+        blufi_sec->dh_param = (uint8_t *)audio_calloc(1, blufi_sec->dh_param_len);
+        if (blufi_sec->dh_param == NULL) {
+            ESP_LOGE(BLUFI_SECURITY_TAG, "%s, Malloc failed", __func__);
+            return;
+        }
+        break;
+    case SEC_TYPE_DH_PARAM_DATA:{
+        if (blufi_sec->dh_param == NULL) {
+            ESP_LOGE(BLUFI_SECURITY_TAG, "%s, Blufi_sec->dh_param == NULL", __func__);
+            return;
+        }
+        uint8_t *param = blufi_sec->dh_param;
+        memcpy(blufi_sec->dh_param, &data[1], blufi_sec->dh_param_len);
+        ret = mbedtls_dhm_read_params(&blufi_sec->dhm, &param, &param[blufi_sec->dh_param_len]);
+        if (ret) {
+            ESP_LOGE(BLUFI_SECURITY_TAG, "%s Read param failed %d", __func__, ret);
+            return;
+        }
+        audio_free(blufi_sec->dh_param);
+        blufi_sec->dh_param = NULL;
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+        const int dhm_len = mbedtls_dhm_get_len(&blufi_sec->dhm);
+        ret = mbedtls_dhm_make_public(&blufi_sec->dhm, dhm_len, blufi_sec->self_public_key, dhm_len, myrand, NULL);
+#else
+        ret = mbedtls_dhm_make_public(&blufi_sec->dhm, (int) mbedtls_mpi_size( &blufi_sec->dhm.P ), blufi_sec->self_public_key, blufi_sec->dhm.len, myrand, NULL);
+ #endif
+        if (ret) {
+            ESP_LOGE(BLUFI_SECURITY_TAG, "%s Make public failed %d", __func__, ret);
+            return;
+        }
+
+        mbedtls_dhm_calc_secret( &blufi_sec->dhm,
+                blufi_sec->share_key,
+                SHARE_KEY_BIT_LEN,
+                &blufi_sec->share_len,
+                NULL, NULL);
+
+        mbedtls_md5(blufi_sec->share_key, blufi_sec->share_len, blufi_sec->psk);
+
+        mbedtls_aes_setkey_enc(&blufi_sec->aes, blufi_sec->psk, 128);
+
+        /* Alloc output data */
+        *output_data = &blufi_sec->self_public_key[0];
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+        *output_len = dhm_len;
+#endif
+        *need_free = false;
+
+    }
+        break;
+    case SEC_TYPE_DH_P:
+        break;
+    case SEC_TYPE_DH_G:
+        break;
+    case SEC_TYPE_DH_PUBLIC:
+        break;
+    }
+}
+
+int blufi_aes_encrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len)
+{
+    int ret;
+    size_t iv_offset = 0;
+    uint8_t iv0[16];
+
+    memcpy(iv0, blufi_sec->iv, sizeof(blufi_sec->iv));
+    /* Set iv8 as the iv0[0] */
+    iv0[0] = iv8;
+
+    ret = mbedtls_aes_crypt_cfb128(&blufi_sec->aes, MBEDTLS_AES_ENCRYPT, crypt_len, &iv_offset, iv0, crypt_data, crypt_data);
+    if (ret) {
+        return ESP_FAIL;
+    }
+
+    return crypt_len;
+}
+
+int blufi_aes_decrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len)
+{
+    int ret;
+    size_t iv_offset = 0;
+    uint8_t iv0[16];
+
+    memcpy(iv0, blufi_sec->iv, sizeof(blufi_sec->iv));
+    /* Set iv8 as the iv0[0] */
+    iv0[0] = iv8;
+
+    ret = mbedtls_aes_crypt_cfb128(&blufi_sec->aes, MBEDTLS_AES_DECRYPT, crypt_len, &iv_offset, iv0, crypt_data, crypt_data);
+    if (ret) {
+        return ESP_FAIL;
+    }
+
+    return crypt_len;
+}
+
+uint16_t blufi_crc_checksum(uint8_t iv8, uint8_t *data, int len)
+{
+    /* This iv8 ignore, not used */
+    return crc16_be(0, data, len);
+}
+
+esp_err_t blufi_security_init(void)
+{
+    blufi_sec = (struct blufi_security *)audio_calloc(1, sizeof(struct blufi_security));
+    if (blufi_sec == NULL) {
+        return ESP_FAIL;
+    }
+
+    mbedtls_dhm_init(&blufi_sec->dhm);
+    mbedtls_aes_init(&blufi_sec->aes);
+
+    memset(blufi_sec->iv, 0x0, 16);
+    return ESP_OK;
+}
+
+esp_err_t blufi_security_deinit(void)
+{
+    if (blufi_sec == NULL) {
+        return ESP_FAIL;
+    }
+    if (blufi_sec->dh_param){
+        audio_free(blufi_sec->dh_param);
+        blufi_sec->dh_param = NULL;
+    }
+    mbedtls_dhm_free(&blufi_sec->dhm);
+    mbedtls_aes_free(&blufi_sec->aes);
+
+    memset(blufi_sec, 0x0, sizeof(struct blufi_security));
+
+    audio_free(blufi_sec);
+    blufi_sec = NULL;
+
+    return ESP_OK;
+}
+
+#endif
diff --git a/components/esp_peripherals/lib/blufi/blufi_security.h b/components/esp_peripherals/lib/blufi/blufi_security.h
index 9de98b8a..945659e1 100644
--- a/components/esp_peripherals/lib/blufi/blufi_security.h
+++ b/components/esp_peripherals/lib/blufi/blufi_security.h
@@ -1,99 +1,99 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _BLUFI_SECURITY_H_
-#define _BLUFI_SECURITY_H_
-
-#include "esp_log.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief       BLUFI negotiate data handler
- *
- * @param[in] data          data from phone
- * @param[in] len           length of data from phone
- * @param[in] output_data   data to be sent to phone
- * @param[in] output_len    length of data to be sent to phone
- */
-void blufi_dh_negotiate_data_handler(uint8_t *data, int len, uint8_t **output_data, int *output_len, bool *need_free);
-
-/**
- * @brief       BLUFI  encrypt the data after negotiating a share key
- *
- * @param[in] iv8           initial vector(8bit), normally, blufi core will input packet sequence number
- * @param[in] crypt_data    plain text and encrypted data, the encrypt function must support autochthonous encrypt
- * @param[in] crypt_len     length of plain text
- *
- * @return  Nonnegative number is encrypted length, if error, return negative number;
- */
-int blufi_aes_encrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len);
-
-/**
- * @brief       BLUFI  decrypt the data after negotiating a share key
- *
- * @param[in] iv8           initial vector(8bit), normally, blufi core will input packet sequence number
- * @param[in] crypt_data    encrypted data and plain text, the encrypt function must support autochthonous decrypt
- * @param[in] crypt_len     length of encrypted text
- *
- * @return  Nonnegative number is decrypted length, if error, return negative number;
- */
-int blufi_aes_decrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len);
-
-/**
- * @brief      BLUFI CRC check sum function
- *
- * @param[in] iv8       initial vector(8bit), normally, blufi core will input packet sequence number
- * @param[in] data      data need to checksum
- * @param[in] len       length of data
- *
- * @return  None
- */
-uint16_t blufi_crc_checksum(uint8_t iv8, uint8_t *data, int len);
-
-/**
- * @brief      Initialize and allocate the resource for BLUFI security
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t blufi_security_init(void);
-
-/**
- * @brief      Uninitialize and free the resource for BLUFI security
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t blufi_security_deinit(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _BLUFI_SECURITY_H_
+#define _BLUFI_SECURITY_H_
+
+#include "esp_log.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief       BLUFI negotiate data handler
+ *
+ * @param[in] data          data from phone
+ * @param[in] len           length of data from phone
+ * @param[in] output_data   data to be sent to phone
+ * @param[in] output_len    length of data to be sent to phone
+ */
+void blufi_dh_negotiate_data_handler(uint8_t *data, int len, uint8_t **output_data, int *output_len, bool *need_free);
+
+/**
+ * @brief       BLUFI  encrypt the data after negotiating a share key
+ *
+ * @param[in] iv8           initial vector(8bit), normally, blufi core will input packet sequence number
+ * @param[in] crypt_data    plain text and encrypted data, the encrypt function must support autochthonous encrypt
+ * @param[in] crypt_len     length of plain text
+ *
+ * @return  Nonnegative number is encrypted length, if error, return negative number;
+ */
+int blufi_aes_encrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len);
+
+/**
+ * @brief       BLUFI  decrypt the data after negotiating a share key
+ *
+ * @param[in] iv8           initial vector(8bit), normally, blufi core will input packet sequence number
+ * @param[in] crypt_data    encrypted data and plain text, the encrypt function must support autochthonous decrypt
+ * @param[in] crypt_len     length of encrypted text
+ *
+ * @return  Nonnegative number is decrypted length, if error, return negative number;
+ */
+int blufi_aes_decrypt(uint8_t iv8, uint8_t *crypt_data, int crypt_len);
+
+/**
+ * @brief      BLUFI CRC check sum function
+ *
+ * @param[in] iv8       initial vector(8bit), normally, blufi core will input packet sequence number
+ * @param[in] data      data need to checksum
+ * @param[in] len       length of data
+ *
+ * @return  None
+ */
+uint16_t blufi_crc_checksum(uint8_t iv8, uint8_t *data, int len);
+
+/**
+ * @brief      Initialize and allocate the resource for BLUFI security
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t blufi_security_init(void);
+
+/**
+ * @brief      Uninitialize and free the resource for BLUFI security
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t blufi_security_deinit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/blufi/wifibleconfig.c b/components/esp_peripherals/lib/blufi/wifibleconfig.c
index f73406fa..ebd0f210 100644
--- a/components/esp_peripherals/lib/blufi/wifibleconfig.c
+++ b/components/esp_peripherals/lib/blufi/wifibleconfig.c
@@ -1,268 +1,268 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-#include <math.h>
-#include "audio_mem.h"
-#include "audio_idf_version.h"
-
-#if defined(CONFIG_BT_BLE_BLUFI_ENABLE)
-#include "esp_system.h"
-#include "esp_bt.h"
-#include "esp_log.h"
-#include "audio_error.h"
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
-#include "esp_blufi.h"
-#else
-#include "esp_blufi_api.h"
-#endif
-
-#ifdef CONFIG_BT_BLE_BLUFI_ENABLE
-#include "esp_bt_defs.h"
-#include "esp_gap_ble_api.h"
-#include "esp_bt_device.h"
-#include "esp_bt_main.h"
-#include "esp_gap_bt_api.h"
-#elif CONFIG_BT_NIMBLE_ENABLED
-#include "esp_nimble_hci.h"
-#include "nimble/nimble_port.h"
-#include "nimble/nimble_port_freertos.h"
-#include "host/ble_hs.h"
-#include "host/util/util.h"
-#include "services/gap/ble_svc_gap.h"
-#include "services/gatt/ble_svc_gatt.h"
-#include "console/console.h"
-#endif
-
-#include "esp_smartconfig.h"
-#include "audio_error.h"
-#include "esp_wifi.h"
-#include "wifibleconfig.h"
-#include "periph_wifi.h"
-#include "blufi_security.h"
-
-#define WIFI_BLE_TAG        "WIFI_BLE_CONFIG"
-#define BLUFI_DEVICE_NAME   "BLUFI_DEVICE"
-#define WIFI_LIST_NUM       (10)
-
-static uint8_t wifi_ble_service_uuid128[32] = {
-    /* LSB <--------------------------------------------------------------------------------> MSB */
-    //first uuid, 16bit, [12],[13] is the value
-    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
-};
-typedef struct wifi_ble_config {
-    uint8_t ble_server_if;
-    uint16_t ble_conn_id;
-    wifi_config_t sta_config;
-    esp_periph_handle_t periph;
-} wifi_ble_config_t;
-
-static wifi_ble_config_t *g_wifi_ble_config = NULL;
-
-static void wifi_ble_event_callback(esp_blufi_cb_event_t event, esp_blufi_cb_param_t *param);
-
-static esp_ble_adv_data_t wifi_ble_adv_data = {
-    .set_scan_rsp = false,
-    .include_name = true,
-    .include_txpower = true,
-    .min_interval = 0x100,
-    .max_interval = 0x100,
-    .appearance = 0x00,
-    .manufacturer_len = 0,
-    .p_manufacturer_data =  NULL,
-    .service_data_len = 0,
-    .p_service_data = NULL,
-    .service_uuid_len = 16,
-    .p_service_uuid = wifi_ble_service_uuid128,
-    .flag = 0x6,
-};
-
-static esp_ble_adv_params_t wifi_ble_adv_params = {
-    .adv_int_min        = 0x100,
-    .adv_int_max        = 0x100,
-    .adv_type           = ADV_TYPE_IND,
-    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,
-    .channel_map        = ADV_CHNL_ALL,
-    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
-};
-
-static esp_blufi_callbacks_t wifi_ble_callbacks = {
-    .event_cb = wifi_ble_event_callback,
-    .negotiate_data_handler = blufi_dh_negotiate_data_handler,
-    .encrypt_func = blufi_aes_encrypt,
-    .decrypt_func = blufi_aes_decrypt,
-    .checksum_func = blufi_crc_checksum,
-};
-
-static void wifi_ble_gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
-{
-    switch (event) {
-        case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
-            esp_ble_gap_start_advertising(&wifi_ble_adv_params);
-            break;
-        default:
-            break;
-    }
-}
-
-esp_err_t ble_config_stop(void)
-{
-    if (g_wifi_ble_config != NULL) {
-        audio_free(g_wifi_ble_config);
-        g_wifi_ble_config = NULL;
-    }
-    blufi_security_deinit();
-    esp_blufi_profile_deinit();
-    esp_bluedroid_disable();
-    esp_bluedroid_deinit();
-    return ESP_OK;
-}
-
-static void wifi_ble_event_callback(esp_blufi_cb_event_t event, esp_blufi_cb_param_t *param)
-{
-    /* actually, should post to blufi_task handle the procedure,
-     * now, as a audio_ble, we do it more simply */
-    esp_err_t ret ;
-    switch (event) {
-        case ESP_BLUFI_EVENT_INIT_FINISH:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI init finish");
-            esp_ble_gap_set_device_name(BLUFI_DEVICE_NAME);
-            esp_ble_gap_config_adv_data(&wifi_ble_adv_data);
-            break;
-        case ESP_BLUFI_EVENT_DEINIT_FINISH:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI deinit finish");
-            break;
-        case ESP_BLUFI_EVENT_BLE_CONNECT:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI ble connect");
-            esp_smartconfig_stop();
-            g_wifi_ble_config->ble_server_if = param->connect.server_if;
-            g_wifi_ble_config->ble_conn_id = param->connect.conn_id;
-            break;
-        case ESP_BLUFI_EVENT_BLE_DISCONNECT:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI ble disconnect");
-            break;
-        case ESP_BLUFI_EVENT_SET_WIFI_OPMODE:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI Set WIFI opmode %d", param->wifi_mode.op_mode);
-            ESP_ERROR_CHECK( esp_wifi_set_mode(param->wifi_mode.op_mode) );
-            break;
-        case ESP_BLUFI_EVENT_REQ_CONNECT_TO_AP:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI request wifi connect to AP");
-            esp_wifi_disconnect();
-            if (ESP_OK != esp_wifi_connect()) {
-                esp_periph_send_event(g_wifi_ble_config->periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
-            } else {
-                esp_periph_send_event(g_wifi_ble_config->periph, PERIPH_WIFI_CONFIG_DONE, NULL, 0);
-                ble_config_stop();
-            }
-            break;
-        case ESP_BLUFI_EVENT_REQ_DISCONNECT_FROM_AP:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI request wifi disconnect from AP");
-            esp_wifi_disconnect();
-            break;
-        case ESP_BLUFI_EVENT_GET_WIFI_STATUS: {
-                wifi_mode_t mode;
-                esp_blufi_extra_info_t info;
-                esp_wifi_get_mode(&mode);
-                memset(&info, 0, sizeof(esp_blufi_extra_info_t));
-                info.sta_bssid_set = true;
-                info.sta_ssid = g_wifi_ble_config->sta_config.sta.ssid;
-                esp_blufi_send_wifi_conn_report(mode, ESP_BLUFI_STA_CONN_SUCCESS, 0, &info);
-                ESP_LOGI(WIFI_BLE_TAG, "BLUFI get wifi status from AP");
-                break;
-            }
-        case ESP_BLUFI_EVENT_RECV_SLAVE_DISCONNECT_BLE:
-            ESP_LOGI(WIFI_BLE_TAG, "BLUFI close a gatt connection");
-            esp_blufi_close(g_wifi_ble_config->ble_server_if, g_wifi_ble_config->ble_conn_id);
-            break;
-        case ESP_BLUFI_EVENT_DEAUTHENTICATE_STA:
-            /* TODO */
-            break;
-        case ESP_BLUFI_EVENT_RECV_STA_BSSID:
-            memcpy(g_wifi_ble_config->sta_config.sta.bssid, param->sta_bssid.bssid, 6);
-            g_wifi_ble_config->sta_config.sta.bssid_set = 1;
-            esp_wifi_set_config(WIFI_IF_STA, &g_wifi_ble_config->sta_config);
-            ESP_LOGI(WIFI_BLE_TAG, "Recv STA BSSID %s", g_wifi_ble_config->sta_config.sta.bssid);
-            break;
-        case ESP_BLUFI_EVENT_RECV_STA_SSID:
-            strncpy((char *)g_wifi_ble_config->sta_config.sta.ssid, (char *)param->sta_ssid.ssid, param->sta_ssid.ssid_len);
-            g_wifi_ble_config->sta_config.sta.ssid[param->sta_ssid.ssid_len] = '\0';
-            ret = esp_wifi_set_config(WIFI_IF_STA, &g_wifi_ble_config->sta_config);
-            ESP_LOGI(WIFI_BLE_TAG, "Recv STA SSID ret %d %s", ret, g_wifi_ble_config->sta_config.sta.ssid);
-            break;
-        case ESP_BLUFI_EVENT_RECV_STA_PASSWD:
-            strncpy((char *)g_wifi_ble_config->sta_config.sta.password, (char *)param->sta_passwd.passwd, param->sta_passwd.passwd_len);
-            g_wifi_ble_config->sta_config.sta.password[param->sta_passwd.passwd_len] = '\0';
-            esp_wifi_set_config(WIFI_IF_STA, &g_wifi_ble_config->sta_config);
-            ESP_LOGI(WIFI_BLE_TAG, "Recv STA PASSWORD %s", g_wifi_ble_config->sta_config.sta.password);
-            break;
-        default:
-            ESP_LOGE(WIFI_BLE_TAG, "Event %d is not supported", event);
-            break;
-    }
-}
-
-esp_err_t ble_config_start(esp_periph_handle_t periph)
-{
-    ESP_LOGI(WIFI_BLE_TAG, "ble_config_start");
-
-    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
-    if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_IDLE) {
-        if (esp_bt_controller_init(&bt_cfg) != ESP_OK) {
-            ESP_LOGE(WIFI_BLE_TAG, "%s initialize controller failed", __func__);
-            return ESP_FAIL;
-        }
-
-        if (esp_bt_controller_enable(ESP_BT_MODE_BLE) != ESP_OK) {
-            ESP_LOGE(WIFI_BLE_TAG, "%s enable controller failed", __func__);
-            return ESP_FAIL;
-        }
-    }
-    if (esp_bluedroid_get_status() == ESP_BLUEDROID_STATUS_UNINITIALIZED) {
-        if (esp_bluedroid_init() != ESP_OK) {
-            ESP_LOGE(WIFI_BLE_TAG, "%s esp_bluedroid_init failed", __func__);
-            return ESP_FAIL;
-        }
-        if (esp_bluedroid_enable() != ESP_OK) {
-            ESP_LOGE(WIFI_BLE_TAG, "%s esp_bluedroid_enable failed", __func__);
-            return ESP_FAIL;
-        }
-    }
-    ESP_LOGI(WIFI_BLE_TAG, "BD ADDR: "ESP_BD_ADDR_STR"", ESP_BD_ADDR_HEX(esp_bt_dev_get_address()));
-    ESP_LOGI(WIFI_BLE_TAG, "BLUFI VERSION %04x", esp_blufi_get_version());
-
-    g_wifi_ble_config = audio_calloc(1, sizeof(wifi_ble_config_t));
-    AUDIO_MEM_CHECK(WIFI_BLE_TAG, g_wifi_ble_config, return ESP_FAIL);
-    g_wifi_ble_config->periph = periph;
-
-    blufi_security_init();
-    esp_ble_gap_register_callback(wifi_ble_gap_event_handler);
-    esp_blufi_register_callbacks(&wifi_ble_callbacks);
-    esp_blufi_profile_init();
-
-    return ESP_OK;
-}
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include "audio_mem.h"
+#include "audio_idf_version.h"
+
+#if defined(CONFIG_BT_BLE_BLUFI_ENABLE)
+#include "esp_system.h"
+#include "esp_bt.h"
+#include "esp_log.h"
+#include "audio_error.h"
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
+#include "esp_blufi.h"
+#else
+#include "esp_blufi_api.h"
+#endif
+
+#ifdef CONFIG_BT_BLE_BLUFI_ENABLE
+#include "esp_bt_defs.h"
+#include "esp_gap_ble_api.h"
+#include "esp_bt_device.h"
+#include "esp_bt_main.h"
+#include "esp_gap_bt_api.h"
+#elif CONFIG_BT_NIMBLE_ENABLED
+#include "esp_nimble_hci.h"
+#include "nimble/nimble_port.h"
+#include "nimble/nimble_port_freertos.h"
+#include "host/ble_hs.h"
+#include "host/util/util.h"
+#include "services/gap/ble_svc_gap.h"
+#include "services/gatt/ble_svc_gatt.h"
+#include "console/console.h"
+#endif
+
+#include "esp_smartconfig.h"
+#include "audio_error.h"
+#include "esp_wifi.h"
+#include "wifibleconfig.h"
+#include "periph_wifi.h"
+#include "blufi_security.h"
+
+#define WIFI_BLE_TAG        "WIFI_BLE_CONFIG"
+#define BLUFI_DEVICE_NAME   "BLUFI_DEVICE"
+#define WIFI_LIST_NUM       (10)
+
+static uint8_t wifi_ble_service_uuid128[32] = {
+    /* LSB <--------------------------------------------------------------------------------> MSB */
+    //first uuid, 16bit, [12],[13] is the value
+    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
+};
+typedef struct wifi_ble_config {
+    uint8_t ble_server_if;
+    uint16_t ble_conn_id;
+    wifi_config_t sta_config;
+    esp_periph_handle_t periph;
+} wifi_ble_config_t;
+
+static wifi_ble_config_t *g_wifi_ble_config = NULL;
+
+static void wifi_ble_event_callback(esp_blufi_cb_event_t event, esp_blufi_cb_param_t *param);
+
+static esp_ble_adv_data_t wifi_ble_adv_data = {
+    .set_scan_rsp = false,
+    .include_name = true,
+    .include_txpower = true,
+    .min_interval = 0x100,
+    .max_interval = 0x100,
+    .appearance = 0x00,
+    .manufacturer_len = 0,
+    .p_manufacturer_data =  NULL,
+    .service_data_len = 0,
+    .p_service_data = NULL,
+    .service_uuid_len = 16,
+    .p_service_uuid = wifi_ble_service_uuid128,
+    .flag = 0x6,
+};
+
+static esp_ble_adv_params_t wifi_ble_adv_params = {
+    .adv_int_min        = 0x100,
+    .adv_int_max        = 0x100,
+    .adv_type           = ADV_TYPE_IND,
+    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,
+    .channel_map        = ADV_CHNL_ALL,
+    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
+};
+
+static esp_blufi_callbacks_t wifi_ble_callbacks = {
+    .event_cb = wifi_ble_event_callback,
+    .negotiate_data_handler = blufi_dh_negotiate_data_handler,
+    .encrypt_func = blufi_aes_encrypt,
+    .decrypt_func = blufi_aes_decrypt,
+    .checksum_func = blufi_crc_checksum,
+};
+
+static void wifi_ble_gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
+{
+    switch (event) {
+        case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
+            esp_ble_gap_start_advertising(&wifi_ble_adv_params);
+            break;
+        default:
+            break;
+    }
+}
+
+esp_err_t ble_config_stop(void)
+{
+    if (g_wifi_ble_config != NULL) {
+        audio_free(g_wifi_ble_config);
+        g_wifi_ble_config = NULL;
+    }
+    blufi_security_deinit();
+    esp_blufi_profile_deinit();
+    esp_bluedroid_disable();
+    esp_bluedroid_deinit();
+    return ESP_OK;
+}
+
+static void wifi_ble_event_callback(esp_blufi_cb_event_t event, esp_blufi_cb_param_t *param)
+{
+    /* actually, should post to blufi_task handle the procedure,
+     * now, as a audio_ble, we do it more simply */
+    esp_err_t ret ;
+    switch (event) {
+        case ESP_BLUFI_EVENT_INIT_FINISH:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI init finish");
+            esp_ble_gap_set_device_name(BLUFI_DEVICE_NAME);
+            esp_ble_gap_config_adv_data(&wifi_ble_adv_data);
+            break;
+        case ESP_BLUFI_EVENT_DEINIT_FINISH:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI deinit finish");
+            break;
+        case ESP_BLUFI_EVENT_BLE_CONNECT:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI ble connect");
+            esp_smartconfig_stop();
+            g_wifi_ble_config->ble_server_if = param->connect.server_if;
+            g_wifi_ble_config->ble_conn_id = param->connect.conn_id;
+            break;
+        case ESP_BLUFI_EVENT_BLE_DISCONNECT:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI ble disconnect");
+            break;
+        case ESP_BLUFI_EVENT_SET_WIFI_OPMODE:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI Set WIFI opmode %d", param->wifi_mode.op_mode);
+            ESP_ERROR_CHECK( esp_wifi_set_mode(param->wifi_mode.op_mode) );
+            break;
+        case ESP_BLUFI_EVENT_REQ_CONNECT_TO_AP:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI request wifi connect to AP");
+            esp_wifi_disconnect();
+            if (ESP_OK != esp_wifi_connect()) {
+                esp_periph_send_event(g_wifi_ble_config->periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
+            } else {
+                esp_periph_send_event(g_wifi_ble_config->periph, PERIPH_WIFI_CONFIG_DONE, NULL, 0);
+                ble_config_stop();
+            }
+            break;
+        case ESP_BLUFI_EVENT_REQ_DISCONNECT_FROM_AP:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI request wifi disconnect from AP");
+            esp_wifi_disconnect();
+            break;
+        case ESP_BLUFI_EVENT_GET_WIFI_STATUS: {
+                wifi_mode_t mode;
+                esp_blufi_extra_info_t info;
+                esp_wifi_get_mode(&mode);
+                memset(&info, 0, sizeof(esp_blufi_extra_info_t));
+                info.sta_bssid_set = true;
+                info.sta_ssid = g_wifi_ble_config->sta_config.sta.ssid;
+                esp_blufi_send_wifi_conn_report(mode, ESP_BLUFI_STA_CONN_SUCCESS, 0, &info);
+                ESP_LOGI(WIFI_BLE_TAG, "BLUFI get wifi status from AP");
+                break;
+            }
+        case ESP_BLUFI_EVENT_RECV_SLAVE_DISCONNECT_BLE:
+            ESP_LOGI(WIFI_BLE_TAG, "BLUFI close a gatt connection");
+            esp_blufi_close(g_wifi_ble_config->ble_server_if, g_wifi_ble_config->ble_conn_id);
+            break;
+        case ESP_BLUFI_EVENT_DEAUTHENTICATE_STA:
+            /* TODO */
+            break;
+        case ESP_BLUFI_EVENT_RECV_STA_BSSID:
+            memcpy(g_wifi_ble_config->sta_config.sta.bssid, param->sta_bssid.bssid, 6);
+            g_wifi_ble_config->sta_config.sta.bssid_set = 1;
+            esp_wifi_set_config(WIFI_IF_STA, &g_wifi_ble_config->sta_config);
+            ESP_LOGI(WIFI_BLE_TAG, "Recv STA BSSID %s", g_wifi_ble_config->sta_config.sta.bssid);
+            break;
+        case ESP_BLUFI_EVENT_RECV_STA_SSID:
+            strncpy((char *)g_wifi_ble_config->sta_config.sta.ssid, (char *)param->sta_ssid.ssid, param->sta_ssid.ssid_len);
+            g_wifi_ble_config->sta_config.sta.ssid[param->sta_ssid.ssid_len] = '\0';
+            ret = esp_wifi_set_config(WIFI_IF_STA, &g_wifi_ble_config->sta_config);
+            ESP_LOGI(WIFI_BLE_TAG, "Recv STA SSID ret %d %s", ret, g_wifi_ble_config->sta_config.sta.ssid);
+            break;
+        case ESP_BLUFI_EVENT_RECV_STA_PASSWD:
+            strncpy((char *)g_wifi_ble_config->sta_config.sta.password, (char *)param->sta_passwd.passwd, param->sta_passwd.passwd_len);
+            g_wifi_ble_config->sta_config.sta.password[param->sta_passwd.passwd_len] = '\0';
+            esp_wifi_set_config(WIFI_IF_STA, &g_wifi_ble_config->sta_config);
+            ESP_LOGI(WIFI_BLE_TAG, "Recv STA PASSWORD %s", g_wifi_ble_config->sta_config.sta.password);
+            break;
+        default:
+            ESP_LOGE(WIFI_BLE_TAG, "Event %d is not supported", event);
+            break;
+    }
+}
+
+esp_err_t ble_config_start(esp_periph_handle_t periph)
+{
+    ESP_LOGI(WIFI_BLE_TAG, "ble_config_start");
+
+    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
+    if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_IDLE) {
+        if (esp_bt_controller_init(&bt_cfg) != ESP_OK) {
+            ESP_LOGE(WIFI_BLE_TAG, "%s initialize controller failed", __func__);
+            return ESP_FAIL;
+        }
+
+        if (esp_bt_controller_enable(ESP_BT_MODE_BLE) != ESP_OK) {
+            ESP_LOGE(WIFI_BLE_TAG, "%s enable controller failed", __func__);
+            return ESP_FAIL;
+        }
+    }
+    if (esp_bluedroid_get_status() == ESP_BLUEDROID_STATUS_UNINITIALIZED) {
+        if (esp_bluedroid_init() != ESP_OK) {
+            ESP_LOGE(WIFI_BLE_TAG, "%s esp_bluedroid_init failed", __func__);
+            return ESP_FAIL;
+        }
+        if (esp_bluedroid_enable() != ESP_OK) {
+            ESP_LOGE(WIFI_BLE_TAG, "%s esp_bluedroid_enable failed", __func__);
+            return ESP_FAIL;
+        }
+    }
+    ESP_LOGI(WIFI_BLE_TAG, "BD ADDR: "ESP_BD_ADDR_STR"", ESP_BD_ADDR_HEX(esp_bt_dev_get_address()));
+    ESP_LOGI(WIFI_BLE_TAG, "BLUFI VERSION %04x", esp_blufi_get_version());
+
+    g_wifi_ble_config = audio_calloc(1, sizeof(wifi_ble_config_t));
+    AUDIO_MEM_CHECK(WIFI_BLE_TAG, g_wifi_ble_config, return ESP_FAIL);
+    g_wifi_ble_config->periph = periph;
+
+    blufi_security_init();
+    esp_ble_gap_register_callback(wifi_ble_gap_event_handler);
+    esp_blufi_register_callbacks(&wifi_ble_callbacks);
+    esp_blufi_profile_init();
+
+    return ESP_OK;
+}
+#endif
diff --git a/components/esp_peripherals/lib/blufi/wifibleconfig.h b/components/esp_peripherals/lib/blufi/wifibleconfig.h
index d2aaa3a2..fc0dd121 100644
--- a/components/esp_peripherals/lib/blufi/wifibleconfig.h
+++ b/components/esp_peripherals/lib/blufi/wifibleconfig.h
@@ -1,59 +1,59 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _WIFI_BLECONFIG_H_
-#define _WIFI_BLECONFIG_H_
-
-#include "esp_err.h"
-#include "esp_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      Start Wi-Fi BLE config
- *
- * @param[in]  periph   The peripheral handle
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t ble_config_start(esp_periph_handle_t periph);
-
-/**
- * @brief      Stop Wi-Fi BLE config.
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t ble_config_stop(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _WIFI_BLECONFIG_H_
+#define _WIFI_BLECONFIG_H_
+
+#include "esp_err.h"
+#include "esp_peripherals.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      Start Wi-Fi BLE config
+ *
+ * @param[in]  periph   The peripheral handle
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t ble_config_start(esp_periph_handle_t periph);
+
+/**
+ * @brief      Stop Wi-Fi BLE config.
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t ble_config_stop(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/button/button.c b/components/esp_peripherals/lib/button/button.c
index 26938818..8666917a 100644
--- a/components/esp_peripherals/lib/button/button.c
+++ b/components/esp_peripherals/lib/button/button.c
@@ -1,198 +1,198 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/queue.h"
-
-#include "esp_log.h"
-#include "driver/gpio.h"
-#include "sys/queue.h"
-#include "button.h"
-#include "audio_mem.h"
-
-#ifdef periph_tick_get
-#define tick_get periph_tick_get
-#else
-static long long tick_get()
-{
-    struct timeval te;
-    gettimeofday(&te, NULL);
-    long long milliseconds = te.tv_sec * 1000LL + te.tv_usec / 1000;
-    return milliseconds;
-}
-#endif
-
-static const char *TAG = "BUTTON";
-
-typedef struct esp_button_item {
-    int                         gpio_num;
-    long long                   last_press_tick;
-    bool                        long_pressed;
-    STAILQ_ENTRY(esp_button_item)    entry;
-} esp_button_item_t;
-
-struct esp_button {
-    int long_press_time_ms;
-    uint64_t gpio_mask;
-    STAILQ_HEAD(esp_button_list, esp_button_item) btn_list;
-};
-
-static button_status_t button_get_state(esp_button_handle_t button, esp_button_item_t *btn_item)
-{
-    int level = gpio_get_level(btn_item->gpio_num);
-    int active_level = 0;
-    int deactive_level = 1;
-
-    if (btn_item->last_press_tick == 0 && level == active_level) {
-        btn_item->last_press_tick = tick_get();
-        btn_item->long_pressed = false;
-        return BTN_PRESSED;
-    }
-
-    if (level == deactive_level && btn_item->last_press_tick && tick_get() - btn_item->last_press_tick > button->long_press_time_ms) {
-        btn_item->last_press_tick = 0;
-        btn_item->long_pressed = false;
-        return BTN_LONG_RELEASE;
-    }
-
-    if (level == deactive_level && btn_item->last_press_tick) {
-        btn_item->last_press_tick = 0;
-        btn_item->long_pressed = false;
-        return BTN_RELEASE;
-    }
-
-    if (btn_item->long_pressed == false && level == active_level && tick_get() - btn_item->last_press_tick > button->long_press_time_ms) {
-        btn_item->long_pressed = true;
-        return BTN_LONG_PRESS;
-    }
-    return BTN_UNCHANGE;
-}
-
-esp_button_handle_t button_init(button_config_t *config)
-{
-    esp_button_handle_t btn = audio_calloc(1, sizeof(struct esp_button));
-    AUDIO_MEM_CHECK(TAG, btn, return NULL);
-    if (config->gpio_mask <= 0) {
-        ESP_LOGE(TAG, "required at least 1 gpio");
-        return NULL;
-    }
-    btn->gpio_mask = config->gpio_mask;
-    btn->long_press_time_ms = config->long_press_time_ms;
-
-    if (btn->long_press_time_ms == 0) {
-        btn->long_press_time_ms = DEFAULT_LONG_PRESS_TIME_MS;
-    }
-
-    gpio_config_t gpiocfg = {
-        .pin_bit_mask = btn->gpio_mask,
-        .mode = GPIO_MODE_INPUT,
-        .pull_up_en = GPIO_PULLUP_ENABLE,
-        .pull_down_en = GPIO_PULLDOWN_DISABLE,
-        .intr_type = GPIO_INTR_ANYEDGE,
-    };
-    gpio_config(&gpiocfg);
-
-    uint64_t gpio_mask = btn->gpio_mask;
-    int gpio_num = 0;
-
-    STAILQ_INIT(&btn->btn_list);
-    while (gpio_mask) {
-        if (gpio_mask & 0x01) {
-            ESP_LOGD(TAG, "Mask = %llx, current_mask = %llx, idx=%d", btn->gpio_mask, gpio_mask, gpio_num);
-            esp_button_item_t *new_btn = audio_calloc(1, sizeof(esp_button_item_t));
-            AUDIO_MEM_CHECK(TAG, new_btn, {
-                button_destroy(btn);
-                return NULL;
-            });
-            new_btn->gpio_num = gpio_num;
-            if (config->button_intr_handler) {
-                gpio_set_intr_type(gpio_num, GPIO_INTR_ANYEDGE);
-                gpio_isr_handler_add(gpio_num, config->button_intr_handler, config->intr_context);
-                gpio_intr_enable(gpio_num);
-            }
-            STAILQ_INSERT_TAIL(&btn->btn_list, new_btn, entry);
-        }
-        gpio_mask >>= 1;
-        gpio_num ++;
-    }
-    return btn;
-}
-
-bool button_read(esp_button_handle_t button, button_result_t *result)
-{
-    esp_button_item_t *btn_item;
-    button_status_t btn_status;
-    bool changed = false;
-    memset(result, 0, sizeof(button_result_t));
-    uint64_t tmp;
-    STAILQ_FOREACH(btn_item, &button->btn_list, entry) {
-        btn_status = button_get_state(button, btn_item);
-        switch (btn_status) {
-            case BTN_UNCHANGE:
-                break;
-            case BTN_PRESSED:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= btn_item->gpio_num;
-                result->press_mask |= tmp;
-                break;
-            case BTN_RELEASE:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= btn_item->gpio_num;
-                result->release_mask |=  tmp;
-                break;
-            case BTN_LONG_RELEASE:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= btn_item->gpio_num;
-                result->long_release_mask |=  tmp;
-                break;
-            case BTN_LONG_PRESS:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= btn_item->gpio_num;
-                result->long_press_mask |=  tmp;
-                break;
-        }
-    }
-    return changed;
-}
-
-esp_err_t button_destroy(esp_button_handle_t button)
-{
-    esp_button_item_t *btn_item, *tmp;
-    STAILQ_FOREACH_SAFE(btn_item, &button->btn_list, entry, tmp) {
-        gpio_intr_disable(btn_item->gpio_num);
-        gpio_isr_handler_remove(btn_item->gpio_num);
-        STAILQ_REMOVE(&button->btn_list, btn_item, esp_button_item, entry);
-        audio_free(btn_item);
-    }
-    audio_free(button);
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/time.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/queue.h"
+
+#include "esp_log.h"
+#include "driver/gpio.h"
+#include "sys/queue.h"
+#include "button.h"
+#include "audio_mem.h"
+
+#ifdef periph_tick_get
+#define tick_get periph_tick_get
+#else
+static long long tick_get()
+{
+    struct timeval te;
+    gettimeofday(&te, NULL);
+    long long milliseconds = te.tv_sec * 1000LL + te.tv_usec / 1000;
+    return milliseconds;
+}
+#endif
+
+static const char *TAG = "BUTTON";
+
+typedef struct esp_button_item {
+    int                         gpio_num;
+    long long                   last_press_tick;
+    bool                        long_pressed;
+    STAILQ_ENTRY(esp_button_item)    entry;
+} esp_button_item_t;
+
+struct esp_button {
+    int long_press_time_ms;
+    uint64_t gpio_mask;
+    STAILQ_HEAD(esp_button_list, esp_button_item) btn_list;
+};
+
+static button_status_t button_get_state(esp_button_handle_t button, esp_button_item_t *btn_item)
+{
+    int level = gpio_get_level(btn_item->gpio_num);
+    int active_level = 0;
+    int deactive_level = 1;
+
+    if (btn_item->last_press_tick == 0 && level == active_level) {
+        btn_item->last_press_tick = tick_get();
+        btn_item->long_pressed = false;
+        return BTN_PRESSED;
+    }
+
+    if (level == deactive_level && btn_item->last_press_tick && tick_get() - btn_item->last_press_tick > button->long_press_time_ms) {
+        btn_item->last_press_tick = 0;
+        btn_item->long_pressed = false;
+        return BTN_LONG_RELEASE;
+    }
+
+    if (level == deactive_level && btn_item->last_press_tick) {
+        btn_item->last_press_tick = 0;
+        btn_item->long_pressed = false;
+        return BTN_RELEASE;
+    }
+
+    if (btn_item->long_pressed == false && level == active_level && tick_get() - btn_item->last_press_tick > button->long_press_time_ms) {
+        btn_item->long_pressed = true;
+        return BTN_LONG_PRESS;
+    }
+    return BTN_UNCHANGE;
+}
+
+esp_button_handle_t button_init(button_config_t *config)
+{
+    esp_button_handle_t btn = audio_calloc(1, sizeof(struct esp_button));
+    AUDIO_MEM_CHECK(TAG, btn, return NULL);
+    if (config->gpio_mask <= 0) {
+        ESP_LOGE(TAG, "required at least 1 gpio");
+        return NULL;
+    }
+    btn->gpio_mask = config->gpio_mask;
+    btn->long_press_time_ms = config->long_press_time_ms;
+
+    if (btn->long_press_time_ms == 0) {
+        btn->long_press_time_ms = DEFAULT_LONG_PRESS_TIME_MS;
+    }
+
+    gpio_config_t gpiocfg = {
+        .pin_bit_mask = btn->gpio_mask,
+        .mode = GPIO_MODE_INPUT,
+        .pull_up_en = GPIO_PULLUP_ENABLE,
+        .pull_down_en = GPIO_PULLDOWN_DISABLE,
+        .intr_type = GPIO_INTR_ANYEDGE,
+    };
+    gpio_config(&gpiocfg);
+
+    uint64_t gpio_mask = btn->gpio_mask;
+    int gpio_num = 0;
+
+    STAILQ_INIT(&btn->btn_list);
+    while (gpio_mask) {
+        if (gpio_mask & 0x01) {
+            ESP_LOGD(TAG, "Mask = %llx, current_mask = %llx, idx=%d", btn->gpio_mask, gpio_mask, gpio_num);
+            esp_button_item_t *new_btn = audio_calloc(1, sizeof(esp_button_item_t));
+            AUDIO_MEM_CHECK(TAG, new_btn, {
+                button_destroy(btn);
+                return NULL;
+            });
+            new_btn->gpio_num = gpio_num;
+            if (config->button_intr_handler) {
+                gpio_set_intr_type(gpio_num, GPIO_INTR_ANYEDGE);
+                gpio_isr_handler_add(gpio_num, config->button_intr_handler, config->intr_context);
+                gpio_intr_enable(gpio_num);
+            }
+            STAILQ_INSERT_TAIL(&btn->btn_list, new_btn, entry);
+        }
+        gpio_mask >>= 1;
+        gpio_num ++;
+    }
+    return btn;
+}
+
+bool button_read(esp_button_handle_t button, button_result_t *result)
+{
+    esp_button_item_t *btn_item;
+    button_status_t btn_status;
+    bool changed = false;
+    memset(result, 0, sizeof(button_result_t));
+    uint64_t tmp;
+    STAILQ_FOREACH(btn_item, &button->btn_list, entry) {
+        btn_status = button_get_state(button, btn_item);
+        switch (btn_status) {
+            case BTN_UNCHANGE:
+                break;
+            case BTN_PRESSED:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= btn_item->gpio_num;
+                result->press_mask |= tmp;
+                break;
+            case BTN_RELEASE:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= btn_item->gpio_num;
+                result->release_mask |=  tmp;
+                break;
+            case BTN_LONG_RELEASE:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= btn_item->gpio_num;
+                result->long_release_mask |=  tmp;
+                break;
+            case BTN_LONG_PRESS:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= btn_item->gpio_num;
+                result->long_press_mask |=  tmp;
+                break;
+        }
+    }
+    return changed;
+}
+
+esp_err_t button_destroy(esp_button_handle_t button)
+{
+    esp_button_item_t *btn_item, *tmp;
+    STAILQ_FOREACH_SAFE(btn_item, &button->btn_list, entry, tmp) {
+        gpio_intr_disable(btn_item->gpio_num);
+        gpio_isr_handler_remove(btn_item->gpio_num);
+        STAILQ_REMOVE(&button->btn_list, btn_item, esp_button_item, entry);
+        audio_free(btn_item);
+    }
+    audio_free(button);
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/lib/button/button.h b/components/esp_peripherals/lib/button/button.h
index 32da4730..0385d400 100644
--- a/components/esp_peripherals/lib/button/button.h
+++ b/components/esp_peripherals/lib/button/button.h
@@ -1,103 +1,103 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ESP_BUTTON_
-#define _ESP_BUTTON_
-
-#include "driver/gpio.h"
-#include "audio_error.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      { item_description }
- */
-typedef enum {
-    BTN_UNCHANGE = 0,
-    BTN_PRESSED,
-    BTN_RELEASE,
-    BTN_LONG_PRESS,
-    BTN_LONG_RELEASE,
-} button_status_t;
-
-/**
- * @brief      { item_description }
- */
-typedef struct {
-    uint64_t press_mask;
-    uint64_t release_mask;
-    uint64_t long_press_mask;
-    uint64_t long_release_mask;
-} button_result_t;
-
-typedef struct esp_button *esp_button_handle_t;
-typedef void (*gpio_intr_handler)(void *);
-
-/**
- * @brief      { item_description }
- */
-typedef struct {
-    int long_press_time_ms;
-    uint64_t gpio_mask;
-    gpio_intr_handler button_intr_handler;
-    void *intr_context;
-} button_config_t;
-
-#define DEFAULT_LONG_PRESS_TIME_MS (2*1000)
-
-/**
- * @brief      { function_description }
- *
- * @param      config  The configuration
- *
- * @return     { description_of_the_return_value }
- */
-esp_button_handle_t button_init(button_config_t *config);
-
-/**
- * @brief      { function_description }
- *
- * @param[in]  button  The button
- * @param      result  The result
- *
- * @return     { description_of_the_return_value }
- */
-bool button_read(esp_button_handle_t button, button_result_t *result);
-
-/**
- * @brief      { function_description }
- *
- * @param[in]  button  The button
- *
- * @return     { description_of_the_return_value }
- */
-esp_err_t button_destroy(esp_button_handle_t button);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ESP_BUTTON_
+#define _ESP_BUTTON_
+
+#include "driver/gpio.h"
+#include "audio_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      { item_description }
+ */
+typedef enum {
+    BTN_UNCHANGE = 0,
+    BTN_PRESSED,
+    BTN_RELEASE,
+    BTN_LONG_PRESS,
+    BTN_LONG_RELEASE,
+} button_status_t;
+
+/**
+ * @brief      { item_description }
+ */
+typedef struct {
+    uint64_t press_mask;
+    uint64_t release_mask;
+    uint64_t long_press_mask;
+    uint64_t long_release_mask;
+} button_result_t;
+
+typedef struct esp_button *esp_button_handle_t;
+typedef void (*gpio_intr_handler)(void *);
+
+/**
+ * @brief      { item_description }
+ */
+typedef struct {
+    int long_press_time_ms;
+    uint64_t gpio_mask;
+    gpio_intr_handler button_intr_handler;
+    void *intr_context;
+} button_config_t;
+
+#define DEFAULT_LONG_PRESS_TIME_MS (2*1000)
+
+/**
+ * @brief      { function_description }
+ *
+ * @param      config  The configuration
+ *
+ * @return     { description_of_the_return_value }
+ */
+esp_button_handle_t button_init(button_config_t *config);
+
+/**
+ * @brief      { function_description }
+ *
+ * @param[in]  button  The button
+ * @param      result  The result
+ *
+ * @return     { description_of_the_return_value }
+ */
+bool button_read(esp_button_handle_t button, button_result_t *result);
+
+/**
+ * @brief      { function_description }
+ *
+ * @param[in]  button  The button
+ *
+ * @return     { description_of_the_return_value }
+ */
+esp_err_t button_destroy(esp_button_handle_t button);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/gpio_isr/gpio_isr.c b/components/esp_peripherals/lib/gpio_isr/gpio_isr.c
index 59fe43b4..15e7a680 100644
--- a/components/esp_peripherals/lib/gpio_isr/gpio_isr.c
+++ b/components/esp_peripherals/lib/gpio_isr/gpio_isr.c
@@ -1,54 +1,54 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "driver/gpio.h"
-
-static const char *TAG = "GPIO_ISR";
-
-esp_err_t gpio_isr_init(int gpio_num, gpio_int_type_t type, gpio_isr_t gpio_isr_handle_func, void *isr_param)
-{
-    esp_err_t ret = ESP_OK;
-    if (gpio_num < 0 || NULL == gpio_isr_handle_func) {
-        ESP_LOGE(TAG, "Please check the parameters!");
-        return ESP_OK;
-    }
-    ret |= gpio_set_direction(gpio_num, GPIO_MODE_INPUT);
-    ret |= gpio_set_intr_type(gpio_num, type);
-    ret |= gpio_isr_handler_add(gpio_num, gpio_isr_handle_func, isr_param);
-    ret |= gpio_intr_enable(gpio_num);
-    return ret;
-}
-
-esp_err_t gpio_isr_deinit(int gpio_num)
-{
-    esp_err_t ret = ESP_OK;
-    if (gpio_num < 0) {
-        ESP_LOGE(TAG, "The gpio number should greater than or equal to 0");
-        return ESP_FAIL;
-    }
-    ret |= gpio_isr_handler_remove(gpio_num);
-    ret |= gpio_intr_disable(gpio_num);
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "driver/gpio.h"
+
+static const char *TAG = "GPIO_ISR";
+
+esp_err_t gpio_isr_init(int gpio_num, gpio_int_type_t type, gpio_isr_t gpio_isr_handle_func, void *isr_param)
+{
+    esp_err_t ret = ESP_OK;
+    if (gpio_num < 0 || NULL == gpio_isr_handle_func) {
+        ESP_LOGE(TAG, "Please check the parameters!");
+        return ESP_OK;
+    }
+    ret |= gpio_set_direction(gpio_num, GPIO_MODE_INPUT);
+    ret |= gpio_set_intr_type(gpio_num, type);
+    ret |= gpio_isr_handler_add(gpio_num, gpio_isr_handle_func, isr_param);
+    ret |= gpio_intr_enable(gpio_num);
+    return ret;
+}
+
+esp_err_t gpio_isr_deinit(int gpio_num)
+{
+    esp_err_t ret = ESP_OK;
+    if (gpio_num < 0) {
+        ESP_LOGE(TAG, "The gpio number should greater than or equal to 0");
+        return ESP_FAIL;
+    }
+    ret |= gpio_isr_handler_remove(gpio_num);
+    ret |= gpio_intr_disable(gpio_num);
+    return ret;
+}
diff --git a/components/esp_peripherals/lib/gpio_isr/gpio_isr.h b/components/esp_peripherals/lib/gpio_isr/gpio_isr.h
index 0723556a..94ff8028 100644
--- a/components/esp_peripherals/lib/gpio_isr/gpio_isr.h
+++ b/components/esp_peripherals/lib/gpio_isr/gpio_isr.h
@@ -1,62 +1,62 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _GPIO_ISR_H_
-#define _GPIO_ISR_H_
-
-#include  "esp_err.h"
-#include "driver/gpio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief  Initialize the gpio's interrupt service routines.
- *
- * @param  gpio_num                The number of gpio to be initialized
- * @param  type                    The type of interrupts
- * @param  gpio_isr_handle_func    Interrupt handler
- * @param  isr_param               The parameters of interrupt handler
- * 
- * @return
- */
-esp_err_t gpio_isr_init(int gpio_num, gpio_int_type_t type, gpio_isr_t gpio_isr_handle_func, void *isr_param);
-
-/**
- * @brief   Deinitialize the gpio isr
- *
- * @param   gpio_num The number of gpio to be deinitialized
- *
- * @return  
- *      - ESP_OK on success
- *      - ESP_FAIL on failed 
- */
-esp_err_t gpio_isr_deinit(int gpio_num);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _GPIO_ISR_H_
+#define _GPIO_ISR_H_
+
+#include  "esp_err.h"
+#include "driver/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief  Initialize the gpio's interrupt service routines.
+ *
+ * @param  gpio_num                The number of gpio to be initialized
+ * @param  type                    The type of interrupts
+ * @param  gpio_isr_handle_func    Interrupt handler
+ * @param  isr_param               The parameters of interrupt handler
+ * 
+ * @return
+ */
+esp_err_t gpio_isr_init(int gpio_num, gpio_int_type_t type, gpio_isr_t gpio_isr_handle_func, void *isr_param);
+
+/**
+ * @brief   Deinitialize the gpio isr
+ *
+ * @param   gpio_num The number of gpio to be deinitialized
+ *
+ * @return  
+ *      - ESP_OK on success
+ *      - ESP_FAIL on failed 
+ */
+esp_err_t gpio_isr_deinit(int gpio_num);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/sdcard/sdcard.c b/components/esp_peripherals/lib/sdcard/sdcard.c
index 83b63a3e..7dcc7358 100644
--- a/components/esp_peripherals/lib/sdcard/sdcard.c
+++ b/components/esp_peripherals/lib/sdcard/sdcard.c
@@ -1,237 +1,237 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-
-#include "esp_log.h"
-#include "esp_err.h"
-#include "esp_vfs_fat.h"
-#include "soc/soc_caps.h"
-
-#if SOC_SDMMC_HOST_SUPPORTED
-#include "driver/sdmmc_host.h"
-#endif
-#include "driver/sdmmc_defs.h"
-#include "driver/gpio.h"
-
-#if SOC_SDMMC_IO_POWER_EXTERNAL
-#include "sd_pwr_ctrl_by_on_chip_ldo.h"
-#endif
-
-#include "sdcard.h"
-#include "board.h"
-#include "esp_idf_version.h"
-
-static const char *TAG = "SDCARD";
-static int g_gpio = -1;
-static sdmmc_card_t *card = NULL;
-
-static void sdmmc_card_print_info(const sdmmc_card_t *card)
-{
-    ESP_LOGD(TAG, "Name: %s\n", card->cid.name);
-    ESP_LOGD(TAG, "Type: %s\n", (card->ocr & SD_OCR_SDHC_CAP) ? "SDHC/SDXC" : "SDSC");
-    ESP_LOGD(TAG, "Speed: %s\n", (card->csd.tr_speed > 25000000) ? "high speed" : "default speed");
-    ESP_LOGD(TAG, "Size: %lluMB\n", ((uint64_t) card->csd.capacity) * card->csd.sector_size / (1024 * 1024));
-    ESP_LOGD(TAG, "CSD: ver=%d, sector_size=%d, capacity=%d read_bl_len=%d\n",
-             card->csd.csd_ver,
-             card->csd.sector_size, card->csd.capacity, card->csd.read_block_len);
-    ESP_LOGD(TAG, "SCR: sd_spec=%d, bus_width=%d\n", card->scr.sd_spec, card->scr.bus_width);
-}
-
-esp_err_t sdcard_mount(const char *base_path, periph_sdcard_mode_t mode)
-{
-    if (mode >= SD_MODE_MAX) {
-        ESP_LOGE(TAG, "PLease select the correct sd mode: 1-line SD mode, 4-line SD mode or SPI mode!, current mode is %d", mode);
-        return ESP_FAIL;
-    }
-
-    esp_err_t ret = ESP_FAIL;
-    esp_vfs_fat_sdmmc_mount_config_t mount_config = {
-        .format_if_mount_failed = false,
-        .max_files = get_sdcard_open_file_num_max(),
-        .allocation_unit_size = 64 * 1024,
-    };
-
-#if defined SD_PWR_CTRL_LDO_INTERNAL_IO
-    sd_pwr_ctrl_ldo_config_t ldo_config = {
-        .ldo_chan_id = SD_PWR_CTRL_LDO_INTERNAL_IO,
-    };
-    sd_pwr_ctrl_handle_t pwr_ctrl_handle = NULL;
-
-    ret = sd_pwr_ctrl_new_on_chip_ldo(&ldo_config, &pwr_ctrl_handle);
-    if (ret != ESP_OK) {
-        ESP_LOGE(TAG, "Failed to create a new on-chip LDO power control driver");
-        return ESP_FAIL;
-    }
-#endif // SD_PWR_CTRL_LDO_INTERNAL_IO
-
-    if (mode != SD_MODE_SPI) {
-#if SOC_SDMMC_HOST_SUPPORTED
-        ESP_LOGI(TAG, "Using %d-line SD mode,  base path=%s", mode, base_path);
-
-        sdmmc_host_t host = SDMMC_HOST_DEFAULT();
-        // host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;
-    /* Note: default sdmmc use slot0, hosted use slot1 */
-#if defined CONFIG_IDF_TARGET_ESP32P4
-        host.slot = SDMMC_HOST_SLOT_0;
-#endif // CONFIG_IDF_TARGET_ESP32P4
-#if defined SD_PWR_CTRL_LDO_INTERNAL_IO
-        host.pwr_ctrl_handle = pwr_ctrl_handle;
-#endif
-        sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();
-        // slot_config.gpio_cd = g_gpio;
-        slot_config.width = mode;
-        // Enable internal pullups on enabled pins. The internal pullups
-        // are insufficient however, please make sure 10k external pullups are
-        // connected on the bus. This is for debug / example purpose only.
-        slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP;
-
-#if SOC_SDMMC_USE_GPIO_MATRIX
-        slot_config.clk = ESP_SD_PIN_CLK;
-        slot_config.cmd = ESP_SD_PIN_CMD;
-        slot_config.d0 = ESP_SD_PIN_D0;
-        slot_config.d1 = ESP_SD_PIN_D1;
-        slot_config.d2 = ESP_SD_PIN_D2;
-        slot_config.d3 = ESP_SD_PIN_D3;
-        slot_config.d4 = ESP_SD_PIN_D4;
-        slot_config.d5 = ESP_SD_PIN_D5;
-        slot_config.d6 = ESP_SD_PIN_D6;
-        slot_config.d7 = ESP_SD_PIN_D7;
-        slot_config.cd = ESP_SD_PIN_CD;
-        slot_config.wp = ESP_SD_PIN_WP;
-#endif
-        ret = esp_vfs_fat_sdmmc_mount(base_path, &host, &slot_config, &mount_config, &card);
-#endif
-    } else {
-        ESP_LOGI(TAG, "Using SPI mode, base path=%s", base_path);
-        sdmmc_host_t host = SDSPI_HOST_DEFAULT();
-#if defined SD_PWR_CTRL_LDO_INTERNAL_IO
-        host.pwr_ctrl_handle = pwr_ctrl_handle;
-#endif
-        spi_bus_config_t bus_cfg = {
-            .mosi_io_num = ESP_SD_PIN_CMD,
-            .miso_io_num = ESP_SD_PIN_D0,
-            .sclk_io_num = ESP_SD_PIN_CLK,
-            .quadwp_io_num = -1,
-            .quadhd_io_num = -1,
-            .max_transfer_sz = 4000,
-        };
-        ret = spi_bus_initialize(host.slot, &bus_cfg, SPI_DMA_CH_AUTO);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "Failed to initialize bus.");
-            return ret;
-        }
-        sdspi_device_config_t slot_config = SDSPI_DEVICE_CONFIG_DEFAULT();
-        slot_config.gpio_cs = ESP_SD_PIN_D3;
-        slot_config.host_id = host.slot;
-        ret = esp_vfs_fat_sdspi_mount(base_path, &host, &slot_config, &mount_config, &card);
-    }
-
-    switch (ret) {
-        case ESP_OK:
-            // Card has been initialized, print its properties
-            sdmmc_card_print_info(card);
-            ESP_LOGI(TAG, "CID name %s!\n", card->cid.name);
-            break;
-
-        case ESP_ERR_INVALID_STATE:
-            ESP_LOGE(TAG, "File system already mounted");
-            break;
-
-        case ESP_FAIL:
-            ESP_LOGE(TAG, "Failed to mount filesystem. If you want the card to be formatted, set format_if_mount_failed = true.");
-            break;
-
-        default:
-            ESP_LOGE(TAG, "Failed to initialize the card (%d). Make sure SD card lines have pull-up resistors in place.", ret);
-            break;
-    }
-
-    return ret;
-
-}
-
-esp_err_t sdcard_unmount(const char *base_path, periph_sdcard_mode_t mode)
-{
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 1, 0))
-    esp_err_t ret = esp_vfs_fat_sdcard_unmount(base_path, card);
-#else
-    esp_err_t ret = esp_vfs_fat_sdmmc_unmount();
-#endif
-    if (mode == SD_MODE_SPI) {
-        sdmmc_host_t host = SDSPI_HOST_DEFAULT();
-        spi_bus_free(host.slot);
-    }
-    if (ret == ESP_ERR_INVALID_STATE) {
-        ESP_LOGE(TAG, "File system not mounted");
-    }
-    return ret;
-}
-
-bool sdcard_is_exist()
-{
-    if (g_gpio >= 0) {
-        return (gpio_get_level(g_gpio) == 0x00);
-    } else {
-        return true;
-    }
-    return false;
-}
-
-int IRAM_ATTR sdcard_read_detect_pin(void)
-{
-    if (g_gpio >= 0) {
-        return gpio_get_level(g_gpio);
-    } else {
-        return -1;
-    }
-    return 0;
-}
-
-esp_err_t sdcard_destroy()
-{
-    if (g_gpio >= 0) {
-        return gpio_isr_handler_remove(g_gpio);
-    }
-    return ESP_OK;
-}
-
-esp_err_t sdcard_init(int card_detect_pin, void (*detect_intr_handler)(void *), void *isr_context)
-{
-    esp_err_t ret = ESP_OK;
-    if (card_detect_pin >= 0) {
-        gpio_set_direction(card_detect_pin, GPIO_MODE_INPUT);
-        if (detect_intr_handler) {
-            gpio_set_intr_type(card_detect_pin, GPIO_INTR_ANYEDGE);
-            gpio_isr_handler_add(card_detect_pin, detect_intr_handler, isr_context);
-            gpio_intr_enable(card_detect_pin);
-        }
-        gpio_pullup_en(card_detect_pin);
-    }
-    g_gpio = card_detect_pin;
-    return ret;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+
+#include "esp_log.h"
+#include "esp_err.h"
+#include "esp_vfs_fat.h"
+#include "soc/soc_caps.h"
+
+#if SOC_SDMMC_HOST_SUPPORTED
+#include "driver/sdmmc_host.h"
+#endif
+#include "driver/sdmmc_defs.h"
+#include "driver/gpio.h"
+
+#if SOC_SDMMC_IO_POWER_EXTERNAL
+#include "sd_pwr_ctrl_by_on_chip_ldo.h"
+#endif
+
+#include "sdcard.h"
+#include "board.h"
+#include "esp_idf_version.h"
+
+static const char *TAG = "SDCARD";
+static int g_gpio = -1;
+static sdmmc_card_t *card = NULL;
+
+static void sdmmc_card_print_info(const sdmmc_card_t *card)
+{
+    ESP_LOGD(TAG, "Name: %s\n", card->cid.name);
+    ESP_LOGD(TAG, "Type: %s\n", (card->ocr & SD_OCR_SDHC_CAP) ? "SDHC/SDXC" : "SDSC");
+    ESP_LOGD(TAG, "Speed: %s\n", (card->csd.tr_speed > 25000000) ? "high speed" : "default speed");
+    ESP_LOGD(TAG, "Size: %lluMB\n", ((uint64_t) card->csd.capacity) * card->csd.sector_size / (1024 * 1024));
+    ESP_LOGD(TAG, "CSD: ver=%d, sector_size=%d, capacity=%d read_bl_len=%d\n",
+             card->csd.csd_ver,
+             card->csd.sector_size, card->csd.capacity, card->csd.read_block_len);
+    ESP_LOGD(TAG, "SCR: sd_spec=%d, bus_width=%d\n", card->scr.sd_spec, card->scr.bus_width);
+}
+
+esp_err_t sdcard_mount(const char *base_path, periph_sdcard_mode_t mode)
+{
+    if (mode >= SD_MODE_MAX) {
+        ESP_LOGE(TAG, "PLease select the correct sd mode: 1-line SD mode, 4-line SD mode or SPI mode!, current mode is %d", mode);
+        return ESP_FAIL;
+    }
+
+    esp_err_t ret = ESP_FAIL;
+    esp_vfs_fat_sdmmc_mount_config_t mount_config = {
+        .format_if_mount_failed = false,
+        .max_files = get_sdcard_open_file_num_max(),
+        .allocation_unit_size = 64 * 1024,
+    };
+
+#if defined SD_PWR_CTRL_LDO_INTERNAL_IO
+    sd_pwr_ctrl_ldo_config_t ldo_config = {
+        .ldo_chan_id = SD_PWR_CTRL_LDO_INTERNAL_IO,
+    };
+    sd_pwr_ctrl_handle_t pwr_ctrl_handle = NULL;
+
+    ret = sd_pwr_ctrl_new_on_chip_ldo(&ldo_config, &pwr_ctrl_handle);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to create a new on-chip LDO power control driver");
+        return ESP_FAIL;
+    }
+#endif // SD_PWR_CTRL_LDO_INTERNAL_IO
+
+    if (mode != SD_MODE_SPI) {
+#if SOC_SDMMC_HOST_SUPPORTED
+        ESP_LOGI(TAG, "Using %d-line SD mode,  base path=%s", mode, base_path);
+
+        sdmmc_host_t host = SDMMC_HOST_DEFAULT();
+        // host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;
+    /* Note: default sdmmc use slot0, hosted use slot1 */
+#if defined CONFIG_IDF_TARGET_ESP32P4
+        host.slot = SDMMC_HOST_SLOT_0;
+#endif // CONFIG_IDF_TARGET_ESP32P4
+#if defined SD_PWR_CTRL_LDO_INTERNAL_IO
+        host.pwr_ctrl_handle = pwr_ctrl_handle;
+#endif
+        sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();
+        // slot_config.gpio_cd = g_gpio;
+        slot_config.width = mode;
+        // Enable internal pullups on enabled pins. The internal pullups
+        // are insufficient however, please make sure 10k external pullups are
+        // connected on the bus. This is for debug / example purpose only.
+        slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP;
+
+#if SOC_SDMMC_USE_GPIO_MATRIX
+        slot_config.clk = ESP_SD_PIN_CLK;
+        slot_config.cmd = ESP_SD_PIN_CMD;
+        slot_config.d0 = ESP_SD_PIN_D0;
+        slot_config.d1 = ESP_SD_PIN_D1;
+        slot_config.d2 = ESP_SD_PIN_D2;
+        slot_config.d3 = ESP_SD_PIN_D3;
+        slot_config.d4 = ESP_SD_PIN_D4;
+        slot_config.d5 = ESP_SD_PIN_D5;
+        slot_config.d6 = ESP_SD_PIN_D6;
+        slot_config.d7 = ESP_SD_PIN_D7;
+        slot_config.cd = ESP_SD_PIN_CD;
+        slot_config.wp = ESP_SD_PIN_WP;
+#endif
+        ret = esp_vfs_fat_sdmmc_mount(base_path, &host, &slot_config, &mount_config, &card);
+#endif
+    } else {
+        ESP_LOGI(TAG, "Using SPI mode, base path=%s", base_path);
+        sdmmc_host_t host = SDSPI_HOST_DEFAULT();
+#if defined SD_PWR_CTRL_LDO_INTERNAL_IO
+        host.pwr_ctrl_handle = pwr_ctrl_handle;
+#endif
+        spi_bus_config_t bus_cfg = {
+            .mosi_io_num = ESP_SD_PIN_CMD,
+            .miso_io_num = ESP_SD_PIN_D0,
+            .sclk_io_num = ESP_SD_PIN_CLK,
+            .quadwp_io_num = -1,
+            .quadhd_io_num = -1,
+            .max_transfer_sz = 4000,
+        };
+        ret = spi_bus_initialize(host.slot, &bus_cfg, SPI_DMA_CH_AUTO);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "Failed to initialize bus.");
+            return ret;
+        }
+        sdspi_device_config_t slot_config = SDSPI_DEVICE_CONFIG_DEFAULT();
+        slot_config.gpio_cs = ESP_SD_PIN_D3;
+        slot_config.host_id = host.slot;
+        ret = esp_vfs_fat_sdspi_mount(base_path, &host, &slot_config, &mount_config, &card);
+    }
+
+    switch (ret) {
+        case ESP_OK:
+            // Card has been initialized, print its properties
+            sdmmc_card_print_info(card);
+            ESP_LOGI(TAG, "CID name %s!\n", card->cid.name);
+            break;
+
+        case ESP_ERR_INVALID_STATE:
+            ESP_LOGE(TAG, "File system already mounted");
+            break;
+
+        case ESP_FAIL:
+            ESP_LOGE(TAG, "Failed to mount filesystem. If you want the card to be formatted, set format_if_mount_failed = true.");
+            break;
+
+        default:
+            ESP_LOGE(TAG, "Failed to initialize the card (%d). Make sure SD card lines have pull-up resistors in place.", ret);
+            break;
+    }
+
+    return ret;
+
+}
+
+esp_err_t sdcard_unmount(const char *base_path, periph_sdcard_mode_t mode)
+{
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 1, 0))
+    esp_err_t ret = esp_vfs_fat_sdcard_unmount(base_path, card);
+#else
+    esp_err_t ret = esp_vfs_fat_sdmmc_unmount();
+#endif
+    if (mode == SD_MODE_SPI) {
+        sdmmc_host_t host = SDSPI_HOST_DEFAULT();
+        spi_bus_free(host.slot);
+    }
+    if (ret == ESP_ERR_INVALID_STATE) {
+        ESP_LOGE(TAG, "File system not mounted");
+    }
+    return ret;
+}
+
+bool sdcard_is_exist()
+{
+    if (g_gpio >= 0) {
+        return (gpio_get_level(g_gpio) == 0x00);
+    } else {
+        return true;
+    }
+    return false;
+}
+
+int IRAM_ATTR sdcard_read_detect_pin(void)
+{
+    if (g_gpio >= 0) {
+        return gpio_get_level(g_gpio);
+    } else {
+        return -1;
+    }
+    return 0;
+}
+
+esp_err_t sdcard_destroy()
+{
+    if (g_gpio >= 0) {
+        return gpio_isr_handler_remove(g_gpio);
+    }
+    return ESP_OK;
+}
+
+esp_err_t sdcard_init(int card_detect_pin, void (*detect_intr_handler)(void *), void *isr_context)
+{
+    esp_err_t ret = ESP_OK;
+    if (card_detect_pin >= 0) {
+        gpio_set_direction(card_detect_pin, GPIO_MODE_INPUT);
+        if (detect_intr_handler) {
+            gpio_set_intr_type(card_detect_pin, GPIO_INTR_ANYEDGE);
+            gpio_isr_handler_add(card_detect_pin, detect_intr_handler, isr_context);
+            gpio_intr_enable(card_detect_pin);
+        }
+        gpio_pullup_en(card_detect_pin);
+    }
+    g_gpio = card_detect_pin;
+    return ret;
+}
diff --git a/components/esp_peripherals/lib/sdcard/sdcard.h b/components/esp_peripherals/lib/sdcard/sdcard.h
index 6f998417..0e7a3078 100644
--- a/components/esp_peripherals/lib/sdcard/sdcard.h
+++ b/components/esp_peripherals/lib/sdcard/sdcard.h
@@ -1,102 +1,102 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ESP_SDCARD_H_
-#define _ESP_SDCARD_H_
-
-#include "audio_error.h"
-#include "periph_sdcard.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      { function_description }
- *
- * @param[in]  gpio                 The gpio
- * @param[in]  detect_intr_handler  The detect intr handler
- * @param      isr_context          The isr context
- *
- * @return     { description_of_the_return_value }
- */
-esp_err_t sdcard_init(int gpio, void (*detect_intr_handler)(void *), void *isr_context);
-
-/**
-  * @brief  mount sdcard to FAT filesystem
-  *
-  * @param  base_path path where partition should be registered (e.g. "/sdcard")
-  * @param  mode      the specificd sdcard mode type
-  *
-  * @return
-  *      - ESP_OK on success
-  *      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called
-  *      - ESP_ERR_NO_MEM if memory can not be allocated
-  *      - ESP_FAIL if partition can not be mounted
-  *      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers
-  */
-esp_err_t sdcard_mount(const char* base_path, periph_sdcard_mode_t mode);
-
-/**
- * @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_sdmmc_mount
- *
- * @param  base_path path where partition is mounted (e.g. "/sdcard")
- * @param  mode      the specificd sdcard mode type
- *
- * @return
- *      - ESP_OK on success
- *      - ESP_ERR_INVALID_STATE if sd_card_mount hasn't been called
- */
-esp_err_t sdcard_unmount(const char *base_path, periph_sdcard_mode_t mode);
-
-/**
- * @brief remove the sdcard device GPIO interruption in Audio board
- *
- * @return
- *      - ESP_OK on success
- *      - ESP_FAIL destroy sdcard gpio handle failed
- */
-esp_err_t sdcard_destroy(void);
-
-/**
- * @brief get the status of sdcard is insert or not
- *
- * @return
- *      - true sdcard is insert
- *      - false sdcard is unplug
- */
-bool sdcard_is_exist();
-
-/**
- * @brief      Read value of CARD DETECT Pin
- *
- * @return     value of CARD DETECT PIN
- */
-int sdcard_read_detect_pin(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ESP_SDCARD_H_
+#define _ESP_SDCARD_H_
+
+#include "audio_error.h"
+#include "periph_sdcard.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      { function_description }
+ *
+ * @param[in]  gpio                 The gpio
+ * @param[in]  detect_intr_handler  The detect intr handler
+ * @param      isr_context          The isr context
+ *
+ * @return     { description_of_the_return_value }
+ */
+esp_err_t sdcard_init(int gpio, void (*detect_intr_handler)(void *), void *isr_context);
+
+/**
+  * @brief  mount sdcard to FAT filesystem
+  *
+  * @param  base_path path where partition should be registered (e.g. "/sdcard")
+  * @param  mode      the specificd sdcard mode type
+  *
+  * @return
+  *      - ESP_OK on success
+  *      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called
+  *      - ESP_ERR_NO_MEM if memory can not be allocated
+  *      - ESP_FAIL if partition can not be mounted
+  *      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers
+  */
+esp_err_t sdcard_mount(const char* base_path, periph_sdcard_mode_t mode);
+
+/**
+ * @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_sdmmc_mount
+ *
+ * @param  base_path path where partition is mounted (e.g. "/sdcard")
+ * @param  mode      the specificd sdcard mode type
+ *
+ * @return
+ *      - ESP_OK on success
+ *      - ESP_ERR_INVALID_STATE if sd_card_mount hasn't been called
+ */
+esp_err_t sdcard_unmount(const char *base_path, periph_sdcard_mode_t mode);
+
+/**
+ * @brief remove the sdcard device GPIO interruption in Audio board
+ *
+ * @return
+ *      - ESP_OK on success
+ *      - ESP_FAIL destroy sdcard gpio handle failed
+ */
+esp_err_t sdcard_destroy(void);
+
+/**
+ * @brief get the status of sdcard is insert or not
+ *
+ * @return
+ *      - true sdcard is insert
+ *      - false sdcard is unplug
+ */
+bool sdcard_is_exist();
+
+/**
+ * @brief      Read value of CARD DETECT Pin
+ *
+ * @return     value of CARD DETECT PIN
+ */
+int sdcard_read_detect_pin(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/tca9554/tca9554.c b/components/esp_peripherals/lib/tca9554/tca9554.c
index dcc94a86..a41b8d09 100644
--- a/components/esp_peripherals/lib/tca9554/tca9554.c
+++ b/components/esp_peripherals/lib/tca9554/tca9554.c
@@ -1,198 +1,198 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "i2c_bus.h"
-#include "board.h"
-#include "esp_log.h"
-#include "tca9554.h"
-
-static char *TAG = "TCA9554";
-static i2c_bus_handle_t i2c_handle;
-
-#define SET_BITS(_m, _s, _v)  ((_v) ? (_m)|((_s)) : (_m)&~((_s)))
-#define GET_BITS(_m, _s)      (((_m) & (_s)) ? true : false)
-
-
-#define TCA9554_INPUT_PORT              0x00
-#define TCA9554_OUTPUT_PORT             0x01
-#define TCA9554_POLARITY_INVERSION_PORT 0x02
-#define TCA9554_CONFIGURATION_PORT      0x03
-
-typedef struct {
-    uint8_t addr;
-    char *name;
-} tca9554_dev_t;
-
-static tca9554_dev_t dev_list[] = {
-    { 0x70, "TCA9554A"},
-    { 0x40, "TCA9554"},
-};
-
-static uint8_t tca9554_addr;
-
-static esp_err_t expander_dev_prob()
-{
-    for (size_t i = 0; i < sizeof(dev_list) / sizeof(dev_list[0]); i++) {
-        if (ESP_OK == i2c_bus_probe_addr(i2c_handle, dev_list[i].addr)) {
-            ESP_LOGI(TAG, "Detected IO expander device at 0x%02X, name is: %s",
-                     dev_list[i].addr, dev_list[i].name);
-            tca9554_addr = dev_list[i].addr;
-            return ESP_OK;
-        }
-    }
-    tca9554_addr = 0;
-    ESP_LOGE(TAG, "IO expander device has not detected");
-    return ESP_ERR_NOT_FOUND;
-}
-
-
-static esp_err_t tca9554_write_reg(uint8_t reg_addr, uint8_t data)
-{
-    return i2c_bus_write_bytes(i2c_handle, tca9554_addr, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-}
-
-static char tca9554_read_reg(uint8_t reg_addr)
-{
-    uint8_t data;
-    i2c_bus_read_bytes(i2c_handle, tca9554_addr, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
-    return data;
-}
-
-static int i2c_init(gpio_num_t clk, gpio_num_t sda)
-{
-    int res = 0;
-    i2c_config_t es_i2c_cfg = {
-        .mode = I2C_MODE_MASTER,
-        .sda_pullup_en = GPIO_PULLUP_ENABLE,
-        .scl_pullup_en = GPIO_PULLUP_ENABLE,
-        .master.clk_speed = 100000,
-        .scl_io_num = clk,
-        .sda_io_num = sda,
-    };
-    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
-    return res;
-}
-
-esp_tca9554_io_level_t tca9554_get_input_state(esp_tca9554_gpio_num_t gpio_num)
-{
-    char data = 0;
-    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
-        data = tca9554_read_reg(TCA9554_INPUT_PORT);
-    } else {
-        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
-        return TCA9554_LEVEL_ERROR;
-    }
-
-    return GET_BITS(data, gpio_num);
-}
-
-esp_tca9554_io_level_t tca9554_get_output_state(esp_tca9554_gpio_num_t gpio_num)
-{
-    char data = 0;
-    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
-        data = tca9554_read_reg(TCA9554_OUTPUT_PORT);
-    } else {
-        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
-        return TCA9554_LEVEL_ERROR;
-    }
-
-    return GET_BITS(data, gpio_num);
-}
-
-esp_err_t tca9554_set_output_state(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_level_t level)
-{
-    char data;
-    esp_err_t res = ESP_FAIL;
-    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
-        data = tca9554_read_reg(TCA9554_OUTPUT_PORT);
-        res = tca9554_write_reg(TCA9554_OUTPUT_PORT, SET_BITS(data, gpio_num, level));
-    } else {
-        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
-    }
-    return res;
-}
-
-esp_err_t tca9554_set_polarity_inversion(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_polarity_t polarity)
-{
-    char data;
-    esp_err_t res = ESP_FAIL;
-    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
-        data = tca9554_read_reg(TCA9554_POLARITY_INVERSION_PORT);
-        res = tca9554_write_reg(TCA9554_POLARITY_INVERSION_PORT, SET_BITS(data, gpio_num, polarity));
-    } else {
-        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
-    }
-    return res;
-}
-
-esp_tca9554_io_config_t tca9554_get_io_config(esp_tca9554_gpio_num_t gpio_num)
-{
-    char data = 0;
-    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
-        data = tca9554_read_reg(TCA9554_CONFIGURATION_PORT);
-    } else {
-        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
-        return TCA9554_LEVEL_ERROR;
-    }
-
-    return GET_BITS(data, gpio_num);
-}
-
-esp_err_t tca9554_set_io_config(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_config_t io_config)
-{
-    char data;
-    esp_err_t res = ESP_FAIL;
-    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
-        data = tca9554_read_reg(TCA9554_CONFIGURATION_PORT);
-        res = tca9554_write_reg(TCA9554_CONFIGURATION_PORT, SET_BITS(data, gpio_num, io_config));
-    } else {
-        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
-    }
-    return res;
-}
-
-void tca9554_read_all()
-{
-    for (int i = 0; i < 0x04; i++) {
-        uint8_t reg = tca9554_read_reg(i);
-        ESP_LOGI(TAG, "REG:%02x, %02x", i, reg);
-    }
-}
-
-esp_err_t tca9554_init(esp_tca9554_config_t *cfg)
-{
-    esp_err_t ret = ESP_OK;
-    i2c_init(cfg->i2c_scl, cfg->i2c_sda);
-
-    expander_dev_prob();
-
-    return ret;
-}
-
-esp_err_t tca9554_deinit()
-{
-    i2c_bus_delete(i2c_handle);
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "i2c_bus.h"
+#include "board.h"
+#include "esp_log.h"
+#include "tca9554.h"
+
+static char *TAG = "TCA9554";
+static i2c_bus_handle_t i2c_handle;
+
+#define SET_BITS(_m, _s, _v)  ((_v) ? (_m)|((_s)) : (_m)&~((_s)))
+#define GET_BITS(_m, _s)      (((_m) & (_s)) ? true : false)
+
+
+#define TCA9554_INPUT_PORT              0x00
+#define TCA9554_OUTPUT_PORT             0x01
+#define TCA9554_POLARITY_INVERSION_PORT 0x02
+#define TCA9554_CONFIGURATION_PORT      0x03
+
+typedef struct {
+    uint8_t addr;
+    char *name;
+} tca9554_dev_t;
+
+static tca9554_dev_t dev_list[] = {
+    { 0x70, "TCA9554A"},
+    { 0x40, "TCA9554"},
+};
+
+static uint8_t tca9554_addr;
+
+static esp_err_t expander_dev_prob()
+{
+    for (size_t i = 0; i < sizeof(dev_list) / sizeof(dev_list[0]); i++) {
+        if (ESP_OK == i2c_bus_probe_addr(i2c_handle, dev_list[i].addr)) {
+            ESP_LOGI(TAG, "Detected IO expander device at 0x%02X, name is: %s",
+                     dev_list[i].addr, dev_list[i].name);
+            tca9554_addr = dev_list[i].addr;
+            return ESP_OK;
+        }
+    }
+    tca9554_addr = 0;
+    ESP_LOGE(TAG, "IO expander device has not detected");
+    return ESP_ERR_NOT_FOUND;
+}
+
+
+static esp_err_t tca9554_write_reg(uint8_t reg_addr, uint8_t data)
+{
+    return i2c_bus_write_bytes(i2c_handle, tca9554_addr, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+}
+
+static char tca9554_read_reg(uint8_t reg_addr)
+{
+    uint8_t data;
+    i2c_bus_read_bytes(i2c_handle, tca9554_addr, &reg_addr, sizeof(reg_addr), &data, sizeof(data));
+    return data;
+}
+
+static int i2c_init(gpio_num_t clk, gpio_num_t sda)
+{
+    int res = 0;
+    i2c_config_t es_i2c_cfg = {
+        .mode = I2C_MODE_MASTER,
+        .sda_pullup_en = GPIO_PULLUP_ENABLE,
+        .scl_pullup_en = GPIO_PULLUP_ENABLE,
+        .master.clk_speed = 100000,
+        .scl_io_num = clk,
+        .sda_io_num = sda,
+    };
+    i2c_handle = i2c_bus_create(I2C_NUM_0, &es_i2c_cfg);
+    return res;
+}
+
+esp_tca9554_io_level_t tca9554_get_input_state(esp_tca9554_gpio_num_t gpio_num)
+{
+    char data = 0;
+    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
+        data = tca9554_read_reg(TCA9554_INPUT_PORT);
+    } else {
+        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
+        return TCA9554_LEVEL_ERROR;
+    }
+
+    return GET_BITS(data, gpio_num);
+}
+
+esp_tca9554_io_level_t tca9554_get_output_state(esp_tca9554_gpio_num_t gpio_num)
+{
+    char data = 0;
+    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
+        data = tca9554_read_reg(TCA9554_OUTPUT_PORT);
+    } else {
+        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
+        return TCA9554_LEVEL_ERROR;
+    }
+
+    return GET_BITS(data, gpio_num);
+}
+
+esp_err_t tca9554_set_output_state(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_level_t level)
+{
+    char data;
+    esp_err_t res = ESP_FAIL;
+    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
+        data = tca9554_read_reg(TCA9554_OUTPUT_PORT);
+        res = tca9554_write_reg(TCA9554_OUTPUT_PORT, SET_BITS(data, gpio_num, level));
+    } else {
+        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
+    }
+    return res;
+}
+
+esp_err_t tca9554_set_polarity_inversion(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_polarity_t polarity)
+{
+    char data;
+    esp_err_t res = ESP_FAIL;
+    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
+        data = tca9554_read_reg(TCA9554_POLARITY_INVERSION_PORT);
+        res = tca9554_write_reg(TCA9554_POLARITY_INVERSION_PORT, SET_BITS(data, gpio_num, polarity));
+    } else {
+        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
+    }
+    return res;
+}
+
+esp_tca9554_io_config_t tca9554_get_io_config(esp_tca9554_gpio_num_t gpio_num)
+{
+    char data = 0;
+    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
+        data = tca9554_read_reg(TCA9554_CONFIGURATION_PORT);
+    } else {
+        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
+        return TCA9554_LEVEL_ERROR;
+    }
+
+    return GET_BITS(data, gpio_num);
+}
+
+esp_err_t tca9554_set_io_config(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_config_t io_config)
+{
+    char data;
+    esp_err_t res = ESP_FAIL;
+    if (gpio_num < TCA9554_GPIO_NUM_MAX) {
+        data = tca9554_read_reg(TCA9554_CONFIGURATION_PORT);
+        res = tca9554_write_reg(TCA9554_CONFIGURATION_PORT, SET_BITS(data, gpio_num, io_config));
+    } else {
+        ESP_LOGE(TAG, "gpio num is error, current gpio: %d", gpio_num);
+    }
+    return res;
+}
+
+void tca9554_read_all()
+{
+    for (int i = 0; i < 0x04; i++) {
+        uint8_t reg = tca9554_read_reg(i);
+        ESP_LOGI(TAG, "REG:%02x, %02x", i, reg);
+    }
+}
+
+esp_err_t tca9554_init(esp_tca9554_config_t *cfg)
+{
+    esp_err_t ret = ESP_OK;
+    i2c_init(cfg->i2c_scl, cfg->i2c_sda);
+
+    expander_dev_prob();
+
+    return ret;
+}
+
+esp_err_t tca9554_deinit()
+{
+    i2c_bus_delete(i2c_handle);
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/lib/tca9554/tca9554.h b/components/esp_peripherals/lib/tca9554/tca9554.h
index c8103ec6..15bcae6b 100644
--- a/components/esp_peripherals/lib/tca9554/tca9554.h
+++ b/components/esp_peripherals/lib/tca9554/tca9554.h
@@ -1,164 +1,164 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _TCA9554_H
-#define _TCA9554_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "driver/gpio.h"
-
-typedef enum {
-    TCA9554_GPIO_NUM_0 = BIT(0),
-    TCA9554_GPIO_NUM_1 = BIT(1),
-    TCA9554_GPIO_NUM_2 = BIT(2),
-    TCA9554_GPIO_NUM_3 = BIT(3),
-    TCA9554_GPIO_NUM_4 = BIT(4),
-    TCA9554_GPIO_NUM_5 = BIT(5),
-    TCA9554_GPIO_NUM_6 = BIT(6),
-    TCA9554_GPIO_NUM_7 = BIT(7),
-    TCA9554_GPIO_NUM_MAX
-} esp_tca9554_gpio_num_t;
-
-typedef enum {
-    TCA9554_IO_LOW,
-    TCA9554_IO_HIGH,
-    TCA9554_LEVEL_ERROR
-} esp_tca9554_io_level_t;
-
-typedef enum {
-    TCA9554_IO_RETAINED,
-    TCA9554_IO_INVERTED
-} esp_tca9554_io_polarity_t;
-
-typedef enum {
-    TCA9554_IO_OUTPUT,
-    TCA9554_IO_INPUT
-} esp_tca9554_io_config_t;
-
-typedef struct {
-    gpio_num_t i2c_sda;
-    gpio_num_t i2c_scl;
-    gpio_num_t interrupt_output;
-} esp_tca9554_config_t;
-
-/*
- * @brief Initialize TCA9554 chip
- *
- * @param codec_cfg  configuration of TCA9554
- *
- * @return
- *      - ESP_OK
- *      - ESP_FAIL
- */
-esp_err_t tca9554_init(esp_tca9554_config_t *cfg);
-
-/**
- * @brief Deinitialize TCA9554 chip
- *
- * @return
- *     - ESP_OK
- *     - ESP_FAIL
- */
-esp_err_t tca9554_deinit(void);
-
-/*
- * @brief Get TCA9554 input level
- *
- * @param gpio_num  GPIO of TCA9554
- *
- * @return
- *      - esp_tca9554_io_level_t
- */
-esp_tca9554_io_level_t tca9554_get_input_state(esp_tca9554_gpio_num_t gpio_num);
-
-/*
- * @brief Get PCA95xian39 output level
- *
- * @param gpio_num  GPIO of TCA9554
- *
- * @return
- *      - esp_tca9554_io_level_t
- */
-esp_tca9554_io_level_t tca9554_get_output_state(esp_tca9554_gpio_num_t gpio_num);
-
-/*
- * @brief Get TCA9554 output state
- *
- * @param gpio_num  GPIO of TCA9554
- *
- * @return
- *      - esp_tca9554_io_level_t
- */
-esp_err_t tca9554_set_output_state(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_level_t level);
-
-/*
- * @brief Set TCA9554 polarity
- *
- * @param gpio_num  GPIO of TCA9554
- *        polarity  polarity
- *
- * @return
- *      - ESP_OK
- *      - ESP_FAIL
- */
-esp_err_t tca9554_set_polarity_inversion(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_polarity_t polarity);
-
-/*
- * @brief Get TCA9554 output level
- *
- * @param gpio_num  GPIO of TCA9554
- *
- * @return
- *      - esp_tca9554_io_level_t
- */
-esp_tca9554_io_config_t tca9554_get_io_config(esp_tca9554_gpio_num_t gpio_num);
-
-/*
- * @brief Set TCA9554 io config
- *
- * @param gpio_num  GPIO of TCA9554
- *        io_config  io config
- *
- * @return
- *      - ESP_OK
- *      - ESP_FAIL
- */
-esp_err_t tca9554_set_io_config(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_config_t io_config);
-
-/**
- * @brief Print all TCA9554 registers
- *
- * @return
- *     - void
- */
-void tca9554_read_all();
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _TCA9554_H
+#define _TCA9554_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "driver/gpio.h"
+
+typedef enum {
+    TCA9554_GPIO_NUM_0 = BIT(0),
+    TCA9554_GPIO_NUM_1 = BIT(1),
+    TCA9554_GPIO_NUM_2 = BIT(2),
+    TCA9554_GPIO_NUM_3 = BIT(3),
+    TCA9554_GPIO_NUM_4 = BIT(4),
+    TCA9554_GPIO_NUM_5 = BIT(5),
+    TCA9554_GPIO_NUM_6 = BIT(6),
+    TCA9554_GPIO_NUM_7 = BIT(7),
+    TCA9554_GPIO_NUM_MAX
+} esp_tca9554_gpio_num_t;
+
+typedef enum {
+    TCA9554_IO_LOW,
+    TCA9554_IO_HIGH,
+    TCA9554_LEVEL_ERROR
+} esp_tca9554_io_level_t;
+
+typedef enum {
+    TCA9554_IO_RETAINED,
+    TCA9554_IO_INVERTED
+} esp_tca9554_io_polarity_t;
+
+typedef enum {
+    TCA9554_IO_OUTPUT,
+    TCA9554_IO_INPUT
+} esp_tca9554_io_config_t;
+
+typedef struct {
+    gpio_num_t i2c_sda;
+    gpio_num_t i2c_scl;
+    gpio_num_t interrupt_output;
+} esp_tca9554_config_t;
+
+/*
+ * @brief Initialize TCA9554 chip
+ *
+ * @param codec_cfg  configuration of TCA9554
+ *
+ * @return
+ *      - ESP_OK
+ *      - ESP_FAIL
+ */
+esp_err_t tca9554_init(esp_tca9554_config_t *cfg);
+
+/**
+ * @brief Deinitialize TCA9554 chip
+ *
+ * @return
+ *     - ESP_OK
+ *     - ESP_FAIL
+ */
+esp_err_t tca9554_deinit(void);
+
+/*
+ * @brief Get TCA9554 input level
+ *
+ * @param gpio_num  GPIO of TCA9554
+ *
+ * @return
+ *      - esp_tca9554_io_level_t
+ */
+esp_tca9554_io_level_t tca9554_get_input_state(esp_tca9554_gpio_num_t gpio_num);
+
+/*
+ * @brief Get PCA95xian39 output level
+ *
+ * @param gpio_num  GPIO of TCA9554
+ *
+ * @return
+ *      - esp_tca9554_io_level_t
+ */
+esp_tca9554_io_level_t tca9554_get_output_state(esp_tca9554_gpio_num_t gpio_num);
+
+/*
+ * @brief Get TCA9554 output state
+ *
+ * @param gpio_num  GPIO of TCA9554
+ *
+ * @return
+ *      - esp_tca9554_io_level_t
+ */
+esp_err_t tca9554_set_output_state(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_level_t level);
+
+/*
+ * @brief Set TCA9554 polarity
+ *
+ * @param gpio_num  GPIO of TCA9554
+ *        polarity  polarity
+ *
+ * @return
+ *      - ESP_OK
+ *      - ESP_FAIL
+ */
+esp_err_t tca9554_set_polarity_inversion(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_polarity_t polarity);
+
+/*
+ * @brief Get TCA9554 output level
+ *
+ * @param gpio_num  GPIO of TCA9554
+ *
+ * @return
+ *      - esp_tca9554_io_level_t
+ */
+esp_tca9554_io_config_t tca9554_get_io_config(esp_tca9554_gpio_num_t gpio_num);
+
+/*
+ * @brief Set TCA9554 io config
+ *
+ * @param gpio_num  GPIO of TCA9554
+ *        io_config  io config
+ *
+ * @return
+ *      - ESP_OK
+ *      - ESP_FAIL
+ */
+esp_err_t tca9554_set_io_config(esp_tca9554_gpio_num_t gpio_num, esp_tca9554_io_config_t io_config);
+
+/**
+ * @brief Print all TCA9554 registers
+ *
+ * @return
+ *     - void
+ */
+void tca9554_read_all();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/lib/touch/touch.c b/components/esp_peripherals/lib/touch/touch.c
index 1b3846c5..26948c4a 100644
--- a/components/esp_peripherals/lib/touch/touch.c
+++ b/components/esp_peripherals/lib/touch/touch.c
@@ -1,304 +1,304 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/queue.h"
-
-#include "esp_log.h"
-#include "driver/gpio.h"
-#include "driver/touch_pad.h"
-#include "sys/queue.h"
-#include "touch.h"
-#include "sdkconfig.h"
-#include "audio_mem.h"
-
-#define TOUCHPAD_TRIGGER_THRESHOLD      100
-#define TOUCHPAD_FILTER_PERIOD          (30)
-#define TOUCHPAD_READ_INTERVAL_MS       (TOUCHPAD_FILTER_PERIOD*4)
-#define TOUCHPAD_INTIALIZE_TIME_MS      1000
-#define UPDATE_THRESHOLD_PERIOD_MS      200
-
-static const char *TAG = "TOUCH";
-
-typedef struct esp_touch_item {
-    int                             touch_num;
-    long long                       last_tap_tick;
-    long long                       update_threshold_tick;
-    long long                       last_read_tick;
-    uint16_t                        last_read_value;
-    uint16_t                        untouch_value;
-    uint16_t                        threshold_value;
-    bool                            long_tapped;
-    bool                            tapped;
-    STAILQ_ENTRY(esp_touch_item)    entry;
-} esp_touch_item_t;
-
-struct esp_touch {
-    int long_tap_time_ms;
-    int touch_mask;
-    int tap_threshold_percent;
-    touch_intr_handler intr_fn;
-    void *intr_context;
-    STAILQ_HEAD(esp_touch_list, esp_touch_item) touch_list;
-};
-
-#ifdef periph_tick_get
-#define tick_get periph_tick_get
-#else
-static long long tick_get()
-{
-    struct timeval te;
-    gettimeofday(&te, NULL); // get current time
-    long long milliseconds = te.tv_sec * 1000LL + te.tv_usec / 1000; // calculate milliseconds
-    return milliseconds;
-}
-#endif
-
-static void touch_pad_isr_handler(void* arg)
-{
-    esp_touch_handle_t touch = (esp_touch_handle_t)arg;
-#if CONFIG_IDF_TARGET_ESP32
-    touch_pad_clear_status();
-#endif
-    if (touch->intr_fn) {
-        touch->intr_fn(touch->intr_context);
-    }
-}
-
-esp_touch_handle_t esp_touch_init(touch_config_t *config)
-{
-    esp_touch_handle_t touch = audio_calloc(1, sizeof(struct esp_touch));
-    AUDIO_MEM_CHECK(TAG, touch, return NULL);
-
-    if (config->touch_mask <= 0) {
-        ESP_LOGE(TAG, "required at least 1 touch");
-        return NULL;
-    }
-
-    touch->touch_mask = config->touch_mask;
-    touch->long_tap_time_ms = config->long_tap_time_ms;
-    touch->tap_threshold_percent = config->tap_threshold_percent;
-
-    if (touch->long_tap_time_ms == 0) {
-        touch->long_tap_time_ms = DEFAULT_LONG_TAP_TIME_MS;
-    }
-
-    if (touch->tap_threshold_percent == 0) {
-        touch->tap_threshold_percent = DEFAULT_TOUCH_THRESHOLD_PERCENT;
-    }
-    bool _success = (touch_pad_init() == ESP_OK);
-
-    AUDIO_MEM_CHECK(TAG, _success, {
-        audio_free(touch);
-        return NULL;
-    });
-
-    int touch_mask = touch->touch_mask;
-    int touch_num = 0;
-    int touch_index = 0;
-    STAILQ_INIT(&touch->touch_list);
-    while (touch_mask) {
-        if (touch_mask & 0x01) {
-            ESP_LOGD(TAG, "Mask = %x, current_mask = %x, idx=%d", touch->touch_mask, touch_mask, touch_num);
-            esp_touch_item_t *new_touch = audio_calloc(1, sizeof(esp_touch_item_t));
-            AUDIO_MEM_CHECK(TAG, new_touch, {
-                esp_touch_destroy(touch);
-                audio_free(touch);
-                return NULL;
-            });
-            new_touch->touch_num = touch_num;
-            new_touch->last_read_tick = tick_get() + touch_index * 10;
-#if CONFIG_IDF_TARGET_ESP32
-            touch_pad_config(touch_num, 0);
-#elif CONFIG_IDF_TARGET_ESP32S2
-            touch_pad_config(touch_num);
-#endif
-            if (config->touch_intr_handler) {
-                touch_pad_set_thresh(touch_num, TOUCHPAD_TRIGGER_THRESHOLD);
-            }
-            STAILQ_INSERT_TAIL(&touch->touch_list, new_touch, entry);
-            touch_index ++;
-        }
-        touch_mask >>= 1;
-        touch_num ++;
-    }
-    touch->intr_fn = config->touch_intr_handler;
-    touch->intr_context = config->intr_context;
-
-    if (config->touch_intr_handler) {
-#if CONFIG_IDF_TARGET_ESP32
-        touch_pad_isr_register(touch_pad_isr_handler, touch);
-        touch_pad_intr_enable();
-#elif CONFIG_IDF_TARGET_ESP32S2
-        touch_pad_isr_register(touch_pad_isr_handler, touch, TOUCH_PAD_INTR_MASK_ALL);
-        touch_pad_intr_enable(TOUCH_PAD_INTR_MASK_ALL);
-#endif
-
-    }
-#if CONFIG_IDF_TARGET_ESP32
-    touch_pad_filter_start(TOUCHPAD_FILTER_PERIOD);
-#endif
-    return touch;
-}
-
-static touch_status_t touch_get_state(esp_touch_handle_t touch, esp_touch_item_t *touch_item, long long tick)
-{
-    if (tick - touch_item->last_read_tick < TOUCHPAD_READ_INTERVAL_MS) {
-        return TOUCH_UNCHANGE;
-    }
-
-    touch_item->last_read_tick = tick;
-    esp_err_t err = ESP_OK;
-#if CONFIG_IDF_TARGET_ESP32
-    err = touch_pad_read_filtered(touch_item->touch_num, &touch_item->last_read_value);
-#elif CONFIG_IDF_TARGET_ESP32S2
-    err = ESP_OK;
-#endif
-
-
-    if (err != ESP_OK) {
-        return TOUCH_UNCHANGE;
-    }
-    if (touch_item->untouch_value == 0) {
-        touch_item->untouch_value = touch_item->last_read_value;
-        int threshold_value = touch_item->untouch_value * touch->tap_threshold_percent / 100;
-        touch_item->threshold_value = threshold_value;
-    }
-
-    if (!touch_item->tapped && touch_item->last_read_value < touch_item->threshold_value) {
-        touch_item->tapped = true;
-
-    } else if (touch_item->tapped && touch_item->last_read_value > touch_item->threshold_value) {
-        touch_item->tapped = false;
-    }
-
-    // Update touch threshold
-    if (tick - touch_item->update_threshold_tick > UPDATE_THRESHOLD_PERIOD_MS && !touch_item->tapped) {
-        touch_item->update_threshold_tick = tick;
-        touch_item->untouch_value += touch_item->last_read_value;
-        touch_item->untouch_value /= 2;
-        int threshold_value = touch_item->untouch_value * touch->tap_threshold_percent / 100;
-        touch_item->threshold_value = threshold_value;
-        // ESP_LOGD(TAG, "UPDATE THRESHOLD[%d]=%d", touch_item->touch_num, threshold_value);
-    }
-
-
-    if (touch_item->last_tap_tick == 0 && touch_item->tapped) {
-        touch_item->last_tap_tick = tick_get();
-        touch_item->long_tapped = false;
-        ESP_LOGD(TAG, "TOUCH_TAPPED[%d] %d, threshold %d",
-                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
-        return TOUCH_TAP;
-    }
-
-    if (!touch_item->tapped && touch_item->last_tap_tick && tick_get() - touch_item->last_tap_tick > touch->long_tap_time_ms) {
-        touch_item->last_tap_tick = 0;
-        touch_item->long_tapped = false;
-        ESP_LOGD(TAG, "TOUCH_LONG_RELEASE[%d] %d, threshold %d",
-                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
-        return TOUCH_LONG_RELEASE;
-    }
-
-    if (!touch_item->tapped && touch_item->last_tap_tick) {
-        touch_item->last_tap_tick = 0;
-        touch_item->long_tapped = false;
-        ESP_LOGD(TAG, "TOUCH_RELEASE[%d] %d, threshold %d",
-                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
-        return TOUCH_RELEASE;
-    }
-
-    if (touch_item->long_tapped == false && touch_item->tapped && tick_get() - touch_item->last_tap_tick > touch->long_tap_time_ms) {
-        touch_item->long_tapped = true;
-        ESP_LOGD(TAG, "TOUCH_LONG_TAP[%d] %d, threshold %d",
-                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
-        return TOUCH_LONG_TAP;
-    }
-    return TOUCH_UNCHANGE;
-}
-
-bool esp_touch_read(esp_touch_handle_t touch, touch_result_t *result)
-{
-    esp_touch_item_t *touch_item;
-    touch_status_t touch_status;
-    bool changed = false;
-    memset(result, 0, sizeof(touch_result_t));
-    int tmp;
-    long long tick = tick_get();
-    STAILQ_FOREACH(touch_item, &touch->touch_list, entry) {
-        touch_status = touch_get_state(touch, touch_item, tick);
-        switch (touch_status) {
-            case TOUCH_UNCHANGE:
-                break;
-            case TOUCH_TAP:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= touch_item->touch_num;
-                result->tap_mask |= tmp;
-                break;
-            case TOUCH_RELEASE:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= touch_item->touch_num;
-                result->release_mask |=  tmp;
-                break;
-            case TOUCH_LONG_RELEASE:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= touch_item->touch_num;
-                result->long_release_mask |=  tmp;
-                break;
-            case TOUCH_LONG_TAP:
-                changed = true;
-                tmp = 0x01;
-                tmp <<= touch_item->touch_num;
-                result->long_tap_mask |=  tmp;
-                break;
-        }
-    }
-    return changed;
-}
-
-esp_err_t esp_touch_destroy(esp_touch_handle_t touch)
-{
-    esp_touch_item_t *touch_item, *tmp;
-#if CONFIG_IDF_TARGET_ESP32
-    touch_pad_filter_delete();
-    touch_pad_intr_disable();
-#elif CONFIG_IDF_TARGET_ESP32S2
-    touch_pad_intr_disable(TOUCH_PAD_INTR_MASK_ALL);
-#endif
-
-    touch_pad_isr_deregister(touch_pad_isr_handler, touch);
-    STAILQ_FOREACH_SAFE(touch_item, &touch->touch_list, entry, tmp) {
-        STAILQ_REMOVE(&touch->touch_list, touch_item, esp_touch_item, entry);
-        audio_free(touch_item);
-    }
-    touch_pad_deinit();
-    audio_free(touch);
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/time.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/queue.h"
+
+#include "esp_log.h"
+#include "driver/gpio.h"
+#include "driver/touch_pad.h"
+#include "sys/queue.h"
+#include "touch.h"
+#include "sdkconfig.h"
+#include "audio_mem.h"
+
+#define TOUCHPAD_TRIGGER_THRESHOLD      100
+#define TOUCHPAD_FILTER_PERIOD          (30)
+#define TOUCHPAD_READ_INTERVAL_MS       (TOUCHPAD_FILTER_PERIOD*4)
+#define TOUCHPAD_INTIALIZE_TIME_MS      1000
+#define UPDATE_THRESHOLD_PERIOD_MS      200
+
+static const char *TAG = "TOUCH";
+
+typedef struct esp_touch_item {
+    int                             touch_num;
+    long long                       last_tap_tick;
+    long long                       update_threshold_tick;
+    long long                       last_read_tick;
+    uint16_t                        last_read_value;
+    uint16_t                        untouch_value;
+    uint16_t                        threshold_value;
+    bool                            long_tapped;
+    bool                            tapped;
+    STAILQ_ENTRY(esp_touch_item)    entry;
+} esp_touch_item_t;
+
+struct esp_touch {
+    int long_tap_time_ms;
+    int touch_mask;
+    int tap_threshold_percent;
+    touch_intr_handler intr_fn;
+    void *intr_context;
+    STAILQ_HEAD(esp_touch_list, esp_touch_item) touch_list;
+};
+
+#ifdef periph_tick_get
+#define tick_get periph_tick_get
+#else
+static long long tick_get()
+{
+    struct timeval te;
+    gettimeofday(&te, NULL); // get current time
+    long long milliseconds = te.tv_sec * 1000LL + te.tv_usec / 1000; // calculate milliseconds
+    return milliseconds;
+}
+#endif
+
+static void touch_pad_isr_handler(void* arg)
+{
+    esp_touch_handle_t touch = (esp_touch_handle_t)arg;
+#if CONFIG_IDF_TARGET_ESP32
+    touch_pad_clear_status();
+#endif
+    if (touch->intr_fn) {
+        touch->intr_fn(touch->intr_context);
+    }
+}
+
+esp_touch_handle_t esp_touch_init(touch_config_t *config)
+{
+    esp_touch_handle_t touch = audio_calloc(1, sizeof(struct esp_touch));
+    AUDIO_MEM_CHECK(TAG, touch, return NULL);
+
+    if (config->touch_mask <= 0) {
+        ESP_LOGE(TAG, "required at least 1 touch");
+        return NULL;
+    }
+
+    touch->touch_mask = config->touch_mask;
+    touch->long_tap_time_ms = config->long_tap_time_ms;
+    touch->tap_threshold_percent = config->tap_threshold_percent;
+
+    if (touch->long_tap_time_ms == 0) {
+        touch->long_tap_time_ms = DEFAULT_LONG_TAP_TIME_MS;
+    }
+
+    if (touch->tap_threshold_percent == 0) {
+        touch->tap_threshold_percent = DEFAULT_TOUCH_THRESHOLD_PERCENT;
+    }
+    bool _success = (touch_pad_init() == ESP_OK);
+
+    AUDIO_MEM_CHECK(TAG, _success, {
+        audio_free(touch);
+        return NULL;
+    });
+
+    int touch_mask = touch->touch_mask;
+    int touch_num = 0;
+    int touch_index = 0;
+    STAILQ_INIT(&touch->touch_list);
+    while (touch_mask) {
+        if (touch_mask & 0x01) {
+            ESP_LOGD(TAG, "Mask = %x, current_mask = %x, idx=%d", touch->touch_mask, touch_mask, touch_num);
+            esp_touch_item_t *new_touch = audio_calloc(1, sizeof(esp_touch_item_t));
+            AUDIO_MEM_CHECK(TAG, new_touch, {
+                esp_touch_destroy(touch);
+                audio_free(touch);
+                return NULL;
+            });
+            new_touch->touch_num = touch_num;
+            new_touch->last_read_tick = tick_get() + touch_index * 10;
+#if CONFIG_IDF_TARGET_ESP32
+            touch_pad_config(touch_num, 0);
+#elif CONFIG_IDF_TARGET_ESP32S2
+            touch_pad_config(touch_num);
+#endif
+            if (config->touch_intr_handler) {
+                touch_pad_set_thresh(touch_num, TOUCHPAD_TRIGGER_THRESHOLD);
+            }
+            STAILQ_INSERT_TAIL(&touch->touch_list, new_touch, entry);
+            touch_index ++;
+        }
+        touch_mask >>= 1;
+        touch_num ++;
+    }
+    touch->intr_fn = config->touch_intr_handler;
+    touch->intr_context = config->intr_context;
+
+    if (config->touch_intr_handler) {
+#if CONFIG_IDF_TARGET_ESP32
+        touch_pad_isr_register(touch_pad_isr_handler, touch);
+        touch_pad_intr_enable();
+#elif CONFIG_IDF_TARGET_ESP32S2
+        touch_pad_isr_register(touch_pad_isr_handler, touch, TOUCH_PAD_INTR_MASK_ALL);
+        touch_pad_intr_enable(TOUCH_PAD_INTR_MASK_ALL);
+#endif
+
+    }
+#if CONFIG_IDF_TARGET_ESP32
+    touch_pad_filter_start(TOUCHPAD_FILTER_PERIOD);
+#endif
+    return touch;
+}
+
+static touch_status_t touch_get_state(esp_touch_handle_t touch, esp_touch_item_t *touch_item, long long tick)
+{
+    if (tick - touch_item->last_read_tick < TOUCHPAD_READ_INTERVAL_MS) {
+        return TOUCH_UNCHANGE;
+    }
+
+    touch_item->last_read_tick = tick;
+    esp_err_t err = ESP_OK;
+#if CONFIG_IDF_TARGET_ESP32
+    err = touch_pad_read_filtered(touch_item->touch_num, &touch_item->last_read_value);
+#elif CONFIG_IDF_TARGET_ESP32S2
+    err = ESP_OK;
+#endif
+
+
+    if (err != ESP_OK) {
+        return TOUCH_UNCHANGE;
+    }
+    if (touch_item->untouch_value == 0) {
+        touch_item->untouch_value = touch_item->last_read_value;
+        int threshold_value = touch_item->untouch_value * touch->tap_threshold_percent / 100;
+        touch_item->threshold_value = threshold_value;
+    }
+
+    if (!touch_item->tapped && touch_item->last_read_value < touch_item->threshold_value) {
+        touch_item->tapped = true;
+
+    } else if (touch_item->tapped && touch_item->last_read_value > touch_item->threshold_value) {
+        touch_item->tapped = false;
+    }
+
+    // Update touch threshold
+    if (tick - touch_item->update_threshold_tick > UPDATE_THRESHOLD_PERIOD_MS && !touch_item->tapped) {
+        touch_item->update_threshold_tick = tick;
+        touch_item->untouch_value += touch_item->last_read_value;
+        touch_item->untouch_value /= 2;
+        int threshold_value = touch_item->untouch_value * touch->tap_threshold_percent / 100;
+        touch_item->threshold_value = threshold_value;
+        // ESP_LOGD(TAG, "UPDATE THRESHOLD[%d]=%d", touch_item->touch_num, threshold_value);
+    }
+
+
+    if (touch_item->last_tap_tick == 0 && touch_item->tapped) {
+        touch_item->last_tap_tick = tick_get();
+        touch_item->long_tapped = false;
+        ESP_LOGD(TAG, "TOUCH_TAPPED[%d] %d, threshold %d",
+                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
+        return TOUCH_TAP;
+    }
+
+    if (!touch_item->tapped && touch_item->last_tap_tick && tick_get() - touch_item->last_tap_tick > touch->long_tap_time_ms) {
+        touch_item->last_tap_tick = 0;
+        touch_item->long_tapped = false;
+        ESP_LOGD(TAG, "TOUCH_LONG_RELEASE[%d] %d, threshold %d",
+                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
+        return TOUCH_LONG_RELEASE;
+    }
+
+    if (!touch_item->tapped && touch_item->last_tap_tick) {
+        touch_item->last_tap_tick = 0;
+        touch_item->long_tapped = false;
+        ESP_LOGD(TAG, "TOUCH_RELEASE[%d] %d, threshold %d",
+                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
+        return TOUCH_RELEASE;
+    }
+
+    if (touch_item->long_tapped == false && touch_item->tapped && tick_get() - touch_item->last_tap_tick > touch->long_tap_time_ms) {
+        touch_item->long_tapped = true;
+        ESP_LOGD(TAG, "TOUCH_LONG_TAP[%d] %d, threshold %d",
+                 touch_item->touch_num, touch_item->last_read_value, touch_item->threshold_value);
+        return TOUCH_LONG_TAP;
+    }
+    return TOUCH_UNCHANGE;
+}
+
+bool esp_touch_read(esp_touch_handle_t touch, touch_result_t *result)
+{
+    esp_touch_item_t *touch_item;
+    touch_status_t touch_status;
+    bool changed = false;
+    memset(result, 0, sizeof(touch_result_t));
+    int tmp;
+    long long tick = tick_get();
+    STAILQ_FOREACH(touch_item, &touch->touch_list, entry) {
+        touch_status = touch_get_state(touch, touch_item, tick);
+        switch (touch_status) {
+            case TOUCH_UNCHANGE:
+                break;
+            case TOUCH_TAP:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= touch_item->touch_num;
+                result->tap_mask |= tmp;
+                break;
+            case TOUCH_RELEASE:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= touch_item->touch_num;
+                result->release_mask |=  tmp;
+                break;
+            case TOUCH_LONG_RELEASE:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= touch_item->touch_num;
+                result->long_release_mask |=  tmp;
+                break;
+            case TOUCH_LONG_TAP:
+                changed = true;
+                tmp = 0x01;
+                tmp <<= touch_item->touch_num;
+                result->long_tap_mask |=  tmp;
+                break;
+        }
+    }
+    return changed;
+}
+
+esp_err_t esp_touch_destroy(esp_touch_handle_t touch)
+{
+    esp_touch_item_t *touch_item, *tmp;
+#if CONFIG_IDF_TARGET_ESP32
+    touch_pad_filter_delete();
+    touch_pad_intr_disable();
+#elif CONFIG_IDF_TARGET_ESP32S2
+    touch_pad_intr_disable(TOUCH_PAD_INTR_MASK_ALL);
+#endif
+
+    touch_pad_isr_deregister(touch_pad_isr_handler, touch);
+    STAILQ_FOREACH_SAFE(touch_item, &touch->touch_list, entry, tmp) {
+        STAILQ_REMOVE(&touch->touch_list, touch_item, esp_touch_item, entry);
+        audio_free(touch_item);
+    }
+    touch_pad_deinit();
+    audio_free(touch);
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/lib/touch/touch.h b/components/esp_peripherals/lib/touch/touch.h
index 30774ec6..e12b4c43 100644
--- a/components/esp_peripherals/lib/touch/touch.h
+++ b/components/esp_peripherals/lib/touch/touch.h
@@ -1,104 +1,104 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef _ESP_TOUCH_PAD_H_
-#define _ESP_TOUCH_PAD_H_
-
-#include "audio_error.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief      { item_description }
- */
-typedef enum {
-    TOUCH_UNCHANGE = 0,
-    TOUCH_TAP,
-    TOUCH_RELEASE,
-    TOUCH_LONG_TAP,
-    TOUCH_LONG_RELEASE,
-} touch_status_t;
-
-/**
- * @brief      { item_description }
- */
-typedef struct {
-    int tap_mask;
-    int release_mask;
-    int long_tap_mask;
-    int long_release_mask;
-} touch_result_t;
-
-typedef struct esp_touch *esp_touch_handle_t;
-typedef void (*touch_intr_handler)(void *);
-
-#define DEFAULT_LONG_TAP_TIME_MS        (2*1000)
-#define DEFAULT_TOUCH_THRESHOLD_PERCENT (70)
-
-/**
- * @brief      { item_description }
- */
-typedef struct {
-    int long_tap_time_ms;
-    int touch_mask;
-    int tap_threshold_percent;
-    touch_intr_handler touch_intr_handler;
-    void *intr_context;
-} touch_config_t;
-
-/**
- * @brief      { function_description }
- *
- * @param      config  The configuration
- *
- * @return     { description_of_the_return_value }
- */
-esp_touch_handle_t esp_touch_init(touch_config_t *config);
-
-/**
- * @brief      { function_description }
- *
- * @param[in]  touch   The touch
- * @param      result  The result
- *
- * @return     { description_of_the_return_value }
- */
-bool esp_touch_read(esp_touch_handle_t touch, touch_result_t *result);
-
-/**
- * @brief      { function_description }
- *
- * @param[in]  touch  The touch
- *
- * @return     { description_of_the_return_value }
- */
-esp_err_t esp_touch_destroy(esp_touch_handle_t touch);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _ESP_TOUCH_PAD_H_
+#define _ESP_TOUCH_PAD_H_
+
+#include "audio_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief      { item_description }
+ */
+typedef enum {
+    TOUCH_UNCHANGE = 0,
+    TOUCH_TAP,
+    TOUCH_RELEASE,
+    TOUCH_LONG_TAP,
+    TOUCH_LONG_RELEASE,
+} touch_status_t;
+
+/**
+ * @brief      { item_description }
+ */
+typedef struct {
+    int tap_mask;
+    int release_mask;
+    int long_tap_mask;
+    int long_release_mask;
+} touch_result_t;
+
+typedef struct esp_touch *esp_touch_handle_t;
+typedef void (*touch_intr_handler)(void *);
+
+#define DEFAULT_LONG_TAP_TIME_MS        (2*1000)
+#define DEFAULT_TOUCH_THRESHOLD_PERCENT (70)
+
+/**
+ * @brief      { item_description }
+ */
+typedef struct {
+    int long_tap_time_ms;
+    int touch_mask;
+    int tap_threshold_percent;
+    touch_intr_handler touch_intr_handler;
+    void *intr_context;
+} touch_config_t;
+
+/**
+ * @brief      { function_description }
+ *
+ * @param      config  The configuration
+ *
+ * @return     { description_of_the_return_value }
+ */
+esp_touch_handle_t esp_touch_init(touch_config_t *config);
+
+/**
+ * @brief      { function_description }
+ *
+ * @param[in]  touch   The touch
+ * @param      result  The result
+ *
+ * @return     { description_of_the_return_value }
+ */
+bool esp_touch_read(esp_touch_handle_t touch, touch_result_t *result);
+
+/**
+ * @brief      { function_description }
+ *
+ * @param[in]  touch  The touch
+ *
+ * @return     { description_of_the_return_value }
+ */
+esp_err_t esp_touch_destroy(esp_touch_handle_t touch);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/components/esp_peripherals/periph_adc_button.c b/components/esp_peripherals/periph_adc_button.c
index e4cf8850..5adbea80 100644
--- a/components/esp_peripherals/periph_adc_button.c
+++ b/components/esp_peripherals/periph_adc_button.c
@@ -1,94 +1,94 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "audio_error.h"
-#include "periph_adc_button.h"
-#include "audio_mem.h"
-
-static const char *TAG = "PERIPH_ADC_BUTTON";
-
-typedef struct {
-    int adc_channels;
-    adc_btn_list *list;
-    adc_btn_task_cfg_t task_cfg;
-} periph_adc_btn_t;
-
-static void btn_cb(void *user_data, int adc, int id, adc_btn_state_t state)
-{
-    esp_periph_handle_t self = (esp_periph_handle_t)user_data;
-    periph_adc_button_event_id_t event_id = PERIPH_ADC_BUTTON_IDLE;
-    if (state == ADC_BTN_STATE_PRESSED) {
-        event_id = PERIPH_ADC_BUTTON_PRESSED;
-    } else if (state == ADC_BTN_STATE_LONG_PRESSED) {
-        event_id = PERIPH_ADC_BUTTON_LONG_PRESSED;
-    } else if (state == ADC_BTN_STATE_RELEASE) {
-        event_id = PERIPH_ADC_BUTTON_RELEASE;
-    } else if (state == ADC_BTN_STATE_LONG_RELEASE) {
-        event_id = PERIPH_ADC_BUTTON_LONG_RELEASE;
-    }
-    //Send ID as data and ADC as data_len
-    esp_periph_send_event(self, event_id, (void *)id, adc);
-}
-
-static esp_err_t _adc_button_destroy(esp_periph_handle_t self)
-{
-    periph_adc_btn_t *periph_adc_btn = esp_periph_get_data(self);
-    adc_btn_delete_task();
-    adc_btn_destroy_list(periph_adc_btn->list);
-    audio_free(periph_adc_btn);
-    return ESP_OK;
-}
-
-static esp_err_t _adc_button_init(esp_periph_handle_t self)
-{
-    periph_adc_btn_t *periph_adc_btn = esp_periph_get_data(self);
-    adc_btn_init((void *)self, btn_cb, periph_adc_btn->list, &periph_adc_btn->task_cfg);
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_adc_button_init(periph_adc_button_cfg_t *config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_ADC_BTN, "periph_adc_btn");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-
-    periph_adc_btn_t *periph_adc_btn = audio_calloc(1, sizeof(periph_adc_btn_t));
-    AUDIO_MEM_CHECK(TAG, periph_adc_btn, {
-        audio_free(periph);
-        return NULL;
-    });
-    periph_adc_btn->adc_channels = config->arr_size;
-    periph_adc_btn->list = adc_btn_create_list(config->arr, config->arr_size);
-    memcpy(&periph_adc_btn->task_cfg, &config->task_cfg, sizeof(adc_btn_task_cfg_t));
-    AUDIO_MEM_CHECK(TAG, periph_adc_btn->list, {
-        audio_free(periph);
-        audio_free(periph_adc_btn);
-        return NULL;
-    });
-
-    esp_periph_set_data(periph, periph_adc_btn);
-    esp_periph_set_function(periph, _adc_button_init, NULL, _adc_button_destroy);
-    return periph;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "audio_error.h"
+#include "periph_adc_button.h"
+#include "audio_mem.h"
+
+static const char *TAG = "PERIPH_ADC_BUTTON";
+
+typedef struct {
+    int adc_channels;
+    adc_btn_list *list;
+    adc_btn_task_cfg_t task_cfg;
+} periph_adc_btn_t;
+
+static void btn_cb(void *user_data, int adc, int id, adc_btn_state_t state)
+{
+    esp_periph_handle_t self = (esp_periph_handle_t)user_data;
+    periph_adc_button_event_id_t event_id = PERIPH_ADC_BUTTON_IDLE;
+    if (state == ADC_BTN_STATE_PRESSED) {
+        event_id = PERIPH_ADC_BUTTON_PRESSED;
+    } else if (state == ADC_BTN_STATE_LONG_PRESSED) {
+        event_id = PERIPH_ADC_BUTTON_LONG_PRESSED;
+    } else if (state == ADC_BTN_STATE_RELEASE) {
+        event_id = PERIPH_ADC_BUTTON_RELEASE;
+    } else if (state == ADC_BTN_STATE_LONG_RELEASE) {
+        event_id = PERIPH_ADC_BUTTON_LONG_RELEASE;
+    }
+    //Send ID as data and ADC as data_len
+    esp_periph_send_event(self, event_id, (void *)id, adc);
+}
+
+static esp_err_t _adc_button_destroy(esp_periph_handle_t self)
+{
+    periph_adc_btn_t *periph_adc_btn = esp_periph_get_data(self);
+    adc_btn_delete_task();
+    adc_btn_destroy_list(periph_adc_btn->list);
+    audio_free(periph_adc_btn);
+    return ESP_OK;
+}
+
+static esp_err_t _adc_button_init(esp_periph_handle_t self)
+{
+    periph_adc_btn_t *periph_adc_btn = esp_periph_get_data(self);
+    adc_btn_init((void *)self, btn_cb, periph_adc_btn->list, &periph_adc_btn->task_cfg);
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_adc_button_init(periph_adc_button_cfg_t *config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_ADC_BTN, "periph_adc_btn");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+
+    periph_adc_btn_t *periph_adc_btn = audio_calloc(1, sizeof(periph_adc_btn_t));
+    AUDIO_MEM_CHECK(TAG, periph_adc_btn, {
+        audio_free(periph);
+        return NULL;
+    });
+    periph_adc_btn->adc_channels = config->arr_size;
+    periph_adc_btn->list = adc_btn_create_list(config->arr, config->arr_size);
+    memcpy(&periph_adc_btn->task_cfg, &config->task_cfg, sizeof(adc_btn_task_cfg_t));
+    AUDIO_MEM_CHECK(TAG, periph_adc_btn->list, {
+        audio_free(periph);
+        audio_free(periph_adc_btn);
+        return NULL;
+    });
+
+    esp_periph_set_data(periph, periph_adc_btn);
+    esp_periph_set_function(periph, _adc_button_init, NULL, _adc_button_destroy);
+    return periph;
+}
diff --git a/components/esp_peripherals/periph_aw2013.c b/components/esp_peripherals/periph_aw2013.c
index 5cbf4255..f1c5b34a 100644
--- a/components/esp_peripherals/periph_aw2013.c
+++ b/components/esp_peripherals/periph_aw2013.c
@@ -1,162 +1,162 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "audio_mem.h"
-#include "esp_peripherals.h"
-#include "aw2013.h"
-#include "periph_aw2013.h"
-
-static const char *TAG = "PERIPH_AW2013";
-
-typedef struct {
-    aw2013_time_level_t time[5];
-    aw2013_brightness_t bright;
-    periph_aw2013_mode_t mode;
-    uint32_t rgb_value;
-    uint8_t rpt_time;
-} periph_aw2013_t;
-
-static esp_err_t _aw2013_set_mode(periph_aw2013_mode_t mode)
-{
-    esp_err_t ret = ESP_OK;
-    switch (mode) {
-        case AW2013_MODE_LED:
-            ret |= aw2013_enable_auto_flash(false);
-            ret |= aw2013_enable_fade_mode(false);
-            break;
-        case AW2013_MODE_FADE:
-            ret |= aw2013_enable_auto_flash(false);
-            ret |= aw2013_enable_fade_mode(true);
-            break;
-        case AW2013_MODE_AUTO:
-            ret |= aw2013_enable_auto_flash(true);
-            ret |= aw2013_enable_fade_mode(false);
-            break;
-        default:
-            ESP_LOGE(TAG, "Invalid mode :%d", mode);
-            return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _aw2013_init(esp_periph_handle_t self)
-{
-    esp_err_t ret = ESP_OK;
-    periph_aw2013_t *aw2013 = esp_periph_get_data(self);
-
-    ret |= aw2013_init();
-    for (int i = 0; i <= AW2013_TIME_4; i++) {
-        ret |= aw2013_set_time(i, aw2013->time[i]);
-    }
-    ret |= aw2013_set_repeat_time(aw2013->rpt_time);
-    ret |= aw2013_set_brightness(aw2013->bright);
-    ret |= _aw2013_set_mode(aw2013->mode);
-    ret |= aw2013_set_pwm_value(aw2013->rgb_value);
-    return ret;
-}
-
-static esp_err_t _aw2013_destroy(esp_periph_handle_t self)
-{
-    esp_err_t ret = ESP_OK;
-    periph_aw2013_t *aw2013 = esp_periph_get_data(self);
-
-    ret |= aw2013_deinit();
-    audio_free(aw2013);
-    return ret;
-}
-
-esp_err_t periph_aw2013_set_brightless(esp_periph_handle_t periph, aw2013_brightness_t bright)
-{
-    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
-    if (bright < AW2013_BRIGHT_0 || bright > AW2013_BRIGHT_3) {
-        ESP_LOGE(TAG, "Fail to set parameters, bright: %d", bright);
-        return ESP_FAIL;
-    }
-    aw2013->bright = bright;
-    return aw2013_set_brightness(bright);
-}
-
-esp_err_t periph_aw2013_set_rgb_value(esp_periph_handle_t periph, uint32_t value)
-{
-    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
-    aw2013->rgb_value = value;
-    return aw2013_set_pwm_value(value);
-}
-
-esp_err_t periph_aw2013_set_repeat_time(esp_periph_handle_t periph, uint8_t cnt)
-{
-    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
-    aw2013->rpt_time = cnt;
-    return aw2013_set_repeat_time(cnt);
-}
-
-esp_err_t periph_aw2013_set_mode(esp_periph_handle_t periph, periph_aw2013_mode_t mode)
-{
-    if (mode < 0 || mode > AW2013_MODE_AUTO) {
-        ESP_LOGE(TAG, "Fail to set parameters, mode: %d", mode);
-        return ESP_FAIL;
-    }
-    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
-    aw2013->mode = mode;
-    return _aw2013_set_mode(mode);
-}
-
-esp_err_t periph_aw2013_set_time(esp_periph_handle_t periph, aw2013_time_t time, aw2013_time_level_t level)
-{
-    if (time < 0 || time > AW2013_TIME_4 || level < 0 || level > AW2013_TIME_LEVEL_8) {
-        ESP_LOGE(TAG, "Fail to set parameters, time: %d, level: %d", time, level);
-        return ESP_FAIL;
-    }
-    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
-    aw2013->time[time] = level;
-    return aw2013_set_time(time, level);
-}
-
-esp_periph_handle_t periph_aw2013_init(periph_aw2013_cfg_t *aw2013_cfg)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_AW2013, "periph_aw2013");
-    AUDIO_NULL_CHECK(TAG, periph, return NULL);
-
-    periph_aw2013_t *aw2013 = audio_calloc(1, sizeof(periph_aw2013_t));
-    AUDIO_MEM_CHECK(TAG, aw2013, {
-        audio_free(periph);
-        return NULL;
-    });
-
-    aw2013->mode = aw2013_cfg->mode;
-    aw2013->bright = aw2013_cfg->bright;
-    aw2013->rgb_value = aw2013_cfg->rgb_value;
-    // Default time period
-    aw2013->time[0] = AW2013_TIME_LEVEL_1;
-    aw2013->time[1] = AW2013_TIME_LEVEL_3;
-    aw2013->time[2] = AW2013_TIME_LEVEL_3;
-    aw2013->time[3] = AW2013_TIME_LEVEL_3;
-    aw2013->time[4] = AW2013_TIME_LEVEL_2;
-    // Cycle all the time
-    aw2013->rpt_time = 0;
-
-    esp_periph_set_data(periph, aw2013);
-    esp_periph_set_function(periph, _aw2013_init, NULL, _aw2013_destroy);
-    return periph;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "audio_mem.h"
+#include "esp_peripherals.h"
+#include "aw2013.h"
+#include "periph_aw2013.h"
+
+static const char *TAG = "PERIPH_AW2013";
+
+typedef struct {
+    aw2013_time_level_t time[5];
+    aw2013_brightness_t bright;
+    periph_aw2013_mode_t mode;
+    uint32_t rgb_value;
+    uint8_t rpt_time;
+} periph_aw2013_t;
+
+static esp_err_t _aw2013_set_mode(periph_aw2013_mode_t mode)
+{
+    esp_err_t ret = ESP_OK;
+    switch (mode) {
+        case AW2013_MODE_LED:
+            ret |= aw2013_enable_auto_flash(false);
+            ret |= aw2013_enable_fade_mode(false);
+            break;
+        case AW2013_MODE_FADE:
+            ret |= aw2013_enable_auto_flash(false);
+            ret |= aw2013_enable_fade_mode(true);
+            break;
+        case AW2013_MODE_AUTO:
+            ret |= aw2013_enable_auto_flash(true);
+            ret |= aw2013_enable_fade_mode(false);
+            break;
+        default:
+            ESP_LOGE(TAG, "Invalid mode :%d", mode);
+            return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _aw2013_init(esp_periph_handle_t self)
+{
+    esp_err_t ret = ESP_OK;
+    periph_aw2013_t *aw2013 = esp_periph_get_data(self);
+
+    ret |= aw2013_init();
+    for (int i = 0; i <= AW2013_TIME_4; i++) {
+        ret |= aw2013_set_time(i, aw2013->time[i]);
+    }
+    ret |= aw2013_set_repeat_time(aw2013->rpt_time);
+    ret |= aw2013_set_brightness(aw2013->bright);
+    ret |= _aw2013_set_mode(aw2013->mode);
+    ret |= aw2013_set_pwm_value(aw2013->rgb_value);
+    return ret;
+}
+
+static esp_err_t _aw2013_destroy(esp_periph_handle_t self)
+{
+    esp_err_t ret = ESP_OK;
+    periph_aw2013_t *aw2013 = esp_periph_get_data(self);
+
+    ret |= aw2013_deinit();
+    audio_free(aw2013);
+    return ret;
+}
+
+esp_err_t periph_aw2013_set_brightless(esp_periph_handle_t periph, aw2013_brightness_t bright)
+{
+    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
+    if (bright < AW2013_BRIGHT_0 || bright > AW2013_BRIGHT_3) {
+        ESP_LOGE(TAG, "Fail to set parameters, bright: %d", bright);
+        return ESP_FAIL;
+    }
+    aw2013->bright = bright;
+    return aw2013_set_brightness(bright);
+}
+
+esp_err_t periph_aw2013_set_rgb_value(esp_periph_handle_t periph, uint32_t value)
+{
+    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
+    aw2013->rgb_value = value;
+    return aw2013_set_pwm_value(value);
+}
+
+esp_err_t periph_aw2013_set_repeat_time(esp_periph_handle_t periph, uint8_t cnt)
+{
+    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
+    aw2013->rpt_time = cnt;
+    return aw2013_set_repeat_time(cnt);
+}
+
+esp_err_t periph_aw2013_set_mode(esp_periph_handle_t periph, periph_aw2013_mode_t mode)
+{
+    if (mode < 0 || mode > AW2013_MODE_AUTO) {
+        ESP_LOGE(TAG, "Fail to set parameters, mode: %d", mode);
+        return ESP_FAIL;
+    }
+    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
+    aw2013->mode = mode;
+    return _aw2013_set_mode(mode);
+}
+
+esp_err_t periph_aw2013_set_time(esp_periph_handle_t periph, aw2013_time_t time, aw2013_time_level_t level)
+{
+    if (time < 0 || time > AW2013_TIME_4 || level < 0 || level > AW2013_TIME_LEVEL_8) {
+        ESP_LOGE(TAG, "Fail to set parameters, time: %d, level: %d", time, level);
+        return ESP_FAIL;
+    }
+    periph_aw2013_t *aw2013 = esp_periph_get_data(periph);
+    aw2013->time[time] = level;
+    return aw2013_set_time(time, level);
+}
+
+esp_periph_handle_t periph_aw2013_init(periph_aw2013_cfg_t *aw2013_cfg)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_AW2013, "periph_aw2013");
+    AUDIO_NULL_CHECK(TAG, periph, return NULL);
+
+    periph_aw2013_t *aw2013 = audio_calloc(1, sizeof(periph_aw2013_t));
+    AUDIO_MEM_CHECK(TAG, aw2013, {
+        audio_free(periph);
+        return NULL;
+    });
+
+    aw2013->mode = aw2013_cfg->mode;
+    aw2013->bright = aw2013_cfg->bright;
+    aw2013->rgb_value = aw2013_cfg->rgb_value;
+    // Default time period
+    aw2013->time[0] = AW2013_TIME_LEVEL_1;
+    aw2013->time[1] = AW2013_TIME_LEVEL_3;
+    aw2013->time[2] = AW2013_TIME_LEVEL_3;
+    aw2013->time[3] = AW2013_TIME_LEVEL_3;
+    aw2013->time[4] = AW2013_TIME_LEVEL_2;
+    // Cycle all the time
+    aw2013->rpt_time = 0;
+
+    esp_periph_set_data(periph, aw2013);
+    esp_periph_set_function(periph, _aw2013_init, NULL, _aw2013_destroy);
+    return periph;
+}
diff --git a/components/esp_peripherals/periph_button.c b/components/esp_peripherals/periph_button.c
index 0719d18c..7ea26388 100644
--- a/components/esp_peripherals/periph_button.c
+++ b/components/esp_peripherals/periph_button.c
@@ -1,127 +1,127 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "button.h"
-#include "periph_button.h"
-#include "audio_mem.h"
-
-static const char* TAG = "PERIPH_BUTTON";
-
-#define VALIDATE_BTN(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_BUTTON)) { \
-    ESP_LOGE(TAG, "Invalid BUTTON periph, at line %d", __LINE__);\
-    return ret;\
-}
-
-typedef struct {
-    esp_button_handle_t btn;
-    uint64_t gpio_mask;
-    int long_press_time_ms;
-} periph_button_t;
-
-static void button_send_event(esp_periph_handle_t self, int event_id, uint64_t mask)
-{
-    int gpio_num = 0;
-    while (mask) {
-        if (mask & 0x01) {
-            esp_periph_send_event(self, event_id, (void*)gpio_num, 0);
-        }
-        mask >>= 1;
-        gpio_num ++;
-    }
-}
-
-static esp_err_t _button_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    button_result_t result;
-    periph_button_t *periph_btn = esp_periph_get_data(self);
-    if (button_read(periph_btn->btn, &result)) {
-        ESP_LOGD(TAG, "Button event, press_mask %llx, release_mask: %llx, long_press_mask: %llx, long_release_mask: %llx",
-                 result.press_mask, result.release_mask, result.long_press_mask, result.long_release_mask);
-        button_send_event(self, PERIPH_BUTTON_PRESSED, result.press_mask);
-        button_send_event(self, PERIPH_BUTTON_RELEASE, result.release_mask);
-        button_send_event(self, PERIPH_BUTTON_LONG_PRESSED, result.long_press_mask);
-        button_send_event(self, PERIPH_BUTTON_LONG_RELEASE, result.long_release_mask);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _button_destroy(esp_periph_handle_t self)
-{
-    periph_button_t *periph_btn = esp_periph_get_data(self);
-    esp_periph_stop_timer(self);
-    button_destroy(periph_btn->btn);
-    audio_free(periph_btn);
-    return ESP_OK;
-}
-
-static void IRAM_ATTR button_intr_handler(void* param)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t)param;
-    esp_periph_send_cmd_from_isr(periph, 0, NULL, 0);
-}
-
-static void button_timer_handler(xTimerHandle tmr)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
-    esp_periph_send_cmd_from_isr(periph, 0, NULL, 0);
-}
-
-static esp_err_t _button_init(esp_periph_handle_t self)
-{
-    int ret = 0;
-    VALIDATE_BTN(self, ESP_FAIL);
-    periph_button_t *periph_btn = esp_periph_get_data(self);
-
-    button_config_t btn_config = {
-        .gpio_mask = periph_btn->gpio_mask,
-        .long_press_time_ms = periph_btn->long_press_time_ms,
-        .button_intr_handler = button_intr_handler,
-        .intr_context = self,
-    };
-    periph_btn->btn = button_init(&btn_config);
-
-    esp_periph_start_timer(self, 50/portTICK_RATE_MS, button_timer_handler);
-    return ret;
-}
-
-esp_periph_handle_t periph_button_init(periph_button_cfg_t *config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_BUTTON, "periph_btn");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-    periph_button_t *periph_btn = audio_calloc(1, sizeof(periph_button_t));
-
-    AUDIO_MEM_CHECK(TAG, periph_btn, {
-        audio_free(periph);
-        return NULL;
-    });
-    periph_btn->gpio_mask = config->gpio_mask;
-    periph_btn->long_press_time_ms = config->long_press_time_ms;
-
-    esp_periph_set_data(periph, periph_btn);
-    esp_periph_set_function(periph, _button_init, _button_run, _button_destroy);
-
-    return periph;
-}
-
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "button.h"
+#include "periph_button.h"
+#include "audio_mem.h"
+
+static const char* TAG = "PERIPH_BUTTON";
+
+#define VALIDATE_BTN(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_BUTTON)) { \
+    ESP_LOGE(TAG, "Invalid BUTTON periph, at line %d", __LINE__);\
+    return ret;\
+}
+
+typedef struct {
+    esp_button_handle_t btn;
+    uint64_t gpio_mask;
+    int long_press_time_ms;
+} periph_button_t;
+
+static void button_send_event(esp_periph_handle_t self, int event_id, uint64_t mask)
+{
+    int gpio_num = 0;
+    while (mask) {
+        if (mask & 0x01) {
+            esp_periph_send_event(self, event_id, (void*)gpio_num, 0);
+        }
+        mask >>= 1;
+        gpio_num ++;
+    }
+}
+
+static esp_err_t _button_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    button_result_t result;
+    periph_button_t *periph_btn = esp_periph_get_data(self);
+    if (button_read(periph_btn->btn, &result)) {
+        ESP_LOGD(TAG, "Button event, press_mask %llx, release_mask: %llx, long_press_mask: %llx, long_release_mask: %llx",
+                 result.press_mask, result.release_mask, result.long_press_mask, result.long_release_mask);
+        button_send_event(self, PERIPH_BUTTON_PRESSED, result.press_mask);
+        button_send_event(self, PERIPH_BUTTON_RELEASE, result.release_mask);
+        button_send_event(self, PERIPH_BUTTON_LONG_PRESSED, result.long_press_mask);
+        button_send_event(self, PERIPH_BUTTON_LONG_RELEASE, result.long_release_mask);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _button_destroy(esp_periph_handle_t self)
+{
+    periph_button_t *periph_btn = esp_periph_get_data(self);
+    esp_periph_stop_timer(self);
+    button_destroy(periph_btn->btn);
+    audio_free(periph_btn);
+    return ESP_OK;
+}
+
+static void IRAM_ATTR button_intr_handler(void* param)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t)param;
+    esp_periph_send_cmd_from_isr(periph, 0, NULL, 0);
+}
+
+static void button_timer_handler(TimerHandle_t tmr)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
+    esp_periph_send_cmd_from_isr(periph, 0, NULL, 0);
+}
+
+static esp_err_t _button_init(esp_periph_handle_t self)
+{
+    int ret = 0;
+    VALIDATE_BTN(self, ESP_FAIL);
+    periph_button_t *periph_btn = esp_periph_get_data(self);
+
+    button_config_t btn_config = {
+        .gpio_mask = periph_btn->gpio_mask,
+        .long_press_time_ms = periph_btn->long_press_time_ms,
+        .button_intr_handler = button_intr_handler,
+        .intr_context = self,
+    };
+    periph_btn->btn = button_init(&btn_config);
+
+    esp_periph_start_timer(self, 50/portTICK_PERIOD_MS, button_timer_handler);
+    return ret;
+}
+
+esp_periph_handle_t periph_button_init(periph_button_cfg_t *config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_BUTTON, "periph_btn");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+    periph_button_t *periph_btn = audio_calloc(1, sizeof(periph_button_t));
+
+    AUDIO_MEM_CHECK(TAG, periph_btn, {
+        audio_free(periph);
+        return NULL;
+    });
+    periph_btn->gpio_mask = config->gpio_mask;
+    periph_btn->long_press_time_ms = config->long_press_time_ms;
+
+    esp_periph_set_data(periph, periph_btn);
+    esp_periph_set_function(periph, _button_init, _button_run, _button_destroy);
+
+    return periph;
+}
+
diff --git a/components/esp_peripherals/periph_console.c b/components/esp_peripherals/periph_console.c
index 53b18fb4..d4a9b50f 100644
--- a/components/esp_peripherals/periph_console.c
+++ b/components/esp_peripherals/periph_console.c
@@ -1,324 +1,324 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "driver/uart.h"
-#include "esp_log.h"
-#include "esp_console.h"
-#include "esp_vfs_dev.h"
-#include "sys/queue.h"
-#include "argtable3/argtable3.h"
-#include "periph_console.h"
-#include "audio_mem.h"
-
-#include "audio_idf_version.h"
-
-#define CONSOLE_MAX_ARGUMENTS (5)
-static const char *TAG = "PERIPH_CONSOLE";
-static const int STOPPED_BIT = BIT1;
-
-typedef struct periph_console *periph_console_handle_t;
-
-typedef struct periph_console {
-    char                        *buffer;
-    int                         total_bytes;
-    bool                        run;
-    const periph_console_cmd_t  *commands;
-    int                         command_num;
-    EventGroupHandle_t          state_event_bits;
-    int                         task_stack;
-    int                         task_prio;
-    int                         buffer_size;
-    char                        *prompt_string;
-} periph_console_t;
-
-static char *conslole_parse_arguments(char *str, char **saveptr)
-{
-    char *p;
-
-    if (str != NULL) {
-        *saveptr = str;
-    }
-
-    p = *saveptr;
-    if (!p) {
-        return NULL;
-    }
-    /* Skipping white space.*/
-    while (*p == ' ' || *p == '\t') {
-        p++;
-    }
-
-    if (*p == '"') {
-        /* If an argument starts with a double quote then its delimiter is another quote.*/
-        p++;
-        *saveptr = strstr(p, "\"");
-    } else {
-        /* The delimiter is white space.*/
-        *saveptr = strpbrk(p, " \t");
-    }
-
-    /* Replacing the delimiter with a zero.*/
-    if (*saveptr != NULL) {
-        *(*saveptr)++ = '\0';
-    }
-    return *p != '\0' ? p : NULL;
-}
-
-bool console_get_line(periph_console_handle_t console, unsigned max_size, TickType_t time_to_wait)
-{
-    char c;
-    char tx[3];
-    int nread = 0;
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-    nread = uart_read_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (uint8_t *)&c, 1, time_to_wait);
-#else
-    nread = uart_read_bytes(CONFIG_CONSOLE_UART_NUM, (uint8_t *)&c, 1, time_to_wait);
-#endif
-
-    if (nread <= 0) {
-        return false;
-    }
-    if ((c == 8) || (c == 127)) {  // backspace or del
-        if (console->total_bytes > 0) {
-            console->total_bytes --;
-            tx[0] = c;
-            tx[1] = 0x20;
-            tx[2] = c;
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-            uart_write_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (const char *)tx, 3);
-#else
-            uart_write_bytes(CONFIG_CONSOLE_UART_NUM, (const char *)tx, 3);
-#endif
-
-        }
-        return false;
-    }
-    if (c == '\n' || c == '\r') {
-        tx[0] = '\r';
-        tx[1] = '\n';
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-        uart_write_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (const char *)tx, 2);
-#else
-        uart_write_bytes(CONFIG_CONSOLE_UART_NUM, (const char *)tx, 2);
-#endif
-
-        console->buffer[console->total_bytes] = 0;
-        return true;
-    }
-
-    if (c < 0x20) {
-        return false;
-    }
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-    uart_write_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (const char *)&c, 1);
-#else
-    uart_write_bytes(CONFIG_CONSOLE_UART_NUM, (const char *)&c, 1);
-#endif
-
-    console->buffer[console->total_bytes++] = (char)c;
-    if (console->total_bytes > max_size) {
-        console->total_bytes = 0;
-    }
-
-    return false;
-}
-
-static bool console_exec(esp_periph_handle_t self, char *cmd, int argc, char *argv[])
-{
-    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
-    if (cmd == NULL) {
-        return false;
-    }
-    int i;
-    for (i = 0; i < console->command_num; i++) {
-        if (strcasecmp(cmd, console->commands[i].cmd) == 0) {
-            if (console->commands[i].func) {
-                console->commands[i].func(self, argc, argv);
-                return true;
-            }
-            int cmd_id = console->commands[i].id;
-            if (cmd_id == 0) {
-                cmd_id = i;
-            }
-            esp_periph_send_event(self, cmd_id, argv, argc);
-            return true;
-        }
-    }
-    printf("----------------------\r\n");
-    printf("Perpheral console HELP\r\n");
-    printf("----------------------\r\n");
-    for (i = 0; i < console->command_num; i++) {
-        printf("%s \t%s\r\n", console->commands[i].cmd, console->commands[i].help);
-    }
-    return false;
-}
-
-static esp_err_t _console_destroy(esp_periph_handle_t self)
-{
-    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
-    console->run = false;
-    xEventGroupWaitBits(console->state_event_bits, STOPPED_BIT, false, true, portMAX_DELAY);
-    vEventGroupDelete(console->state_event_bits);
-    if (console->prompt_string) {
-        audio_free(console->prompt_string);
-    }
-    audio_free(console->buffer);
-    audio_free(console);
-    return ESP_OK;
-}
-
-static void _console_task(void *pv)
-{
-    esp_periph_handle_t self = (esp_periph_handle_t)pv;
-    char *lp, *cmd, *tokp;
-    char *args[CONSOLE_MAX_ARGUMENTS + 1];
-    int n;
-
-    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
-    if (console->total_bytes >= console->buffer_size) {
-        console->total_bytes = 0;
-    }
-    console->run = true;
-    xEventGroupClearBits(console->state_event_bits, STOPPED_BIT);
-    const char *prompt_string = CONSOLE_DEFAULT_PROMPT_STRING;
-    if (console->prompt_string) {
-        prompt_string = console->prompt_string;
-    }
-    printf("\r\n%s ", prompt_string);
-    while (console->run) {
-        if (console_get_line(console, console->buffer_size, 10 / portTICK_RATE_MS)) {
-            if (console->total_bytes) {
-                ESP_LOGD(TAG, "Read line: %s", console->buffer);
-            }
-            lp = conslole_parse_arguments(console->buffer, &tokp);
-            cmd = lp;
-            n = 0;
-            while ((lp = conslole_parse_arguments(NULL, &tokp)) != NULL) {
-                if (n >= CONSOLE_MAX_ARGUMENTS) {
-                    printf("too many arguments\r\n");
-                    cmd = NULL;
-                    break;
-                }
-                args[n++] = lp;
-            }
-            args[n] = NULL;
-            if (console->total_bytes > 0) {
-                console_exec(self, cmd, n, args);
-                console->total_bytes = 0;
-            }
-            printf("%s ", prompt_string);
-        }
-
-    }
-    xEventGroupSetBits(console->state_event_bits, STOPPED_BIT);
-    vTaskDelete(NULL);
-}
-
-static esp_err_t _console_init(esp_periph_handle_t self)
-{
-    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
-
-    setvbuf(stdin, NULL, _IONBF, 0);
-    setvbuf(stdout, NULL, _IONBF, 0);
-
-
-    /* Minicom, screen, idf_monitor send CR when ENTER key is pressed */
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
-    esp_vfs_dev_uart_port_set_rx_line_endings(CONFIG_ESP_CONSOLE_UART_NUM, ESP_LINE_ENDINGS_CR);
-#else
-    esp_vfs_dev_uart_set_rx_line_endings(ESP_LINE_ENDINGS_CR);
-#endif
-    /* Move the caret to the beginning of the next line on '\n' */
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
-    esp_vfs_dev_uart_port_set_tx_line_endings(CONFIG_ESP_CONSOLE_UART_NUM, ESP_LINE_ENDINGS_CRLF);
-#else
-    esp_vfs_dev_uart_set_tx_line_endings(ESP_LINE_ENDINGS_CRLF);
-#endif
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-    uart_driver_install(CONFIG_ESP_CONSOLE_UART_NUM, console->buffer_size * 2, 0, 0, NULL, 0);
-#else
-    uart_driver_install(CONFIG_CONSOLE_UART_NUM, console->buffer_size * 2, 0, 0, NULL, 0);
-#endif
-
-    /* Tell VFS to use UART driver */
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-    esp_vfs_dev_uart_use_driver(CONFIG_ESP_CONSOLE_UART_NUM);
-#else
-    esp_vfs_dev_uart_use_driver(CONFIG_CONSOLE_UART_NUM);
-#endif
-
-    console->buffer = (char *) audio_malloc(console->buffer_size);
-    AUDIO_MEM_CHECK(TAG, console->buffer, {
-        return ESP_ERR_NO_MEM;
-    });
-
-    if (xTaskCreate(_console_task, "console_task", console->task_stack, self, console->task_prio, NULL) != pdTRUE) {
-        ESP_LOGE(TAG, "Error create console task, memory exhausted?");
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-
-esp_periph_handle_t periph_console_init(periph_console_cfg_t *config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_CONSOLE, "periph_console");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-    periph_console_t *console = audio_calloc(1, sizeof(periph_console_t));
-    AUDIO_MEM_CHECK(TAG, console, {
-        audio_free(periph);
-        return NULL;
-    });
-    console->commands = config->commands;
-    console->command_num = config->command_num;
-    console->task_stack = CONSOLE_DEFAULT_TASK_STACK;
-    console->task_prio = CONSOLE_DEFAULT_TASK_PRIO;
-    console->buffer_size = CONSOLE_DEFAULT_BUFFER_SIZE;
-     if (config->buffer_size > 0) {
-        console->buffer_size = config->buffer_size;
-    }
-    if (config->task_stack > 0) {
-        console->task_stack = config->task_stack;
-    }
-    if (config->task_prio) {
-        console->task_prio = config->task_prio;
-    }
-    if (config->prompt_string) {
-        console->prompt_string = audio_strdup(config->prompt_string);
-        AUDIO_MEM_CHECK(TAG, console->prompt_string, {
-            audio_free(periph);
-            audio_free(console);
-            return NULL;
-        });
-    }
-    console->state_event_bits = xEventGroupCreate();
-    esp_periph_set_data(periph, console);
-    esp_periph_set_function(periph, _console_init, NULL, _console_destroy);
-    return periph;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "driver/uart.h"
+#include "esp_log.h"
+#include "esp_console.h"
+#include "esp_vfs_dev.h"
+#include "sys/queue.h"
+#include "argtable3/argtable3.h"
+#include "periph_console.h"
+#include "audio_mem.h"
+
+#include "audio_idf_version.h"
+
+#define CONSOLE_MAX_ARGUMENTS (5)
+static const char *TAG = "PERIPH_CONSOLE";
+static const int STOPPED_BIT = BIT1;
+
+typedef struct periph_console *periph_console_handle_t;
+
+typedef struct periph_console {
+    char                        *buffer;
+    int                         total_bytes;
+    bool                        run;
+    const periph_console_cmd_t  *commands;
+    int                         command_num;
+    EventGroupHandle_t          state_event_bits;
+    int                         task_stack;
+    int                         task_prio;
+    int                         buffer_size;
+    char                        *prompt_string;
+} periph_console_t;
+
+static char *conslole_parse_arguments(char *str, char **saveptr)
+{
+    char *p;
+
+    if (str != NULL) {
+        *saveptr = str;
+    }
+
+    p = *saveptr;
+    if (!p) {
+        return NULL;
+    }
+    /* Skipping white space.*/
+    while (*p == ' ' || *p == '\t') {
+        p++;
+    }
+
+    if (*p == '"') {
+        /* If an argument starts with a double quote then its delimiter is another quote.*/
+        p++;
+        *saveptr = strstr(p, "\"");
+    } else {
+        /* The delimiter is white space.*/
+        *saveptr = strpbrk(p, " \t");
+    }
+
+    /* Replacing the delimiter with a zero.*/
+    if (*saveptr != NULL) {
+        *(*saveptr)++ = '\0';
+    }
+    return *p != '\0' ? p : NULL;
+}
+
+bool console_get_line(periph_console_handle_t console, unsigned max_size, TickType_t time_to_wait)
+{
+    char c;
+    char tx[3];
+    int nread = 0;
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+    nread = uart_read_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (uint8_t *)&c, 1, time_to_wait);
+#else
+    nread = uart_read_bytes(CONFIG_CONSOLE_UART_NUM, (uint8_t *)&c, 1, time_to_wait);
+#endif
+
+    if (nread <= 0) {
+        return false;
+    }
+    if ((c == 8) || (c == 127)) {  // backspace or del
+        if (console->total_bytes > 0) {
+            console->total_bytes --;
+            tx[0] = c;
+            tx[1] = 0x20;
+            tx[2] = c;
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+            uart_write_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (const char *)tx, 3);
+#else
+            uart_write_bytes(CONFIG_CONSOLE_UART_NUM, (const char *)tx, 3);
+#endif
+
+        }
+        return false;
+    }
+    if (c == '\n' || c == '\r') {
+        tx[0] = '\r';
+        tx[1] = '\n';
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+        uart_write_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (const char *)tx, 2);
+#else
+        uart_write_bytes(CONFIG_CONSOLE_UART_NUM, (const char *)tx, 2);
+#endif
+
+        console->buffer[console->total_bytes] = 0;
+        return true;
+    }
+
+    if (c < 0x20) {
+        return false;
+    }
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+    uart_write_bytes(CONFIG_ESP_CONSOLE_UART_NUM, (const char *)&c, 1);
+#else
+    uart_write_bytes(CONFIG_CONSOLE_UART_NUM, (const char *)&c, 1);
+#endif
+
+    console->buffer[console->total_bytes++] = (char)c;
+    if (console->total_bytes > max_size) {
+        console->total_bytes = 0;
+    }
+
+    return false;
+}
+
+static bool console_exec(esp_periph_handle_t self, char *cmd, int argc, char *argv[])
+{
+    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
+    if (cmd == NULL) {
+        return false;
+    }
+    int i;
+    for (i = 0; i < console->command_num; i++) {
+        if (strcasecmp(cmd, console->commands[i].cmd) == 0) {
+            if (console->commands[i].func) {
+                console->commands[i].func(self, argc, argv);
+                return true;
+            }
+            int cmd_id = console->commands[i].id;
+            if (cmd_id == 0) {
+                cmd_id = i;
+            }
+            esp_periph_send_event(self, cmd_id, argv, argc);
+            return true;
+        }
+    }
+    printf("----------------------\r\n");
+    printf("Perpheral console HELP\r\n");
+    printf("----------------------\r\n");
+    for (i = 0; i < console->command_num; i++) {
+        printf("%s \t%s\r\n", console->commands[i].cmd, console->commands[i].help);
+    }
+    return false;
+}
+
+static esp_err_t _console_destroy(esp_periph_handle_t self)
+{
+    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
+    console->run = false;
+    xEventGroupWaitBits(console->state_event_bits, STOPPED_BIT, false, true, portMAX_DELAY);
+    vEventGroupDelete(console->state_event_bits);
+    if (console->prompt_string) {
+        audio_free(console->prompt_string);
+    }
+    audio_free(console->buffer);
+    audio_free(console);
+    return ESP_OK;
+}
+
+static void _console_task(void *pv)
+{
+    esp_periph_handle_t self = (esp_periph_handle_t)pv;
+    char *lp, *cmd, *tokp;
+    char *args[CONSOLE_MAX_ARGUMENTS + 1];
+    int n;
+
+    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
+    if (console->total_bytes >= console->buffer_size) {
+        console->total_bytes = 0;
+    }
+    console->run = true;
+    xEventGroupClearBits(console->state_event_bits, STOPPED_BIT);
+    const char *prompt_string = CONSOLE_DEFAULT_PROMPT_STRING;
+    if (console->prompt_string) {
+        prompt_string = console->prompt_string;
+    }
+    printf("\r\n%s ", prompt_string);
+    while (console->run) {
+        if (console_get_line(console, console->buffer_size, 10 / portTICK_PERIOD_MS)) {
+            if (console->total_bytes) {
+                ESP_LOGD(TAG, "Read line: %s", console->buffer);
+            }
+            lp = conslole_parse_arguments(console->buffer, &tokp);
+            cmd = lp;
+            n = 0;
+            while ((lp = conslole_parse_arguments(NULL, &tokp)) != NULL) {
+                if (n >= CONSOLE_MAX_ARGUMENTS) {
+                    printf("too many arguments\r\n");
+                    cmd = NULL;
+                    break;
+                }
+                args[n++] = lp;
+            }
+            args[n] = NULL;
+            if (console->total_bytes > 0) {
+                console_exec(self, cmd, n, args);
+                console->total_bytes = 0;
+            }
+            printf("%s ", prompt_string);
+        }
+
+    }
+    xEventGroupSetBits(console->state_event_bits, STOPPED_BIT);
+    vTaskDelete(NULL);
+}
+
+static esp_err_t _console_init(esp_periph_handle_t self)
+{
+    periph_console_handle_t console = (periph_console_handle_t)esp_periph_get_data(self);
+
+    setvbuf(stdin, NULL, _IONBF, 0);
+    setvbuf(stdout, NULL, _IONBF, 0);
+
+
+    /* Minicom, screen, idf_monitor send CR when ENTER key is pressed */
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
+    esp_vfs_dev_uart_port_set_rx_line_endings(CONFIG_ESP_CONSOLE_UART_NUM, ESP_LINE_ENDINGS_CR);
+#else
+    esp_vfs_dev_uart_set_rx_line_endings(ESP_LINE_ENDINGS_CR);
+#endif
+    /* Move the caret to the beginning of the next line on '\n' */
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 3, 0))
+    esp_vfs_dev_uart_port_set_tx_line_endings(CONFIG_ESP_CONSOLE_UART_NUM, ESP_LINE_ENDINGS_CRLF);
+#else
+    esp_vfs_dev_uart_set_tx_line_endings(ESP_LINE_ENDINGS_CRLF);
+#endif
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+    uart_driver_install(CONFIG_ESP_CONSOLE_UART_NUM, console->buffer_size * 2, 0, 0, NULL, 0);
+#else
+    uart_driver_install(CONFIG_CONSOLE_UART_NUM, console->buffer_size * 2, 0, 0, NULL, 0);
+#endif
+
+    /* Tell VFS to use UART driver */
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+    esp_vfs_dev_uart_use_driver(CONFIG_ESP_CONSOLE_UART_NUM);
+#else
+    esp_vfs_dev_uart_use_driver(CONFIG_CONSOLE_UART_NUM);
+#endif
+
+    console->buffer = (char *) audio_malloc(console->buffer_size);
+    AUDIO_MEM_CHECK(TAG, console->buffer, {
+        return ESP_ERR_NO_MEM;
+    });
+
+    if (xTaskCreate(_console_task, "console_task", console->task_stack, self, console->task_prio, NULL) != pdTRUE) {
+        ESP_LOGE(TAG, "Error create console task, memory exhausted?");
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+
+esp_periph_handle_t periph_console_init(periph_console_cfg_t *config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_CONSOLE, "periph_console");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+    periph_console_t *console = audio_calloc(1, sizeof(periph_console_t));
+    AUDIO_MEM_CHECK(TAG, console, {
+        audio_free(periph);
+        return NULL;
+    });
+    console->commands = config->commands;
+    console->command_num = config->command_num;
+    console->task_stack = CONSOLE_DEFAULT_TASK_STACK;
+    console->task_prio = CONSOLE_DEFAULT_TASK_PRIO;
+    console->buffer_size = CONSOLE_DEFAULT_BUFFER_SIZE;
+     if (config->buffer_size > 0) {
+        console->buffer_size = config->buffer_size;
+    }
+    if (config->task_stack > 0) {
+        console->task_stack = config->task_stack;
+    }
+    if (config->task_prio) {
+        console->task_prio = config->task_prio;
+    }
+    if (config->prompt_string) {
+        console->prompt_string = audio_strdup(config->prompt_string);
+        AUDIO_MEM_CHECK(TAG, console->prompt_string, {
+            audio_free(periph);
+            audio_free(console);
+            return NULL;
+        });
+    }
+    console->state_event_bits = xEventGroupCreate();
+    esp_periph_set_data(periph, console);
+    esp_periph_set_function(periph, _console_init, NULL, _console_destroy);
+    return periph;
+}
diff --git a/components/esp_peripherals/periph_gpio_isr.c b/components/esp_peripherals/periph_gpio_isr.c
index af5573fd..89a9ce6c 100644
--- a/components/esp_peripherals/periph_gpio_isr.c
+++ b/components/esp_peripherals/periph_gpio_isr.c
@@ -1,157 +1,157 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "driver/gpio.h"
-#include "audio_error.h"
-#include "audio_mem.h"
-#include "sys/queue.h"
-#include "esp_peripherals.h"
-#include "periph_gpio_isr.h"
-
-static const char *TAG = "PERIPH_GPIO_ISR";
-
-typedef struct gpio_info_node {
-    gpio_isr_info_t gpio_info;
-    STAILQ_ENTRY(gpio_info_node) entries;
-} gpio_isr_node_t;
-
-static esp_periph_handle_t g_handle = NULL;
-static STAILQ_HEAD(gpio_isr_list, gpio_info_node) gpio_isr_info_list;
-
-static void IRAM_ATTR gpio_isr_handler(void *param)
-{
-    int gpio_num = (int)param;
-    esp_periph_send_cmd_from_isr(g_handle, gpio_num, NULL, 0);
-}
-
-static esp_err_t _gpio_isr_init(esp_periph_handle_t self)
-{
-    esp_err_t ret = ESP_OK;
-    gpio_isr_node_t *tmp_node = NULL;
-    gpio_isr_info_t *tmp_info = NULL;
-
-    STAILQ_FOREACH(tmp_node, &gpio_isr_info_list, entries) {
-        tmp_info = &tmp_node->gpio_info;
-        ret |= gpio_isr_init(tmp_info->gpio_num, tmp_info->type, gpio_isr_handler, (void *)tmp_info->gpio_num);
-    }
-
-    return ret;
-}
-
-static esp_err_t _gpio_isr_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    esp_err_t ret = ESP_OK;
-    if (msg->cmd >= 0) {
-        ret = esp_periph_send_event(self, 0, (void *)msg->cmd, 0);
-        return ret;
-    }
-
-    return ESP_FAIL;
-}
-
-static esp_err_t _gpio_isr_destroy(esp_periph_handle_t self)
-{
-    esp_err_t ret = ESP_OK;
-    gpio_isr_node_t *tmp, *item;
-    gpio_isr_info_t *tmp_info = NULL;
-
-    STAILQ_FOREACH_SAFE(item, &gpio_isr_info_list, entries, tmp) {
-        tmp_info = &item->gpio_info;
-        ret |= gpio_isr_deinit(tmp_info->gpio_num);
-        STAILQ_REMOVE(&gpio_isr_info_list, item, gpio_info_node, entries);
-        audio_free(item);
-    }
-
-    return ret;
-}
-
-esp_err_t periph_gpio_isr_add(gpio_isr_info_t *gpio_info)
-{
-    AUDIO_NULL_CHECK(TAG, gpio_info, return ESP_FAIL);
-    gpio_isr_node_t *tmp_node = NULL;
-    gpio_isr_info_t *tmp_info = NULL;
-
-    STAILQ_FOREACH(tmp_node, &gpio_isr_info_list, entries) {
-        tmp_info = &tmp_node->gpio_info;
-        if (tmp_info->gpio_num == gpio_info->gpio_num) {
-            ESP_LOGW(TAG, "The gpio has already registered isr");
-            return ESP_FAIL;
-        }
-    }
-
-    gpio_isr_node_t *gpio_isr_node = (gpio_isr_node_t *)audio_calloc(1, sizeof(gpio_isr_node_t));
-    AUDIO_NULL_CHECK(TAG, gpio_isr_node, return ESP_FAIL);
-    memcpy(gpio_isr_node, gpio_info, sizeof(gpio_isr_info_t));
-    STAILQ_INSERT_TAIL(&gpio_isr_info_list, gpio_isr_node, entries);
-    return gpio_isr_init(gpio_info->gpio_num, gpio_info->type, gpio_isr_handler, (void *)gpio_info->gpio_num);
-}
-
-esp_err_t periph_gpio_isr_delete(int gpio_num)
-{
-    esp_err_t ret = ESP_OK;
-    if (gpio_num < 0) {
-        ESP_LOGW(TAG, "The gpio number should be greater than 0");
-    }
-
-    gpio_isr_node_t *tmp_node = NULL;
-    gpio_isr_info_t *tmp_info = NULL;
-    STAILQ_FOREACH(tmp_node, &gpio_isr_info_list, entries) {
-        tmp_info = &tmp_node->gpio_info;
-        if (tmp_info->gpio_num == gpio_num) {
-            STAILQ_REMOVE(&gpio_isr_info_list, tmp_node, gpio_info_node, entries);
-            ret |= gpio_isr_deinit(tmp_info->gpio_num);
-            audio_free(tmp_node);
-            return ret;
-        }
-    }
-    ESP_LOGW(TAG, "The gpio %d hasn't been registered", gpio_num);
-    return ESP_FAIL;
-}
-
-esp_periph_handle_t periph_gpio_isr_init(periph_gpio_isr_cfg_t *isr_config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_GPIO_ISR, "periph_gpio_isr");
-    AUDIO_NULL_CHECK(TAG, periph, return NULL);
-
-    STAILQ_INIT(&gpio_isr_info_list);
-
-    if (isr_config) {
-        for (int i = 0; i < isr_config->info_size; i++) {
-            gpio_isr_node_t *gpio_isr_node = (gpio_isr_node_t *)audio_calloc(1, sizeof(gpio_isr_node_t));
-            AUDIO_NULL_CHECK(TAG, gpio_isr_node, {
-                audio_free(periph);
-                return NULL;
-            });
-            memcpy(gpio_isr_node, &isr_config->gpio_isr_info[i], sizeof(gpio_isr_info_t));
-            STAILQ_INSERT_TAIL(&gpio_isr_info_list, gpio_isr_node, entries);
-        }
-    }
-
-    esp_periph_set_data(periph, &gpio_isr_info_list);
-    esp_periph_set_function(periph, _gpio_isr_init, _gpio_isr_run, _gpio_isr_destroy);
-    g_handle = periph;
-    return periph;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2019 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "driver/gpio.h"
+#include "audio_error.h"
+#include "audio_mem.h"
+#include "sys/queue.h"
+#include "esp_peripherals.h"
+#include "periph_gpio_isr.h"
+
+static const char *TAG = "PERIPH_GPIO_ISR";
+
+typedef struct gpio_info_node {
+    gpio_isr_info_t gpio_info;
+    STAILQ_ENTRY(gpio_info_node) entries;
+} gpio_isr_node_t;
+
+static esp_periph_handle_t g_handle = NULL;
+static STAILQ_HEAD(gpio_isr_list, gpio_info_node) gpio_isr_info_list;
+
+static void IRAM_ATTR gpio_isr_handler(void *param)
+{
+    int gpio_num = (int)param;
+    esp_periph_send_cmd_from_isr(g_handle, gpio_num, NULL, 0);
+}
+
+static esp_err_t _gpio_isr_init(esp_periph_handle_t self)
+{
+    esp_err_t ret = ESP_OK;
+    gpio_isr_node_t *tmp_node = NULL;
+    gpio_isr_info_t *tmp_info = NULL;
+
+    STAILQ_FOREACH(tmp_node, &gpio_isr_info_list, entries) {
+        tmp_info = &tmp_node->gpio_info;
+        ret |= gpio_isr_init(tmp_info->gpio_num, tmp_info->type, gpio_isr_handler, (void *)tmp_info->gpio_num);
+    }
+
+    return ret;
+}
+
+static esp_err_t _gpio_isr_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    esp_err_t ret = ESP_OK;
+    if (msg->cmd >= 0) {
+        ret = esp_periph_send_event(self, 0, (void *)msg->cmd, 0);
+        return ret;
+    }
+
+    return ESP_FAIL;
+}
+
+static esp_err_t _gpio_isr_destroy(esp_periph_handle_t self)
+{
+    esp_err_t ret = ESP_OK;
+    gpio_isr_node_t *tmp, *item;
+    gpio_isr_info_t *tmp_info = NULL;
+
+    STAILQ_FOREACH_SAFE(item, &gpio_isr_info_list, entries, tmp) {
+        tmp_info = &item->gpio_info;
+        ret |= gpio_isr_deinit(tmp_info->gpio_num);
+        STAILQ_REMOVE(&gpio_isr_info_list, item, gpio_info_node, entries);
+        audio_free(item);
+    }
+
+    return ret;
+}
+
+esp_err_t periph_gpio_isr_add(gpio_isr_info_t *gpio_info)
+{
+    AUDIO_NULL_CHECK(TAG, gpio_info, return ESP_FAIL);
+    gpio_isr_node_t *tmp_node = NULL;
+    gpio_isr_info_t *tmp_info = NULL;
+
+    STAILQ_FOREACH(tmp_node, &gpio_isr_info_list, entries) {
+        tmp_info = &tmp_node->gpio_info;
+        if (tmp_info->gpio_num == gpio_info->gpio_num) {
+            ESP_LOGW(TAG, "The gpio has already registered isr");
+            return ESP_FAIL;
+        }
+    }
+
+    gpio_isr_node_t *gpio_isr_node = (gpio_isr_node_t *)audio_calloc(1, sizeof(gpio_isr_node_t));
+    AUDIO_NULL_CHECK(TAG, gpio_isr_node, return ESP_FAIL);
+    memcpy(gpio_isr_node, gpio_info, sizeof(gpio_isr_info_t));
+    STAILQ_INSERT_TAIL(&gpio_isr_info_list, gpio_isr_node, entries);
+    return gpio_isr_init(gpio_info->gpio_num, gpio_info->type, gpio_isr_handler, (void *)gpio_info->gpio_num);
+}
+
+esp_err_t periph_gpio_isr_delete(int gpio_num)
+{
+    esp_err_t ret = ESP_OK;
+    if (gpio_num < 0) {
+        ESP_LOGW(TAG, "The gpio number should be greater than 0");
+    }
+
+    gpio_isr_node_t *tmp_node = NULL;
+    gpio_isr_info_t *tmp_info = NULL;
+    STAILQ_FOREACH(tmp_node, &gpio_isr_info_list, entries) {
+        tmp_info = &tmp_node->gpio_info;
+        if (tmp_info->gpio_num == gpio_num) {
+            STAILQ_REMOVE(&gpio_isr_info_list, tmp_node, gpio_info_node, entries);
+            ret |= gpio_isr_deinit(tmp_info->gpio_num);
+            audio_free(tmp_node);
+            return ret;
+        }
+    }
+    ESP_LOGW(TAG, "The gpio %d hasn't been registered", gpio_num);
+    return ESP_FAIL;
+}
+
+esp_periph_handle_t periph_gpio_isr_init(periph_gpio_isr_cfg_t *isr_config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_GPIO_ISR, "periph_gpio_isr");
+    AUDIO_NULL_CHECK(TAG, periph, return NULL);
+
+    STAILQ_INIT(&gpio_isr_info_list);
+
+    if (isr_config) {
+        for (int i = 0; i < isr_config->info_size; i++) {
+            gpio_isr_node_t *gpio_isr_node = (gpio_isr_node_t *)audio_calloc(1, sizeof(gpio_isr_node_t));
+            AUDIO_NULL_CHECK(TAG, gpio_isr_node, {
+                audio_free(periph);
+                return NULL;
+            });
+            memcpy(gpio_isr_node, &isr_config->gpio_isr_info[i], sizeof(gpio_isr_info_t));
+            STAILQ_INSERT_TAIL(&gpio_isr_info_list, gpio_isr_node, entries);
+        }
+    }
+
+    esp_periph_set_data(periph, &gpio_isr_info_list);
+    esp_periph_set_function(periph, _gpio_isr_init, _gpio_isr_run, _gpio_isr_destroy);
+    g_handle = periph;
+    return periph;
+}
diff --git a/components/esp_peripherals/periph_is31fl3216.c b/components/esp_peripherals/periph_is31fl3216.c
index 61d6be54..c49dfeee 100644
--- a/components/esp_peripherals/periph_is31fl3216.c
+++ b/components/esp_peripherals/periph_is31fl3216.c
@@ -1,441 +1,441 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include <inttypes.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/queue.h"
-#include "periph_is31fl3216.h"
-#include "IS31FL3216.h"
-#include "audio_mem.h"
-#include "esp_log.h"
-
-#define IS31FL3216_TASK_STACK_SIZE  (2048 + 1024)
-#define IS31FL3216_TASK_PRIORITY    3
-
-#define ONE_FRAME_BYTE_SIZE         18
-#define DEFAULT_FLASH_STEP          2
-
-static const char *TAG = "PERIPH_IS31";
-static const int DESTROY_BIT = BIT0;
-
-#define VALIDATE_IS31FL3216(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_IS31FL3216)) { \
-    ESP_LOGE(TAG, "Invalid is31fl3216 periph, at line %d", __LINE__);\
-    return ret;\
-}
-
-static const uint8_t light_audio_frames[8][ONE_FRAME_BYTE_SIZE] = {
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xff, 0xff},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xff, 0xff, 0xff},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xff, 0xff, 0xff},
-    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xff, 0xFF, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
-};
-
-typedef enum {
-    PERIPH_IS31_CMD_CHG_STATE,
-    PERIPH_IS31_CMD_QUIT,
-} periph_is31_cmd_t;
-
-typedef struct {
-    uint16_t                    max_light_num;              // Maximum light number
-    uint16_t                    light_num;                  // Working lights number
-    uint16_t                    light_mask;                 // Light bits mask
-    int                         interval_time;              // Interval working time
-    uint16_t                    act_time;                   // Action times
-    uint8_t                     duty_step;                  // Duty step
-    periph_is31_shift_mode_t    shift_mode;                 // Shift mode step
-} periph_is31_arg_t;
-
-typedef struct {
-    periph_is31_arg_t           *arg;
-    uint8_t                     duty[IS31FL3216_CH_NUM];    // Duty of lights
-    is31fl3216_handle_t         handle;
-    periph_is31fl3216_state_t   cur_state;
-    QueueHandle_t               evt;
-    EventGroupHandle_t          g_event_bit;
-} periph_is31fl3216_t;
-
-typedef struct {
-    periph_is31_cmd_t   type;
-    uint32_t            data;
-} periph_is31_msg_t;
-
-static esp_err_t is31_leds_ctrl(is31fl3216_handle_t *handle, uint16_t mask)
-{
-    esp_err_t ret = ESP_OK;
-    for (int i = 0; i < IS31FL3216_CH_NUM; i++) {
-        if (mask & (1UL << i)) {
-            ret |= is31fl3216_ch_enable(handle, 1UL << i);
-        } else {
-            ret |= is31fl3216_ch_disable(handle, 1UL << i);
-        }
-    }
-    return ret;
-}
-
-static esp_err_t is31_leds_duty(is31fl3216_handle_t *handle, int duty, uint16_t mask)
-{
-    esp_err_t ret = ESP_OK;
-    for (int i = 0; i < IS31FL3216_CH_NUM; i++) {
-        if (mask & (1UL << i))
-            ret |= is31fl3216_ch_duty_set(handle, 1UL << i, duty);
-    }
-    return ret;
-}
-
-static void is31_evt_send(void *que, periph_is31_cmd_t type, uint32_t data, int dir)
-{
-    periph_is31_msg_t evt = {0};
-    evt.type = type;
-    evt.data = data;
-    if (dir) {
-        xQueueSendToFront(que, &evt, 0) ;
-    } else {
-        xQueueSend(que, &evt, 0);
-    }
-}
-static esp_err_t is31_change_state(periph_is31fl3216_t *is31, int state, periph_is31_arg_t *arg)
-{
-    esp_err_t ret = ESP_OK;
-    switch (state) {
-        case IS31FL3216_STATE_OFF:
-            ret |= is31fl3216_ch_disable(is31->handle, arg->light_mask);
-            arg->interval_time = portMAX_DELAY;
-            is31->cur_state = IS31FL3216_STATE_OFF;
-            break;
-        case IS31FL3216_STATE_ON:
-            if (is31->cur_state == IS31FL3216_STATE_BY_AUDIO) {
-                ret |= is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_PWM);
-                is31_leds_duty(is31->handle, IS31FL3216_DUTY_MAX, arg->light_mask);
-            }
-            is31_leds_ctrl(is31->handle, arg->light_mask);
-            arg->interval_time = portMAX_DELAY;
-            is31->cur_state = IS31FL3216_STATE_ON;
-            break;
-        case IS31FL3216_STATE_FLASH:
-            if (is31->cur_state == IS31FL3216_STATE_BY_AUDIO) {
-                ret |= is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_PWM);
-            }
-            is31->cur_state = IS31FL3216_STATE_FLASH;
-            break;
-        case IS31FL3216_STATE_SHIFT:
-            if (is31->cur_state == IS31FL3216_STATE_BY_AUDIO) {
-                ret |= is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_PWM);
-            }
-            is31->cur_state = IS31FL3216_STATE_SHIFT;
-            break;
-        case IS31FL3216_STATE_BY_AUDIO:
-            is31fl3216_reset(is31->handle);
-            is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_FRAME);
-            is31fl3216_sample_rate_set(is31->handle, 0xB4); // Set adc sample rate
-            is31fl3216_frame_value_set(is31->handle, 1, (uint8_t *)&light_audio_frames, sizeof(light_audio_frames));
-            is31fl3216_first_frame_set(is31->handle, 0);
-            is31->cur_state = IS31FL3216_STATE_BY_AUDIO;
-            arg->interval_time = portMAX_DELAY;
-            break;
-        default:
-            ESP_LOGE(TAG, "State %d is not supported", state);
-            break;
-    }
-    return ret;
-}
-
-static void is31fl3216_run_task(void *Para)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t) Para;
-    periph_is31fl3216_t *is31 = esp_periph_get_data(periph);
-    periph_is31_arg_t is31_arg = {
-        .max_light_num = IS31FL3216_CH_NUM,
-        .light_num = 1,
-        .light_mask = 1,
-        .interval_time = 1000,
-        .act_time = 0,
-        .duty_step = DEFAULT_FLASH_STEP,
-        .shift_mode = 0,
-    };
-    periph_is31_msg_t msg = {0};
-    int wait_time_ms = portMAX_DELAY;
-    bool task_run = true;
-    xEventGroupClearBits(is31->g_event_bit, DESTROY_BIT);
-    int cur_duty = 0;
-    int sig = 2;
-    int cur_bits_mask = 0;
-    int i = 0;
-    uint16_t act_times = 0;
-    while (task_run) {
-        if (xQueueReceive(is31->evt, &msg, (wait_time_ms / portTICK_PERIOD_MS))) {
-            ESP_LOGD(TAG, "cmd:%d, data:%"PRIu32, msg.type, msg.data);
-            switch (msg.type) {
-                case PERIPH_IS31_CMD_CHG_STATE:
-                    memcpy(&is31_arg, is31->arg, sizeof(periph_is31_arg_t));
-                    wait_time_ms = is31->arg->interval_time;
-
-                    memset(is31->arg, 0, sizeof(periph_is31_arg_t));
-                    is31->arg->interval_time = portMAX_DELAY;
-                    is31->arg->max_light_num = IS31FL3216_CH_NUM;
-                    is31->arg->duty_step = DEFAULT_FLASH_STEP;
-                    is31_change_state(is31, msg.data, &is31_arg);
-
-                    if (IS31FL3216_STATE_FLASH == msg.data) {
-                        sig = is31_arg.duty_step;
-                    }
-                    if (is31_arg.act_time && wait_time_ms) {
-                        act_times = is31_arg.act_time / wait_time_ms;
-                    } else {
-                        act_times = 0;
-                    }
-                    break;
-
-                case PERIPH_IS31_CMD_QUIT:
-                    task_run = false;
-                    if (is31->g_event_bit) {
-                        xEventGroupSetBits(is31->g_event_bit, DESTROY_BIT);
-                    }
-                    break;
-                default:
-                    break;
-            }
-            if (task_run == false) {
-                ESP_LOGW(TAG, "Quit is31fl3216 task ...");
-                break;
-            }
-        }
-        switch (is31->cur_state) {
-            case IS31FL3216_STATE_FLASH: {
-                    is31_leds_duty(is31->handle, cur_duty, is31_arg.light_mask);
-                    is31_leds_ctrl(is31->handle, is31_arg.light_mask);
-                    cur_duty += sig;
-                    if (cur_duty > IS31FL3216_DUTY_MAX) {
-                        cur_duty = IS31FL3216_DUTY_MAX;
-                        sig = -(is31_arg.duty_step);
-                    }
-                    if (cur_duty < 0) {
-                        cur_duty = 0;
-                        sig = (is31_arg.duty_step);
-                    }
-                }
-                if (is31_arg.act_time == 0) {
-                    act_times = 0;
-                    break;
-                }
-                act_times--;
-                if (act_times == 0) {
-                    wait_time_ms = portMAX_DELAY;
-                    is31->cur_state = IS31FL3216_STATE_UNKNOWN;
-                    is31_leds_ctrl(is31->handle, 0);
-                }
-                break;
-            case IS31FL3216_STATE_SHIFT:
-                if (is31_arg.shift_mode == PERIPH_IS31_SHIFT_MODE_SINGLE) {
-                    cur_bits_mask = ((1UL << is31_arg.light_num) - 1) << (i++);
-                    if (i == (is31_arg.max_light_num - is31_arg.light_num + 1)) {
-                        i = 0;
-                    }
-                } else if (is31_arg.shift_mode == PERIPH_IS31_SHIFT_MODE_ACC) {
-                    cur_bits_mask = (1UL << (is31_arg.light_num * ((i++) + 1))) - 1;
-                    if ((cur_bits_mask >> is31_arg.max_light_num) & 0x01) {
-                        cur_bits_mask = 0;
-                        i = 0;
-                    }
-                }
-                is31_leds_duty(is31->handle, IS31FL3216_DUTY_MAX, cur_bits_mask);
-                is31_leds_ctrl(is31->handle, cur_bits_mask);
-
-                ESP_LOGD(TAG, "Mask:%08x, %d", cur_bits_mask, wait_time_ms);
-                if (is31_arg.act_time == 0) {
-                    act_times = 0;
-                    break;
-                }
-                act_times--;
-                if (act_times == 0) {
-                    wait_time_ms = portMAX_DELAY;
-                    is31->cur_state = IS31FL3216_STATE_UNKNOWN;
-                    is31_leds_ctrl(is31->handle, 0);
-                }
-
-                break;
-            default:
-                break;
-        }
-    }
-    vTaskDelete(NULL);
-}
-
-esp_err_t periph_is31fl3216_set_state(esp_periph_handle_t periph, periph_is31fl3216_state_t state)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31_evt_send(is31fl3216->evt, PERIPH_IS31_CMD_CHG_STATE, state, 0);
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_blink_pattern(esp_periph_handle_t periph, uint16_t blink_pattern)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->arg->light_mask = blink_pattern;
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_duty(esp_periph_handle_t periph, uint8_t index, uint8_t value)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->duty[index] = value;
-    is31fl3216_ch_duty_set(is31fl3216->handle, 1UL << index, is31fl3216->duty[index]);
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_duty_step(esp_periph_handle_t periph, uint8_t step)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->arg->duty_step = step;
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_interval(esp_periph_handle_t periph, uint16_t interval_ms)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->arg->interval_time = interval_ms;
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_shift_mode(esp_periph_handle_t periph, periph_is31_shift_mode_t mode)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->arg->shift_mode = mode;
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_light_on_num(esp_periph_handle_t periph, uint16_t light_on_num, uint16_t max_light_num)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->arg->max_light_num = max_light_num;
-    is31fl3216->arg->light_num = light_on_num;
-    return ESP_OK;
-}
-
-esp_err_t periph_is31fl3216_set_act_time(esp_periph_handle_t periph, uint16_t act_ms)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
-    is31fl3216->arg->act_time = act_ms;
-    return ESP_OK;
-}
-
-static esp_err_t _is31fl3216_init(esp_periph_handle_t self)
-{
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(self);
-    esp_err_t ret = ESP_OK;
-    is31fl3216_ch_disable(is31fl3216->handle, IS31FL3216_CH_ALL);
-    is31_leds_duty(is31fl3216->handle, 0, IS31FL3216_CH_ALL);
-    xTaskCreate(is31fl3216_run_task, "is31fl3216_run_task", IS31FL3216_TASK_STACK_SIZE, (void *)self, IS31FL3216_TASK_PRIORITY, NULL);
-    if (ret) {
-        ESP_LOGE(TAG, "Failed to initialize is31fl3216");
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _is31fl3216_destroy(esp_periph_handle_t self)
-{
-    VALIDATE_IS31FL3216(self, ESP_FAIL);
-    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(self);
-    is31_evt_send(is31fl3216->evt, PERIPH_IS31_CMD_QUIT, 0, 0);
-    if (is31fl3216->g_event_bit) {
-        xEventGroupWaitBits(is31fl3216->g_event_bit, DESTROY_BIT, pdTRUE, pdFALSE, portMAX_DELAY);
-        vEventGroupDelete(is31fl3216->g_event_bit);
-        is31fl3216->g_event_bit = NULL;
-    }
-    esp_err_t ret = ESP_OK;
-    ret |= is31fl3216_ch_disable(is31fl3216->handle, IS31FL3216_CH_ALL);
-    ret |= is31fl3216_deinit(is31fl3216->handle);
-    audio_free(is31fl3216->arg);
-    vQueueDelete(is31fl3216->evt);
-    audio_free(is31fl3216);
-    if (ret) {
-        ESP_LOGE(TAG, "Error occurred when stopping the is31fl3216");
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_is31fl3216_init(periph_is31fl3216_cfg_t *is31fl3216_config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_IS31FL3216, "periph_is31fl3216");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-
-    periph_is31fl3216_t *is31fl3216 = audio_calloc(1, sizeof(periph_is31fl3216_t));
-    AUDIO_MEM_CHECK(TAG, is31fl3216, {
-        audio_free(periph);
-        return NULL;
-    });
-
-    is31fl3216->g_event_bit = xEventGroupCreate();
-    AUDIO_NULL_CHECK(TAG, is31fl3216->g_event_bit, {
-        audio_free(periph);
-        audio_free(is31fl3216);
-    });
-
-    is31fl3216->evt = xQueueCreate(2, sizeof(periph_is31_msg_t));
-    AUDIO_MEM_CHECK(TAG, is31fl3216->evt, {
-        audio_free(periph);
-        vEventGroupDelete(is31fl3216->g_event_bit);
-        audio_free(is31fl3216);
-        return NULL;
-    });
-    is31fl3216->arg = audio_calloc(1, sizeof(periph_is31_arg_t));
-    AUDIO_MEM_CHECK(TAG, is31fl3216->arg, {
-        vQueueDelete(is31fl3216->evt);
-        vEventGroupDelete(is31fl3216->g_event_bit);
-        audio_free(periph);
-        audio_free(is31fl3216);
-        return NULL;
-    });
-    is31fl3216->arg->max_light_num = IS31FL3216_CH_NUM;
-    is31fl3216->arg->light_num = 0;
-    is31fl3216->arg->light_mask = 0;
-    is31fl3216->arg->interval_time = 1000;
-    is31fl3216->arg->act_time = 0;
-    is31fl3216->arg->duty_step = DEFAULT_FLASH_STEP;
-    is31fl3216->arg->shift_mode = PERIPH_IS31_SHIFT_MODE_ACC;
-
-    for (int i = 0; i < IS31FL3216_CH_NUM; i++) {
-        is31fl3216->duty[i] = is31fl3216_config->duty[i];
-    }
-    is31fl3216->handle = is31fl3216_init();
-    AUDIO_MEM_CHECK(TAG, is31fl3216, {
-        audio_free(is31fl3216->arg);
-        vQueueDelete(is31fl3216->evt);
-        audio_free(periph);
-        vEventGroupDelete(is31fl3216->g_event_bit);
-        audio_free(is31fl3216);
-        return NULL;
-    });
-
-    esp_periph_set_data(periph, is31fl3216);
-    esp_periph_set_function(periph, _is31fl3216_init, NULL, _is31fl3216_destroy);
-    return periph;
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include <inttypes.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/queue.h"
+#include "periph_is31fl3216.h"
+#include "IS31FL3216.h"
+#include "audio_mem.h"
+#include "esp_log.h"
+
+#define IS31FL3216_TASK_STACK_SIZE  (2048 + 1024)
+#define IS31FL3216_TASK_PRIORITY    3
+
+#define ONE_FRAME_BYTE_SIZE         18
+#define DEFAULT_FLASH_STEP          2
+
+static const char *TAG = "PERIPH_IS31";
+static const int DESTROY_BIT = BIT0;
+
+#define VALIDATE_IS31FL3216(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_IS31FL3216)) { \
+    ESP_LOGE(TAG, "Invalid is31fl3216 periph, at line %d", __LINE__);\
+    return ret;\
+}
+
+static const uint8_t light_audio_frames[8][ONE_FRAME_BYTE_SIZE] = {
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xff, 0xff},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xff, 0xff, 0xff},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xff, 0xff, 0xff},
+    {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xff, 0xFF, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+};
+
+typedef enum {
+    PERIPH_IS31_CMD_CHG_STATE,
+    PERIPH_IS31_CMD_QUIT,
+} periph_is31_cmd_t;
+
+typedef struct {
+    uint16_t                    max_light_num;              // Maximum light number
+    uint16_t                    light_num;                  // Working lights number
+    uint16_t                    light_mask;                 // Light bits mask
+    int                         interval_time;              // Interval working time
+    uint16_t                    act_time;                   // Action times
+    uint8_t                     duty_step;                  // Duty step
+    periph_is31_shift_mode_t    shift_mode;                 // Shift mode step
+} periph_is31_arg_t;
+
+typedef struct {
+    periph_is31_arg_t           *arg;
+    uint8_t                     duty[IS31FL3216_CH_NUM];    // Duty of lights
+    is31fl3216_handle_t         handle;
+    periph_is31fl3216_state_t   cur_state;
+    QueueHandle_t               evt;
+    EventGroupHandle_t          g_event_bit;
+} periph_is31fl3216_t;
+
+typedef struct {
+    periph_is31_cmd_t   type;
+    uint32_t            data;
+} periph_is31_msg_t;
+
+static esp_err_t is31_leds_ctrl(is31fl3216_handle_t *handle, uint16_t mask)
+{
+    esp_err_t ret = ESP_OK;
+    for (int i = 0; i < IS31FL3216_CH_NUM; i++) {
+        if (mask & (1UL << i)) {
+            ret |= is31fl3216_ch_enable(handle, 1UL << i);
+        } else {
+            ret |= is31fl3216_ch_disable(handle, 1UL << i);
+        }
+    }
+    return ret;
+}
+
+static esp_err_t is31_leds_duty(is31fl3216_handle_t *handle, int duty, uint16_t mask)
+{
+    esp_err_t ret = ESP_OK;
+    for (int i = 0; i < IS31FL3216_CH_NUM; i++) {
+        if (mask & (1UL << i))
+            ret |= is31fl3216_ch_duty_set(handle, 1UL << i, duty);
+    }
+    return ret;
+}
+
+static void is31_evt_send(void *que, periph_is31_cmd_t type, uint32_t data, int dir)
+{
+    periph_is31_msg_t evt = {0};
+    evt.type = type;
+    evt.data = data;
+    if (dir) {
+        xQueueSendToFront(que, &evt, 0) ;
+    } else {
+        xQueueSend(que, &evt, 0);
+    }
+}
+static esp_err_t is31_change_state(periph_is31fl3216_t *is31, int state, periph_is31_arg_t *arg)
+{
+    esp_err_t ret = ESP_OK;
+    switch (state) {
+        case IS31FL3216_STATE_OFF:
+            ret |= is31fl3216_ch_disable(is31->handle, arg->light_mask);
+            arg->interval_time = portMAX_DELAY;
+            is31->cur_state = IS31FL3216_STATE_OFF;
+            break;
+        case IS31FL3216_STATE_ON:
+            if (is31->cur_state == IS31FL3216_STATE_BY_AUDIO) {
+                ret |= is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_PWM);
+                is31_leds_duty(is31->handle, IS31FL3216_DUTY_MAX, arg->light_mask);
+            }
+            is31_leds_ctrl(is31->handle, arg->light_mask);
+            arg->interval_time = portMAX_DELAY;
+            is31->cur_state = IS31FL3216_STATE_ON;
+            break;
+        case IS31FL3216_STATE_FLASH:
+            if (is31->cur_state == IS31FL3216_STATE_BY_AUDIO) {
+                ret |= is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_PWM);
+            }
+            is31->cur_state = IS31FL3216_STATE_FLASH;
+            break;
+        case IS31FL3216_STATE_SHIFT:
+            if (is31->cur_state == IS31FL3216_STATE_BY_AUDIO) {
+                ret |= is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_PWM);
+            }
+            is31->cur_state = IS31FL3216_STATE_SHIFT;
+            break;
+        case IS31FL3216_STATE_BY_AUDIO:
+            is31fl3216_reset(is31->handle);
+            is31fl3216_work_mode_set(is31->handle, IS31FL3216_MODE_FRAME);
+            is31fl3216_sample_rate_set(is31->handle, 0xB4); // Set adc sample rate
+            is31fl3216_frame_value_set(is31->handle, 1, (uint8_t *)&light_audio_frames, sizeof(light_audio_frames));
+            is31fl3216_first_frame_set(is31->handle, 0);
+            is31->cur_state = IS31FL3216_STATE_BY_AUDIO;
+            arg->interval_time = portMAX_DELAY;
+            break;
+        default:
+            ESP_LOGE(TAG, "State %d is not supported", state);
+            break;
+    }
+    return ret;
+}
+
+static void is31fl3216_run_task(void *Para)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t) Para;
+    periph_is31fl3216_t *is31 = esp_periph_get_data(periph);
+    periph_is31_arg_t is31_arg = {
+        .max_light_num = IS31FL3216_CH_NUM,
+        .light_num = 1,
+        .light_mask = 1,
+        .interval_time = 1000,
+        .act_time = 0,
+        .duty_step = DEFAULT_FLASH_STEP,
+        .shift_mode = 0,
+    };
+    periph_is31_msg_t msg = {0};
+    int wait_time_ms = portMAX_DELAY;
+    bool task_run = true;
+    xEventGroupClearBits(is31->g_event_bit, DESTROY_BIT);
+    int cur_duty = 0;
+    int sig = 2;
+    int cur_bits_mask = 0;
+    int i = 0;
+    uint16_t act_times = 0;
+    while (task_run) {
+        if (xQueueReceive(is31->evt, &msg, (wait_time_ms / portTICK_PERIOD_MS))) {
+            ESP_LOGD(TAG, "cmd:%d, data:%"PRIu32, msg.type, msg.data);
+            switch (msg.type) {
+                case PERIPH_IS31_CMD_CHG_STATE:
+                    memcpy(&is31_arg, is31->arg, sizeof(periph_is31_arg_t));
+                    wait_time_ms = is31->arg->interval_time;
+
+                    memset(is31->arg, 0, sizeof(periph_is31_arg_t));
+                    is31->arg->interval_time = portMAX_DELAY;
+                    is31->arg->max_light_num = IS31FL3216_CH_NUM;
+                    is31->arg->duty_step = DEFAULT_FLASH_STEP;
+                    is31_change_state(is31, msg.data, &is31_arg);
+
+                    if (IS31FL3216_STATE_FLASH == msg.data) {
+                        sig = is31_arg.duty_step;
+                    }
+                    if (is31_arg.act_time && wait_time_ms) {
+                        act_times = is31_arg.act_time / wait_time_ms;
+                    } else {
+                        act_times = 0;
+                    }
+                    break;
+
+                case PERIPH_IS31_CMD_QUIT:
+                    task_run = false;
+                    if (is31->g_event_bit) {
+                        xEventGroupSetBits(is31->g_event_bit, DESTROY_BIT);
+                    }
+                    break;
+                default:
+                    break;
+            }
+            if (task_run == false) {
+                ESP_LOGW(TAG, "Quit is31fl3216 task ...");
+                break;
+            }
+        }
+        switch (is31->cur_state) {
+            case IS31FL3216_STATE_FLASH: {
+                    is31_leds_duty(is31->handle, cur_duty, is31_arg.light_mask);
+                    is31_leds_ctrl(is31->handle, is31_arg.light_mask);
+                    cur_duty += sig;
+                    if (cur_duty > IS31FL3216_DUTY_MAX) {
+                        cur_duty = IS31FL3216_DUTY_MAX;
+                        sig = -(is31_arg.duty_step);
+                    }
+                    if (cur_duty < 0) {
+                        cur_duty = 0;
+                        sig = (is31_arg.duty_step);
+                    }
+                }
+                if (is31_arg.act_time == 0) {
+                    act_times = 0;
+                    break;
+                }
+                act_times--;
+                if (act_times == 0) {
+                    wait_time_ms = portMAX_DELAY;
+                    is31->cur_state = IS31FL3216_STATE_UNKNOWN;
+                    is31_leds_ctrl(is31->handle, 0);
+                }
+                break;
+            case IS31FL3216_STATE_SHIFT:
+                if (is31_arg.shift_mode == PERIPH_IS31_SHIFT_MODE_SINGLE) {
+                    cur_bits_mask = ((1UL << is31_arg.light_num) - 1) << (i++);
+                    if (i == (is31_arg.max_light_num - is31_arg.light_num + 1)) {
+                        i = 0;
+                    }
+                } else if (is31_arg.shift_mode == PERIPH_IS31_SHIFT_MODE_ACC) {
+                    cur_bits_mask = (1UL << (is31_arg.light_num * ((i++) + 1))) - 1;
+                    if ((cur_bits_mask >> is31_arg.max_light_num) & 0x01) {
+                        cur_bits_mask = 0;
+                        i = 0;
+                    }
+                }
+                is31_leds_duty(is31->handle, IS31FL3216_DUTY_MAX, cur_bits_mask);
+                is31_leds_ctrl(is31->handle, cur_bits_mask);
+
+                ESP_LOGD(TAG, "Mask:%08x, %d", cur_bits_mask, wait_time_ms);
+                if (is31_arg.act_time == 0) {
+                    act_times = 0;
+                    break;
+                }
+                act_times--;
+                if (act_times == 0) {
+                    wait_time_ms = portMAX_DELAY;
+                    is31->cur_state = IS31FL3216_STATE_UNKNOWN;
+                    is31_leds_ctrl(is31->handle, 0);
+                }
+
+                break;
+            default:
+                break;
+        }
+    }
+    vTaskDelete(NULL);
+}
+
+esp_err_t periph_is31fl3216_set_state(esp_periph_handle_t periph, periph_is31fl3216_state_t state)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31_evt_send(is31fl3216->evt, PERIPH_IS31_CMD_CHG_STATE, state, 0);
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_blink_pattern(esp_periph_handle_t periph, uint16_t blink_pattern)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->arg->light_mask = blink_pattern;
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_duty(esp_periph_handle_t periph, uint8_t index, uint8_t value)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->duty[index] = value;
+    is31fl3216_ch_duty_set(is31fl3216->handle, 1UL << index, is31fl3216->duty[index]);
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_duty_step(esp_periph_handle_t periph, uint8_t step)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->arg->duty_step = step;
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_interval(esp_periph_handle_t periph, uint16_t interval_ms)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->arg->interval_time = interval_ms;
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_shift_mode(esp_periph_handle_t periph, periph_is31_shift_mode_t mode)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->arg->shift_mode = mode;
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_light_on_num(esp_periph_handle_t periph, uint16_t light_on_num, uint16_t max_light_num)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->arg->max_light_num = max_light_num;
+    is31fl3216->arg->light_num = light_on_num;
+    return ESP_OK;
+}
+
+esp_err_t periph_is31fl3216_set_act_time(esp_periph_handle_t periph, uint16_t act_ms)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(periph);
+    is31fl3216->arg->act_time = act_ms;
+    return ESP_OK;
+}
+
+static esp_err_t _is31fl3216_init(esp_periph_handle_t self)
+{
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(self);
+    esp_err_t ret = ESP_OK;
+    is31fl3216_ch_disable(is31fl3216->handle, IS31FL3216_CH_ALL);
+    is31_leds_duty(is31fl3216->handle, 0, IS31FL3216_CH_ALL);
+    xTaskCreate(is31fl3216_run_task, "is31fl3216_run_task", IS31FL3216_TASK_STACK_SIZE, (void *)self, IS31FL3216_TASK_PRIORITY, NULL);
+    if (ret) {
+        ESP_LOGE(TAG, "Failed to initialize is31fl3216");
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _is31fl3216_destroy(esp_periph_handle_t self)
+{
+    VALIDATE_IS31FL3216(self, ESP_FAIL);
+    periph_is31fl3216_t *is31fl3216 = esp_periph_get_data(self);
+    is31_evt_send(is31fl3216->evt, PERIPH_IS31_CMD_QUIT, 0, 0);
+    if (is31fl3216->g_event_bit) {
+        xEventGroupWaitBits(is31fl3216->g_event_bit, DESTROY_BIT, pdTRUE, pdFALSE, portMAX_DELAY);
+        vEventGroupDelete(is31fl3216->g_event_bit);
+        is31fl3216->g_event_bit = NULL;
+    }
+    esp_err_t ret = ESP_OK;
+    ret |= is31fl3216_ch_disable(is31fl3216->handle, IS31FL3216_CH_ALL);
+    ret |= is31fl3216_deinit(is31fl3216->handle);
+    audio_free(is31fl3216->arg);
+    vQueueDelete(is31fl3216->evt);
+    audio_free(is31fl3216);
+    if (ret) {
+        ESP_LOGE(TAG, "Error occurred when stopping the is31fl3216");
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_is31fl3216_init(periph_is31fl3216_cfg_t *is31fl3216_config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_IS31FL3216, "periph_is31fl3216");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+
+    periph_is31fl3216_t *is31fl3216 = audio_calloc(1, sizeof(periph_is31fl3216_t));
+    AUDIO_MEM_CHECK(TAG, is31fl3216, {
+        audio_free(periph);
+        return NULL;
+    });
+
+    is31fl3216->g_event_bit = xEventGroupCreate();
+    AUDIO_NULL_CHECK(TAG, is31fl3216->g_event_bit, {
+        audio_free(periph);
+        audio_free(is31fl3216);
+    });
+
+    is31fl3216->evt = xQueueCreate(2, sizeof(periph_is31_msg_t));
+    AUDIO_MEM_CHECK(TAG, is31fl3216->evt, {
+        audio_free(periph);
+        vEventGroupDelete(is31fl3216->g_event_bit);
+        audio_free(is31fl3216);
+        return NULL;
+    });
+    is31fl3216->arg = audio_calloc(1, sizeof(periph_is31_arg_t));
+    AUDIO_MEM_CHECK(TAG, is31fl3216->arg, {
+        vQueueDelete(is31fl3216->evt);
+        vEventGroupDelete(is31fl3216->g_event_bit);
+        audio_free(periph);
+        audio_free(is31fl3216);
+        return NULL;
+    });
+    is31fl3216->arg->max_light_num = IS31FL3216_CH_NUM;
+    is31fl3216->arg->light_num = 0;
+    is31fl3216->arg->light_mask = 0;
+    is31fl3216->arg->interval_time = 1000;
+    is31fl3216->arg->act_time = 0;
+    is31fl3216->arg->duty_step = DEFAULT_FLASH_STEP;
+    is31fl3216->arg->shift_mode = PERIPH_IS31_SHIFT_MODE_ACC;
+
+    for (int i = 0; i < IS31FL3216_CH_NUM; i++) {
+        is31fl3216->duty[i] = is31fl3216_config->duty[i];
+    }
+    is31fl3216->handle = is31fl3216_init();
+    AUDIO_MEM_CHECK(TAG, is31fl3216, {
+        audio_free(is31fl3216->arg);
+        vQueueDelete(is31fl3216->evt);
+        audio_free(periph);
+        vEventGroupDelete(is31fl3216->g_event_bit);
+        audio_free(is31fl3216);
+        return NULL;
+    });
+
+    esp_periph_set_data(periph, is31fl3216);
+    esp_periph_set_function(periph, _is31fl3216_init, NULL, _is31fl3216_destroy);
+    return periph;
 }
\ No newline at end of file
diff --git a/components/esp_peripherals/periph_lcd.c b/components/esp_peripherals/periph_lcd.c
index 5bc43bc7..c0c60963 100644
--- a/components/esp_peripherals/periph_lcd.c
+++ b/components/esp_peripherals/periph_lcd.c
@@ -1,152 +1,152 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_log.h"
-#include "board.h"
-#include "audio_mem.h"
-#include "audio_sys.h"
-#include "audio_idf_version.h"
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
-#include "periph_lcd.h"
-#include "esp_lcd_panel_ops.h"
-
-static const char *TAG = "PERIPH_LCD";
-
-typedef struct periph_lcd {
-    void                                *io_bus;
-    get_lcd_io_bus                      new_panel_io;
-    esp_lcd_panel_io_spi_config_t       lcd_io_cfg;
-    get_lcd_panel                       new_lcd_panel;
-    esp_lcd_panel_dev_config_t          lcd_dev_cfg;
-
-    esp_lcd_panel_io_handle_t           lcd_io_handle;
-    esp_lcd_panel_handle_t              lcd_panel_handle;
-
-    perph_lcd_rest                      rest_cb;
-    lcd_vender_init_func                vendor_init;
-    void                                *rest_cb_ctx;
-    bool                                lcd_swap_xy;
-    bool                                lcd_mirror_x;
-    bool                                lcd_mirror_y;
-    bool                                lcd_color_invert;
-} periph_lcd_t;
-
-esp_err_t _lcd_rest_default(esp_periph_handle_t self, void *ctx);
-
-static esp_err_t _lcd_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    return ESP_OK;
-}
-
-static esp_err_t _lcd_init(esp_periph_handle_t self)
-{
-    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
-    if (periph_lcd->rest_cb) {
-        periph_lcd->rest_cb(self, periph_lcd->rest_cb_ctx);
-    }
-    // Initialize LCD panel
-    ESP_ERROR_CHECK(esp_lcd_panel_init(periph_lcd->lcd_panel_handle));
-    if (periph_lcd->vendor_init) {
-        ESP_ERROR_CHECK(periph_lcd->vendor_init(periph_lcd->lcd_io_handle));
-    }
-    ESP_ERROR_CHECK(esp_lcd_panel_invert_color(periph_lcd->lcd_panel_handle, periph_lcd->lcd_color_invert));
-    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(periph_lcd->lcd_panel_handle, 0, 0));
-    ESP_ERROR_CHECK(esp_lcd_panel_swap_xy(periph_lcd->lcd_panel_handle, periph_lcd->lcd_swap_xy));
-    ESP_ERROR_CHECK(esp_lcd_panel_mirror(periph_lcd->lcd_panel_handle, periph_lcd->lcd_mirror_x, periph_lcd->lcd_mirror_y));
-    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(periph_lcd->lcd_panel_handle, true));
-    return ESP_OK;
-}
-
-static esp_err_t _lcd_destroy(esp_periph_handle_t self)
-{
-    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
-    esp_lcd_panel_del(periph_lcd->lcd_panel_handle);
-    esp_lcd_panel_io_del(periph_lcd->lcd_io_handle);
-    return ESP_OK;
-}
-
-esp_err_t _lcd_rest_default(esp_periph_handle_t self, void *ctx)
-{
-    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
-    ESP_ERROR_CHECK(esp_lcd_panel_reset(periph_lcd->lcd_panel_handle));
-    return ESP_OK;
-}
-
-esp_err_t _setup_lcd(esp_periph_handle_t self)
-{
-    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
-    // Attach the LCD to the specific bus
-    ESP_ERROR_CHECK(periph_lcd->new_panel_io(periph_lcd->io_bus,
-                    &periph_lcd->lcd_io_cfg, &periph_lcd->lcd_io_handle));
-    // Initialize the LCD configuration
-    ESP_ERROR_CHECK(periph_lcd->new_lcd_panel(periph_lcd->lcd_io_handle, &periph_lcd->lcd_dev_cfg, &periph_lcd->lcd_panel_handle));
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_lcd_init(periph_lcd_cfg_t *config)
-{
-    periph_lcd_t *periph_lcd = audio_calloc(1, sizeof(periph_lcd_t));
-    AUDIO_MEM_CHECK(TAG, periph_lcd, return NULL);
-    periph_lcd->io_bus = config->io_bus;
-
-    memcpy(&periph_lcd->lcd_io_cfg, config->lcd_io_cfg, sizeof(esp_lcd_panel_io_spi_config_t));
-    memcpy(&periph_lcd->lcd_dev_cfg, config->lcd_dev_cfg, sizeof(esp_lcd_panel_dev_config_t));
-    periph_lcd->new_panel_io = config->new_panel_io;
-    periph_lcd->new_lcd_panel = config->new_lcd_panel;
-    periph_lcd->lcd_swap_xy = config->lcd_swap_xy;
-    periph_lcd->lcd_mirror_x = config->lcd_mirror_x;
-    periph_lcd->lcd_mirror_y = config->lcd_mirror_y;
-    periph_lcd->lcd_color_invert = config->lcd_color_invert;
-    periph_lcd->rest_cb = config->rest_cb;
-    periph_lcd->vendor_init = config->vendor_init;
-
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_LCD, "periph_lcd");
-    AUDIO_MEM_CHECK(TAG, periph, {audio_free(periph_lcd);
-                                  return NULL;
-                                 });
-    if (periph_lcd->rest_cb == NULL) {
-        periph_lcd->rest_cb = _lcd_rest_default;
-    }
-    periph_lcd->rest_cb_ctx = config->rest_cb_ctx;
-
-    esp_periph_set_data(periph, periph_lcd);
-    esp_periph_set_function(periph, NULL, _lcd_run, _lcd_destroy);
-
-    _setup_lcd(periph);
-     _lcd_init(periph);
-    return periph;
-}
-
-esp_lcd_panel_handle_t periph_lcd_get_panel_handle(esp_periph_handle_t handle)
-{
-    periph_lcd_t *periph_lcd = esp_periph_get_data(handle);
-    if (periph_lcd) {
-        return periph_lcd->lcd_panel_handle;
-    }
-    return NULL;
-}
-
-#endif
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_log.h"
+#include "board.h"
+#include "audio_mem.h"
+#include "audio_sys.h"
+#include "audio_idf_version.h"
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
+#include "periph_lcd.h"
+#include "esp_lcd_panel_ops.h"
+
+static const char *TAG = "PERIPH_LCD";
+
+typedef struct periph_lcd {
+    void                                *io_bus;
+    get_lcd_io_bus                      new_panel_io;
+    esp_lcd_panel_io_spi_config_t       lcd_io_cfg;
+    get_lcd_panel                       new_lcd_panel;
+    esp_lcd_panel_dev_config_t          lcd_dev_cfg;
+
+    esp_lcd_panel_io_handle_t           lcd_io_handle;
+    esp_lcd_panel_handle_t              lcd_panel_handle;
+
+    perph_lcd_rest                      rest_cb;
+    lcd_vender_init_func                vendor_init;
+    void                                *rest_cb_ctx;
+    bool                                lcd_swap_xy;
+    bool                                lcd_mirror_x;
+    bool                                lcd_mirror_y;
+    bool                                lcd_color_invert;
+} periph_lcd_t;
+
+esp_err_t _lcd_rest_default(esp_periph_handle_t self, void *ctx);
+
+static esp_err_t _lcd_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    return ESP_OK;
+}
+
+static esp_err_t _lcd_init(esp_periph_handle_t self)
+{
+    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
+    if (periph_lcd->rest_cb) {
+        periph_lcd->rest_cb(self, periph_lcd->rest_cb_ctx);
+    }
+    // Initialize LCD panel
+    ESP_ERROR_CHECK(esp_lcd_panel_init(periph_lcd->lcd_panel_handle));
+    if (periph_lcd->vendor_init) {
+        ESP_ERROR_CHECK(periph_lcd->vendor_init(periph_lcd->lcd_io_handle));
+    }
+    ESP_ERROR_CHECK(esp_lcd_panel_invert_color(periph_lcd->lcd_panel_handle, periph_lcd->lcd_color_invert));
+    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(periph_lcd->lcd_panel_handle, 0, 0));
+    ESP_ERROR_CHECK(esp_lcd_panel_swap_xy(periph_lcd->lcd_panel_handle, periph_lcd->lcd_swap_xy));
+    ESP_ERROR_CHECK(esp_lcd_panel_mirror(periph_lcd->lcd_panel_handle, periph_lcd->lcd_mirror_x, periph_lcd->lcd_mirror_y));
+    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(periph_lcd->lcd_panel_handle, true));
+    return ESP_OK;
+}
+
+static esp_err_t _lcd_destroy(esp_periph_handle_t self)
+{
+    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
+    esp_lcd_panel_del(periph_lcd->lcd_panel_handle);
+    esp_lcd_panel_io_del(periph_lcd->lcd_io_handle);
+    return ESP_OK;
+}
+
+esp_err_t _lcd_rest_default(esp_periph_handle_t self, void *ctx)
+{
+    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
+    ESP_ERROR_CHECK(esp_lcd_panel_reset(periph_lcd->lcd_panel_handle));
+    return ESP_OK;
+}
+
+esp_err_t _setup_lcd(esp_periph_handle_t self)
+{
+    periph_lcd_t *periph_lcd = esp_periph_get_data(self);
+    // Attach the LCD to the specific bus
+    ESP_ERROR_CHECK(periph_lcd->new_panel_io(periph_lcd->io_bus,
+                    &periph_lcd->lcd_io_cfg, &periph_lcd->lcd_io_handle));
+    // Initialize the LCD configuration
+    ESP_ERROR_CHECK(periph_lcd->new_lcd_panel(periph_lcd->lcd_io_handle, &periph_lcd->lcd_dev_cfg, &periph_lcd->lcd_panel_handle));
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_lcd_init(periph_lcd_cfg_t *config)
+{
+    periph_lcd_t *periph_lcd = audio_calloc(1, sizeof(periph_lcd_t));
+    AUDIO_MEM_CHECK(TAG, periph_lcd, return NULL);
+    periph_lcd->io_bus = config->io_bus;
+
+    memcpy(&periph_lcd->lcd_io_cfg, config->lcd_io_cfg, sizeof(esp_lcd_panel_io_spi_config_t));
+    memcpy(&periph_lcd->lcd_dev_cfg, config->lcd_dev_cfg, sizeof(esp_lcd_panel_dev_config_t));
+    periph_lcd->new_panel_io = config->new_panel_io;
+    periph_lcd->new_lcd_panel = config->new_lcd_panel;
+    periph_lcd->lcd_swap_xy = config->lcd_swap_xy;
+    periph_lcd->lcd_mirror_x = config->lcd_mirror_x;
+    periph_lcd->lcd_mirror_y = config->lcd_mirror_y;
+    periph_lcd->lcd_color_invert = config->lcd_color_invert;
+    periph_lcd->rest_cb = config->rest_cb;
+    periph_lcd->vendor_init = config->vendor_init;
+
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_LCD, "periph_lcd");
+    AUDIO_MEM_CHECK(TAG, periph, {audio_free(periph_lcd);
+                                  return NULL;
+                                 });
+    if (periph_lcd->rest_cb == NULL) {
+        periph_lcd->rest_cb = _lcd_rest_default;
+    }
+    periph_lcd->rest_cb_ctx = config->rest_cb_ctx;
+
+    esp_periph_set_data(periph, periph_lcd);
+    esp_periph_set_function(periph, NULL, _lcd_run, _lcd_destroy);
+
+    _setup_lcd(periph);
+     _lcd_init(periph);
+    return periph;
+}
+
+esp_lcd_panel_handle_t periph_lcd_get_panel_handle(esp_periph_handle_t handle)
+{
+    periph_lcd_t *periph_lcd = esp_periph_get_data(handle);
+    if (periph_lcd) {
+        return periph_lcd->lcd_panel_handle;
+    }
+    return NULL;
+}
+
+#endif
diff --git a/components/esp_peripherals/periph_led.c b/components/esp_peripherals/periph_led.c
index 1cde6b1e..dc768893 100644
--- a/components/esp_peripherals/periph_led.c
+++ b/components/esp_peripherals/periph_led.c
@@ -1,243 +1,243 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include <math.h>
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "audio_sys.h"
-#include "periph_led.h"
-#include "esp_peripherals.h"
-#include "audio_mutex.h"
-
-#define MAX_LED_CHANNEL (8)
-
-static const char *TAG = "PERIPH_LED";
-
-#define VALIDATE_LED(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_LED)) { \
-    ESP_LOGE(TAG, "Invalid LED periph, at line %d", __LINE__);\
-    return ret;\
-}
-
-typedef struct {
-    int index;
-    int pin;
-    int high_level_ms;
-    int low_level_ms;
-    long long tick;
-    int loop;
-    bool is_high_level;
-    bool fade;
-    bool stop;
-    int  level;
-} periph_led_channel_t;
-
-typedef struct periph_led {
-    ledc_mode_t      led_speed_mode;
-    ledc_timer_bit_t led_duty_resolution;
-    ledc_timer_t     led_timer_num;
-    uint32_t         led_freq_hz;
-    QueueHandle_t    led_mutex;
-    periph_led_channel_t   channels[MAX_LED_CHANNEL];
-} periph_led_t;
-
-static esp_err_t _led_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    return ESP_OK;
-}
-
-static esp_err_t _led_init(esp_periph_handle_t self)
-{
-    VALIDATE_LED(self, ESP_FAIL);
-    periph_led_t *periph_led = esp_periph_get_data(self);
-    ledc_timer_config_t ledc_timer = {
-        .duty_resolution = periph_led->led_duty_resolution, // resolution of PWM duty
-        .freq_hz = periph_led->led_freq_hz,                      // frequency of PWM signal
-        .speed_mode = periph_led->led_speed_mode,           // timer mode
-        .timer_num = periph_led->led_timer_num            // timer index
-    };
-
-    // Set configuration of timer0 for high speed channels
-    ledc_timer_config(&ledc_timer);
-    ledc_fade_func_install(0);
-    return ESP_OK;
-}
-
-static esp_err_t _led_destroy(esp_periph_handle_t self)
-{
-    periph_led_t *periph_led = esp_periph_get_data(self);
-    for (int i = 0; i < MAX_LED_CHANNEL; i++) {
-        periph_led_channel_t *ch = &periph_led->channels[i];
-        if (ch->index > 0 && ch->pin > 0) {
-            ledc_stop(periph_led->led_speed_mode, ch->index, ch->level);
-        }
-    }
-    esp_periph_stop_timer(self);
-    ledc_fade_func_uninstall();
-    mutex_destroy(periph_led->led_mutex);
-    audio_free(periph_led);
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_led_init(periph_led_cfg_t *config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_LED, "periph_led");
-    //check periph
-    periph_led_t *periph_led = audio_calloc(1, sizeof(periph_led_t));
-    //check periph_led
-    periph_led->led_speed_mode      = config->led_speed_mode;
-    periph_led->led_duty_resolution = config->led_duty_resolution;
-    periph_led->led_timer_num       = config->led_timer_num;
-    periph_led->led_freq_hz         = config->led_freq_hz;
-    periph_led->led_mutex           = mutex_create();
-    if (periph_led->led_freq_hz == 0) {
-        periph_led->led_freq_hz = 5000;
-    }
-    memset(&periph_led->channels, -1, sizeof(periph_led->channels));
-    esp_periph_set_data(periph, periph_led);
-    esp_periph_set_function(periph, _led_init, _led_run, _led_destroy);
-    return periph;
-}
-
-static periph_led_channel_t *_find_led_channel(periph_led_t *periph_led, int gpio_num)
-{
-    periph_led_channel_t *ch = NULL;
-    for (int i = 0; i < MAX_LED_CHANNEL; i++) {
-        if (periph_led->channels[i].pin == gpio_num) {
-            ch = &periph_led->channels[i];
-            ch->index = i;
-            break;
-        } else if (periph_led->channels[i].pin == -1) {
-            ch = &periph_led->channels[i];
-            ch->index = i;
-        }
-    }
-    return ch;
-}
-
-static void led_timer_handler(xTimerHandle tmr)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
-
-    periph_led_t *periph_led = esp_periph_get_data(periph);
-    mutex_lock(periph_led->led_mutex);
-    for (int i = 0; i < MAX_LED_CHANNEL; i++) {
-        periph_led_channel_t *ch = &periph_led->channels[i];
-        if (ch->pin < 0 || ch->stop == true) {
-            continue;
-        }
-
-        if (ch->loop == 0) {
-            ledc_stop(periph_led->led_speed_mode, ch->index, ch->level);
-            esp_periph_send_event(periph, PERIPH_LED_BLINK_FINISH, (void *)ch->pin, 0);
-            ch->stop = true;
-            continue;
-        }
-
-        if (!ch->is_high_level && audio_sys_get_time_ms() - ch->tick > ch->low_level_ms) {
-            if (ch->loop > 0) {
-                ch->loop --;
-            }
-            // now, switch on
-            if (ch->fade) {
-                ledc_set_fade_with_time(periph_led->led_speed_mode, ch->index, pow(2, periph_led->led_duty_resolution) - 1, ch->high_level_ms);
-                ledc_fade_start(periph_led->led_speed_mode, ch->index, LEDC_FADE_NO_WAIT);
-            } else {
-                ledc_set_duty(periph_led->led_speed_mode, ch->index, pow(2, periph_led->led_duty_resolution) - 1);
-                ledc_update_duty(periph_led->led_speed_mode, ch->index);
-            }
-            if (ch->low_level_ms > 0) {
-                ch->is_high_level = true;
-            }
-            ch->tick = audio_sys_get_time_ms();
-        } else if (ch->is_high_level && audio_sys_get_time_ms() - ch->tick > ch->high_level_ms) {
-            if (ch->loop > 0) {
-                ch->loop --;
-            }
-            // switch off
-            if (ch->fade) {
-                ledc_set_fade_with_time(periph_led->led_speed_mode, ch->index, 0, ch->low_level_ms);
-                ledc_fade_start(periph_led->led_speed_mode, ch->index, LEDC_FADE_NO_WAIT);
-            } else {
-                ledc_set_duty(periph_led->led_speed_mode, ch->index, 0);
-                ledc_update_duty(periph_led->led_speed_mode, ch->index);
-            }
-            if (ch->high_level_ms > 0) {
-                ch->is_high_level = false;
-            }
-            ch->tick = audio_sys_get_time_ms();
-        }
-    }
-    mutex_unlock(periph_led->led_mutex);
-}
-
-esp_err_t periph_led_blink(esp_periph_handle_t periph, int gpio_num, int time_on_ms, int time_off_ms, bool fade, int loop, periph_led_idle_level_t level)
-{
-    periph_led_t *periph_led = esp_periph_get_data(periph);
-    periph_led_channel_t *ch = _find_led_channel(periph_led, gpio_num);
-    if (ch == NULL) {
-        return ESP_FAIL;
-    }
-    ledc_channel_config_t ledc_channel_cfg = {
-        .channel    = ch->index,
-        .duty       = 0,
-        .gpio_num   = gpio_num,
-        .speed_mode = periph_led->led_speed_mode,
-        .timer_sel  = periph_led->led_timer_num,
-    };
-    ledc_channel_config(&ledc_channel_cfg);
-    ch->pin = gpio_num;
-    ch->tick = audio_sys_get_time_ms();
-    ch->loop = loop;
-    ch->fade = fade;
-    if (level == PERIPH_LED_IDLE_LEVEL_LOW) {
-        ch->is_high_level = false;
-        ch->high_level_ms = time_on_ms;
-        ch->low_level_ms = time_off_ms;
-    } else {
-        ch->is_high_level = true;
-        ch->high_level_ms = time_off_ms;
-        ch->low_level_ms = time_on_ms;
-    }
-    ch->stop = false;
-    ch->level = level;
-    esp_periph_start_timer(periph, portTICK_RATE_MS, led_timer_handler);
-    return ESP_OK;
-}
-
-esp_err_t periph_led_stop(esp_periph_handle_t periph, int gpio_num)
-{
-    periph_led_t *periph_led = esp_periph_get_data(periph);
-    periph_led_channel_t *ch = _find_led_channel(periph_led, gpio_num);
-    if (ch && (ch->pin < 0 || ch->index < 0)) {
-        return ESP_OK;
-    }
-
-    mutex_lock(periph_led->led_mutex);
-    ch->stop = true;
-    ledc_stop(periph_led->led_speed_mode, ch->index, ch->level);
-    mutex_unlock(periph_led->led_mutex);
-
-    return ESP_OK;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include <math.h>
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "audio_sys.h"
+#include "periph_led.h"
+#include "esp_peripherals.h"
+#include "audio_mutex.h"
+
+#define MAX_LED_CHANNEL (8)
+
+static const char *TAG = "PERIPH_LED";
+
+#define VALIDATE_LED(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_LED)) { \
+    ESP_LOGE(TAG, "Invalid LED periph, at line %d", __LINE__);\
+    return ret;\
+}
+
+typedef struct {
+    int index;
+    int pin;
+    int high_level_ms;
+    int low_level_ms;
+    long long tick;
+    int loop;
+    bool is_high_level;
+    bool fade;
+    bool stop;
+    int  level;
+} periph_led_channel_t;
+
+typedef struct periph_led {
+    ledc_mode_t      led_speed_mode;
+    ledc_timer_bit_t led_duty_resolution;
+    ledc_timer_t     led_timer_num;
+    uint32_t         led_freq_hz;
+    QueueHandle_t    led_mutex;
+    periph_led_channel_t   channels[MAX_LED_CHANNEL];
+} periph_led_t;
+
+static esp_err_t _led_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    return ESP_OK;
+}
+
+static esp_err_t _led_init(esp_periph_handle_t self)
+{
+    VALIDATE_LED(self, ESP_FAIL);
+    periph_led_t *periph_led = esp_periph_get_data(self);
+    ledc_timer_config_t ledc_timer = {
+        .duty_resolution = periph_led->led_duty_resolution, // resolution of PWM duty
+        .freq_hz = periph_led->led_freq_hz,                      // frequency of PWM signal
+        .speed_mode = periph_led->led_speed_mode,           // timer mode
+        .timer_num = periph_led->led_timer_num            // timer index
+    };
+
+    // Set configuration of timer0 for high speed channels
+    ledc_timer_config(&ledc_timer);
+    ledc_fade_func_install(0);
+    return ESP_OK;
+}
+
+static esp_err_t _led_destroy(esp_periph_handle_t self)
+{
+    periph_led_t *periph_led = esp_periph_get_data(self);
+    for (int i = 0; i < MAX_LED_CHANNEL; i++) {
+        periph_led_channel_t *ch = &periph_led->channels[i];
+        if (ch->index > 0 && ch->pin > 0) {
+            ledc_stop(periph_led->led_speed_mode, ch->index, ch->level);
+        }
+    }
+    esp_periph_stop_timer(self);
+    ledc_fade_func_uninstall();
+    mutex_destroy(periph_led->led_mutex);
+    audio_free(periph_led);
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_led_init(periph_led_cfg_t *config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_LED, "periph_led");
+    //check periph
+    periph_led_t *periph_led = audio_calloc(1, sizeof(periph_led_t));
+    //check periph_led
+    periph_led->led_speed_mode      = config->led_speed_mode;
+    periph_led->led_duty_resolution = config->led_duty_resolution;
+    periph_led->led_timer_num       = config->led_timer_num;
+    periph_led->led_freq_hz         = config->led_freq_hz;
+    periph_led->led_mutex           = mutex_create();
+    if (periph_led->led_freq_hz == 0) {
+        periph_led->led_freq_hz = 5000;
+    }
+    memset(&periph_led->channels, -1, sizeof(periph_led->channels));
+    esp_periph_set_data(periph, periph_led);
+    esp_periph_set_function(periph, _led_init, _led_run, _led_destroy);
+    return periph;
+}
+
+static periph_led_channel_t *_find_led_channel(periph_led_t *periph_led, int gpio_num)
+{
+    periph_led_channel_t *ch = NULL;
+    for (int i = 0; i < MAX_LED_CHANNEL; i++) {
+        if (periph_led->channels[i].pin == gpio_num) {
+            ch = &periph_led->channels[i];
+            ch->index = i;
+            break;
+        } else if (periph_led->channels[i].pin == -1) {
+            ch = &periph_led->channels[i];
+            ch->index = i;
+        }
+    }
+    return ch;
+}
+
+static void led_timer_handler(TimerHandle_t tmr)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
+
+    periph_led_t *periph_led = esp_periph_get_data(periph);
+    mutex_lock(periph_led->led_mutex);
+    for (int i = 0; i < MAX_LED_CHANNEL; i++) {
+        periph_led_channel_t *ch = &periph_led->channels[i];
+        if (ch->pin < 0 || ch->stop == true) {
+            continue;
+        }
+
+        if (ch->loop == 0) {
+            ledc_stop(periph_led->led_speed_mode, ch->index, ch->level);
+            esp_periph_send_event(periph, PERIPH_LED_BLINK_FINISH, (void *)ch->pin, 0);
+            ch->stop = true;
+            continue;
+        }
+
+        if (!ch->is_high_level && audio_sys_get_time_ms() - ch->tick > ch->low_level_ms) {
+            if (ch->loop > 0) {
+                ch->loop --;
+            }
+            // now, switch on
+            if (ch->fade) {
+                ledc_set_fade_with_time(periph_led->led_speed_mode, ch->index, pow(2, periph_led->led_duty_resolution) - 1, ch->high_level_ms);
+                ledc_fade_start(periph_led->led_speed_mode, ch->index, LEDC_FADE_NO_WAIT);
+            } else {
+                ledc_set_duty(periph_led->led_speed_mode, ch->index, pow(2, periph_led->led_duty_resolution) - 1);
+                ledc_update_duty(periph_led->led_speed_mode, ch->index);
+            }
+            if (ch->low_level_ms > 0) {
+                ch->is_high_level = true;
+            }
+            ch->tick = audio_sys_get_time_ms();
+        } else if (ch->is_high_level && audio_sys_get_time_ms() - ch->tick > ch->high_level_ms) {
+            if (ch->loop > 0) {
+                ch->loop --;
+            }
+            // switch off
+            if (ch->fade) {
+                ledc_set_fade_with_time(periph_led->led_speed_mode, ch->index, 0, ch->low_level_ms);
+                ledc_fade_start(periph_led->led_speed_mode, ch->index, LEDC_FADE_NO_WAIT);
+            } else {
+                ledc_set_duty(periph_led->led_speed_mode, ch->index, 0);
+                ledc_update_duty(periph_led->led_speed_mode, ch->index);
+            }
+            if (ch->high_level_ms > 0) {
+                ch->is_high_level = false;
+            }
+            ch->tick = audio_sys_get_time_ms();
+        }
+    }
+    mutex_unlock(periph_led->led_mutex);
+}
+
+esp_err_t periph_led_blink(esp_periph_handle_t periph, int gpio_num, int time_on_ms, int time_off_ms, bool fade, int loop, periph_led_idle_level_t level)
+{
+    periph_led_t *periph_led = esp_periph_get_data(periph);
+    periph_led_channel_t *ch = _find_led_channel(periph_led, gpio_num);
+    if (ch == NULL) {
+        return ESP_FAIL;
+    }
+    ledc_channel_config_t ledc_channel_cfg = {
+        .channel    = ch->index,
+        .duty       = 0,
+        .gpio_num   = gpio_num,
+        .speed_mode = periph_led->led_speed_mode,
+        .timer_sel  = periph_led->led_timer_num,
+    };
+    ledc_channel_config(&ledc_channel_cfg);
+    ch->pin = gpio_num;
+    ch->tick = audio_sys_get_time_ms();
+    ch->loop = loop;
+    ch->fade = fade;
+    if (level == PERIPH_LED_IDLE_LEVEL_LOW) {
+        ch->is_high_level = false;
+        ch->high_level_ms = time_on_ms;
+        ch->low_level_ms = time_off_ms;
+    } else {
+        ch->is_high_level = true;
+        ch->high_level_ms = time_off_ms;
+        ch->low_level_ms = time_on_ms;
+    }
+    ch->stop = false;
+    ch->level = level;
+    esp_periph_start_timer(periph, portTICK_PERIOD_MS, led_timer_handler);
+    return ESP_OK;
+}
+
+esp_err_t periph_led_stop(esp_periph_handle_t periph, int gpio_num)
+{
+    periph_led_t *periph_led = esp_periph_get_data(periph);
+    periph_led_channel_t *ch = _find_led_channel(periph_led, gpio_num);
+    if (ch && (ch->pin < 0 || ch->index < 0)) {
+        return ESP_OK;
+    }
+
+    mutex_lock(periph_led->led_mutex);
+    ch->stop = true;
+    ledc_stop(periph_led->led_speed_mode, ch->index, ch->level);
+    mutex_unlock(periph_led->led_mutex);
+
+    return ESP_OK;
+}
diff --git a/components/esp_peripherals/periph_sdcard.c b/components/esp_peripherals/periph_sdcard.c
index fb3f8e06..b52d0e88 100644
--- a/components/esp_peripherals/periph_sdcard.c
+++ b/components/esp_peripherals/periph_sdcard.c
@@ -1,196 +1,196 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#if SOC_SDMMC_HOST_SUPPORTED
-#include "driver/sdmmc_host.h"
-#endif
-#include "driver/sdmmc_defs.h"
-#include "driver/gpio.h"
-#include "sdcard.h"
-#include "periph_sdcard.h"
-#include "audio_mem.h"
-
-static const char *TAG = "PERIPH_SDCARD";
-
-#define SDCARD_CHECK_TIMEOUT_MS (20)
-
-#define VALIDATE_SDCARD(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_SDCARD)) { \
-    ESP_LOGE(TAG, "Invalid SDCARD periph, at line %d", __LINE__);\
-    return ret;\
-}
-
-#define tick_get periph_tick_get
-
-static esp_err_t periph_sdcard_mount(esp_periph_handle_t periph);
-static esp_err_t periph_sdcard_unmount(esp_periph_handle_t periph);
-
-typedef struct {
-    char *root;
-    int card_detect_pin;
-    bool is_mounted;
-    long long last_detect_time;
-    periph_sdcard_mode_t sd_mode;
-} periph_sdcard_t;
-
-
-static void IRAM_ATTR sdcard_gpio_intr_handler(void *param)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t)param;
-    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
-
-    if (sdcard_is_exist() && !sdcard->is_mounted) {
-        esp_periph_send_cmd_from_isr(periph, SDCARD_STATUS_CARD_DETECT_CHANGE, NULL, 0);
-    } else if (!sdcard_is_exist() && sdcard->is_mounted) {
-        esp_periph_send_cmd_from_isr(periph, SDCARD_STATUS_CARD_DETECT_CHANGE, NULL, 0);
-    }
-}
-
-static esp_err_t _sdcard_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    if (msg->cmd != SDCARD_STATUS_CARD_DETECT_CHANGE) {
-        return ESP_OK;
-    }
-    periph_sdcard_t *sdcard = esp_periph_get_data(self);
-    if (sdcard_is_exist() && !sdcard->is_mounted) {
-        periph_sdcard_mount(self);
-    } else if (!sdcard_is_exist() && sdcard->is_mounted) {
-        periph_sdcard_unmount(self);
-    }
-    return ESP_OK;
-}
-
-static void sdcard_timer_handler(xTimerHandle tmr)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
-    esp_periph_send_cmd(periph, SDCARD_STATUS_CARD_DETECT_CHANGE, NULL, 0);
-}
-
-static esp_err_t _sdcard_init(esp_periph_handle_t self)
-{
-    periph_sdcard_t *sdcard = esp_periph_get_data(self);
-    esp_err_t ret = sdcard_init(sdcard->card_detect_pin, sdcard_gpio_intr_handler, self);
-    if (sdcard_is_exist()) {
-        ret |= periph_sdcard_mount(self);
-    } else {
-        ESP_LOGE(TAG, "no sdcard detect");
-    }
-    esp_periph_start_timer(self, 1000 / portTICK_RATE_MS, sdcard_timer_handler);
-    return ESP_OK;
-}
-
-static esp_err_t _sdcard_destroy(esp_periph_handle_t self)
-{
-    VALIDATE_SDCARD(self, ESP_FAIL);
-    esp_err_t ret = ESP_OK;
-    periph_sdcard_t *sdcard = esp_periph_get_data(self);
-    if (sdcard->is_mounted) {
-        ret |= sdcard_unmount(sdcard->root, sdcard->sd_mode);
-        sdcard->is_mounted = false;
-    }
-    ret |= sdcard_destroy();
-    if (ret != ESP_OK) {
-        ESP_LOGE(TAG, "stop sdcard error!");
-    }
-    esp_periph_stop_timer(self);
-    audio_free(sdcard->root);
-    audio_free(sdcard);
-    return ret;
-}
-
-esp_err_t periph_sdcard_mount(esp_periph_handle_t periph)
-{
-    VALIDATE_SDCARD(periph, ESP_FAIL);
-
-    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
-
-    int ret = sdcard_mount(sdcard->root, sdcard->sd_mode);
-    if (ret == ESP_OK) {
-        ESP_LOGD(TAG, "Mount SDCARD success");
-        sdcard->is_mounted = true;
-        return esp_periph_send_event(periph, SDCARD_STATUS_MOUNTED, NULL, 0);
-    } else if (ret == ESP_ERR_INVALID_STATE) {
-        ESP_LOGD(TAG, "periph sdcard handle already mounted!");
-        return ESP_OK;
-    } else {
-        esp_periph_send_event(periph, SDCARD_STATUS_MOUNT_ERROR, NULL, 0);
-        sdcard->is_mounted = false;
-        ESP_LOGE(TAG, "mount sdcard error!");
-        return ESP_FAIL;
-    }
-}
-
-esp_err_t periph_sdcard_unmount(esp_periph_handle_t periph)
-{
-    VALIDATE_SDCARD(periph, ESP_FAIL);
-    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
-    int ret = sdcard_unmount(sdcard->root, sdcard->sd_mode);
-    if (ret == ESP_OK) {
-        ESP_LOGD(TAG, "UnMount SDCARD success");
-        sdcard->is_mounted = false;
-        return esp_periph_send_event(periph, SDCARD_STATUS_UNMOUNTED, NULL, 0);
-    } else {
-        esp_periph_send_event(periph, SDCARD_STATUS_UNMOUNT_ERROR, NULL, 0);
-        ESP_LOGE(TAG, "unmount sdcard error!");
-        sdcard->is_mounted = false;
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_sdcard_init(periph_sdcard_cfg_t *sdcard_cfg)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_SDCARD, "periph_sdcard");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-
-    periph_sdcard_t *sdcard = audio_calloc(1, sizeof(periph_sdcard_t));
-    AUDIO_MEM_CHECK(TAG, sdcard, {
-        audio_free(periph);
-        return NULL;
-    });
-
-    if (sdcard_cfg->root) {
-        sdcard->root = audio_strdup(sdcard_cfg->root);
-    } else {
-        sdcard->root = audio_strdup("/sdcard");
-    }
-    AUDIO_MEM_CHECK(TAG, sdcard->root, {
-        audio_free(sdcard);
-        audio_free(periph);
-        return NULL;
-    });
-
-    sdcard->card_detect_pin = sdcard_cfg->card_detect_pin;
-    sdcard->sd_mode = sdcard_cfg->mode;
-    esp_periph_set_data(periph, sdcard);
-    esp_periph_set_function(periph, _sdcard_init, _sdcard_run, _sdcard_destroy);
-    return periph;
-}
-
-bool periph_sdcard_is_mounted(esp_periph_handle_t periph)
-{
-    VALIDATE_SDCARD(periph, ESP_FAIL);
-    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
-    return sdcard->is_mounted;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#if SOC_SDMMC_HOST_SUPPORTED
+#include "driver/sdmmc_host.h"
+#endif
+#include "driver/sdmmc_defs.h"
+#include "driver/gpio.h"
+#include "sdcard.h"
+#include "periph_sdcard.h"
+#include "audio_mem.h"
+
+static const char *TAG = "PERIPH_SDCARD";
+
+#define SDCARD_CHECK_TIMEOUT_MS (20)
+
+#define VALIDATE_SDCARD(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_SDCARD)) { \
+    ESP_LOGE(TAG, "Invalid SDCARD periph, at line %d", __LINE__);\
+    return ret;\
+}
+
+#define tick_get periph_tick_get
+
+static esp_err_t periph_sdcard_mount(esp_periph_handle_t periph);
+static esp_err_t periph_sdcard_unmount(esp_periph_handle_t periph);
+
+typedef struct {
+    char *root;
+    int card_detect_pin;
+    bool is_mounted;
+    long long last_detect_time;
+    periph_sdcard_mode_t sd_mode;
+} periph_sdcard_t;
+
+
+static void IRAM_ATTR sdcard_gpio_intr_handler(void *param)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t)param;
+    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
+
+    if (sdcard_is_exist() && !sdcard->is_mounted) {
+        esp_periph_send_cmd_from_isr(periph, SDCARD_STATUS_CARD_DETECT_CHANGE, NULL, 0);
+    } else if (!sdcard_is_exist() && sdcard->is_mounted) {
+        esp_periph_send_cmd_from_isr(periph, SDCARD_STATUS_CARD_DETECT_CHANGE, NULL, 0);
+    }
+}
+
+static esp_err_t _sdcard_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    if (msg->cmd != SDCARD_STATUS_CARD_DETECT_CHANGE) {
+        return ESP_OK;
+    }
+    periph_sdcard_t *sdcard = esp_periph_get_data(self);
+    if (sdcard_is_exist() && !sdcard->is_mounted) {
+        periph_sdcard_mount(self);
+    } else if (!sdcard_is_exist() && sdcard->is_mounted) {
+        periph_sdcard_unmount(self);
+    }
+    return ESP_OK;
+}
+
+static void sdcard_timer_handler(TimerHandle_t tmr)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
+    esp_periph_send_cmd(periph, SDCARD_STATUS_CARD_DETECT_CHANGE, NULL, 0);
+}
+
+static esp_err_t _sdcard_init(esp_periph_handle_t self)
+{
+    periph_sdcard_t *sdcard = esp_periph_get_data(self);
+    esp_err_t ret = sdcard_init(sdcard->card_detect_pin, sdcard_gpio_intr_handler, self);
+    if (sdcard_is_exist()) {
+        ret |= periph_sdcard_mount(self);
+    } else {
+        ESP_LOGE(TAG, "no sdcard detect");
+    }
+    esp_periph_start_timer(self, 1000 / portTICK_PERIOD_MS, sdcard_timer_handler);
+    return ESP_OK;
+}
+
+static esp_err_t _sdcard_destroy(esp_periph_handle_t self)
+{
+    VALIDATE_SDCARD(self, ESP_FAIL);
+    esp_err_t ret = ESP_OK;
+    periph_sdcard_t *sdcard = esp_periph_get_data(self);
+    if (sdcard->is_mounted) {
+        ret |= sdcard_unmount(sdcard->root, sdcard->sd_mode);
+        sdcard->is_mounted = false;
+    }
+    ret |= sdcard_destroy();
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "stop sdcard error!");
+    }
+    esp_periph_stop_timer(self);
+    audio_free(sdcard->root);
+    audio_free(sdcard);
+    return ret;
+}
+
+esp_err_t periph_sdcard_mount(esp_periph_handle_t periph)
+{
+    VALIDATE_SDCARD(periph, ESP_FAIL);
+
+    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
+
+    int ret = sdcard_mount(sdcard->root, sdcard->sd_mode);
+    if (ret == ESP_OK) {
+        ESP_LOGD(TAG, "Mount SDCARD success");
+        sdcard->is_mounted = true;
+        return esp_periph_send_event(periph, SDCARD_STATUS_MOUNTED, NULL, 0);
+    } else if (ret == ESP_ERR_INVALID_STATE) {
+        ESP_LOGD(TAG, "periph sdcard handle already mounted!");
+        return ESP_OK;
+    } else {
+        esp_periph_send_event(periph, SDCARD_STATUS_MOUNT_ERROR, NULL, 0);
+        sdcard->is_mounted = false;
+        ESP_LOGE(TAG, "mount sdcard error!");
+        return ESP_FAIL;
+    }
+}
+
+esp_err_t periph_sdcard_unmount(esp_periph_handle_t periph)
+{
+    VALIDATE_SDCARD(periph, ESP_FAIL);
+    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
+    int ret = sdcard_unmount(sdcard->root, sdcard->sd_mode);
+    if (ret == ESP_OK) {
+        ESP_LOGD(TAG, "UnMount SDCARD success");
+        sdcard->is_mounted = false;
+        return esp_periph_send_event(periph, SDCARD_STATUS_UNMOUNTED, NULL, 0);
+    } else {
+        esp_periph_send_event(periph, SDCARD_STATUS_UNMOUNT_ERROR, NULL, 0);
+        ESP_LOGE(TAG, "unmount sdcard error!");
+        sdcard->is_mounted = false;
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_sdcard_init(periph_sdcard_cfg_t *sdcard_cfg)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_SDCARD, "periph_sdcard");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+
+    periph_sdcard_t *sdcard = audio_calloc(1, sizeof(periph_sdcard_t));
+    AUDIO_MEM_CHECK(TAG, sdcard, {
+        audio_free(periph);
+        return NULL;
+    });
+
+    if (sdcard_cfg->root) {
+        sdcard->root = audio_strdup(sdcard_cfg->root);
+    } else {
+        sdcard->root = audio_strdup("/sdcard");
+    }
+    AUDIO_MEM_CHECK(TAG, sdcard->root, {
+        audio_free(sdcard);
+        audio_free(periph);
+        return NULL;
+    });
+
+    sdcard->card_detect_pin = sdcard_cfg->card_detect_pin;
+    sdcard->sd_mode = sdcard_cfg->mode;
+    esp_periph_set_data(periph, sdcard);
+    esp_periph_set_function(periph, _sdcard_init, _sdcard_run, _sdcard_destroy);
+    return periph;
+}
+
+bool periph_sdcard_is_mounted(esp_periph_handle_t periph)
+{
+    VALIDATE_SDCARD(periph, ESP_FAIL);
+    periph_sdcard_t *sdcard = esp_periph_get_data(periph);
+    return sdcard->is_mounted;
+}
diff --git a/components/esp_peripherals/periph_spiffs.c b/components/esp_peripherals/periph_spiffs.c
index 3bbef181..9ae450cc 100644
--- a/components/esp_peripherals/periph_spiffs.c
+++ b/components/esp_peripherals/periph_spiffs.c
@@ -1,194 +1,194 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "esp_spiffs.h"
-#include "periph_spiffs.h"
-
-static const char *TAG = "PERIPH_SPIFFS";
-
-#define VALIDATE_SPIFFS(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_SPIFFS)) { \
-    ESP_LOGE(TAG, "Invalid SPIFFS periph, at line %d", __LINE__);\
-    return ret;\
-}
-
-#define SPIFFS_DEFAULT_MAX_FILES 5
-
-static esp_err_t periph_spiffs_mount(esp_periph_handle_t periph);
-static esp_err_t periph_spiffs_unmount(esp_periph_handle_t periph);
-
-typedef struct {
-    char *root;
-    char *partition_label;
-    size_t max_files;
-    bool format_if_mount_failed;
-    bool is_mounted;
-} periph_spiffs_t;
-
-static esp_err_t _spiffs_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    return ESP_OK;
-}
-
-static esp_err_t _spiffs_init(esp_periph_handle_t self)
-{
-    return periph_spiffs_mount(self);;
-}
-
-static esp_err_t _spiffs_destroy(esp_periph_handle_t self)
-{
-    VALIDATE_SPIFFS(self, ESP_FAIL);
-    esp_err_t ret = ESP_OK;
-
-    ret |= periph_spiffs_unmount(self);
-    if (ret != ESP_OK) {
-        ESP_LOGE(TAG,  "Failed to unmount SPIFFS");
-    }
-
-    periph_spiffs_t *spiffs = esp_periph_get_data(self);
-    audio_free(spiffs->root);
-    if (spiffs->partition_label != NULL) {
-        audio_free(spiffs->partition_label);
-    }
-    audio_free(spiffs);
-    return ret;
-}
-
-esp_err_t periph_spiffs_mount(esp_periph_handle_t periph)
-{
-    VALIDATE_SPIFFS(periph, ESP_FAIL);
-
-    periph_spiffs_t *spiffs = esp_periph_get_data(periph);
-
-    esp_vfs_spiffs_conf_t conf = {
-        .base_path = spiffs->root,
-        .partition_label = spiffs->partition_label,
-        .max_files = spiffs->max_files,
-        .format_if_mount_failed = spiffs->format_if_mount_failed
-    };
-
-    // Use settings defined above to initialize and mount SPIFFS filesystem.
-    // Note: esp_vfs_spiffs_register is an all-in-one convenience function.
-    esp_err_t ret = esp_vfs_spiffs_register(&conf);
-    if (ret != ESP_OK) {
-        if (ret == ESP_FAIL) {
-            ESP_LOGE(TAG, "Failed to mount or format filesystem");
-        } else if (ret == ESP_ERR_NOT_FOUND) {
-            printf("root %s ", spiffs->root);
-            ESP_LOGE(TAG, "Failed to find SPIFFS partition");
-        } else {
-            ESP_LOGE(TAG, "Failed to initialize SPIFFS (%d)", ret);
-        }
-        return ESP_FAIL;
-    }
-
-    if (ret == ESP_OK) {
-        ESP_LOGD(TAG, "Mount SPIFFS success");
-        spiffs->is_mounted = true;
-        size_t total = 0, used = 0;
-        ret = esp_spiffs_info(conf.partition_label, &total, &used);
-        if (ret != ESP_OK) {
-            ESP_LOGE(TAG, "Failed to get SPIFFS partition information (%d)", ret);
-        } else {
-            ESP_LOGI(TAG, "Partition size: total: %d, used: %d", total, used);
-        }
-        return esp_periph_send_event(periph, SPIFFS_STATUS_MOUNTED, NULL, 0);
-    } else if (ret == ESP_ERR_INVALID_STATE) {
-        ESP_LOGD(TAG, "Periph SPIFFS handle already mounted!");
-        return ESP_OK;
-    } else {
-        esp_periph_send_event(periph, SPIFFS_STATUS_MOUNT_ERROR, NULL, 0);
-        spiffs->is_mounted = false;
-        ESP_LOGE(TAG, "Mount SPIFFS error!");
-        return ESP_FAIL;
-    }
-}
-
-esp_err_t periph_spiffs_unmount(esp_periph_handle_t periph)
-{
-    VALIDATE_SPIFFS(periph, ESP_FAIL);
-    periph_spiffs_t *spiffs = esp_periph_get_data(periph);
-
-    int ret = esp_vfs_spiffs_unregister(spiffs->partition_label);
-    if (ret == ESP_OK) {
-        ESP_LOGD(TAG, "Unmount SPIFFS success");
-        spiffs->is_mounted = false;
-        return esp_periph_send_event(periph, SPIFFS_STATUS_UNMOUNTED, NULL, 0);
-    } else {
-        esp_periph_send_event(periph, SPIFFS_STATUS_UNMOUNT_ERROR, NULL, 0);
-        ESP_LOGE(TAG, "Unmount SPIFFS error!");
-        spiffs->is_mounted = false;
-        return ESP_FAIL;
-    }
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_spiffs_init(periph_spiffs_cfg_t *spiffs_cfg)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_SPIFFS, "periph_spiffs");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-
-    periph_spiffs_t *spiffs = audio_calloc(1, sizeof(periph_spiffs_t));
-    AUDIO_MEM_CHECK(TAG, spiffs, {
-        audio_free(periph);
-        return NULL;
-    });
-    if (spiffs_cfg->root) {
-        spiffs->root = audio_strdup(spiffs_cfg->root);
-    } else {
-        spiffs->root = audio_strdup("/spiffs");
-    }
-
-    if (spiffs_cfg->partition_label) {
-        spiffs->partition_label = audio_strdup(spiffs_cfg->partition_label);
-    } else {
-        spiffs->partition_label = NULL;
-    }
-
-    if (spiffs_cfg->max_files < SPIFFS_DEFAULT_MAX_FILES) {
-        spiffs->max_files = SPIFFS_DEFAULT_MAX_FILES;
-    } else {
-        spiffs->max_files = spiffs_cfg->max_files;
-    }
-
-    spiffs->format_if_mount_failed = spiffs_cfg->format_if_mount_failed;
-
-    AUDIO_MEM_CHECK(TAG, spiffs->root, {
-        audio_free(spiffs);
-        audio_free(periph);
-        return NULL;
-    });
-
-    esp_periph_set_data(periph, spiffs);
-    esp_periph_set_function(periph, _spiffs_init, _spiffs_run, _spiffs_destroy);
-    return periph;
-}
-
-bool periph_spiffs_is_mounted(esp_periph_handle_t periph)
-{
-    VALIDATE_SPIFFS(periph, ESP_FAIL);
-    periph_spiffs_t *spiffs = esp_periph_get_data(periph);
-    return spiffs->is_mounted;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "esp_spiffs.h"
+#include "periph_spiffs.h"
+
+static const char *TAG = "PERIPH_SPIFFS";
+
+#define VALIDATE_SPIFFS(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_SPIFFS)) { \
+    ESP_LOGE(TAG, "Invalid SPIFFS periph, at line %d", __LINE__);\
+    return ret;\
+}
+
+#define SPIFFS_DEFAULT_MAX_FILES 5
+
+static esp_err_t periph_spiffs_mount(esp_periph_handle_t periph);
+static esp_err_t periph_spiffs_unmount(esp_periph_handle_t periph);
+
+typedef struct {
+    char *root;
+    char *partition_label;
+    size_t max_files;
+    bool format_if_mount_failed;
+    bool is_mounted;
+} periph_spiffs_t;
+
+static esp_err_t _spiffs_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    return ESP_OK;
+}
+
+static esp_err_t _spiffs_init(esp_periph_handle_t self)
+{
+    return periph_spiffs_mount(self);;
+}
+
+static esp_err_t _spiffs_destroy(esp_periph_handle_t self)
+{
+    VALIDATE_SPIFFS(self, ESP_FAIL);
+    esp_err_t ret = ESP_OK;
+
+    ret |= periph_spiffs_unmount(self);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG,  "Failed to unmount SPIFFS");
+    }
+
+    periph_spiffs_t *spiffs = esp_periph_get_data(self);
+    audio_free(spiffs->root);
+    if (spiffs->partition_label != NULL) {
+        audio_free(spiffs->partition_label);
+    }
+    audio_free(spiffs);
+    return ret;
+}
+
+esp_err_t periph_spiffs_mount(esp_periph_handle_t periph)
+{
+    VALIDATE_SPIFFS(periph, ESP_FAIL);
+
+    periph_spiffs_t *spiffs = esp_periph_get_data(periph);
+
+    esp_vfs_spiffs_conf_t conf = {
+        .base_path = spiffs->root,
+        .partition_label = spiffs->partition_label,
+        .max_files = spiffs->max_files,
+        .format_if_mount_failed = spiffs->format_if_mount_failed
+    };
+
+    // Use settings defined above to initialize and mount SPIFFS filesystem.
+    // Note: esp_vfs_spiffs_register is an all-in-one convenience function.
+    esp_err_t ret = esp_vfs_spiffs_register(&conf);
+    if (ret != ESP_OK) {
+        if (ret == ESP_FAIL) {
+            ESP_LOGE(TAG, "Failed to mount or format filesystem");
+        } else if (ret == ESP_ERR_NOT_FOUND) {
+            printf("root %s ", spiffs->root);
+            ESP_LOGE(TAG, "Failed to find SPIFFS partition");
+        } else {
+            ESP_LOGE(TAG, "Failed to initialize SPIFFS (%d)", ret);
+        }
+        return ESP_FAIL;
+    }
+
+    if (ret == ESP_OK) {
+        ESP_LOGD(TAG, "Mount SPIFFS success");
+        spiffs->is_mounted = true;
+        size_t total = 0, used = 0;
+        ret = esp_spiffs_info(conf.partition_label, &total, &used);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "Failed to get SPIFFS partition information (%d)", ret);
+        } else {
+            ESP_LOGI(TAG, "Partition size: total: %d, used: %d", total, used);
+        }
+        return esp_periph_send_event(periph, SPIFFS_STATUS_MOUNTED, NULL, 0);
+    } else if (ret == ESP_ERR_INVALID_STATE) {
+        ESP_LOGD(TAG, "Periph SPIFFS handle already mounted!");
+        return ESP_OK;
+    } else {
+        esp_periph_send_event(periph, SPIFFS_STATUS_MOUNT_ERROR, NULL, 0);
+        spiffs->is_mounted = false;
+        ESP_LOGE(TAG, "Mount SPIFFS error!");
+        return ESP_FAIL;
+    }
+}
+
+esp_err_t periph_spiffs_unmount(esp_periph_handle_t periph)
+{
+    VALIDATE_SPIFFS(periph, ESP_FAIL);
+    periph_spiffs_t *spiffs = esp_periph_get_data(periph);
+
+    int ret = esp_vfs_spiffs_unregister(spiffs->partition_label);
+    if (ret == ESP_OK) {
+        ESP_LOGD(TAG, "Unmount SPIFFS success");
+        spiffs->is_mounted = false;
+        return esp_periph_send_event(periph, SPIFFS_STATUS_UNMOUNTED, NULL, 0);
+    } else {
+        esp_periph_send_event(periph, SPIFFS_STATUS_UNMOUNT_ERROR, NULL, 0);
+        ESP_LOGE(TAG, "Unmount SPIFFS error!");
+        spiffs->is_mounted = false;
+        return ESP_FAIL;
+    }
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_spiffs_init(periph_spiffs_cfg_t *spiffs_cfg)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_SPIFFS, "periph_spiffs");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+
+    periph_spiffs_t *spiffs = audio_calloc(1, sizeof(periph_spiffs_t));
+    AUDIO_MEM_CHECK(TAG, spiffs, {
+        audio_free(periph);
+        return NULL;
+    });
+    if (spiffs_cfg->root) {
+        spiffs->root = audio_strdup(spiffs_cfg->root);
+    } else {
+        spiffs->root = audio_strdup("/spiffs");
+    }
+
+    if (spiffs_cfg->partition_label) {
+        spiffs->partition_label = audio_strdup(spiffs_cfg->partition_label);
+    } else {
+        spiffs->partition_label = NULL;
+    }
+
+    if (spiffs_cfg->max_files < SPIFFS_DEFAULT_MAX_FILES) {
+        spiffs->max_files = SPIFFS_DEFAULT_MAX_FILES;
+    } else {
+        spiffs->max_files = spiffs_cfg->max_files;
+    }
+
+    spiffs->format_if_mount_failed = spiffs_cfg->format_if_mount_failed;
+
+    AUDIO_MEM_CHECK(TAG, spiffs->root, {
+        audio_free(spiffs);
+        audio_free(periph);
+        return NULL;
+    });
+
+    esp_periph_set_data(periph, spiffs);
+    esp_periph_set_function(periph, _spiffs_init, _spiffs_run, _spiffs_destroy);
+    return periph;
+}
+
+bool periph_spiffs_is_mounted(esp_periph_handle_t periph)
+{
+    VALIDATE_SPIFFS(periph, ESP_FAIL);
+    periph_spiffs_t *spiffs = esp_periph_get_data(periph);
+    return spiffs->is_mounted;
+}
diff --git a/components/esp_peripherals/periph_touch.c b/components/esp_peripherals/periph_touch.c
index d6904d4f..a67e572e 100644
--- a/components/esp_peripherals/periph_touch.c
+++ b/components/esp_peripherals/periph_touch.c
@@ -1,124 +1,124 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "esp_log.h"
-#include "periph_touch.h"
-#include "touch.h"
-#include "esp_peripherals.h"
-#include "audio_mem.h"
-
-static const char *TAG = "PERIPH_TOUCH";
-
-#define VALIDATE_TOUCH(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_TOUCH)) { \
-    ESP_LOGE(TAG, "Invalid TOUCH periph, at line %d", __LINE__);\
-    return ret;\
-}
-
-typedef struct periph_touch {
-    esp_touch_handle_t touch;
-    int touch_mask;
-    int long_tap_time_ms;
-    int tap_threshold_percent;
-    touch_result_t result;
-} periph_touch_t;
-
-static void touch_send_event(esp_periph_handle_t self, int event_id, int mask)
-{
-    int touch_num = 0;
-    while (mask) {
-        if (mask & 0x01) {
-            esp_periph_send_event(self, event_id, (void *)touch_num, 0);
-        }
-        mask >>= 1;
-        touch_num ++;
-    }
-}
-
-static esp_err_t _touch_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    periph_touch_t *periph_touch = esp_periph_get_data(self);
-    touch_send_event(self, PERIPH_TOUCH_TAP, periph_touch->result.tap_mask);
-    touch_send_event(self, PERIPH_TOUCH_RELEASE, periph_touch->result.release_mask);
-    touch_send_event(self, PERIPH_TOUCH_LONG_TAP, periph_touch->result.long_tap_mask);
-    touch_send_event(self, PERIPH_TOUCH_LONG_RELEASE, periph_touch->result.long_release_mask);
-    return ESP_OK;
-}
-
-static void touch_timer_handler(xTimerHandle tmr)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
-
-    periph_touch_t *periph_touch = esp_periph_get_data(periph);
-    if (esp_touch_read(periph_touch->touch, &periph_touch->result)) {
-        ESP_LOGD(TAG, "Touch event, tap %x, release_mask: %x, long_tap_mask: %x, long_tap_mask: %x",
-                 periph_touch->result.tap_mask, periph_touch->result.release_mask,
-                 periph_touch->result.long_tap_mask, periph_touch->result.long_release_mask);
-        esp_periph_send_cmd(periph, 0, NULL, 0);
-    }
-}
-
-static esp_err_t _touch_init(esp_periph_handle_t self)
-{
-    VALIDATE_TOUCH(self, ESP_FAIL);
-    periph_touch_t *periph_touch = esp_periph_get_data(self);
-
-    touch_config_t touch_config = {
-        .touch_mask = periph_touch->touch_mask,
-        .long_tap_time_ms = periph_touch->long_tap_time_ms,
-        .tap_threshold_percent = periph_touch->tap_threshold_percent,
-    };
-    periph_touch->touch = esp_touch_init(&touch_config);
-
-    esp_periph_start_timer(self, 150 / portTICK_PERIOD_MS, touch_timer_handler);
-    ESP_LOGW(TAG, "_touch_init");
-    return ESP_OK;
-}
-
-static esp_err_t _touch_destroy(esp_periph_handle_t self)
-{
-    periph_touch_t *periph_touch = esp_periph_get_data(self);
-    esp_periph_stop_timer(self);
-    esp_touch_destroy(periph_touch->touch);
-    audio_free(periph_touch);
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_touch_init(periph_touch_cfg_t *config)
-{
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_TOUCH, "periph_touch");
-    AUDIO_MEM_CHECK(TAG, periph, return NULL);
-    periph_touch_t *periph_touch = audio_calloc(1, sizeof(periph_touch_t));
-    AUDIO_MEM_CHECK(TAG, periph_touch, {
-        audio_free(periph);
-        return NULL;
-    });
-    periph_touch->touch_mask = config->touch_mask;
-    periph_touch->long_tap_time_ms = config->long_tap_time_ms;
-    periph_touch->tap_threshold_percent = config->tap_threshold_percent;
-
-    esp_periph_set_data(periph, periph_touch);
-    esp_periph_set_function(periph, _touch_init, _touch_run, _touch_destroy);
-
-    return periph;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "esp_log.h"
+#include "periph_touch.h"
+#include "touch.h"
+#include "esp_peripherals.h"
+#include "audio_mem.h"
+
+static const char *TAG = "PERIPH_TOUCH";
+
+#define VALIDATE_TOUCH(periph, ret) if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_TOUCH)) { \
+    ESP_LOGE(TAG, "Invalid TOUCH periph, at line %d", __LINE__);\
+    return ret;\
+}
+
+typedef struct periph_touch {
+    esp_touch_handle_t touch;
+    int touch_mask;
+    int long_tap_time_ms;
+    int tap_threshold_percent;
+    touch_result_t result;
+} periph_touch_t;
+
+static void touch_send_event(esp_periph_handle_t self, int event_id, int mask)
+{
+    int touch_num = 0;
+    while (mask) {
+        if (mask & 0x01) {
+            esp_periph_send_event(self, event_id, (void *)touch_num, 0);
+        }
+        mask >>= 1;
+        touch_num ++;
+    }
+}
+
+static esp_err_t _touch_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    periph_touch_t *periph_touch = esp_periph_get_data(self);
+    touch_send_event(self, PERIPH_TOUCH_TAP, periph_touch->result.tap_mask);
+    touch_send_event(self, PERIPH_TOUCH_RELEASE, periph_touch->result.release_mask);
+    touch_send_event(self, PERIPH_TOUCH_LONG_TAP, periph_touch->result.long_tap_mask);
+    touch_send_event(self, PERIPH_TOUCH_LONG_RELEASE, periph_touch->result.long_release_mask);
+    return ESP_OK;
+}
+
+static void touch_timer_handler(TimerHandle_t tmr)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t) pvTimerGetTimerID(tmr);
+
+    periph_touch_t *periph_touch = esp_periph_get_data(periph);
+    if (esp_touch_read(periph_touch->touch, &periph_touch->result)) {
+        ESP_LOGD(TAG, "Touch event, tap %x, release_mask: %x, long_tap_mask: %x, long_tap_mask: %x",
+                 periph_touch->result.tap_mask, periph_touch->result.release_mask,
+                 periph_touch->result.long_tap_mask, periph_touch->result.long_release_mask);
+        esp_periph_send_cmd(periph, 0, NULL, 0);
+    }
+}
+
+static esp_err_t _touch_init(esp_periph_handle_t self)
+{
+    VALIDATE_TOUCH(self, ESP_FAIL);
+    periph_touch_t *periph_touch = esp_periph_get_data(self);
+
+    touch_config_t touch_config = {
+        .touch_mask = periph_touch->touch_mask,
+        .long_tap_time_ms = periph_touch->long_tap_time_ms,
+        .tap_threshold_percent = periph_touch->tap_threshold_percent,
+    };
+    periph_touch->touch = esp_touch_init(&touch_config);
+
+    esp_periph_start_timer(self, 150 / portTICK_PERIOD_MS, touch_timer_handler);
+    ESP_LOGW(TAG, "_touch_init");
+    return ESP_OK;
+}
+
+static esp_err_t _touch_destroy(esp_periph_handle_t self)
+{
+    periph_touch_t *periph_touch = esp_periph_get_data(self);
+    esp_periph_stop_timer(self);
+    esp_touch_destroy(periph_touch->touch);
+    audio_free(periph_touch);
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_touch_init(periph_touch_cfg_t *config)
+{
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_TOUCH, "periph_touch");
+    AUDIO_MEM_CHECK(TAG, periph, return NULL);
+    periph_touch_t *periph_touch = audio_calloc(1, sizeof(periph_touch_t));
+    AUDIO_MEM_CHECK(TAG, periph_touch, {
+        audio_free(periph);
+        return NULL;
+    });
+    periph_touch->touch_mask = config->touch_mask;
+    periph_touch->long_tap_time_ms = config->long_tap_time_ms;
+    periph_touch->tap_threshold_percent = config->tap_threshold_percent;
+
+    esp_periph_set_data(periph, periph_touch);
+    esp_periph_set_function(periph, _touch_init, _touch_run, _touch_destroy);
+
+    return periph;
+}
diff --git a/components/esp_peripherals/periph_wifi.c b/components/esp_peripherals/periph_wifi.c
index c11cfd98..9f83e2ee 100644
--- a/components/esp_peripherals/periph_wifi.c
+++ b/components/esp_peripherals/periph_wifi.c
@@ -1,522 +1,522 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "esp_wpa2.h"
-#include "esp_event.h"
-#include "esp_log.h"
-#include "esp_smartconfig.h"
-#include "esp_wifi.h"
-
-#include "esp_peripherals.h"
-#include "periph_wifi.h"
-#include "wifibleconfig.h"
-#include "audio_mem.h"
-
-#include "audio_idf_version.h"
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
-#include "nvs_flash.h"
-#include "esp_netif.h"
-#include "esp_wifi_netif.h"
-static esp_netif_t *sta = NULL;
-#endif
-
-static const char *TAG = "PERIPH_WIFI";
-
-#define VALIDATE_WIFI(periph, ret)                                  \
-    if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_WIFI)) { \
-        ESP_LOGE(TAG, "Invalid WIFI periph, at line %d", __LINE__); \
-        return ret;                                                 \
-    }
-
-#define DEFAULT_RECONNECT_TIMEOUT_MS (1000)
-
-/* Constants that aren't configurable in menuconfig */
-#define EAP_PEAP 1
-#define EAP_TTLS 2
-
-typedef struct periph_wifi *periph_wifi_handle_t;
-
-struct periph_wifi {
-    periph_wifi_state_t wifi_state;
-    bool disable_auto_reconnect;
-    bool is_open;
-    uint8_t max_recon_time;
-    wifi_config_t wifi_config;
-    EventGroupHandle_t state_event;
-    int reconnect_timeout_ms;
-    periph_wifi_config_mode_t config_mode;
-    periph_wpa2_enterprise_cfg_t *wpa2_e_cfg;
-};
-
-static const int CONNECTED_BIT = BIT0;
-static const int DISCONNECTED_BIT = BIT1;
-static const int SMARTCONFIG_DONE_BIT = BIT2;
-static const int SMARTCONFIG_ERROR_BIT = BIT3;
-
-static esp_periph_handle_t g_periph = NULL;
-
-esp_err_t periph_wifi_wait_for_connected(esp_periph_handle_t periph, TickType_t tick_to_wait)
-{
-    VALIDATE_WIFI(periph, ESP_FAIL);
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    EventBits_t connected_bit = xEventGroupWaitBits(periph_wifi->state_event, CONNECTED_BIT, false, true, tick_to_wait);
-    if (connected_bit & CONNECTED_BIT) {
-        return ESP_OK;
-    }
-#if defined(CONFIG_BT_BLE_BLUFI_ENABLE)
-    if (periph_wifi->config_mode == WIFI_CONFIG_BLUEFI) {
-        ble_config_stop();
-    }
-#endif
-    return ESP_FAIL;
-}
-
-periph_wifi_state_t periph_wifi_is_connected(esp_periph_handle_t periph)
-{
-    VALIDATE_WIFI(periph, false);
-    periph_wifi_handle_t wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    return wifi->wifi_state;
-}
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-static void _wifi_smartconfig_event_callback(void *arg, esp_event_base_t event_base,
-        int32_t event_id, void *event_data)
-{
-    wifi_config_t sta_conf;
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(g_periph);
-    switch (event_id) {
-        case SC_EVENT_SCAN_DONE:
-            ESP_LOGD(TAG, "SC_EVENT_SCAN_DONE");
-            break;
-
-        case SC_EVENT_FOUND_CHANNEL:
-            ESP_LOGD(TAG, "SC_EVENT_FOUND_CHANNEL");
-            break;
-
-        case SC_EVENT_GOT_SSID_PSWD:
-            ESP_LOGE(TAG, "SC_EVENT_GOT_SSID_PSWD");
-            smartconfig_event_got_ssid_pswd_t *evt = (smartconfig_event_got_ssid_pswd_t *)event_data;
-            memcpy(periph_wifi->wifi_config.sta.ssid, evt->ssid, sizeof(periph_wifi->wifi_config.sta.ssid));
-            memcpy(periph_wifi->wifi_config.sta.password, evt->password, sizeof(periph_wifi->wifi_config.sta.password));
-            periph_wifi->wifi_config.sta.bssid_set = evt->bssid_set;
-            if (periph_wifi->wifi_config.sta.bssid_set == true) {
-                memcpy(periph_wifi->wifi_config.sta.bssid, evt->bssid, sizeof(periph_wifi->wifi_config.sta.bssid));
-            }
-            ESP_LOGE(TAG, "SSID=%s, PASS=%s", periph_wifi->wifi_config.sta.ssid, periph_wifi->wifi_config.sta.password);
-
-            esp_wifi_disconnect();
-
-            if (esp_wifi_set_config(WIFI_IF_STA, &sta_conf) != ESP_OK) {
-                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
-                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
-            }
-            if (esp_wifi_connect() != ESP_OK) {
-                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
-                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
-                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
-                break;
-            }
-            break;
-
-        case SC_EVENT_SEND_ACK_DONE:
-            ESP_LOGE(TAG, "SC_EVENT_SEND_ACK_DONE");
-
-            periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_DONE;
-            esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_DONE, NULL, 0);
-            xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_DONE_BIT);
-            esp_smartconfig_stop();
-            break;
-    }
-}
-#else
-static void _wifi_smartconfig_event_callback(smartconfig_status_t status, void *pdata)
-{
-    wifi_config_t sta_conf;
-    smartconfig_type_t *type;
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(g_periph);
-    switch (status) {
-        case SC_STATUS_WAIT:
-            ESP_LOGD(TAG, "SC_STATUS_WAIT");
-            break;
-
-        case SC_STATUS_FIND_CHANNEL:
-            ESP_LOGD(TAG, "SC_STATUS_FIND_CHANNEL");
-            break;
-
-        case SC_STATUS_GETTING_SSID_PSWD:
-            type = pdata;
-            ESP_LOGD(TAG, "SC_STATUS_GETTING_SSID_PSWD, SC_TYPE=%d", (int)*type);
-            break;
-
-        case SC_STATUS_LINK:
-            ESP_LOGE(TAG, "SC_STATUS_LINK");
-            memset(&periph_wifi->wifi_config, 0x00, sizeof(periph_wifi->wifi_config));
-            memcpy(&periph_wifi->wifi_config.sta, pdata, sizeof(wifi_sta_config_t));
-            ESP_LOGE(TAG, "SSID=%s, PASS=%s", periph_wifi->wifi_config.sta.ssid, periph_wifi->wifi_config.sta.password);
-            esp_wifi_disconnect();
-
-            if (esp_wifi_set_config(WIFI_IF_STA, &periph_wifi->wifi_config) != ESP_OK) {
-                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
-                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
-            }
-            if (esp_wifi_connect() != ESP_OK) {
-                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
-                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
-                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
-                break;
-            }
-            break;
-
-        case SC_STATUS_LINK_OVER:
-            ESP_LOGE(TAG, "SC_STATUS_LINK_OVER");
-
-            if (pdata != NULL) {
-                char phone_ip[4] = { 0 };
-                memcpy(phone_ip, (const void *)pdata, 4);
-                ESP_LOGD(TAG, "Phone ip: %d.%d.%d.%d", phone_ip[0], phone_ip[1], phone_ip[2], phone_ip[3]);
-                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_DONE;
-                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_DONE, NULL, 0);
-                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_DONE_BIT);
-            } else {
-                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
-                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
-                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
-            }
-            esp_smartconfig_stop();
-            break;
-    }
-}
-#endif
-
-esp_err_t periph_wifi_wait_for_disconnected(esp_periph_handle_t periph, TickType_t tick_to_wait)
-{
-    VALIDATE_WIFI(periph, ESP_FAIL);
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    EventBits_t disconnected_bit = xEventGroupWaitBits(periph_wifi->state_event, DISCONNECTED_BIT, false, true, tick_to_wait);
-    if (disconnected_bit & DISCONNECTED_BIT) {
-        return ESP_OK;
-    }
-    return ESP_FAIL;
-}
-
-esp_err_t periph_wifi_config_start(esp_periph_handle_t periph, periph_wifi_config_mode_t mode)
-{
-    VALIDATE_WIFI(periph, ESP_FAIL);
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    esp_err_t err = ESP_OK;
-    periph_wifi->disable_auto_reconnect = true;
-    periph_wifi->config_mode = mode;
-    esp_wifi_disconnect();
-
-    if (periph_wifi_wait_for_disconnected(periph, portMAX_DELAY) != ESP_OK) {
-        return ESP_FAIL;
-    }
-    periph_wifi->wifi_state = PERIPH_WIFI_SETTING;
-    if (mode >= WIFI_CONFIG_ESPTOUCH && mode <= WIFI_CONFIG_ESPTOUCH_AIRKISS) {
-        err = ESP_OK;  // 0;
-        // esp_wifi_start();
-        err |= esp_smartconfig_set_type(mode);
-        err |= esp_smartconfig_fast_mode(true);
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-        smartconfig_start_config_t cfg = SMARTCONFIG_START_CONFIG_DEFAULT();
-        err |= esp_smartconfig_start(&cfg);
-        esp_event_handler_register(SC_EVENT, ESP_EVENT_ANY_ID, &_wifi_smartconfig_event_callback, NULL);
-#else
-        err |= esp_smartconfig_start(_wifi_smartconfig_event_callback, 0);
-#endif
-        xEventGroupClearBits(periph_wifi->state_event, SMARTCONFIG_DONE_BIT);
-        xEventGroupClearBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
-
-    } else if (mode == WIFI_CONFIG_WPS) {
-        // todo : add wps
-        return ESP_OK;
-    } else if (mode == WIFI_CONFIG_BLUEFI) {
-#if defined(CONFIG_BT_BLE_BLUFI_ENABLE)
-        ble_config_start(periph);
-#endif
-        return ESP_OK;
-    }
-
-    return err;
-}
-
-esp_err_t periph_wifi_config_wait_done(esp_periph_handle_t periph, TickType_t tick_to_wait)
-{
-    VALIDATE_WIFI(periph, ESP_FAIL);
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    EventBits_t wificonfig_bit = xEventGroupWaitBits(periph_wifi->state_event,
-                                 SMARTCONFIG_DONE_BIT | SMARTCONFIG_ERROR_BIT, false, false, tick_to_wait);
-
-    if (wificonfig_bit & SMARTCONFIG_DONE_BIT) {
-        return ESP_OK;
-    }
-    if (wificonfig_bit & SMARTCONFIG_ERROR_BIT) {
-        return ESP_FAIL;
-    }
-    esp_smartconfig_stop();
-    return ESP_FAIL;
-}
-
-static void wifi_reconnect_timer(xTimerHandle tmr)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t)pvTimerGetTimerID(tmr);
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    esp_periph_stop_timer(periph);
-    if (periph_wifi->disable_auto_reconnect != true) {
-        esp_wifi_connect();
-    }
-}
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-static void _wifi_event_callback(void *arg, esp_event_base_t event_base,
-                                 int32_t event_id, void *event_data)
-{
-    esp_periph_handle_t self = (esp_periph_handle_t)arg;
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
-    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
-        esp_wifi_connect();
-    }  else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
-        ip_event_got_ip_t *event = (ip_event_got_ip_t *) event_data;
-        ESP_LOGI(TAG, "Got ip:" IPSTR, IP2STR(&event->ip_info.ip));
-        periph_wifi->wifi_state = PERIPH_WIFI_CONNECTED;
-        xEventGroupClearBits(periph_wifi->state_event, DISCONNECTED_BIT);
-        esp_periph_send_event(self, PERIPH_WIFI_CONNECTED, NULL, 0);
-        xEventGroupSetBits(periph_wifi->state_event, CONNECTED_BIT);
-        wifi_config_t w_config;
-        memset(&w_config, 0x00, sizeof(wifi_config_t));
-        esp_wifi_get_config(WIFI_IF_STA, &w_config);
-        memcpy(&periph_wifi->wifi_config.sta.ssid, (char *)w_config.sta.ssid, sizeof(periph_wifi->wifi_config.sta.ssid));
-    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
-        wifi_event_sta_disconnected_t *event = (wifi_event_sta_disconnected_t *) event_data;
-        if (event->reason == WIFI_REASON_ROAMING) {
-            ESP_LOGI(TAG, "Wi-Fi Station Roaming");
-            return;
-        }
-        periph_wifi->wifi_state = PERIPH_WIFI_DISCONNECTED;
-        xEventGroupClearBits(periph_wifi->state_event, CONNECTED_BIT);
-        xEventGroupSetBits(periph_wifi->state_event, DISCONNECTED_BIT);
-        esp_periph_send_event(self, PERIPH_WIFI_DISCONNECTED, NULL, 0);
-
-        ESP_LOGW(TAG, "Wi-Fi disconnected from SSID %s, auto-reconnect %s, reconnect after %d ms",
-                 periph_wifi->wifi_config.sta.ssid,
-                 periph_wifi->disable_auto_reconnect == 0 ? "enabled" : "disabled",
-                 periph_wifi->reconnect_timeout_ms);
-        if (periph_wifi->disable_auto_reconnect) {
-            return;
-        }
-        esp_periph_start_timer(self, periph_wifi->reconnect_timeout_ms / portTICK_RATE_MS, wifi_reconnect_timer);
-
-    } else {
-        ESP_LOGW(TAG, "WiFi Event cb, Unhandle event_base:%s, event_id:%d", event_base, (int)event_id);
-    }
-}
-#else
-static esp_err_t _wifi_event_callback(void *ctx, system_event_t *event)
-{
-    esp_periph_handle_t self = (esp_periph_handle_t)ctx;
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
-    switch (event->event_id) {
-        case SYSTEM_EVENT_STA_START:
-            periph_wifi->wifi_state = PERIPH_WIFI_CONNECTING;
-            esp_wifi_connect();
-            break;
-
-        case SYSTEM_EVENT_STA_CONNECTED:
-            break;
-        case SYSTEM_EVENT_STA_GOT_IP:
-            periph_wifi->wifi_state = PERIPH_WIFI_CONNECTED;
-            xEventGroupClearBits(periph_wifi->state_event, DISCONNECTED_BIT);
-            esp_periph_send_event(self, PERIPH_WIFI_CONNECTED, NULL, 0);
-            xEventGroupSetBits(periph_wifi->state_event, CONNECTED_BIT);
-            wifi_config_t w_config;
-            memset(&w_config, 0x00, sizeof(wifi_config_t));
-            esp_wifi_get_config(WIFI_IF_STA, &w_config);
-            memcpy(&periph_wifi->wifi_config.sta.ssid, (char *)w_config.sta.ssid, sizeof(periph_wifi->wifi_config.sta.ssid));
-            break;
-        case SYSTEM_EVENT_STA_DISCONNECTED:
-            periph_wifi->wifi_state = PERIPH_WIFI_DISCONNECTED;
-            xEventGroupClearBits(periph_wifi->state_event, CONNECTED_BIT);
-            xEventGroupSetBits(periph_wifi->state_event, DISCONNECTED_BIT);
-            esp_periph_send_event(self, PERIPH_WIFI_DISCONNECTED, NULL, 0);
-
-            ESP_LOGW(TAG, "Wi-Fi disconnected from SSID %s, auto-reconnect %s, reconnect after %d ms",
-                     periph_wifi->wifi_config.sta.ssid,
-                     periph_wifi->disable_auto_reconnect == 0 ? "enabled" : "disabled",
-                     periph_wifi->reconnect_timeout_ms);
-            if (periph_wifi->disable_auto_reconnect) {
-                break;
-            }
-            esp_periph_start_timer(self, periph_wifi->reconnect_timeout_ms / portTICK_RATE_MS, wifi_reconnect_timer);
-            break;
-        default:
-            break;
-    }
-    return ESP_OK;
-}
-#endif
-
-static esp_err_t _wifi_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
-{
-    esp_periph_send_event(self, msg->cmd, NULL, 0);
-    return ESP_OK;
-}
-
-esp_err_t esp_wifi_set_listen_interval(esp_periph_handle_t periph, int interval)
-{
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
-    if (periph_wifi->wifi_config.sta.listen_interval != interval) {
-        periph_wifi->wifi_config.sta.listen_interval = interval;
-    } else {
-        ESP_LOGW(TAG, "Wifi listen interval %d is already set", interval);
-    }
-    return ESP_OK;
-}
-
-static esp_err_t _wifi_init(esp_periph_handle_t self)
-{
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
-
-    if (periph_wifi->is_open) {
-        ESP_LOGE(TAG, "Wifi has initialized");
-        return ESP_FAIL;
-    }
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-    ESP_ERROR_CHECK(esp_event_loop_create_default());
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
-    sta = esp_netif_create_default_wifi_sta();
-#elif (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 1, 0))
-    esp_netif_create_default_wifi_sta();
-#endif
-    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &_wifi_event_callback, self));
-    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &_wifi_event_callback, self));
-#else
-#include "esp_event_loop.h"
-    if (esp_event_loop_get_queue() == NULL) {
-        ESP_ERROR_CHECK(esp_event_loop_init(_wifi_event_callback, self));
-    } else {
-        esp_event_loop_set_cb(_wifi_event_callback, self);
-    }
-#endif
-
-    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
-    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
-    ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
-    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
-    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &periph_wifi->wifi_config));
-    ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_MIN_MODEM));
-
-#ifdef CONFIG_ESP_WIFI_ENABLED
-    if (periph_wifi->wpa2_e_cfg->diasble_wpa2_e) {
-        unsigned int ca_pem_bytes = periph_wifi->wpa2_e_cfg->ca_pem_end - periph_wifi->wpa2_e_cfg->ca_pem_start;
-        unsigned int client_crt_bytes = periph_wifi->wpa2_e_cfg->wpa2_e_cert_end - periph_wifi->wpa2_e_cfg->wpa2_e_cert_start;
-        unsigned int client_key_bytes = periph_wifi->wpa2_e_cfg->wpa2_e_key_end - periph_wifi->wpa2_e_cfg->wpa2_e_key_start;
-
-        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_ca_cert((const unsigned char *)periph_wifi->wpa2_e_cfg->ca_pem_start, ca_pem_bytes));
-        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_cert_key((const unsigned char *)periph_wifi->wpa2_e_cfg->wpa2_e_cert_start, client_crt_bytes, \
-                        (const unsigned char *)periph_wifi->wpa2_e_cfg->wpa2_e_key_start, client_key_bytes, NULL, 0));
-        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_identity((uint8_t *)periph_wifi->wpa2_e_cfg->eap_id, strlen(periph_wifi->wpa2_e_cfg->eap_id)));
-        if (periph_wifi->wpa2_e_cfg->eap_method == EAP_PEAP || periph_wifi->wpa2_e_cfg->eap_method == EAP_TTLS) {
-            ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_username((uint8_t *)periph_wifi->wpa2_e_cfg->eap_username, strlen(periph_wifi->wpa2_e_cfg->eap_username)));
-            ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_password((uint8_t *)periph_wifi->wpa2_e_cfg->eap_password, strlen(periph_wifi->wpa2_e_cfg->eap_password)));
-        }
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
-        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_enable());
-#else
-        esp_wpa2_config_t wpa2_config = WPA2_CONFIG_INIT_DEFAULT();
-        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_enable(&wpa2_config));
-#endif
-    }
-#endif
-
-    ESP_ERROR_CHECK(esp_wifi_start());
-    periph_wifi->is_open = true;
-    periph_wifi->wifi_state = PERIPH_WIFI_DISCONNECTED;
-    xEventGroupClearBits(periph_wifi->state_event, CONNECTED_BIT);
-    xEventGroupSetBits(periph_wifi->state_event, DISCONNECTED_BIT);
-    return ESP_OK;
-}
-
-static esp_err_t _wifi_destroy(esp_periph_handle_t self)
-{
-    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
-    esp_periph_stop_timer(self);
-    periph_wifi->disable_auto_reconnect = true;
-    esp_wifi_disconnect();
-    periph_wifi_wait_for_disconnected(self, portMAX_DELAY);
-    esp_wifi_stop();
-    esp_wifi_deinit();
-
-    vEventGroupDelete(periph_wifi->state_event);
-    if (periph_wifi->wpa2_e_cfg != NULL) {
-        audio_free(periph_wifi->wpa2_e_cfg);
-        periph_wifi->wpa2_e_cfg = NULL;
-    }
-    audio_free(periph_wifi);
-    g_periph = NULL;
-
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
-    esp_event_loop_delete_default();
-    esp_netif_destroy_default_wifi(sta);
-#endif
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_wifi_init(periph_wifi_cfg_t *config)
-{
-    esp_periph_handle_t periph = NULL;
-    periph_wifi_handle_t periph_wifi = NULL;
-    bool _success = ((periph = esp_periph_create(PERIPH_ID_WIFI, "periph_wifi"))
-                     && (periph_wifi = audio_calloc(1, sizeof(struct periph_wifi)))
-                     && (periph_wifi->state_event = xEventGroupCreate()));
-
-    AUDIO_MEM_CHECK(TAG, _success, goto _periph_wifi_init_failed);
-
-    periph_wifi->reconnect_timeout_ms = config->reconnect_timeout_ms;
-    if (periph_wifi->reconnect_timeout_ms == 0) {
-        periph_wifi->reconnect_timeout_ms = DEFAULT_RECONNECT_TIMEOUT_MS;
-    }
-    periph_wifi->disable_auto_reconnect = config->disable_auto_reconnect;
-
-    periph_wifi->wpa2_e_cfg = audio_malloc(sizeof(periph_wpa2_enterprise_cfg_t));
-    AUDIO_NULL_CHECK(TAG, periph_wifi->wpa2_e_cfg, {
-        audio_free(periph);
-        goto _periph_wifi_init_failed;
-    });
-    memcpy(periph_wifi->wpa2_e_cfg, &config->wpa2_e_cfg, sizeof(periph_wpa2_enterprise_cfg_t));
-    memcpy(&periph_wifi->wifi_config, &config->wifi_config, sizeof(wifi_config_t));
-
-    esp_periph_set_data(periph, periph_wifi);
-    esp_periph_set_function(periph, _wifi_init, _wifi_run, _wifi_destroy);
-    g_periph = periph;
-    return periph;
-
-_periph_wifi_init_failed:
-    if (periph_wifi) {
-        vEventGroupDelete(periph_wifi->state_event);
-        audio_free(periph_wifi);
-    }
-    return NULL;
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "esp_wpa2.h"
+#include "esp_event.h"
+#include "esp_log.h"
+#include "esp_smartconfig.h"
+#include "esp_wifi.h"
+
+#include "esp_peripherals.h"
+#include "periph_wifi.h"
+#include "wifibleconfig.h"
+#include "audio_mem.h"
+
+#include "audio_idf_version.h"
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
+#include "nvs_flash.h"
+#include "esp_netif.h"
+#include "esp_wifi_netif.h"
+static esp_netif_t *sta = NULL;
+#endif
+
+static const char *TAG = "PERIPH_WIFI";
+
+#define VALIDATE_WIFI(periph, ret)                                  \
+    if (!(periph && esp_periph_get_id(periph) == PERIPH_ID_WIFI)) { \
+        ESP_LOGE(TAG, "Invalid WIFI periph, at line %d", __LINE__); \
+        return ret;                                                 \
+    }
+
+#define DEFAULT_RECONNECT_TIMEOUT_MS (1000)
+
+/* Constants that aren't configurable in menuconfig */
+#define EAP_PEAP 1
+#define EAP_TTLS 2
+
+typedef struct periph_wifi *periph_wifi_handle_t;
+
+struct periph_wifi {
+    periph_wifi_state_t wifi_state;
+    bool disable_auto_reconnect;
+    bool is_open;
+    uint8_t max_recon_time;
+    wifi_config_t wifi_config;
+    EventGroupHandle_t state_event;
+    int reconnect_timeout_ms;
+    periph_wifi_config_mode_t config_mode;
+    periph_wpa2_enterprise_cfg_t *wpa2_e_cfg;
+};
+
+static const int CONNECTED_BIT = BIT0;
+static const int DISCONNECTED_BIT = BIT1;
+static const int SMARTCONFIG_DONE_BIT = BIT2;
+static const int SMARTCONFIG_ERROR_BIT = BIT3;
+
+static esp_periph_handle_t g_periph = NULL;
+
+esp_err_t periph_wifi_wait_for_connected(esp_periph_handle_t periph, TickType_t tick_to_wait)
+{
+    VALIDATE_WIFI(periph, ESP_FAIL);
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    EventBits_t connected_bit = xEventGroupWaitBits(periph_wifi->state_event, CONNECTED_BIT, false, true, tick_to_wait);
+    if (connected_bit & CONNECTED_BIT) {
+        return ESP_OK;
+    }
+#if defined(CONFIG_BT_BLE_BLUFI_ENABLE)
+    if (periph_wifi->config_mode == WIFI_CONFIG_BLUEFI) {
+        ble_config_stop();
+    }
+#endif
+    return ESP_FAIL;
+}
+
+periph_wifi_state_t periph_wifi_is_connected(esp_periph_handle_t periph)
+{
+    VALIDATE_WIFI(periph, false);
+    periph_wifi_handle_t wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    return wifi->wifi_state;
+}
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+static void _wifi_smartconfig_event_callback(void *arg, esp_event_base_t event_base,
+        int32_t event_id, void *event_data)
+{
+    wifi_config_t sta_conf;
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(g_periph);
+    switch (event_id) {
+        case SC_EVENT_SCAN_DONE:
+            ESP_LOGD(TAG, "SC_EVENT_SCAN_DONE");
+            break;
+
+        case SC_EVENT_FOUND_CHANNEL:
+            ESP_LOGD(TAG, "SC_EVENT_FOUND_CHANNEL");
+            break;
+
+        case SC_EVENT_GOT_SSID_PSWD:
+            ESP_LOGE(TAG, "SC_EVENT_GOT_SSID_PSWD");
+            smartconfig_event_got_ssid_pswd_t *evt = (smartconfig_event_got_ssid_pswd_t *)event_data;
+            memcpy(periph_wifi->wifi_config.sta.ssid, evt->ssid, sizeof(periph_wifi->wifi_config.sta.ssid));
+            memcpy(periph_wifi->wifi_config.sta.password, evt->password, sizeof(periph_wifi->wifi_config.sta.password));
+            periph_wifi->wifi_config.sta.bssid_set = evt->bssid_set;
+            if (periph_wifi->wifi_config.sta.bssid_set == true) {
+                memcpy(periph_wifi->wifi_config.sta.bssid, evt->bssid, sizeof(periph_wifi->wifi_config.sta.bssid));
+            }
+            ESP_LOGE(TAG, "SSID=%s, PASS=%s", periph_wifi->wifi_config.sta.ssid, periph_wifi->wifi_config.sta.password);
+
+            esp_wifi_disconnect();
+
+            if (esp_wifi_set_config(WIFI_IF_STA, &sta_conf) != ESP_OK) {
+                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
+                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
+            }
+            if (esp_wifi_connect() != ESP_OK) {
+                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
+                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
+                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
+                break;
+            }
+            break;
+
+        case SC_EVENT_SEND_ACK_DONE:
+            ESP_LOGE(TAG, "SC_EVENT_SEND_ACK_DONE");
+
+            periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_DONE;
+            esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_DONE, NULL, 0);
+            xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_DONE_BIT);
+            esp_smartconfig_stop();
+            break;
+    }
+}
+#else
+static void _wifi_smartconfig_event_callback(smartconfig_status_t status, void *pdata)
+{
+    wifi_config_t sta_conf;
+    smartconfig_type_t *type;
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(g_periph);
+    switch (status) {
+        case SC_STATUS_WAIT:
+            ESP_LOGD(TAG, "SC_STATUS_WAIT");
+            break;
+
+        case SC_STATUS_FIND_CHANNEL:
+            ESP_LOGD(TAG, "SC_STATUS_FIND_CHANNEL");
+            break;
+
+        case SC_STATUS_GETTING_SSID_PSWD:
+            type = pdata;
+            ESP_LOGD(TAG, "SC_STATUS_GETTING_SSID_PSWD, SC_TYPE=%d", (int)*type);
+            break;
+
+        case SC_STATUS_LINK:
+            ESP_LOGE(TAG, "SC_STATUS_LINK");
+            memset(&periph_wifi->wifi_config, 0x00, sizeof(periph_wifi->wifi_config));
+            memcpy(&periph_wifi->wifi_config.sta, pdata, sizeof(wifi_sta_config_t));
+            ESP_LOGE(TAG, "SSID=%s, PASS=%s", periph_wifi->wifi_config.sta.ssid, periph_wifi->wifi_config.sta.password);
+            esp_wifi_disconnect();
+
+            if (esp_wifi_set_config(WIFI_IF_STA, &periph_wifi->wifi_config) != ESP_OK) {
+                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
+                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
+            }
+            if (esp_wifi_connect() != ESP_OK) {
+                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
+                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
+                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
+                break;
+            }
+            break;
+
+        case SC_STATUS_LINK_OVER:
+            ESP_LOGE(TAG, "SC_STATUS_LINK_OVER");
+
+            if (pdata != NULL) {
+                char phone_ip[4] = { 0 };
+                memcpy(phone_ip, (const void *)pdata, 4);
+                ESP_LOGD(TAG, "Phone ip: %d.%d.%d.%d", phone_ip[0], phone_ip[1], phone_ip[2], phone_ip[3]);
+                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_DONE;
+                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_DONE, NULL, 0);
+                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_DONE_BIT);
+            } else {
+                periph_wifi->wifi_state = PERIPH_WIFI_CONFIG_ERROR;
+                esp_periph_send_event(g_periph, PERIPH_WIFI_CONFIG_ERROR, NULL, 0);
+                xEventGroupSetBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
+            }
+            esp_smartconfig_stop();
+            break;
+    }
+}
+#endif
+
+esp_err_t periph_wifi_wait_for_disconnected(esp_periph_handle_t periph, TickType_t tick_to_wait)
+{
+    VALIDATE_WIFI(periph, ESP_FAIL);
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    EventBits_t disconnected_bit = xEventGroupWaitBits(periph_wifi->state_event, DISCONNECTED_BIT, false, true, tick_to_wait);
+    if (disconnected_bit & DISCONNECTED_BIT) {
+        return ESP_OK;
+    }
+    return ESP_FAIL;
+}
+
+esp_err_t periph_wifi_config_start(esp_periph_handle_t periph, periph_wifi_config_mode_t mode)
+{
+    VALIDATE_WIFI(periph, ESP_FAIL);
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    esp_err_t err = ESP_OK;
+    periph_wifi->disable_auto_reconnect = true;
+    periph_wifi->config_mode = mode;
+    esp_wifi_disconnect();
+
+    if (periph_wifi_wait_for_disconnected(periph, portMAX_DELAY) != ESP_OK) {
+        return ESP_FAIL;
+    }
+    periph_wifi->wifi_state = PERIPH_WIFI_SETTING;
+    if (mode >= WIFI_CONFIG_ESPTOUCH && mode <= WIFI_CONFIG_ESPTOUCH_AIRKISS) {
+        err = ESP_OK;  // 0;
+        // esp_wifi_start();
+        err |= esp_smartconfig_set_type(mode);
+        err |= esp_smartconfig_fast_mode(true);
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+        smartconfig_start_config_t cfg = SMARTCONFIG_START_CONFIG_DEFAULT();
+        err |= esp_smartconfig_start(&cfg);
+        esp_event_handler_register(SC_EVENT, ESP_EVENT_ANY_ID, &_wifi_smartconfig_event_callback, NULL);
+#else
+        err |= esp_smartconfig_start(_wifi_smartconfig_event_callback, 0);
+#endif
+        xEventGroupClearBits(periph_wifi->state_event, SMARTCONFIG_DONE_BIT);
+        xEventGroupClearBits(periph_wifi->state_event, SMARTCONFIG_ERROR_BIT);
+
+    } else if (mode == WIFI_CONFIG_WPS) {
+        // todo : add wps
+        return ESP_OK;
+    } else if (mode == WIFI_CONFIG_BLUEFI) {
+#if defined(CONFIG_BT_BLE_BLUFI_ENABLE)
+        ble_config_start(periph);
+#endif
+        return ESP_OK;
+    }
+
+    return err;
+}
+
+esp_err_t periph_wifi_config_wait_done(esp_periph_handle_t periph, TickType_t tick_to_wait)
+{
+    VALIDATE_WIFI(periph, ESP_FAIL);
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    EventBits_t wificonfig_bit = xEventGroupWaitBits(periph_wifi->state_event,
+                                 SMARTCONFIG_DONE_BIT | SMARTCONFIG_ERROR_BIT, false, false, tick_to_wait);
+
+    if (wificonfig_bit & SMARTCONFIG_DONE_BIT) {
+        return ESP_OK;
+    }
+    if (wificonfig_bit & SMARTCONFIG_ERROR_BIT) {
+        return ESP_FAIL;
+    }
+    esp_smartconfig_stop();
+    return ESP_FAIL;
+}
+
+static void wifi_reconnect_timer(TimerHandle_t tmr)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t)pvTimerGetTimerID(tmr);
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    esp_periph_stop_timer(periph);
+    if (periph_wifi->disable_auto_reconnect != true) {
+        esp_wifi_connect();
+    }
+}
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+static void _wifi_event_callback(void *arg, esp_event_base_t event_base,
+                                 int32_t event_id, void *event_data)
+{
+    esp_periph_handle_t self = (esp_periph_handle_t)arg;
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
+    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
+        esp_wifi_connect();
+    }  else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
+        ip_event_got_ip_t *event = (ip_event_got_ip_t *) event_data;
+        ESP_LOGI(TAG, "Got ip:" IPSTR, IP2STR(&event->ip_info.ip));
+        periph_wifi->wifi_state = PERIPH_WIFI_CONNECTED;
+        xEventGroupClearBits(periph_wifi->state_event, DISCONNECTED_BIT);
+        esp_periph_send_event(self, PERIPH_WIFI_CONNECTED, NULL, 0);
+        xEventGroupSetBits(periph_wifi->state_event, CONNECTED_BIT);
+        wifi_config_t w_config;
+        memset(&w_config, 0x00, sizeof(wifi_config_t));
+        esp_wifi_get_config(WIFI_IF_STA, &w_config);
+        memcpy(&periph_wifi->wifi_config.sta.ssid, (char *)w_config.sta.ssid, sizeof(periph_wifi->wifi_config.sta.ssid));
+    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
+        wifi_event_sta_disconnected_t *event = (wifi_event_sta_disconnected_t *) event_data;
+        if (event->reason == WIFI_REASON_ROAMING) {
+            ESP_LOGI(TAG, "Wi-Fi Station Roaming");
+            return;
+        }
+        periph_wifi->wifi_state = PERIPH_WIFI_DISCONNECTED;
+        xEventGroupClearBits(periph_wifi->state_event, CONNECTED_BIT);
+        xEventGroupSetBits(periph_wifi->state_event, DISCONNECTED_BIT);
+        esp_periph_send_event(self, PERIPH_WIFI_DISCONNECTED, NULL, 0);
+
+        ESP_LOGW(TAG, "Wi-Fi disconnected from SSID %s, auto-reconnect %s, reconnect after %d ms",
+                 periph_wifi->wifi_config.sta.ssid,
+                 periph_wifi->disable_auto_reconnect == 0 ? "enabled" : "disabled",
+                 periph_wifi->reconnect_timeout_ms);
+        if (periph_wifi->disable_auto_reconnect) {
+            return;
+        }
+        esp_periph_start_timer(self, periph_wifi->reconnect_timeout_ms / portTICK_PERIOD_MS, wifi_reconnect_timer);
+
+    } else {
+        ESP_LOGW(TAG, "WiFi Event cb, Unhandle event_base:%s, event_id:%d", event_base, (int)event_id);
+    }
+}
+#else
+static esp_err_t _wifi_event_callback(void *ctx, system_event_t *event)
+{
+    esp_periph_handle_t self = (esp_periph_handle_t)ctx;
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
+    switch (event->event_id) {
+        case SYSTEM_EVENT_STA_START:
+            periph_wifi->wifi_state = PERIPH_WIFI_CONNECTING;
+            esp_wifi_connect();
+            break;
+
+        case SYSTEM_EVENT_STA_CONNECTED:
+            break;
+        case SYSTEM_EVENT_STA_GOT_IP:
+            periph_wifi->wifi_state = PERIPH_WIFI_CONNECTED;
+            xEventGroupClearBits(periph_wifi->state_event, DISCONNECTED_BIT);
+            esp_periph_send_event(self, PERIPH_WIFI_CONNECTED, NULL, 0);
+            xEventGroupSetBits(periph_wifi->state_event, CONNECTED_BIT);
+            wifi_config_t w_config;
+            memset(&w_config, 0x00, sizeof(wifi_config_t));
+            esp_wifi_get_config(WIFI_IF_STA, &w_config);
+            memcpy(&periph_wifi->wifi_config.sta.ssid, (char *)w_config.sta.ssid, sizeof(periph_wifi->wifi_config.sta.ssid));
+            break;
+        case SYSTEM_EVENT_STA_DISCONNECTED:
+            periph_wifi->wifi_state = PERIPH_WIFI_DISCONNECTED;
+            xEventGroupClearBits(periph_wifi->state_event, CONNECTED_BIT);
+            xEventGroupSetBits(periph_wifi->state_event, DISCONNECTED_BIT);
+            esp_periph_send_event(self, PERIPH_WIFI_DISCONNECTED, NULL, 0);
+
+            ESP_LOGW(TAG, "Wi-Fi disconnected from SSID %s, auto-reconnect %s, reconnect after %d ms",
+                     periph_wifi->wifi_config.sta.ssid,
+                     periph_wifi->disable_auto_reconnect == 0 ? "enabled" : "disabled",
+                     periph_wifi->reconnect_timeout_ms);
+            if (periph_wifi->disable_auto_reconnect) {
+                break;
+            }
+            esp_periph_start_timer(self, periph_wifi->reconnect_timeout_ms / portTICK_RATE_MS, wifi_reconnect_timer);
+            break;
+        default:
+            break;
+    }
+    return ESP_OK;
+}
+#endif
+
+static esp_err_t _wifi_run(esp_periph_handle_t self, audio_event_iface_msg_t *msg)
+{
+    esp_periph_send_event(self, msg->cmd, NULL, 0);
+    return ESP_OK;
+}
+
+esp_err_t esp_wifi_set_listen_interval(esp_periph_handle_t periph, int interval)
+{
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(periph);
+    if (periph_wifi->wifi_config.sta.listen_interval != interval) {
+        periph_wifi->wifi_config.sta.listen_interval = interval;
+    } else {
+        ESP_LOGW(TAG, "Wifi listen interval %d is already set", interval);
+    }
+    return ESP_OK;
+}
+
+static esp_err_t _wifi_init(esp_periph_handle_t self)
+{
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
+
+    if (periph_wifi->is_open) {
+        ESP_LOGE(TAG, "Wifi has initialized");
+        return ESP_FAIL;
+    }
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+    ESP_ERROR_CHECK(esp_event_loop_create_default());
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
+    sta = esp_netif_create_default_wifi_sta();
+#elif (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 1, 0))
+    esp_netif_create_default_wifi_sta();
+#endif
+    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &_wifi_event_callback, self));
+    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &_wifi_event_callback, self));
+#else
+#include "esp_event_loop.h"
+    if (esp_event_loop_get_queue() == NULL) {
+        ESP_ERROR_CHECK(esp_event_loop_init(_wifi_event_callback, self));
+    } else {
+        esp_event_loop_set_cb(_wifi_event_callback, self);
+    }
+#endif
+
+    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
+    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
+    ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
+    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
+    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &periph_wifi->wifi_config));
+    ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_MIN_MODEM));
+
+#ifdef CONFIG_ESP_WIFI_ENABLED
+    if (periph_wifi->wpa2_e_cfg->diasble_wpa2_e) {
+        unsigned int ca_pem_bytes = periph_wifi->wpa2_e_cfg->ca_pem_end - periph_wifi->wpa2_e_cfg->ca_pem_start;
+        unsigned int client_crt_bytes = periph_wifi->wpa2_e_cfg->wpa2_e_cert_end - periph_wifi->wpa2_e_cfg->wpa2_e_cert_start;
+        unsigned int client_key_bytes = periph_wifi->wpa2_e_cfg->wpa2_e_key_end - periph_wifi->wpa2_e_cfg->wpa2_e_key_start;
+
+        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_ca_cert((const unsigned char *)periph_wifi->wpa2_e_cfg->ca_pem_start, ca_pem_bytes));
+        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_cert_key((const unsigned char *)periph_wifi->wpa2_e_cfg->wpa2_e_cert_start, client_crt_bytes, \
+                        (const unsigned char *)periph_wifi->wpa2_e_cfg->wpa2_e_key_start, client_key_bytes, NULL, 0));
+        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_identity((uint8_t *)periph_wifi->wpa2_e_cfg->eap_id, strlen(periph_wifi->wpa2_e_cfg->eap_id)));
+        if (periph_wifi->wpa2_e_cfg->eap_method == EAP_PEAP || periph_wifi->wpa2_e_cfg->eap_method == EAP_TTLS) {
+            ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_username((uint8_t *)periph_wifi->wpa2_e_cfg->eap_username, strlen(periph_wifi->wpa2_e_cfg->eap_username)));
+            ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_set_password((uint8_t *)periph_wifi->wpa2_e_cfg->eap_password, strlen(periph_wifi->wpa2_e_cfg->eap_password)));
+        }
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0))
+        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_enable());
+#else
+        esp_wpa2_config_t wpa2_config = WPA2_CONFIG_INIT_DEFAULT();
+        ESP_ERROR_CHECK(esp_wifi_sta_wpa2_ent_enable(&wpa2_config));
+#endif
+    }
+#endif
+
+    ESP_ERROR_CHECK(esp_wifi_start());
+    periph_wifi->is_open = true;
+    periph_wifi->wifi_state = PERIPH_WIFI_DISCONNECTED;
+    xEventGroupClearBits(periph_wifi->state_event, CONNECTED_BIT);
+    xEventGroupSetBits(periph_wifi->state_event, DISCONNECTED_BIT);
+    return ESP_OK;
+}
+
+static esp_err_t _wifi_destroy(esp_periph_handle_t self)
+{
+    periph_wifi_handle_t periph_wifi = (periph_wifi_handle_t)esp_periph_get_data(self);
+    esp_periph_stop_timer(self);
+    periph_wifi->disable_auto_reconnect = true;
+    esp_wifi_disconnect();
+    periph_wifi_wait_for_disconnected(self, portMAX_DELAY);
+    esp_wifi_stop();
+    esp_wifi_deinit();
+
+    vEventGroupDelete(periph_wifi->state_event);
+    if (periph_wifi->wpa2_e_cfg != NULL) {
+        audio_free(periph_wifi->wpa2_e_cfg);
+        periph_wifi->wpa2_e_cfg = NULL;
+    }
+    audio_free(periph_wifi);
+    g_periph = NULL;
+
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0))
+    esp_event_loop_delete_default();
+    esp_netif_destroy_default_wifi(sta);
+#endif
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_wifi_init(periph_wifi_cfg_t *config)
+{
+    esp_periph_handle_t periph = NULL;
+    periph_wifi_handle_t periph_wifi = NULL;
+    bool _success = ((periph = esp_periph_create(PERIPH_ID_WIFI, "periph_wifi"))
+                     && (periph_wifi = audio_calloc(1, sizeof(struct periph_wifi)))
+                     && (periph_wifi->state_event = xEventGroupCreate()));
+
+    AUDIO_MEM_CHECK(TAG, _success, goto _periph_wifi_init_failed);
+
+    periph_wifi->reconnect_timeout_ms = config->reconnect_timeout_ms;
+    if (periph_wifi->reconnect_timeout_ms == 0) {
+        periph_wifi->reconnect_timeout_ms = DEFAULT_RECONNECT_TIMEOUT_MS;
+    }
+    periph_wifi->disable_auto_reconnect = config->disable_auto_reconnect;
+
+    periph_wifi->wpa2_e_cfg = audio_malloc(sizeof(periph_wpa2_enterprise_cfg_t));
+    AUDIO_NULL_CHECK(TAG, periph_wifi->wpa2_e_cfg, {
+        audio_free(periph);
+        goto _periph_wifi_init_failed;
+    });
+    memcpy(periph_wifi->wpa2_e_cfg, &config->wpa2_e_cfg, sizeof(periph_wpa2_enterprise_cfg_t));
+    memcpy(&periph_wifi->wifi_config, &config->wifi_config, sizeof(wifi_config_t));
+
+    esp_periph_set_data(periph, periph_wifi);
+    esp_periph_set_function(periph, _wifi_init, _wifi_run, _wifi_destroy);
+    g_periph = periph;
+    return periph;
+
+_periph_wifi_init_failed:
+    if (periph_wifi) {
+        vEventGroupDelete(periph_wifi->state_event);
+        audio_free(periph_wifi);
+    }
+    return NULL;
+}
diff --git a/components/esp_peripherals/periph_ws2812.c b/components/esp_peripherals/periph_ws2812.c
old mode 100755
new mode 100644
index 2008c503..5676c39f
--- a/components/esp_peripherals/periph_ws2812.c
+++ b/components/esp_peripherals/periph_ws2812.c
@@ -1,431 +1,431 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <string.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "freertos/task.h"
-#include <driver/rmt.h>
-#include "esp_log.h"
-#include "audio_mem.h"
-#include "audio_sys.h"
-#include "periph_ws2812.h"
-#include "esp_peripherals.h"
-#include "soc/dport_access.h"
-#if !defined CONFIG_IDF_TARGET_ESP32C3 && !defined CONFIG_IDF_TARGET_ESP32C6 && !defined CONFIG_IDF_TARGET_ESP32P4
-#include "soc/dport_reg.h"
-#endif
-#include "driver/rmt.h"
-#include "audio_idf_version.h"
-
-static const char *TAG = "PERIPH_WS2812";
-
-#define DIVIDER                 4
-#define DURATION                12.5
-#define RMTCHANNEL              0
-#define MAX_PULSES              32
-#define PULSE_T0H               ((uint32_t)( 350 / (DURATION*DIVIDER)) & 0x00007FFF )
-#define PULSE_T1H               ((uint32_t)( 900 / (DURATION*DIVIDER)) & 0x00007FFF )
-#define PULSE_T0L               ((uint32_t)( 900 / (DURATION*DIVIDER)) & 0x00007FFF )
-#define PULSE_T1L               ((uint32_t)( 350 / (DURATION*DIVIDER)) & 0x00007FFF )
-#define PULSE_TRS               ( 50000 / (DURATION*DIVIDER))
-#define PULSE_BIT0              (((uint32_t)PULSE_T0L<<16) + (((uint32_t)1)<<15) + (PULSE_T0H))
-#define PULSE_BIT1              (((uint32_t)PULSE_T1L<<16) + (((uint32_t)1)<<15) + (PULSE_T1H))
-
-#define FADE_STEP               30
-#define INTERVAL_TIME_MS        10
-
-typedef union {
-    struct __attribute__ ((packed)) {
-        uint8_t r, g, b;
-    };
-    uint32_t num;
-} rgb_value;
-
-typedef struct {
-    periph_rgb_value         color;
-    periph_ws2812_mode_t     mode;
-    uint32_t                 time_on_ms;
-    uint32_t                 time_off_ms;
-    long long                tick;
-    uint32_t                 loop;
-    bool                     is_on;
-    bool                     is_set;
-} periph_ws2812_state_t;
-
-typedef struct {
-    uint32_t                 pos;
-    uint32_t                 half;
-    uint8_t                  *buffer;
-} periph_ws2812_process_t;
-
-typedef struct periph_ws2812 {
-    periph_rgb_value          *color;
-    uint32_t                  led_num;
-    TimerHandle_t             timer;
-    xSemaphoreHandle          sem;
-    intr_handle_t             rmt_intr_handle;
-    periph_ws2812_state_t     *state;
-    periph_ws2812_process_t   process;
-} periph_ws2812_t;
-
-static esp_err_t ws2812_init_rmt_channel(int rmt_channel, int gpio_num)
-{
-    rmt_config_t rmt_tx;
-    rmt_tx.channel = rmt_channel;
-    rmt_tx.gpio_num = gpio_num;
-    rmt_tx.mem_block_num = 1;
-    rmt_tx.clk_div = DIVIDER;
-    rmt_tx.tx_config.loop_en = false;
-    rmt_tx.tx_config.carrier_level = 1;
-    rmt_tx.tx_config.carrier_en = 0;
-    rmt_tx.tx_config.idle_level = 0;
-    rmt_tx.tx_config.idle_output_en = true;
-    rmt_tx.rmt_mode = RMT_MODE_TX;
-    rmt_config(&rmt_tx);
-    rmt_driver_install(rmt_tx.channel, 0, 0);
-
-    rmt_set_tx_thr_intr_en(RMTCHANNEL, true, MAX_PULSES);
-    rmt_set_mem_block_num(RMTCHANNEL, 1);
-    rmt_set_mem_pd(RMTCHANNEL, false);
-    rmt_set_tx_loop_mode(RMTCHANNEL, false);
-#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
-    rmt_set_source_clk(RMTCHANNEL, RMT_BASECLK_DEFAULT);
-#else
-    rmt_set_source_clk(RMTCHANNEL, RMT_BASECLK_APB);
-#endif
-#if (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 3, 0))
-    rmt_set_intr_enable_mask(BIT(0) | BIT(24));
-#endif
-    return ESP_OK;
-}
-
-static esp_err_t ws2812_data_copy(periph_ws2812_t *ws)
-{
-    unsigned int i, j, len, bit;
-
-    len = ws->led_num * 3;;// - ws->process.pos;
-    rmt_item32_t *rmt_data  = malloc(sizeof(rmt_item32_t) * len * 8);
-
-    for (i = 0; i < len; i++) {
-        bit = ws->process.buffer[i];
-        for (j = 0; j < 8; j++, bit <<= 1) {
-            if ((bit >> 7) & 0x01) {
-                rmt_data[j + i * 8].val = PULSE_BIT1;
-            } else {
-                rmt_data[j + i * 8].val = PULSE_BIT0;
-            }
-        }
-        if (i + ws->process.pos == ws->led_num * 3 - 1) {
-            rmt_data[7 + i * 8].duration1 = PULSE_TRS;
-        }
-    }
-    
-    rmt_write_items(RMTCHANNEL, rmt_data, len * 8, portMAX_DELAY);
-    
-    if (rmt_data) {
-        free(rmt_data);
-        rmt_data = NULL;
-    }
-    return ESP_OK;
-}
-
-static void rmt_handle_tx_end(rmt_channel_t channel, void *arg)
-{
-    portBASE_TYPE taskAwoken = 0;
-    periph_ws2812_t *ws = (periph_ws2812_t *)(arg);
-    xSemaphoreGiveFromISR(ws->sem, &taskAwoken);
-}
-
-static esp_err_t ws2812_set_colors(periph_ws2812_t *ws)
-{
-    AUDIO_NULL_CHECK(TAG, ws, return ESP_FAIL);
-
-    ws->process.buffer = audio_malloc(ws->led_num * 3 * sizeof(uint8_t));
-    AUDIO_NULL_CHECK(TAG, ws->process.buffer, return ESP_FAIL);
-
-    for (int i = 0; i < ws->led_num; i++) {
-        rgb_value rgb = {
-            .num = ws->color[i]
-        };
-        ws->process.buffer[0 + i * 3] = rgb.g;
-        ws->process.buffer[1 + i * 3] = rgb.r;
-        ws->process.buffer[2 + i * 3] = rgb.b;
-    }
-    ws->process.pos = 0;
-    ws->process.half = 0;
-
-    ws2812_data_copy(ws);
-    xSemaphoreTake(ws->sem, portMAX_DELAY);
-    if (ws->process.buffer) {
-        audio_free(ws->process.buffer);
-        ws->process.buffer = NULL;
-    }
-
-    return ESP_OK;
-}
-
-static void ws2812_timer_handler(TimerHandle_t tmr)
-{
-    esp_periph_handle_t periph = (esp_periph_handle_t)pvTimerGetTimerID(tmr);
-    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
-    periph_ws2812_state_t *st = periph_ws2812->state;
-    for ( int i = 0; i < periph_ws2812->led_num; i++ ) {
-        switch (st[i].mode) {
-            case PERIPH_WS2812_ONE:
-                if (st[i].is_on) {
-                    periph_ws2812->color[i] = st[i].color;
-                    ws2812_set_colors(periph_ws2812);
-                    st[i].is_on = false;
-                    st[i].loop = 0;
-                }
-                break;
-
-            case PERIPH_WS2812_BLINK:
-                if (st[i].is_set == false) {
-                    continue;
-                }
-                if (st[i].loop == 0) {
-                    periph_ws2812->color[i] = LED2812_COLOR_BLACK;
-                    ws2812_set_colors(periph_ws2812);
-                    st[i].is_set = false;
-                }
-
-                if (st[i].is_on && audio_sys_get_time_ms() - st[i].tick > st[i].time_off_ms) {
-                    if (st[i].loop > 0) {
-                        st[i].loop--;
-                    } else {
-                        continue;
-                    }
-                    st[i].is_on = false;
-                    st[i].tick = audio_sys_get_time_ms();
-                    periph_ws2812->color[i] = st[i].color;
-                    ws2812_set_colors(periph_ws2812);
-                } else if (!st[i].is_on && audio_sys_get_time_ms() - st[i].tick > st[i].time_on_ms) {
-                    st[i].is_on = true;
-                    st[i].tick = audio_sys_get_time_ms();
-                    periph_ws2812->color[i] = LED2812_COLOR_BLACK;
-                    ws2812_set_colors(periph_ws2812);
-                }
-                break;
-
-            case PERIPH_WS2812_FADE:
-                if (st[i].is_set == false) {
-                    continue;
-                }
-                if (st[i].loop == 0) {
-                    periph_ws2812->color[i] = LED2812_COLOR_BLACK;
-                    ws2812_set_colors(periph_ws2812);
-                    st[i].is_set = false;
-                    continue;
-                }
-
-                if (st[i].is_on && (audio_sys_get_time_ms() - st[i].tick > ((st[i].time_on_ms / FADE_STEP)))) {
-                    st[i].tick = audio_sys_get_time_ms();
-                    rgb_value rgb = {
-                        .num = st[i].color
-                    };
-                    rgb_value rgb1 = {
-                        .num =  periph_ws2812->color[i]
-                    };
-                    rgb1.r -= (uint8_t)rgb.r / FADE_STEP;
-                    rgb1.g -= (uint8_t)rgb.g / FADE_STEP;
-                    rgb1.b -= (uint8_t)rgb.b / FADE_STEP;
-                    ws2812_set_colors(periph_ws2812);
-                    periph_ws2812->color[i] = rgb1.num;
-                    if ((rgb1.r <= (uint8_t)rgb.r / FADE_STEP)
-                        && (rgb1.g <= (uint8_t)rgb.g / FADE_STEP)
-                        && (rgb1.b <= (uint8_t)rgb.b / FADE_STEP)) {
-                        st[i].is_on = false;
-                        st[i].loop--;
-                    }
-                } else if ((st[i].is_on == false) && (audio_sys_get_time_ms() - st[i].tick > ((st[i].time_off_ms / FADE_STEP)))) {
-                    st[i].tick = audio_sys_get_time_ms();
-                    rgb_value rgb = {
-                        .num = st[i].color
-                    };
-                    rgb_value rgb1 = {
-                        .num =  periph_ws2812->color[i]
-                    };
-                    rgb1.r += (uint8_t)rgb.r / FADE_STEP;
-                    rgb1.g += (uint8_t)rgb.g / FADE_STEP;
-                    rgb1.b += (uint8_t)rgb.b / FADE_STEP;
-                    ws2812_set_colors(periph_ws2812);
-                    periph_ws2812->color[i] = rgb1.num;
-                    if ((((uint8_t)rgb.r - rgb1.r) <= (uint8_t)rgb.r / FADE_STEP)
-                        && (((uint8_t)rgb.g - rgb1.g) <= (uint8_t)rgb.g / FADE_STEP)
-                        && (((uint8_t)rgb.b - rgb1.b) <= (uint8_t)rgb.b / FADE_STEP))  {
-                        st[i].is_on = true;
-                    }
-                }
-                break;
-            default:
-                ESP_LOGW(TAG, "The ws2812 mode[%d] is invalid", st[i].mode);
-                break;
-        }
-    }
-
-}
-
-static esp_err_t _ws2812_run(esp_periph_handle_t periph, audio_event_iface_msg_t *msg)
-{
-    return ESP_OK;
-}
-
-static esp_err_t _ws2812_init(esp_periph_handle_t periph)
-{
-    return ESP_OK;
-}
-
-static esp_err_t _ws2812_destroy(esp_periph_handle_t periph)
-{
-    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
-    AUDIO_NULL_CHECK(TAG, periph_ws2812, return ESP_FAIL);
-
-    if (periph_ws2812) {
-        periph_ws2812_state_t *st = periph_ws2812->state;
-        for (int i = 0; i < periph_ws2812->led_num; i++) {
-            st[i].color = LED2812_COLOR_BLACK;
-            st[i].is_on = true;
-            st[i].mode = PERIPH_WS2812_ONE;
-        }
-        ws2812_set_colors(periph_ws2812);
-
-        if (periph_ws2812->color) {
-            audio_free(periph_ws2812->color);
-            periph_ws2812->color = NULL;
-        }
-
-        if (periph_ws2812->state) {
-            audio_free(periph_ws2812->state);
-            periph_ws2812->state = NULL;
-        }
-
-        esp_periph_stop_timer(periph);
-        rmt_tx_stop(RMTCHANNEL);
-        rmt_driver_uninstall(RMTCHANNEL);
-        vSemaphoreDelete(periph_ws2812->sem);
-
-        audio_free(periph_ws2812);
-        periph_ws2812 = NULL;
-    }
-
-    return ESP_OK;
-}
-
-esp_periph_handle_t periph_ws2812_init(periph_ws2812_cfg_t *config)
-{
-    AUDIO_NULL_CHECK(TAG, config, return NULL);
-
-    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_WS2812, "periph_ws2812");
-    periph_ws2812_t *periph_ws2812 = audio_calloc(1, sizeof(periph_ws2812_t));
-    AUDIO_NULL_CHECK(TAG, periph_ws2812, goto ws2812_init_err);
-
-    periph_ws2812->led_num = config->led_num;
-    periph_ws2812->timer = NULL;
-    periph_ws2812->sem = xSemaphoreCreateBinary();
-    periph_ws2812->rmt_intr_handle = NULL;
-
-    periph_ws2812->color = audio_malloc(sizeof(periph_rgb_value) * periph_ws2812->led_num);
-    AUDIO_NULL_CHECK(TAG, periph_ws2812->color, goto ws2812_init_err);
-
-    for (int i = 0; i < periph_ws2812->led_num; i++) {
-        periph_ws2812->color[i] = LED2812_COLOR_BLACK;
-    }
-
-    periph_ws2812->state = audio_malloc(sizeof(periph_ws2812_state_t) * (periph_ws2812->led_num));
-    AUDIO_NULL_CHECK(TAG, periph_ws2812->state, goto ws2812_init_err);
-
-    ws2812_init_rmt_channel(RMTCHANNEL, (gpio_num_t)config->gpio_num);
-    esp_periph_set_data(periph, periph_ws2812);
-    rmt_register_tx_end_callback(rmt_handle_tx_end, (void *)periph_ws2812);
-
-    esp_periph_set_function(periph, _ws2812_init, _ws2812_run, _ws2812_destroy);
-    ws2812_set_colors(periph_ws2812);
-    ESP_LOGD(TAG, "periph ws2812 init");
-    return periph;
-
-ws2812_init_err:
-    if (periph_ws2812->sem) {
-        vSemaphoreDelete(periph_ws2812->sem);
-        periph_ws2812->sem = NULL;
-    }
-    if (periph_ws2812->color) {
-        audio_free(periph_ws2812->color);
-        periph_ws2812->color = NULL;
-    }
-    if (periph_ws2812->state) {
-        audio_free(periph_ws2812->state);
-        periph_ws2812->state = NULL;
-    }
-    if (periph_ws2812) {
-        audio_free(periph_ws2812);
-        periph_ws2812 = NULL;
-    }
-    if (periph) {
-        audio_free(periph);
-    }
-    periph = NULL;
-    return periph;
-}
-
-esp_err_t periph_ws2812_control(esp_periph_handle_t periph, periph_ws2812_ctrl_cfg_t *control_cfg, void *ctx)
-{
-    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
-
-    AUDIO_NULL_CHECK(TAG, periph_ws2812, return ESP_FAIL);
-    AUDIO_NULL_CHECK(TAG, control_cfg, return ESP_FAIL);
-
-    for (int i = 0; i < periph_ws2812->led_num; i++) {
-        periph_ws2812->state[i].color = control_cfg[i].color;
-        periph_ws2812->color[i] = control_cfg[i].color;
-        periph_ws2812->state[i].time_on_ms = control_cfg[i].time_on_ms;
-        periph_ws2812->state[i].time_off_ms = control_cfg[i].time_off_ms;
-        periph_ws2812->state[i].tick = audio_sys_get_time_ms();
-        periph_ws2812->state[i].loop = control_cfg[i].loop;
-        periph_ws2812->state[i].is_on = true;
-        periph_ws2812->state[i].is_set = true;
-        periph_ws2812->state[i].mode = control_cfg[i].mode;
-    }
-
-    esp_periph_start_timer(periph, INTERVAL_TIME_MS / portTICK_RATE_MS, ws2812_timer_handler);
-
-    return ESP_OK;
-}
-
-esp_err_t periph_ws2812_stop(esp_periph_handle_t periph)
-{
-    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
-
-    AUDIO_NULL_CHECK(TAG, periph_ws2812, return ESP_FAIL);
-
-    periph_ws2812_state_t *st = periph_ws2812->state;
-    for (int i = 0; i < periph_ws2812->led_num; i++) {
-        st[i].color = LED2812_COLOR_BLACK;
-        st[i].is_on = true;
-        st[i].mode = PERIPH_WS2812_ONE;
-    }
-    ws2812_set_colors(periph_ws2812);
-    return ESP_OK;
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2020 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/task.h"
+#include <driver/rmt.h>
+#include "esp_log.h"
+#include "audio_mem.h"
+#include "audio_sys.h"
+#include "periph_ws2812.h"
+#include "esp_peripherals.h"
+#include "soc/dport_access.h"
+#if !defined CONFIG_IDF_TARGET_ESP32C3 && !defined CONFIG_IDF_TARGET_ESP32C6 && !defined CONFIG_IDF_TARGET_ESP32P4
+#include "soc/dport_reg.h"
+#endif
+#include "driver/rmt.h"
+#include "audio_idf_version.h"
+
+static const char *TAG = "PERIPH_WS2812";
+
+#define DIVIDER                 4
+#define DURATION                12.5
+#define RMTCHANNEL              0
+#define MAX_PULSES              32
+#define PULSE_T0H               ((uint32_t)( 350 / (DURATION*DIVIDER)) & 0x00007FFF )
+#define PULSE_T1H               ((uint32_t)( 900 / (DURATION*DIVIDER)) & 0x00007FFF )
+#define PULSE_T0L               ((uint32_t)( 900 / (DURATION*DIVIDER)) & 0x00007FFF )
+#define PULSE_T1L               ((uint32_t)( 350 / (DURATION*DIVIDER)) & 0x00007FFF )
+#define PULSE_TRS               ( 50000 / (DURATION*DIVIDER))
+#define PULSE_BIT0              (((uint32_t)PULSE_T0L<<16) + (((uint32_t)1)<<15) + (PULSE_T0H))
+#define PULSE_BIT1              (((uint32_t)PULSE_T1L<<16) + (((uint32_t)1)<<15) + (PULSE_T1H))
+
+#define FADE_STEP               30
+#define INTERVAL_TIME_MS        10
+
+typedef union {
+    struct __attribute__ ((packed)) {
+        uint8_t r, g, b;
+    };
+    uint32_t num;
+} rgb_value;
+
+typedef struct {
+    periph_rgb_value         color;
+    periph_ws2812_mode_t     mode;
+    uint32_t                 time_on_ms;
+    uint32_t                 time_off_ms;
+    long long                tick;
+    uint32_t                 loop;
+    bool                     is_on;
+    bool                     is_set;
+} periph_ws2812_state_t;
+
+typedef struct {
+    uint32_t                 pos;
+    uint32_t                 half;
+    uint8_t                  *buffer;
+} periph_ws2812_process_t;
+
+typedef struct periph_ws2812 {
+    periph_rgb_value          *color;
+    uint32_t                  led_num;
+    TimerHandle_t             timer;
+    SemaphoreHandle_t          sem;
+    intr_handle_t             rmt_intr_handle;
+    periph_ws2812_state_t     *state;
+    periph_ws2812_process_t   process;
+} periph_ws2812_t;
+
+static esp_err_t ws2812_init_rmt_channel(int rmt_channel, int gpio_num)
+{
+    rmt_config_t rmt_tx;
+    rmt_tx.channel = rmt_channel;
+    rmt_tx.gpio_num = gpio_num;
+    rmt_tx.mem_block_num = 1;
+    rmt_tx.clk_div = DIVIDER;
+    rmt_tx.tx_config.loop_en = false;
+    rmt_tx.tx_config.carrier_level = 1;
+    rmt_tx.tx_config.carrier_en = 0;
+    rmt_tx.tx_config.idle_level = 0;
+    rmt_tx.tx_config.idle_output_en = true;
+    rmt_tx.rmt_mode = RMT_MODE_TX;
+    rmt_config(&rmt_tx);
+    rmt_driver_install(rmt_tx.channel, 0, 0);
+
+    rmt_set_tx_thr_intr_en(RMTCHANNEL, true, MAX_PULSES);
+    rmt_set_mem_block_num(RMTCHANNEL, 1);
+    rmt_set_mem_pd(RMTCHANNEL, false);
+    rmt_set_tx_loop_mode(RMTCHANNEL, false);
+#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0))
+    rmt_set_source_clk(RMTCHANNEL, RMT_BASECLK_DEFAULT);
+#else
+    rmt_set_source_clk(RMTCHANNEL, RMT_BASECLK_APB);
+#endif
+#if (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 3, 0))
+    rmt_set_intr_enable_mask(BIT(0) | BIT(24));
+#endif
+    return ESP_OK;
+}
+
+static esp_err_t ws2812_data_copy(periph_ws2812_t *ws)
+{
+    unsigned int i, j, len, bit;
+
+    len = ws->led_num * 3;;// - ws->process.pos;
+    rmt_item32_t *rmt_data  = malloc(sizeof(rmt_item32_t) * len * 8);
+
+    for (i = 0; i < len; i++) {
+        bit = ws->process.buffer[i];
+        for (j = 0; j < 8; j++, bit <<= 1) {
+            if ((bit >> 7) & 0x01) {
+                rmt_data[j + i * 8].val = PULSE_BIT1;
+            } else {
+                rmt_data[j + i * 8].val = PULSE_BIT0;
+            }
+        }
+        if (i + ws->process.pos == ws->led_num * 3 - 1) {
+            rmt_data[7 + i * 8].duration1 = PULSE_TRS;
+        }
+    }
+    
+    rmt_write_items(RMTCHANNEL, rmt_data, len * 8, portMAX_DELAY);
+    
+    if (rmt_data) {
+        free(rmt_data);
+        rmt_data = NULL;
+    }
+    return ESP_OK;
+}
+
+static void rmt_handle_tx_end(rmt_channel_t channel, void *arg)
+{
+    portBASE_TYPE taskAwoken = 0;
+    periph_ws2812_t *ws = (periph_ws2812_t *)(arg);
+    xSemaphoreGiveFromISR(ws->sem, &taskAwoken);
+}
+
+static esp_err_t ws2812_set_colors(periph_ws2812_t *ws)
+{
+    AUDIO_NULL_CHECK(TAG, ws, return ESP_FAIL);
+
+    ws->process.buffer = audio_malloc(ws->led_num * 3 * sizeof(uint8_t));
+    AUDIO_NULL_CHECK(TAG, ws->process.buffer, return ESP_FAIL);
+
+    for (int i = 0; i < ws->led_num; i++) {
+        rgb_value rgb = {
+            .num = ws->color[i]
+        };
+        ws->process.buffer[0 + i * 3] = rgb.g;
+        ws->process.buffer[1 + i * 3] = rgb.r;
+        ws->process.buffer[2 + i * 3] = rgb.b;
+    }
+    ws->process.pos = 0;
+    ws->process.half = 0;
+
+    ws2812_data_copy(ws);
+    xSemaphoreTake(ws->sem, portMAX_DELAY);
+    if (ws->process.buffer) {
+        audio_free(ws->process.buffer);
+        ws->process.buffer = NULL;
+    }
+
+    return ESP_OK;
+}
+
+static void ws2812_timer_handler(TimerHandle_t tmr)
+{
+    esp_periph_handle_t periph = (esp_periph_handle_t)pvTimerGetTimerID(tmr);
+    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
+    periph_ws2812_state_t *st = periph_ws2812->state;
+    for ( int i = 0; i < periph_ws2812->led_num; i++ ) {
+        switch (st[i].mode) {
+            case PERIPH_WS2812_ONE:
+                if (st[i].is_on) {
+                    periph_ws2812->color[i] = st[i].color;
+                    ws2812_set_colors(periph_ws2812);
+                    st[i].is_on = false;
+                    st[i].loop = 0;
+                }
+                break;
+
+            case PERIPH_WS2812_BLINK:
+                if (st[i].is_set == false) {
+                    continue;
+                }
+                if (st[i].loop == 0) {
+                    periph_ws2812->color[i] = LED2812_COLOR_BLACK;
+                    ws2812_set_colors(periph_ws2812);
+                    st[i].is_set = false;
+                }
+
+                if (st[i].is_on && audio_sys_get_time_ms() - st[i].tick > st[i].time_off_ms) {
+                    if (st[i].loop > 0) {
+                        st[i].loop--;
+                    } else {
+                        continue;
+                    }
+                    st[i].is_on = false;
+                    st[i].tick = audio_sys_get_time_ms();
+                    periph_ws2812->color[i] = st[i].color;
+                    ws2812_set_colors(periph_ws2812);
+                } else if (!st[i].is_on && audio_sys_get_time_ms() - st[i].tick > st[i].time_on_ms) {
+                    st[i].is_on = true;
+                    st[i].tick = audio_sys_get_time_ms();
+                    periph_ws2812->color[i] = LED2812_COLOR_BLACK;
+                    ws2812_set_colors(periph_ws2812);
+                }
+                break;
+
+            case PERIPH_WS2812_FADE:
+                if (st[i].is_set == false) {
+                    continue;
+                }
+                if (st[i].loop == 0) {
+                    periph_ws2812->color[i] = LED2812_COLOR_BLACK;
+                    ws2812_set_colors(periph_ws2812);
+                    st[i].is_set = false;
+                    continue;
+                }
+
+                if (st[i].is_on && (audio_sys_get_time_ms() - st[i].tick > ((st[i].time_on_ms / FADE_STEP)))) {
+                    st[i].tick = audio_sys_get_time_ms();
+                    rgb_value rgb = {
+                        .num = st[i].color
+                    };
+                    rgb_value rgb1 = {
+                        .num =  periph_ws2812->color[i]
+                    };
+                    rgb1.r -= (uint8_t)rgb.r / FADE_STEP;
+                    rgb1.g -= (uint8_t)rgb.g / FADE_STEP;
+                    rgb1.b -= (uint8_t)rgb.b / FADE_STEP;
+                    ws2812_set_colors(periph_ws2812);
+                    periph_ws2812->color[i] = rgb1.num;
+                    if ((rgb1.r <= (uint8_t)rgb.r / FADE_STEP)
+                        && (rgb1.g <= (uint8_t)rgb.g / FADE_STEP)
+                        && (rgb1.b <= (uint8_t)rgb.b / FADE_STEP)) {
+                        st[i].is_on = false;
+                        st[i].loop--;
+                    }
+                } else if ((st[i].is_on == false) && (audio_sys_get_time_ms() - st[i].tick > ((st[i].time_off_ms / FADE_STEP)))) {
+                    st[i].tick = audio_sys_get_time_ms();
+                    rgb_value rgb = {
+                        .num = st[i].color
+                    };
+                    rgb_value rgb1 = {
+                        .num =  periph_ws2812->color[i]
+                    };
+                    rgb1.r += (uint8_t)rgb.r / FADE_STEP;
+                    rgb1.g += (uint8_t)rgb.g / FADE_STEP;
+                    rgb1.b += (uint8_t)rgb.b / FADE_STEP;
+                    ws2812_set_colors(periph_ws2812);
+                    periph_ws2812->color[i] = rgb1.num;
+                    if ((((uint8_t)rgb.r - rgb1.r) <= (uint8_t)rgb.r / FADE_STEP)
+                        && (((uint8_t)rgb.g - rgb1.g) <= (uint8_t)rgb.g / FADE_STEP)
+                        && (((uint8_t)rgb.b - rgb1.b) <= (uint8_t)rgb.b / FADE_STEP))  {
+                        st[i].is_on = true;
+                    }
+                }
+                break;
+            default:
+                ESP_LOGW(TAG, "The ws2812 mode[%d] is invalid", st[i].mode);
+                break;
+        }
+    }
+
+}
+
+static esp_err_t _ws2812_run(esp_periph_handle_t periph, audio_event_iface_msg_t *msg)
+{
+    return ESP_OK;
+}
+
+static esp_err_t _ws2812_init(esp_periph_handle_t periph)
+{
+    return ESP_OK;
+}
+
+static esp_err_t _ws2812_destroy(esp_periph_handle_t periph)
+{
+    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
+    AUDIO_NULL_CHECK(TAG, periph_ws2812, return ESP_FAIL);
+
+    if (periph_ws2812) {
+        periph_ws2812_state_t *st = periph_ws2812->state;
+        for (int i = 0; i < periph_ws2812->led_num; i++) {
+            st[i].color = LED2812_COLOR_BLACK;
+            st[i].is_on = true;
+            st[i].mode = PERIPH_WS2812_ONE;
+        }
+        ws2812_set_colors(periph_ws2812);
+
+        if (periph_ws2812->color) {
+            audio_free(periph_ws2812->color);
+            periph_ws2812->color = NULL;
+        }
+
+        if (periph_ws2812->state) {
+            audio_free(periph_ws2812->state);
+            periph_ws2812->state = NULL;
+        }
+
+        esp_periph_stop_timer(periph);
+        rmt_tx_stop(RMTCHANNEL);
+        rmt_driver_uninstall(RMTCHANNEL);
+        vSemaphoreDelete(periph_ws2812->sem);
+
+        audio_free(periph_ws2812);
+        periph_ws2812 = NULL;
+    }
+
+    return ESP_OK;
+}
+
+esp_periph_handle_t periph_ws2812_init(periph_ws2812_cfg_t *config)
+{
+    AUDIO_NULL_CHECK(TAG, config, return NULL);
+
+    esp_periph_handle_t periph = esp_periph_create(PERIPH_ID_WS2812, "periph_ws2812");
+    periph_ws2812_t *periph_ws2812 = audio_calloc(1, sizeof(periph_ws2812_t));
+    AUDIO_NULL_CHECK(TAG, periph_ws2812, goto ws2812_init_err);
+
+    periph_ws2812->led_num = config->led_num;
+    periph_ws2812->timer = NULL;
+    periph_ws2812->sem = xSemaphoreCreateBinary();
+    periph_ws2812->rmt_intr_handle = NULL;
+
+    periph_ws2812->color = audio_malloc(sizeof(periph_rgb_value) * periph_ws2812->led_num);
+    AUDIO_NULL_CHECK(TAG, periph_ws2812->color, goto ws2812_init_err);
+
+    for (int i = 0; i < periph_ws2812->led_num; i++) {
+        periph_ws2812->color[i] = LED2812_COLOR_BLACK;
+    }
+
+    periph_ws2812->state = audio_malloc(sizeof(periph_ws2812_state_t) * (periph_ws2812->led_num));
+    AUDIO_NULL_CHECK(TAG, periph_ws2812->state, goto ws2812_init_err);
+
+    ws2812_init_rmt_channel(RMTCHANNEL, (gpio_num_t)config->gpio_num);
+    esp_periph_set_data(periph, periph_ws2812);
+    rmt_register_tx_end_callback(rmt_handle_tx_end, (void *)periph_ws2812);
+
+    esp_periph_set_function(periph, _ws2812_init, _ws2812_run, _ws2812_destroy);
+    ws2812_set_colors(periph_ws2812);
+    ESP_LOGD(TAG, "periph ws2812 init");
+    return periph;
+
+ws2812_init_err:
+    if (periph_ws2812->sem) {
+        vSemaphoreDelete(periph_ws2812->sem);
+        periph_ws2812->sem = NULL;
+    }
+    if (periph_ws2812->color) {
+        audio_free(periph_ws2812->color);
+        periph_ws2812->color = NULL;
+    }
+    if (periph_ws2812->state) {
+        audio_free(periph_ws2812->state);
+        periph_ws2812->state = NULL;
+    }
+    if (periph_ws2812) {
+        audio_free(periph_ws2812);
+        periph_ws2812 = NULL;
+    }
+    if (periph) {
+        audio_free(periph);
+    }
+    periph = NULL;
+    return periph;
+}
+
+esp_err_t periph_ws2812_control(esp_periph_handle_t periph, periph_ws2812_ctrl_cfg_t *control_cfg, void *ctx)
+{
+    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
+
+    AUDIO_NULL_CHECK(TAG, periph_ws2812, return ESP_FAIL);
+    AUDIO_NULL_CHECK(TAG, control_cfg, return ESP_FAIL);
+
+    for (int i = 0; i < periph_ws2812->led_num; i++) {
+        periph_ws2812->state[i].color = control_cfg[i].color;
+        periph_ws2812->color[i] = control_cfg[i].color;
+        periph_ws2812->state[i].time_on_ms = control_cfg[i].time_on_ms;
+        periph_ws2812->state[i].time_off_ms = control_cfg[i].time_off_ms;
+        periph_ws2812->state[i].tick = audio_sys_get_time_ms();
+        periph_ws2812->state[i].loop = control_cfg[i].loop;
+        periph_ws2812->state[i].is_on = true;
+        periph_ws2812->state[i].is_set = true;
+        periph_ws2812->state[i].mode = control_cfg[i].mode;
+    }
+
+    esp_periph_start_timer(periph, INTERVAL_TIME_MS / portTICK_PERIOD_MS, ws2812_timer_handler);
+
+    return ESP_OK;
+}
+
+esp_err_t periph_ws2812_stop(esp_periph_handle_t periph)
+{
+    periph_ws2812_t *periph_ws2812 = esp_periph_get_data(periph);
+
+    AUDIO_NULL_CHECK(TAG, periph_ws2812, return ESP_FAIL);
+
+    periph_ws2812_state_t *st = periph_ws2812->state;
+    for (int i = 0; i < periph_ws2812->led_num; i++) {
+        st[i].color = LED2812_COLOR_BLACK;
+        st[i].is_on = true;
+        st[i].mode = PERIPH_WS2812_ONE;
+    }
+    ws2812_set_colors(periph_ws2812);
+    return ESP_OK;
 }
\ No newline at end of file
diff --git a/components/esp_peripherals/test/component.mk b/components/esp_peripherals/test/component.mk
index 5dd172bd..5f441ada 100644
--- a/components/esp_peripherals/test/component.mk
+++ b/components/esp_peripherals/test/component.mk
@@ -1,5 +1,5 @@
-#
-#Component Makefile
-#
-
-COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
+#
+#Component Makefile
+#
+
+COMPONENT_ADD_LDFLAGS = -Wl,--whole-archive -l$(COMPONENT_NAME) -Wl,--no-whole-archive
diff --git a/components/esp_peripherals/test/esp_peripherals_test.c b/components/esp_peripherals/test/esp_peripherals_test.c
index 83e2d6c9..5c01feee 100644
--- a/components/esp_peripherals/test/esp_peripherals_test.c
+++ b/components/esp_peripherals/test/esp_peripherals_test.c
@@ -1,716 +1,716 @@
-/*
- * ESPRESSIF MIT License
- *
- * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
- *
- * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
- * it is free of charge, to any person obtaining a copy of this software and associated
- * documentation files (the "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
- * to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-#include <string.h>
-#include <unistd.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "audio_event_iface.h"
-#include "esp_log.h"
-#include "esp_err.h"
-
-#include "unity.h"
-#include "nvs_flash.h"
-#include "tcpip_adapter.h"
-#include "audio_mem.h"
-#include "esp_peripherals.h"
-#include "periph_sdcard.h"
-#include "periph_button.h"
-#include "periph_touch.h"
-#include "periph_wifi.h"
-#include "periph_console.h"
-#include "periph_led.h"
-#include "periph_adc_button.h"
-#include "periph_gpio_isr.h"
-#include "periph_is31fl3216.h"
-#include "periph_spiffs.h"
-#include "periph_ws2812.h"
-#include "board.h"
-
-static const char *TAG = "ESP_PERIPH_TEST";
-
-#define TEST_PERIPHERALS_MEMORY_LEAK_TIMES  1000
-
-static void periph_adc_button_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    ESP_LOGI(TAG, "Register ADC button to peripherals");
-    periph_adc_button_cfg_t adc_btn_cfg = PERIPH_ADC_BUTTON_DEFAULT_CONFIG();
-    adc_arr_t adc_btn_tag = ADC_DEFAULT_ARR();
-    adc_btn_tag.total_steps = 6;
-    int btn_array[7] = {190, 600, 1000, 1375, 1775, 2195, 3100};
-    adc_btn_tag.adc_level_step = btn_array;
-    adc_btn_cfg.arr = &adc_btn_tag;
-    adc_btn_cfg.arr_size = 1;
-    esp_periph_handle_t adc_btn_handle = periph_adc_button_init(&adc_btn_cfg);
-    TEST_ASSERT_NOT_NULL(adc_btn_handle);
-    TEST_ASSERT_FALSE(esp_periph_start(set, adc_btn_handle));
-
-    ESP_LOGI(TAG, "Set up event listener");
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    ESP_LOGI(TAG, "Listening event from peripherals");
-    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    ESP_LOGI(TAG, "Test start, please press buttons on the board ... ");
-    while (1) {
-        audio_event_iface_msg_t msg;
-        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
-        ESP_LOGI(TAG, "action: %d, act id: %d", msg.cmd, (int)msg.data);
-        if ((int)msg.data == 0) {
-            ESP_LOGW(TAG, "press id 0, quit test");
-            break;
-        }
-    }
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-TEST_CASE("adc button test", "[peripherals]")
-{
-    periph_adc_button_test();
-}
-
-static void periph_gpio_button_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    ESP_LOGI(TAG, "Register gpio button to peripherals");
-    periph_button_cfg_t btn_cfg = {
-        .gpio_mask = (1ULL << get_input_rec_id()) | (1ULL << get_input_mode_id()), //REC BTN & MODE BTN
-    };
-    esp_periph_handle_t button_handle = periph_button_init(&btn_cfg);
-    TEST_ASSERT_NOT_NULL(button_handle);
-    TEST_ASSERT_FALSE(esp_periph_start(set, button_handle));
-
-    ESP_LOGI(TAG, "Set up event listener");
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    ESP_LOGI(TAG, "Listening event from peripherals");
-    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    ESP_LOGI(TAG, "Test start, please press buttons on the board ... ");
-    while (1) {
-        audio_event_iface_msg_t msg;
-        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
-        ESP_LOGI(TAG, "action: %d, act id: %d", msg.cmd, (int)msg.data);
-        if ((int)msg.data == get_input_mode_id()) {
-            ESP_LOGW(TAG, "press [mode] button, quit test");
-            break;
-        }
-    }
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-TEST_CASE("gpio button test", "[peripherals]")
-{
-    periph_gpio_button_test();
-}
-
-static esp_err_t play_func(esp_periph_handle_t periph, int argc, char *argv[])
-{
-    if (argc == 1) {
-        ESP_LOGI(TAG, "play music, url:%s", argv[0]);
-    } else if (argc == 0) {
-        ESP_LOGI(TAG, "play");
-    } else {
-        ESP_LOGE(TAG, "error input");
-    }
-    return ESP_OK;
-}
-
-static esp_err_t pause_func(esp_periph_handle_t periph, int argc, char *argv[])
-{
-    if (argc == 0) {
-        ESP_LOGI(TAG, "pause");
-    } else {
-        ESP_LOGE(TAG, "error input");
-    }
-    return ESP_OK;
-}
-
-static bool task_flag;
-
-static esp_err_t quit_func(esp_periph_handle_t periph, int argc, char *argv[])
-{
-    if (argc == 0) {
-        ESP_LOGI(TAG, "quit console");
-        task_flag = false;
-    } else {
-        ESP_LOGE(TAG, "error input");
-    }
-    return ESP_OK;
-}
-
-const periph_console_cmd_t cli_cmd[] = {
-    {
-        .cmd = "play",
-        .id  = 0,
-        .help = "play music",
-        .func = play_func,
-    },
-    {
-        .cmd = "pause",
-        .id = 1,
-        .help = "pause music",
-        .func = pause_func,
-    },
-    {
-        .cmd = "quit",
-        .id = 2,
-        .help = "quit command line",
-        .func = quit_func
-    }
-};
-
-static void periph_console_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    ESP_LOGI(TAG, "Register console to peripherals");
-    periph_console_cfg_t console_cfg = {
-        .command_num = sizeof(cli_cmd) / sizeof(periph_console_cmd_t),
-        .commands = cli_cmd,
-    };
-    esp_periph_handle_t console_handle = periph_console_init(&console_cfg);
-    TEST_ASSERT_NOT_NULL(console_handle);
-
-    task_flag = true;
-    ESP_LOGI(TAG, "Start console, please input ...");
-    TEST_ASSERT_FALSE(esp_periph_start(set, console_handle));
-
-    while (task_flag) {
-        vTaskDelay(10 / portTICK_RATE_MS);
-    }
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-TEST_CASE("console test", "[peripherals]")
-{
-    periph_console_test();
-}
-
-static void periph_gpio_isr_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    ESP_LOGI(TAG, "Register gpio isr to peripherals");
-    gpio_isr_info_t gpio_isr_info = {
-        .gpio_num = SDCARD_INTR_GPIO,
-        .type = GPIO_INTR_ANYEDGE
-    };
-    periph_gpio_isr_cfg_t gpio_isr_cfg = {
-        .info_size = 1,
-        .gpio_isr_info = &gpio_isr_info
-    };
-    esp_periph_handle_t gpio_isr_handle = periph_gpio_isr_init(&gpio_isr_cfg);
-    TEST_ASSERT_NOT_NULL(gpio_isr_handle);
-    TEST_ASSERT_FALSE(esp_periph_start(set, gpio_isr_handle));
-
-    ESP_LOGI(TAG, "Set up event listener");
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    ESP_LOGI(TAG, "Listening event from peripherals, please insert a sdcard to the board ...");
-    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
-
-        if ((int)msg.data == SDCARD_INTR_GPIO) {
-            ESP_LOGW(TAG, "Detect sdcard insertion, quit test");
-            break;
-        }
-    }
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-TEST_CASE("gpio isr test", "[peripherals]")
-{
-    periph_gpio_isr_test();
-}
-
-static void periph_is31fl3216_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-    periph_is31fl3216_cfg_t is31fl3216_cfg = {
-        .state = IS31FL3216_STATE_ON
-    };
-
-    ESP_LOGI(TAG, "Register gpio isr to peripherals");
-    esp_periph_handle_t is31fl3216_handle = periph_is31fl3216_init(&is31fl3216_cfg);
-    TEST_ASSERT_FALSE(esp_periph_start(set, is31fl3216_handle));
-
-    for (int i = 0; i < BLUE_LED_MAX_NUM; i++) {
-        TEST_ASSERT_FALSE(periph_is31fl3216_set_duty(is31fl3216_handle, i, 255));
-    }
-
-    TEST_ASSERT_FALSE(periph_is31fl3216_set_light_on_num(is31fl3216_handle, 1, BLUE_LED_MAX_NUM));
-    TEST_ASSERT_FALSE(periph_is31fl3216_set_interval(is31fl3216_handle, 100));
-    TEST_ASSERT_FALSE(periph_is31fl3216_set_shift_mode(is31fl3216_handle, PERIPH_IS31_SHIFT_MODE_ACC));
-    TEST_ASSERT_FALSE(periph_is31fl3216_set_state(is31fl3216_handle, IS31FL3216_STATE_SHIFT));
-    ESP_LOGI(TAG, "Start testing for 5 seconds...");
-
-    vTaskDelay(5000 / portTICK_RATE_MS);
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-TEST_CASE("is31fl3216 test", "[peripherals]")
-{
-    periph_is31fl3216_test();
-}
-
-static void periph_led_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    periph_led_cfg_t led_cfg = {
-        .led_speed_mode = LEDC_LOW_SPEED_MODE,
-        .led_duty_resolution = LEDC_TIMER_10_BIT,
-        .led_timer_num = LEDC_TIMER_0,
-        .led_freq_hz = 5000,
-    };
-
-    esp_periph_handle_t led_handle = periph_led_init(&led_cfg);
-    TEST_ASSERT_FALSE(esp_periph_start(set, led_handle));
-
-    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_blue_led_gpio(), 1000, 1000, true, -1, 0));
-    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_green_led_gpio(), 500, 500, false, 4, 0));
-
-    ESP_LOGI(TAG, "running...");
-    vTaskDelay(1000 / portTICK_RATE_MS);
-    ESP_LOGI(TAG, "STOP BLUE LED");
-    TEST_ASSERT_FALSE(periph_led_stop(led_handle, get_blue_led_gpio()));
-
-    vTaskDelay(1000 / portTICK_RATE_MS);
-    ESP_LOGI(TAG, "Changing blink preset...");
-    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_blue_led_gpio(), 500, 200, false, -1, 0));
-    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_green_led_gpio(), 500, 1000, true, -1, 0));
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-TEST_CASE("led test", "[peripherals]")
-{
-    periph_led_test();
-}
-
-static void periph_sdcard_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-#ifdef CONFIG_ESP_LYRAT_MINI_V1_1_BOARD
-    gpio_config_t sdcard_pwr_pin_cfg = {
-        .pin_bit_mask = 1UL << SDCARD_PWR_CTRL,
-        .mode = GPIO_MODE_OUTPUT,
-        .pull_up_en = GPIO_PULLUP_DISABLE,
-        .pull_down_en = GPIO_PULLDOWN_DISABLE,
-        .intr_type = GPIO_INTR_DISABLE,
-    };
-
-    gpio_config(&sdcard_pwr_pin_cfg);
-    gpio_set_level(SDCARD_PWR_CTRL, 0);
-#endif
-
-    periph_sdcard_cfg_t sdcard_cfg = {
-        .card_detect_pin = get_sdcard_intr_gpio(),
-        .root = "/sdcard"
-    };
-
-    esp_periph_handle_t sdcard_handle = periph_sdcard_init(&sdcard_cfg);
-    TEST_ASSERT_NOT_NULL(sdcard_handle);
-    TEST_ASSERT_FALSE(esp_periph_start(set, sdcard_handle));
-
-    while (!periph_sdcard_is_mounted(sdcard_handle)) {
-        vTaskDelay(500 / portTICK_PERIOD_MS);
-    }
-
-    ESP_LOGI(TAG, "Wirte a string to sdcard");
-    FILE *fp = fopen("/sdcard/test", "w+");
-    TEST_ASSERT_NOT_NULL(fp);
-    char test_str[] = "hello, this is sdcard test";
-    TEST_ASSERT_EQUAL_INT(strlen(test_str), fwrite(test_str, 1, strlen(test_str), fp));
-    TEST_ASSERT_FALSE(fsync(fileno(fp)));
-    TEST_ASSERT_FALSE(fclose(fp));
-
-    ESP_LOGI(TAG, "Read a string from sdcard");
-    fp = fopen("/sdcard/test", "r");
-    TEST_ASSERT_NOT_NULL(fp);
-    char *read_str = audio_calloc(1, strlen(test_str) + 1);
-    TEST_ASSERT_NOT_NULL(read_str);
-    TEST_ASSERT_EQUAL_INT(strlen(test_str), fread(read_str, 1, strlen(test_str), fp));
-    ESP_LOGW(TAG, "read string from sdcard file: %s", read_str);
-    TEST_ASSERT_EQUAL_INT(0, strncmp(read_str, test_str, strlen(test_str)));
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-    free(read_str);
-    fclose(fp);
-}
-
-TEST_CASE("sdcard test", "[peripherals]")
-{
-    periph_sdcard_test();
-}
-
-static void periph_spiffs_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    periph_spiffs_cfg_t spiffs_cfg = {
-        .root = "/spiffs",
-        .max_files = 5,
-        .format_if_mount_failed = true,
-        .partition_label = NULL
-    };
-    esp_periph_handle_t spiffs_handle = periph_spiffs_init(&spiffs_cfg);
-    TEST_ASSERT_NOT_NULL(spiffs_handle);
-    TEST_ASSERT_FALSE(esp_periph_start(set, spiffs_handle));
-
-    while (!periph_spiffs_is_mounted(spiffs_handle)) {
-        vTaskDelay(500 / portTICK_PERIOD_MS);
-    }
-
-    FILE *fp = fopen("/spiffs/test", "w+");
-    TEST_ASSERT_NOT_NULL(fp);
-    char test_str[] = "hello, this is spiffs test";
-    TEST_ASSERT_EQUAL_INT(strlen(test_str), fwrite(test_str, 1, strlen(test_str), fp));
-    TEST_ASSERT_FALSE(fclose(fp));
-
-    ESP_LOGI(TAG, "Read a string from spiffs");
-    fp = fopen("/spiffs/test", "r");
-    TEST_ASSERT_NOT_NULL(fp);
-    char *read_str = audio_calloc(1, strlen(test_str) + 1);
-    TEST_ASSERT_NOT_NULL(read_str);
-    TEST_ASSERT_EQUAL_INT(strlen(test_str), fread(read_str, 1, strlen(test_str), fp));
-    ESP_LOGW(TAG, "read string from spiffs file: %s", read_str);
-    TEST_ASSERT_EQUAL_INT(0, strncmp(read_str, test_str, strlen(test_str)));
-    fclose(fp);
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-    free(read_str);
-}
-
-TEST_CASE("spiffs test", "[peripherals]")
-{
-    periph_spiffs_test();
-}
-
-static void periph_touch_pad_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    ESP_LOGI(TAG, "Register touch pad to peripherals");
-    periph_touch_cfg_t touch_cfg = {
-        .touch_mask = TOUCH_PAD_SEL4 | TOUCH_PAD_SEL7 | TOUCH_PAD_SEL8 | TOUCH_PAD_SEL9,
-        .tap_threshold_percent = 70,
-    };
-    esp_periph_handle_t touch_handle = periph_touch_init(&touch_cfg);
-    TEST_ASSERT_NOT_NULL(touch_handle);
-    TEST_ASSERT_FALSE(esp_periph_start(set, touch_handle));
-
-    ESP_LOGI(TAG, "Set up event listener");
-    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
-    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
-    TEST_ASSERT_NOT_NULL(evt);
-
-    ESP_LOGI(TAG, "Listening event from peripherals, please press the touch pad");
-    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
-
-    while (1) {
-        audio_event_iface_msg_t msg;
-        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
-        if ((int)msg.data == get_input_set_id()) {
-            ESP_LOGI(TAG, "[set] touched, quit test");
-            break;
-        }
-
-        if (msg.cmd == PERIPH_TOUCH_TAP) {
-            if ((int)msg.data == get_input_play_id()) {
-                ESP_LOGI(TAG, "[play] touched");
-            }
-            if ((int)msg.data == get_input_volup_id()) {
-                ESP_LOGI(TAG, "[vol+] touched");
-            }
-            if ((int)msg.data == get_input_voldown_id()) {
-                ESP_LOGI(TAG, "[vol-] touched");
-            }
-        }
-
-        if (msg.cmd == PERIPH_TOUCH_RELEASE) {
-            if ((int)msg.data == get_input_play_id()) {
-                ESP_LOGI(TAG, "[play] released");
-            }
-            if ((int)msg.data == get_input_volup_id()) {
-                ESP_LOGI(TAG, "[vol+] released");
-            }
-            if ((int)msg.data == get_input_voldown_id()) {
-                ESP_LOGI(TAG, "[vol-] released");
-            }
-        }
-    }
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
-    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-}
-
-static void periph_ws2812_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    periph_ws2812_cfg_t cfg = {
-        .gpio_num = GPIO_NUM_3,
-        .led_num = 2,
-    };
-    esp_periph_handle_t handle = periph_ws2812_init(&cfg);
-    TEST_ASSERT_FALSE(esp_periph_start(set, handle));
-
-    periph_ws2812_ctrl_cfg_t *control_cfg = malloc(sizeof(periph_ws2812_ctrl_cfg_t) * cfg.led_num);
-
-    control_cfg[0].color = LED2812_COLOR_RED;
-    control_cfg[0].mode = PERIPH_WS2812_BLINK;
-    control_cfg[0].loop = 50;
-    control_cfg[0].time_off_ms = 100;
-    control_cfg[0].time_on_ms = 1000;
-
-    control_cfg[1].color = LED2812_COLOR_BLUE;
-    control_cfg[1].mode = PERIPH_WS2812_ONE;
-    control_cfg[1].loop = 50;
-    control_cfg[1].time_off_ms = 2000;
-    control_cfg[1].time_on_ms = 2000;
-
-    TEST_ASSERT_FALSE(periph_ws2812_control(handle, control_cfg, NULL));
-    vTaskDelay(5000 / portTICK_PERIOD_MS);
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-    free(control_cfg);
-}
-
-TEST_CASE("touch pad test", "[peripherals]")
-{
-    periph_touch_pad_test();
-}
-
-static void periph_wifi_test(void)
-{
-    ESP_LOGI(TAG, "Set up peripherals handle");
-    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
-    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
-    TEST_ASSERT_NOT_NULL(set);
-
-    ESP_LOGI(TAG, "Initialize wifi environment");
-    esp_err_t ret = nvs_flash_init();
-    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
-        ESP_ERROR_CHECK( nvs_flash_erase() );
-        ret = nvs_flash_init();
-    }
-    ESP_ERROR_CHECK( ret );
-    tcpip_adapter_init();
-
-    periph_wifi_cfg_t wifi_cfg = {
-        .wifi_config.sta.ssid = "YOUR_SSID",
-        .wifi_config.sta.password = "YOUR_PASSWORD",
-    }
-    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
-    esp_periph_start(set, wifi_handle);
-    periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY);
-
-    vTaskDelay(100 / portTICK_PERIOD_MS);
-
-    ESP_LOGI(TAG, "Quit test, release all resources");
-    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
-    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
-    TEST_ASSERT_FALSE(nvs_flash_deinit());
-}
-
-TEST_CASE("wifi test", "[peripherals]")
-{
-    periph_wifi_test();
-}
-
-
-TEST_CASE("[memory leak test] [gpio isr]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_gpio_isr_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [adc button]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_adc_button_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [console]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_console_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [led]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_led_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [spiffs]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_spiffs_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [wifi]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_wifi_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [gpio button]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_gpio_button_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [is31fl3216]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_is31fl3216_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [sdcard]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_sdcard_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [touch]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_touch_pad_test();
-    }
-}
-
-TEST_CASE("[memory leak test] [ws2812]", "[peripherals]")
-{
-    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
-    while (test_count--) {
-        printf("-------Residual times: %d -------\n", test_count);
-        periph_ws2812_test();
-    }
-}
+/*
+ * ESPRESSIF MIT License
+ *
+ * Copyright (c) 2018 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
+ *
+ * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
+ * it is free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <string.h>
+#include <unistd.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "audio_event_iface.h"
+#include "esp_log.h"
+#include "esp_err.h"
+
+#include "unity.h"
+#include "nvs_flash.h"
+#include "tcpip_adapter.h"
+#include "audio_mem.h"
+#include "esp_peripherals.h"
+#include "periph_sdcard.h"
+#include "periph_button.h"
+#include "periph_touch.h"
+#include "periph_wifi.h"
+#include "periph_console.h"
+#include "periph_led.h"
+#include "periph_adc_button.h"
+#include "periph_gpio_isr.h"
+#include "periph_is31fl3216.h"
+#include "periph_spiffs.h"
+#include "periph_ws2812.h"
+#include "board.h"
+
+static const char *TAG = "ESP_PERIPH_TEST";
+
+#define TEST_PERIPHERALS_MEMORY_LEAK_TIMES  1000
+
+static void periph_adc_button_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    ESP_LOGI(TAG, "Register ADC button to peripherals");
+    periph_adc_button_cfg_t adc_btn_cfg = PERIPH_ADC_BUTTON_DEFAULT_CONFIG();
+    adc_arr_t adc_btn_tag = ADC_DEFAULT_ARR();
+    adc_btn_tag.total_steps = 6;
+    int btn_array[7] = {190, 600, 1000, 1375, 1775, 2195, 3100};
+    adc_btn_tag.adc_level_step = btn_array;
+    adc_btn_cfg.arr = &adc_btn_tag;
+    adc_btn_cfg.arr_size = 1;
+    esp_periph_handle_t adc_btn_handle = periph_adc_button_init(&adc_btn_cfg);
+    TEST_ASSERT_NOT_NULL(adc_btn_handle);
+    TEST_ASSERT_FALSE(esp_periph_start(set, adc_btn_handle));
+
+    ESP_LOGI(TAG, "Set up event listener");
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    ESP_LOGI(TAG, "Listening event from peripherals");
+    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    ESP_LOGI(TAG, "Test start, please press buttons on the board ... ");
+    while (1) {
+        audio_event_iface_msg_t msg;
+        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
+        ESP_LOGI(TAG, "action: %d, act id: %d", msg.cmd, (int)msg.data);
+        if ((int)msg.data == 0) {
+            ESP_LOGW(TAG, "press id 0, quit test");
+            break;
+        }
+    }
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+TEST_CASE("adc button test", "[peripherals]")
+{
+    periph_adc_button_test();
+}
+
+static void periph_gpio_button_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    ESP_LOGI(TAG, "Register gpio button to peripherals");
+    periph_button_cfg_t btn_cfg = {
+        .gpio_mask = (1ULL << get_input_rec_id()) | (1ULL << get_input_mode_id()), //REC BTN & MODE BTN
+    };
+    esp_periph_handle_t button_handle = periph_button_init(&btn_cfg);
+    TEST_ASSERT_NOT_NULL(button_handle);
+    TEST_ASSERT_FALSE(esp_periph_start(set, button_handle));
+
+    ESP_LOGI(TAG, "Set up event listener");
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    ESP_LOGI(TAG, "Listening event from peripherals");
+    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    ESP_LOGI(TAG, "Test start, please press buttons on the board ... ");
+    while (1) {
+        audio_event_iface_msg_t msg;
+        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
+        ESP_LOGI(TAG, "action: %d, act id: %d", msg.cmd, (int)msg.data);
+        if ((int)msg.data == get_input_mode_id()) {
+            ESP_LOGW(TAG, "press [mode] button, quit test");
+            break;
+        }
+    }
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+TEST_CASE("gpio button test", "[peripherals]")
+{
+    periph_gpio_button_test();
+}
+
+static esp_err_t play_func(esp_periph_handle_t periph, int argc, char *argv[])
+{
+    if (argc == 1) {
+        ESP_LOGI(TAG, "play music, url:%s", argv[0]);
+    } else if (argc == 0) {
+        ESP_LOGI(TAG, "play");
+    } else {
+        ESP_LOGE(TAG, "error input");
+    }
+    return ESP_OK;
+}
+
+static esp_err_t pause_func(esp_periph_handle_t periph, int argc, char *argv[])
+{
+    if (argc == 0) {
+        ESP_LOGI(TAG, "pause");
+    } else {
+        ESP_LOGE(TAG, "error input");
+    }
+    return ESP_OK;
+}
+
+static bool task_flag;
+
+static esp_err_t quit_func(esp_periph_handle_t periph, int argc, char *argv[])
+{
+    if (argc == 0) {
+        ESP_LOGI(TAG, "quit console");
+        task_flag = false;
+    } else {
+        ESP_LOGE(TAG, "error input");
+    }
+    return ESP_OK;
+}
+
+const periph_console_cmd_t cli_cmd[] = {
+    {
+        .cmd = "play",
+        .id  = 0,
+        .help = "play music",
+        .func = play_func,
+    },
+    {
+        .cmd = "pause",
+        .id = 1,
+        .help = "pause music",
+        .func = pause_func,
+    },
+    {
+        .cmd = "quit",
+        .id = 2,
+        .help = "quit command line",
+        .func = quit_func
+    }
+};
+
+static void periph_console_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    ESP_LOGI(TAG, "Register console to peripherals");
+    periph_console_cfg_t console_cfg = {
+        .command_num = sizeof(cli_cmd) / sizeof(periph_console_cmd_t),
+        .commands = cli_cmd,
+    };
+    esp_periph_handle_t console_handle = periph_console_init(&console_cfg);
+    TEST_ASSERT_NOT_NULL(console_handle);
+
+    task_flag = true;
+    ESP_LOGI(TAG, "Start console, please input ...");
+    TEST_ASSERT_FALSE(esp_periph_start(set, console_handle));
+
+    while (task_flag) {
+        vTaskDelay(10 / portTICK_RATE_MS);
+    }
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+TEST_CASE("console test", "[peripherals]")
+{
+    periph_console_test();
+}
+
+static void periph_gpio_isr_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    ESP_LOGI(TAG, "Register gpio isr to peripherals");
+    gpio_isr_info_t gpio_isr_info = {
+        .gpio_num = SDCARD_INTR_GPIO,
+        .type = GPIO_INTR_ANYEDGE
+    };
+    periph_gpio_isr_cfg_t gpio_isr_cfg = {
+        .info_size = 1,
+        .gpio_isr_info = &gpio_isr_info
+    };
+    esp_periph_handle_t gpio_isr_handle = periph_gpio_isr_init(&gpio_isr_cfg);
+    TEST_ASSERT_NOT_NULL(gpio_isr_handle);
+    TEST_ASSERT_FALSE(esp_periph_start(set, gpio_isr_handle));
+
+    ESP_LOGI(TAG, "Set up event listener");
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    ESP_LOGI(TAG, "Listening event from peripherals, please insert a sdcard to the board ...");
+    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
+
+        if ((int)msg.data == SDCARD_INTR_GPIO) {
+            ESP_LOGW(TAG, "Detect sdcard insertion, quit test");
+            break;
+        }
+    }
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+TEST_CASE("gpio isr test", "[peripherals]")
+{
+    periph_gpio_isr_test();
+}
+
+static void periph_is31fl3216_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+    periph_is31fl3216_cfg_t is31fl3216_cfg = {
+        .state = IS31FL3216_STATE_ON
+    };
+
+    ESP_LOGI(TAG, "Register gpio isr to peripherals");
+    esp_periph_handle_t is31fl3216_handle = periph_is31fl3216_init(&is31fl3216_cfg);
+    TEST_ASSERT_FALSE(esp_periph_start(set, is31fl3216_handle));
+
+    for (int i = 0; i < BLUE_LED_MAX_NUM; i++) {
+        TEST_ASSERT_FALSE(periph_is31fl3216_set_duty(is31fl3216_handle, i, 255));
+    }
+
+    TEST_ASSERT_FALSE(periph_is31fl3216_set_light_on_num(is31fl3216_handle, 1, BLUE_LED_MAX_NUM));
+    TEST_ASSERT_FALSE(periph_is31fl3216_set_interval(is31fl3216_handle, 100));
+    TEST_ASSERT_FALSE(periph_is31fl3216_set_shift_mode(is31fl3216_handle, PERIPH_IS31_SHIFT_MODE_ACC));
+    TEST_ASSERT_FALSE(periph_is31fl3216_set_state(is31fl3216_handle, IS31FL3216_STATE_SHIFT));
+    ESP_LOGI(TAG, "Start testing for 5 seconds...");
+
+    vTaskDelay(5000 / portTICK_RATE_MS);
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+TEST_CASE("is31fl3216 test", "[peripherals]")
+{
+    periph_is31fl3216_test();
+}
+
+static void periph_led_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    periph_led_cfg_t led_cfg = {
+        .led_speed_mode = LEDC_LOW_SPEED_MODE,
+        .led_duty_resolution = LEDC_TIMER_10_BIT,
+        .led_timer_num = LEDC_TIMER_0,
+        .led_freq_hz = 5000,
+    };
+
+    esp_periph_handle_t led_handle = periph_led_init(&led_cfg);
+    TEST_ASSERT_FALSE(esp_periph_start(set, led_handle));
+
+    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_blue_led_gpio(), 1000, 1000, true, -1, 0));
+    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_green_led_gpio(), 500, 500, false, 4, 0));
+
+    ESP_LOGI(TAG, "running...");
+    vTaskDelay(1000 / portTICK_RATE_MS);
+    ESP_LOGI(TAG, "STOP BLUE LED");
+    TEST_ASSERT_FALSE(periph_led_stop(led_handle, get_blue_led_gpio()));
+
+    vTaskDelay(1000 / portTICK_RATE_MS);
+    ESP_LOGI(TAG, "Changing blink preset...");
+    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_blue_led_gpio(), 500, 200, false, -1, 0));
+    TEST_ASSERT_FALSE(periph_led_blink(led_handle, get_green_led_gpio(), 500, 1000, true, -1, 0));
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+TEST_CASE("led test", "[peripherals]")
+{
+    periph_led_test();
+}
+
+static void periph_sdcard_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+#ifdef CONFIG_ESP_LYRAT_MINI_V1_1_BOARD
+    gpio_config_t sdcard_pwr_pin_cfg = {
+        .pin_bit_mask = 1UL << SDCARD_PWR_CTRL,
+        .mode = GPIO_MODE_OUTPUT,
+        .pull_up_en = GPIO_PULLUP_DISABLE,
+        .pull_down_en = GPIO_PULLDOWN_DISABLE,
+        .intr_type = GPIO_INTR_DISABLE,
+    };
+
+    gpio_config(&sdcard_pwr_pin_cfg);
+    gpio_set_level(SDCARD_PWR_CTRL, 0);
+#endif
+
+    periph_sdcard_cfg_t sdcard_cfg = {
+        .card_detect_pin = get_sdcard_intr_gpio(),
+        .root = "/sdcard"
+    };
+
+    esp_periph_handle_t sdcard_handle = periph_sdcard_init(&sdcard_cfg);
+    TEST_ASSERT_NOT_NULL(sdcard_handle);
+    TEST_ASSERT_FALSE(esp_periph_start(set, sdcard_handle));
+
+    while (!periph_sdcard_is_mounted(sdcard_handle)) {
+        vTaskDelay(500 / portTICK_PERIOD_MS);
+    }
+
+    ESP_LOGI(TAG, "Wirte a string to sdcard");
+    FILE *fp = fopen("/sdcard/test", "w+");
+    TEST_ASSERT_NOT_NULL(fp);
+    char test_str[] = "hello, this is sdcard test";
+    TEST_ASSERT_EQUAL_INT(strlen(test_str), fwrite(test_str, 1, strlen(test_str), fp));
+    TEST_ASSERT_FALSE(fsync(fileno(fp)));
+    TEST_ASSERT_FALSE(fclose(fp));
+
+    ESP_LOGI(TAG, "Read a string from sdcard");
+    fp = fopen("/sdcard/test", "r");
+    TEST_ASSERT_NOT_NULL(fp);
+    char *read_str = audio_calloc(1, strlen(test_str) + 1);
+    TEST_ASSERT_NOT_NULL(read_str);
+    TEST_ASSERT_EQUAL_INT(strlen(test_str), fread(read_str, 1, strlen(test_str), fp));
+    ESP_LOGW(TAG, "read string from sdcard file: %s", read_str);
+    TEST_ASSERT_EQUAL_INT(0, strncmp(read_str, test_str, strlen(test_str)));
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+    free(read_str);
+    fclose(fp);
+}
+
+TEST_CASE("sdcard test", "[peripherals]")
+{
+    periph_sdcard_test();
+}
+
+static void periph_spiffs_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    periph_spiffs_cfg_t spiffs_cfg = {
+        .root = "/spiffs",
+        .max_files = 5,
+        .format_if_mount_failed = true,
+        .partition_label = NULL
+    };
+    esp_periph_handle_t spiffs_handle = periph_spiffs_init(&spiffs_cfg);
+    TEST_ASSERT_NOT_NULL(spiffs_handle);
+    TEST_ASSERT_FALSE(esp_periph_start(set, spiffs_handle));
+
+    while (!periph_spiffs_is_mounted(spiffs_handle)) {
+        vTaskDelay(500 / portTICK_PERIOD_MS);
+    }
+
+    FILE *fp = fopen("/spiffs/test", "w+");
+    TEST_ASSERT_NOT_NULL(fp);
+    char test_str[] = "hello, this is spiffs test";
+    TEST_ASSERT_EQUAL_INT(strlen(test_str), fwrite(test_str, 1, strlen(test_str), fp));
+    TEST_ASSERT_FALSE(fclose(fp));
+
+    ESP_LOGI(TAG, "Read a string from spiffs");
+    fp = fopen("/spiffs/test", "r");
+    TEST_ASSERT_NOT_NULL(fp);
+    char *read_str = audio_calloc(1, strlen(test_str) + 1);
+    TEST_ASSERT_NOT_NULL(read_str);
+    TEST_ASSERT_EQUAL_INT(strlen(test_str), fread(read_str, 1, strlen(test_str), fp));
+    ESP_LOGW(TAG, "read string from spiffs file: %s", read_str);
+    TEST_ASSERT_EQUAL_INT(0, strncmp(read_str, test_str, strlen(test_str)));
+    fclose(fp);
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+    free(read_str);
+}
+
+TEST_CASE("spiffs test", "[peripherals]")
+{
+    periph_spiffs_test();
+}
+
+static void periph_touch_pad_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    ESP_LOGI(TAG, "Register touch pad to peripherals");
+    periph_touch_cfg_t touch_cfg = {
+        .touch_mask = TOUCH_PAD_SEL4 | TOUCH_PAD_SEL7 | TOUCH_PAD_SEL8 | TOUCH_PAD_SEL9,
+        .tap_threshold_percent = 70,
+    };
+    esp_periph_handle_t touch_handle = periph_touch_init(&touch_cfg);
+    TEST_ASSERT_NOT_NULL(touch_handle);
+    TEST_ASSERT_FALSE(esp_periph_start(set, touch_handle));
+
+    ESP_LOGI(TAG, "Set up event listener");
+    audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();
+    audio_event_iface_handle_t evt = audio_event_iface_init(&evt_cfg);
+    TEST_ASSERT_NOT_NULL(evt);
+
+    ESP_LOGI(TAG, "Listening event from peripherals, please press the touch pad");
+    TEST_ASSERT_FALSE(audio_event_iface_set_listener(esp_periph_set_get_event_iface(set), evt));
+
+    while (1) {
+        audio_event_iface_msg_t msg;
+        TEST_ASSERT_FALSE(audio_event_iface_listen(evt, &msg, portMAX_DELAY));
+        if ((int)msg.data == get_input_set_id()) {
+            ESP_LOGI(TAG, "[set] touched, quit test");
+            break;
+        }
+
+        if (msg.cmd == PERIPH_TOUCH_TAP) {
+            if ((int)msg.data == get_input_play_id()) {
+                ESP_LOGI(TAG, "[play] touched");
+            }
+            if ((int)msg.data == get_input_volup_id()) {
+                ESP_LOGI(TAG, "[vol+] touched");
+            }
+            if ((int)msg.data == get_input_voldown_id()) {
+                ESP_LOGI(TAG, "[vol-] touched");
+            }
+        }
+
+        if (msg.cmd == PERIPH_TOUCH_RELEASE) {
+            if ((int)msg.data == get_input_play_id()) {
+                ESP_LOGI(TAG, "[play] released");
+            }
+            if ((int)msg.data == get_input_volup_id()) {
+                ESP_LOGI(TAG, "[vol+] released");
+            }
+            if ((int)msg.data == get_input_voldown_id()) {
+                ESP_LOGI(TAG, "[vol-] released");
+            }
+        }
+    }
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(audio_event_iface_remove_listener(esp_periph_set_get_event_iface(set), evt));
+    TEST_ASSERT_FALSE(audio_event_iface_destroy(evt));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+}
+
+static void periph_ws2812_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    periph_ws2812_cfg_t cfg = {
+        .gpio_num = GPIO_NUM_3,
+        .led_num = 2,
+    };
+    esp_periph_handle_t handle = periph_ws2812_init(&cfg);
+    TEST_ASSERT_FALSE(esp_periph_start(set, handle));
+
+    periph_ws2812_ctrl_cfg_t *control_cfg = malloc(sizeof(periph_ws2812_ctrl_cfg_t) * cfg.led_num);
+
+    control_cfg[0].color = LED2812_COLOR_RED;
+    control_cfg[0].mode = PERIPH_WS2812_BLINK;
+    control_cfg[0].loop = 50;
+    control_cfg[0].time_off_ms = 100;
+    control_cfg[0].time_on_ms = 1000;
+
+    control_cfg[1].color = LED2812_COLOR_BLUE;
+    control_cfg[1].mode = PERIPH_WS2812_ONE;
+    control_cfg[1].loop = 50;
+    control_cfg[1].time_off_ms = 2000;
+    control_cfg[1].time_on_ms = 2000;
+
+    TEST_ASSERT_FALSE(periph_ws2812_control(handle, control_cfg, NULL));
+    vTaskDelay(5000 / portTICK_PERIOD_MS);
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+    free(control_cfg);
+}
+
+TEST_CASE("touch pad test", "[peripherals]")
+{
+    periph_touch_pad_test();
+}
+
+static void periph_wifi_test(void)
+{
+    ESP_LOGI(TAG, "Set up peripherals handle");
+    esp_periph_config_t periph_cfg = DEFAULT_ESP_PERIPH_SET_CONFIG();
+    esp_periph_set_handle_t set = esp_periph_set_init(&periph_cfg);
+    TEST_ASSERT_NOT_NULL(set);
+
+    ESP_LOGI(TAG, "Initialize wifi environment");
+    esp_err_t ret = nvs_flash_init();
+    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
+        ESP_ERROR_CHECK( nvs_flash_erase() );
+        ret = nvs_flash_init();
+    }
+    ESP_ERROR_CHECK( ret );
+    tcpip_adapter_init();
+
+    periph_wifi_cfg_t wifi_cfg = {
+        .wifi_config.sta.ssid = "YOUR_SSID",
+        .wifi_config.sta.password = "YOUR_PASSWORD",
+    }
+    esp_periph_handle_t wifi_handle = periph_wifi_init(&wifi_cfg);
+    esp_periph_start(set, wifi_handle);
+    periph_wifi_wait_for_connected(wifi_handle, portMAX_DELAY);
+
+    vTaskDelay(100 / portTICK_PERIOD_MS);
+
+    ESP_LOGI(TAG, "Quit test, release all resources");
+    TEST_ASSERT_FALSE(esp_periph_set_stop_all(set));
+    TEST_ASSERT_FALSE(esp_periph_set_destroy(set));
+    TEST_ASSERT_FALSE(nvs_flash_deinit());
+}
+
+TEST_CASE("wifi test", "[peripherals]")
+{
+    periph_wifi_test();
+}
+
+
+TEST_CASE("[memory leak test] [gpio isr]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_gpio_isr_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [adc button]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_adc_button_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [console]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_console_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [led]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_led_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [spiffs]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_spiffs_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [wifi]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_wifi_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [gpio button]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_gpio_button_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [is31fl3216]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_is31fl3216_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [sdcard]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_sdcard_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [touch]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_touch_pad_test();
+    }
+}
+
+TEST_CASE("[memory leak test] [ws2812]", "[peripherals]")
+{
+    int test_count = TEST_PERIPHERALS_MEMORY_LEAK_TIMES;
+    while (test_count--) {
+        printf("-------Residual times: %d -------\n", test_count);
+        periph_ws2812_test();
+    }
+}
diff --git a/components/ota_service/ota_service.c b/components/ota_service/ota_service.c
index 9a199ceb..d7f18575 100644
--- a/components/ota_service/ota_service.c
+++ b/components/ota_service/ota_service.c
@@ -44,7 +44,7 @@ typedef enum {
 
 typedef struct {
     int state;
-    xQueueHandle srv_q;
+    QueueHandle_t srv_q;
     ota_upgrade_ops_t *upgrade_list;
     int list_len;
     int result;
@@ -276,4 +276,4 @@ periph_service_handle_t ota_service_create(ota_service_config_t *config)
     periph_service_set_callback(periph_ota, config->evt_cb, config->cb_ctx);
 
     return periph_ota;
-}
\ No newline at end of file
+}
diff --git a/components/playlist/playlist.c b/components/playlist/playlist.c
index c1d4b8db..f7fd789d 100644
--- a/components/playlist/playlist.c
+++ b/components/playlist/playlist.c
@@ -46,7 +46,7 @@ typedef struct playlist_info {
 struct playlist_handle {
     uint8_t list_num;                                           /*!< The number of all the playlists in the handle */
     playlist_info_t *cur_playlist;                              /*!< Pointer of current playlist */
-    xSemaphoreHandle playlist_operate_lock;                     /*!< A semaphore of operations */
+    SemaphoreHandle_t playlist_operate_lock;                     /*!< A semaphore of operations */
     STAILQ_HEAD(list_info, playlist_info) playlist_info_list;   /*!< List head of playlists */
 };
 
diff --git a/components/wifi_service/airkiss_config/airkiss_config.c b/components/wifi_service/airkiss_config/airkiss_config.c
index d6b2ed0c..e7b2c8ba 100644
--- a/components/wifi_service/airkiss_config/airkiss_config.c
+++ b/components/wifi_service/airkiss_config/airkiss_config.c
@@ -166,7 +166,7 @@ static void airkiss_notify_task(void *pvParameters)
         send_socket = socket(AF_INET, SOCK_DGRAM, 0);
         if (send_socket == -1) {
             ESP_LOGE(TAG, "failed to create sock!");
-            vTaskDelay(1000 / portTICK_RATE_MS);
+            vTaskDelay(1000 / portTICK_PERIOD_MS);
         }
     } while (send_socket == -1);
 
@@ -180,7 +180,7 @@ static void airkiss_notify_task(void *pvParameters)
         fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //IPPROTO_UDP
         if (fd == -1) {
             ESP_LOGE(TAG, "failed to create sock!");
-            vTaskDelay(1000 / portTICK_RATE_MS);
+            vTaskDelay(1000 / portTICK_PERIOD_MS);
         }
     } while (fd == -1);
 
@@ -306,7 +306,7 @@ static void airkiss_send_ack_task(void *pvParameters)
     buf[0] = (uint8_t)ak_random_num;
     esp_wifi_get_mac(WIFI_IF_STA, &buf[1]);
 
-    vTaskDelay(200 / portTICK_RATE_MS);
+    vTaskDelay(200 / portTICK_PERIOD_MS);
 
     while (1) {
         /* Get local IP address of station */
@@ -322,13 +322,13 @@ static void airkiss_send_ack_task(void *pvParameters)
             send_socket = socket(AF_INET, SOCK_DGRAM, 0);
             if (send_socket < 0) {
                 ESP_LOGE(TAG, "Create airkiss udp socket failed");
-                vTaskDelay(1000 / portTICK_RATE_MS);
+                vTaskDelay(1000 / portTICK_PERIOD_MS);
                 continue;
             }
 
             while (1) {
                 /* Send airkiss ACK every 100ms. */
-                vTaskDelay(100 / portTICK_RATE_MS);
+                vTaskDelay(100 / portTICK_PERIOD_MS);
 
                 sendlen = sendto(send_socket, buf, 7, 0,
                                  (struct sockaddr *) &server_addr, sin_size);
@@ -348,7 +348,7 @@ static void airkiss_send_ack_task(void *pvParameters)
                 }
             }
         } else {
-            vTaskDelay((portTickType) (100 / portTICK_RATE_MS));
+            vTaskDelay((TickType_t) (100 / portTICK_PERIOD_MS));
         }
     }
 
diff --git a/components/wifi_service/src/wifi_service.c b/components/wifi_service/src/wifi_service.c
index ce6c41ea..5ef76bf8 100644
--- a/components/wifi_service/src/wifi_service.c
+++ b/components/wifi_service/src/wifi_service.c
@@ -68,7 +68,7 @@ typedef struct wifi_setting_item {
 typedef STAILQ_HEAD(wifi_setting_list, wifi_setting_item) wifi_setting_list_t;
 
 typedef struct {
-    xQueueHandle                     wifi_serv_que;
+    QueueHandle_t                     wifi_serv_que;
     wifi_service_event_t             wifi_serv_state;
     wifi_config_t                    info;
     wifi_setting_list_t              setting_list;
