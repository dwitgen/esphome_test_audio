from os.path import join, isfile
import subprocess

Import("env")

FRAMEWORK_DIR = env.PioPlatform().get_package_dir("framework-espidf")
print(f"FRAMEWORK_DIR: {FRAMEWORK_DIR}")
VERSION_FILE = join(FRAMEWORK_DIR, "version.txt")

patchflag_path = join(FRAMEWORK_DIR, ".adf-patching-done")
PROJECT_DIR = env.get('PROJECT_DIR')


# Define patch files for different versions
PATCH_FILES = {
    "4.4": join(PROJECT_DIR, "esp_adf_patches", "idf_v4.4_freertos.patch"),
    "5.0": join(PROJECT_DIR, "esp_adf_patches", "idf_v5.0_freertos.patch"),
    "5.1": join(PROJECT_DIR, "esp_adf_patches", "idf_v5.1_freertos.patch"),
    "5.2": join(PROJECT_DIR, "esp_adf_patches", "idf_v5.2_freertos.patch"),
    "5.3": join(PROJECT_DIR, "esp_adf_patches", "idf_v5.3_freertos.patch"),
}

with open(VERSION_FILE, "r") as f:
    idf_version = f.read().strip()

# Find the matching patch file
PATCH_FILE = None
for version_prefix, patch_path in PATCH_FILES.items():
    if idf_version.startswith(version_prefix):
        PATCH_FILE = patch_path
        break
print(f"Patch file: {PATCH_FILE}")
if not PATCH_FILE or not isfile(PATCH_FILE):
    raise ValueError(f"No patch file found for ESP-IDF version: {idf_version}")

# Apply the patch if it hasn't been applied before
if not isfile(patchflag_path):
    print(f"Applying patch for ESP-IDF version {idf_version}: {PATCH_FILE}")
    assert isfile(PATCH_FILE)
    
    env.Execute(f"patch -p1 -d {FRAMEWORK_DIR} -i {PATCH_FILE}")
    
    # Create the patch flag file to prevent re-patching
    def _touch(path):
        with open(path, "w") as fp:
            fp.write("")
    
    env.Execute(lambda *args, **kwargs: _touch(patchflag_path))
